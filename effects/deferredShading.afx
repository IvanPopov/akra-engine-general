#include "floatSpecialFunctions.afx"

texture tex0 : DEFERRED_TEXTURE0;

sampler deferredTexture0 : SAMPLER_TEXTURE0 = sampler_state
{
	Texture = <tex0>;
	MinFilter = NEAREST;
	MagFilter = NEAREST;
};

texture tex1 : DEFERRED_TEXTURE1;

sampler deferredTexture1 : SAMPLER_TEXTURE1 = sampler_state
{
	Texture = <tex1>;
	MinFilter = NEAREST;
	MagFilter = NEAREST;
};

texture tex2 : DEFERRED_TEXTURE2;

sampler deferredTexture2 : SAMPLER_TEXTURE2 = sampler_state
{
	Texture = <tex2>;
	MinFilter = NEAREST;
	MagFilter = NEAREST;
};

texture tex3 : DEFERRED_TEXTURE3;

sampler deferredTexture3 : SAMPLER_TEXTURE3 = sampler_state
{
	Texture = <tex3>;
	MinFilter = NEAREST;
	MagFilter = NEAREST;
};

texture tex4 : SCENE_DEPTH_TEXTURE;

sampler sceneDepthTexture : SAMPLER_SCENE_DEPTH = sampler_state
{
	TEXTURE = <tex4>;
	MinFilter = LINEAR;
	MagFilter = LINEAR;
};

float2 textureScreenRatio : TEXTURE_SCREEN_RATIO;

struct VS_IN{
	float2 position : POSITION;
};

struct VS_OUT{
	float4 position : POSITION;
	float2 screenPosition : SCREEN_POSITION;
	float2 textureCoords : TEXCOORD0; 
};

VS_OUT vs_deferred_shading(VS_IN IN){
	VS_OUT Out;

	float texCoodrX = (IN.position.x + 1.)/2. * textureScreenRatio.x;
	float texCoordY = 1. - (1. - (IN.position.y + 1.)/2.) * textureScreenRatio.y;

	Out.position = float4(IN.position,0.,1.);
	Out.screenPosition = IN.position;
	Out.textureCoords = float2(texCoodrX,texCoordY);
	
	return Out;
};

struct LIGHTPOINT {
	float4 position:LIGHT_POSITION;
 	float4 ambient:LIGHT_AMBIENT;
	float4 diffuse:LIGHT_DIFFUSE;
	float4 specular:LIGHT_SPECULAR;
	float4 emissive:LIGHT_EMISSIVE;
	float3 attenuation:LIGHT_ATTENUATION;
};

float3 eye_pos:EYE_POSITION;
float4x4 projMat : PROJ_MATRIX;

float3 unproj(float4x4 projMat,float3 screenCoords){
	
	//mat4[i] - i-й столбец матрицы 
	//не строка, а именно столбец
  
    float z = -projMat[4][3]/(projMat[3][3] + screenCoords.z);
    float y = -(screenCoords.y * z + projMat[3][2] * z)/projMat[2][2];
    float x = -(screenCoords.x * z + projMat[3][1] * z)/projMat[1][1];
  
    return float3(x,y,z);
};

float unprojZ(float4x4 projMat, float screenZ){
	return -projMat[4][3]/(projMat[3][3] + screenCoords.z);
};

float4 fs_deferred_shading(VS_OUT IN) : COLOR{
	float4 textureCoords = IN.textureCoords;

	LIGHTPOINT light_point;
    light_point.position = float4(10., 20., 10., 1.);
    light_point.ambient = float4(1., 1., 1., 1.);
    light_point.diffuse = float4(1., 1., 1., 1.);
    light_point.specular = float4(1., 1., 1., 1.);
    light_point.attenuation = float3(1., 0.00, .000);

    float depth = tex2D(sceneDepthTexture,textureCoords).x*2.-1.;
    float4 data0 = tex2D(deferredTexture0,textureCoords);
    float4 data1 = tex2D(deferredTexture1,textureCoords);

    float3 vertex = unproj(projMat,float3(IN.screenPosition.xy,depth));

    float3 temp;

    temp = floatTofloat3(data0.x);

    float3 normal = float3(temp.xy,sqrt(1. - dot(temp.xy,temp.xy)));
    float shininess = temp.z * 255.;

    float4 emissive = float4(floatTofloat3(data0.y),1.);
    float4 diffuse = float4(floatTofloat3(data0.z),1.);
    float4 ambient = float4(floatTofloat3(data0.w),1.);

    float4 specular = float4(floatTofloat3(data1.x),1.);

    float3 lightDir = light_point.position.xyz - vertex;
    float light_dir_length = length(light_dir);
    light_dir = normalize(light_dir);

    // direction from vert to observer (ViewDir)
    float3 view_dir = normalize(eye_pos - vertex);

    // reflect direction
    float3 reflect_dir = normalize(reflect(-light_dir, normal));

    // attenuation
    float attenuation = 1.0 / (light_point.attenuation.x +
        light_point.attenuation.y *
        light_dir_length + light_point.attenuation.z *
        light_dir_length * light_dir_length);

    float light_distancedotVpow = pow(max(dot(reflect_dir, view_dir), .0), shininess);

    float4 color = emissive;
    //add ambient
    color += ambient * light_point.ambient * attenuation;
    //add diffuse
    color += diffuse * light_point.diffuse * max(dot(IN.norm, light_dir), .0) * attenuation;
    // add reflect lighting
    color += specular * light_point.specular * light_distancedotVpow * attenuation;

    return float4(color.xyz,1.);
};	

technique deferredShading{
	pass applyLighting{
		VertexShader = compile vs_deferred_shading();
		PixelShader = compile fs_deferred_shading();
	};
};