window.$$enum_GRAPHICS_EXTENTIONS$_keys = ['texture_float', 'texture_half_float', 'compressed_texture', 'standard_derivatives', 'debug_shaders', 'debug_renderer_info', 'depth_texture', 'lose_context', 'texture_filter_anisotropic'];
window.$$enum_SURFACEMATERIAL_TEXTURES$_obj = {TEXTURE0: 0, TEXTURE1: 1, TEXTURE2: 2, TEXTURE3: 3, TEXTURE4: 4, TEXTURE5: 5, TEXTURE6: 6, TEXTURE7: 7, TEXTURE8: 8, TEXTURE9: 9, TEXTURE10: 10, TEXTURE11: 11, TEXTURE12: 12, TEXTURE13: 13, TEXTURE14: 14, TEXTURE15: 15, DIFFUSE: 0, AMBIENT: 1, SPECULAR: 2, EMISSIVE: 3, EMISSION: 3};
window.$$enum_MATERIAL_COMPONENTS$_obj = {DIFFUSE: 'DIFFUSE', AMBIENT: 'AMBIENT', SPECULAR: 'SPECULAR', EMISSIVE: 'EMISSIVE', EMISSION: 'EMISSIVE', SHININESS: 'SHININESS', REFLECTIVE: 'REFLECTIVE', REFLECTIVITY: 'REFLECTIVITY', TRANSPARENT: 'TRANSPARENT', TRANSPARENCY: 'TRANSPARENCY', INDEXOFREFRACTION: 'INDEXOFREFRACTION'};
window.$$enum_SYSTEM_SEMANTICS$_obj = {MODEL_MATRIX: 'MODEL_MATRIX', VIEW_MATRIX: 'VIEW_MATRIX', PROJ_MATRIX: 'PROJ_MATRIX', NORMAL_MATRIX: 'NORMAL_MATRIX', EYE_POS: 'EYE_POSITION', BIND_MATRIX: 'BIND_SHAPE_MATRIX'};
;
var a=window.akra = window.AKRA =  {};
window.trace = console.log.bind(console);
if (!(a["fx"]))a["fx"] =  {};

;
if (!(a["util"]))a["util"] =  {};

;
function extend(pChild) {
var fnGet, fnSet, i, sKey;
var pParent=arguments[1];
var argv=arguments;
pChild.prototype = Object.create(pParent.prototype);
pChild.prototype.constructor = pChild;
pChild.superclass = pParent.prototype;
for (i = 2; i < (argv.length); ++i) {
for (sKey in argv[i].prototype) {
if (sKey === "constructor") {
continue ;

}

fnGet = argv[i].prototype.__lookupGetter__(sKey);
fnSet = argv[i].prototype.__lookupSetter__(sKey);
if ((!fnGet) && (!fnSet)) {
pChild.prototype[sKey] = argv[i].prototype[sKey];
continue ;

}

if (fnGet) {
a.defineProperty(pChild, sKey, fnGet);

}

if (fnSet) {
a.defineProperty(pChild, sKey, null, fnSet);

}


}


}

pChild.superclasses =  {};
for (var i=1; i < (argv.length); ++i) {
pChild.superclasses[arguments[i].toString().match(/function\s*(\w+)/)[1]] = arguments[i].prototype;

}

pChild.ctor = function() {
for (var i=1; i < (argv.length); ++i) {
var pCtorValue=argv[i].apply(this, arguments);
if (pCtorValue !== undefined) {
return pCtorValue;

}


}


};

}

;
a["extend"] = extend;
function allocateStorage(pObject, nSize) {
var nStorageSize=nSize || 100;
pObject._nStorageSize = nStorageSize;
pObject._pStorage = new Array(pObject._nStorageSize);
pObject._iIndex = 0;
var pStorage=pObject._pStorage;
for (var i=0; i < (pObject._nStorageSize); i++) {
pStorage[i] = new pObject();

}


}

a["allocateStorage"] = allocateStorage;
function now() {
"use strict";
return new Date().getTime();

}

a["now"] = now;
a.clone = function(pObject) {
if ((pObject === null) || ((typeof pObject) !== "object")) {
return pObject;

}

var tmp=pObject.constructor();
for (var i in pObject) {
tmp[i] = a.clone(pObject[i]);

}

return tmp;

};
function getClass(pObj) {
if ((((pObj && ((typeof pObj) === "object")) && ((Object.prototype.toString.call(pObj)) !== "[object Array]")) && (pObj.constructor)) && (pObj != (this.window))) {
var arr=pObj.constructor.toString().match(/function\s*(\w+)/);
if (arr && ((arr.length) == 2)) {
return arr[1];

}


}

var sType=typeof pObj;
return (sType[0].toUpperCase()) + (sType.substr(1));

}

;
a["getClass"] = getClass;
function parseJSON(sJSON) {
return eval(("(" + sJSON) + ")");

}

;
a["parseJSON"] = parseJSON;
function toDOM(sHTML, useDocFragment) {
useDocFragment = (useDocFragment === undefined? true : useDocFragment);
var pDivEl=document.createElement("div");
var pDocFrag=document.createDocumentFragment();
pDivEl.innerHTML = sHTML;
if (!useDocFragment) {
return pDivEl.childNodes;

}

for (var i=0, len=pDivEl.childNodes.length; i < len; ++i) {
if ((typeof (pDivEl.childNodes[i])) === "undefined") {
continue ;

}

pDocFrag.appendChild(pDivEl.childNodes[i]);

}

return pDocFrag;

}

;
a["toDOM"] = toDOM;
function sid() {
return ++sid.iValue;

}

sid.iValue = 0;
a["sid"] = sid;
function buf2str(pBuf) {
var s="";
for (var n=0; n < (pBuf.length); ++n) {
var c=String.fromCharCode(pBuf[n]);
s += c;

}

return s;

}

a["buf2str"] = buf2str;
function str2buf(s) {
var arr=new Array(len);
for (var i=0, len=s.length; i < len; ++i) {
arr[i] = s.charCodeAt(i);

}

return new Uint8Array(arr).buffer;

}

a["str2buf"] = str2buf;
a.defineProperty = function(pObj, sProperty, fnGetter, fnSetter) {
if ((!fnGetter) && (!fnSetter))return ;

fnGetter = fnGetter || (pObj.prototype.__lookupGetter__(sProperty));
fnSetter = fnSetter || (pObj.prototype.__lookupSetter__(sProperty));
Object.defineProperty(pObj.prototype, sProperty,  {get: fnGetter, set: fnSetter, enumerable: true, configurable: true});

};
window["GEN_ARRAY"] = function(pType, nSize) {
var tmp=new Array(nSize);
for (var _i=0; _i < nSize; ++_i) {
tmp[_i] = (pType? new pType() : null);

}

return tmp;

};
function getTypeSize(eType) {
switch(eType) {
case 5120:
;

case 5121:
return 1;

case 5122:
;

case 5123:
;

case 32819:
;

case 32820:
;

case 33635:
return 2;

case 5124:
;

case 5125:
;

case 5126:
return 4;

default:
return undefined;
}

}

a.getTypeSize = getTypeSize;
function getIFormatNumElements(eFormat) {
switch(eFormat) {
case 6407:
;

case 32864:
;

case 32855:
;

case 32856:
;

case 36194:
;

case 36195:
;

case 33776:
return 3;

case 6408:
;

case 6409:
;

case 32854:
;

case 32857:
;

case 33777:
;

case 33780:
;

case 33778:
;

case 33781:
;

case 33779:
return 4;

default:
if (!0) {
var err=((((((("Error:: " + "unknown image format") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/3DImplement.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("unknown image format");

}


}

;
}

}

a.getIFormatNumElements = getIFormatNumElements;
function ParameterDesc() {
this.sName = null;
this.sSemantics = null;
this.eClass = 0;
this.eType = 0;
this.iRows = 0;
this.iColumns = 0;
this.iElements = 0;
this.iStructMembers = 0;

}

ParameterDesc.prototype.dump = function(pWriter) {
pWriter = pWriter || (new a.BinWriter());
pWriter.string(this.sName);
pWriter.string(this.sSemantic);
pWriter.int32(this.eClass);
pWriter.int32(this.eType);
pWriter.int32(this.iRows);
pWriter.int32(this.iColumns);
pWriter.int32(this.iElements);
pWriter.int32(this.iStructMembers);
return pWriter;

};
ParameterDesc.prototype.undump = function(pReader) {
this.sName = pReader.string();
this.sSemantic = pReader.string();
this.eClass = pReader.int32();
this.eType = pReader.int32();
this.iRows = pReader.int32();
this.iColumns = pReader.int32();
this.iElements = pReader.int32();
this.iStructMembers = pReader.int32();
return this;

};
a.ParameterDesc = ParameterDesc;
function calcPOTtextureSize(n, iElements) {
var w, h;
iElements = iElements || 4;
n /= iElements;
w = Math.ceil(((Math.log(n)) / (Math.LN2)) / 2);
h = Math.ceil((Math.log(n / (Math.pow(2, w)))) / (Math.LN2));
w = Math.pow(2, w);
h = Math.pow(2, h);
n = (w * h) * iElements;
return [w, h, n];

}

a.calcPOTtextureSize = calcPOTtextureSize;
function computeNormalMap(pDevice, pImage, pNormalTable, iChannel, fAmplitude) {
var vertexShaderSrc=(((((("" + "/*vertex shader*/") + "attribute vec2 position;") + "varying vec2 texturePosition;") + "void main(void){") + "texturePosition = (position + vec2(1.,1.))/2.;") + "gl_Position = vec4(position,0.,1.);") + "}";
var fragmentShaderSrc=(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((("" + "/*fragment shader*/\n") + "#ifdef GL_ES\n") + "precision highp float;\n") + "#endif\n") + "uniform vec2 steps; /*iverse texture size*/") + "uniform float booster; /*height boost*/") + "uniform sampler2D texture;") + "uniform float fChannel;") + "varying vec2 texturePosition;") + "void main(void){") + "/*generation normals;*/") + "float fHeight0,fHeight1,fHeight2,fHeight3,fHeight4,fHeight5,fHeight6,") + "fHeight7,fHeight8;") + "if(fChannel == 0.){") + "fHeight0 = (texture2D(texture,texturePosition)).r;") + "fHeight1 = (texture2D(texture,texturePosition + vec2(steps.x,0.))).r;") + "fHeight2 = (texture2D(texture,texturePosition + vec2(steps.x,steps.y))).r;") + "fHeight3 = (texture2D(texture,texturePosition + vec2(0.,steps.x))).r;") + "fHeight4 = (texture2D(texture,texturePosition + vec2(-steps.x,steps.y))).r;") + "fHeight5 = (texture2D(texture,texturePosition + vec2(-steps.x,0.))).r;") + "fHeight6 = (texture2D(texture,texturePosition + vec2(-steps.x,-steps.y))).r;") + "fHeight7 = (texture2D(texture,texturePosition + vec2(0.,-steps.y))).r;") + "fHeight8 = (texture2D(texture,texturePosition + vec2(steps.x,-steps.y))).r;") + "}") + "else if(fChannel == 1.){") + "fHeight0 = (texture2D(texture,texturePosition)).g;") + "fHeight1 = (texture2D(texture,texturePosition + vec2(steps.x,0.))).g;") + "fHeight2 = (texture2D(texture,texturePosition + vec2(steps.x,steps.y))).g;") + "fHeight3 = (texture2D(texture,texturePosition + vec2(0.,steps.x))).g;") + "fHeight4 = (texture2D(texture,texturePosition + vec2(-steps.x,steps.y))).g;") + "fHeight5 = (texture2D(texture,texturePosition + vec2(-steps.x,0.))).g;") + "fHeight6 = (texture2D(texture,texturePosition + vec2(-steps.x,-steps.y))).g;") + "fHeight7 = (texture2D(texture,texturePosition + vec2(0.,-steps.y))).g;") + "fHeight8 = (texture2D(texture,texturePosition + vec2(steps.x,-steps.y))).g;") + "}") + "else if(fChannel == 2.){") + "fHeight0 = (texture2D(texture,texturePosition)).b;") + "fHeight1 = (texture2D(texture,texturePosition + vec2(steps.x,0.))).b;") + "fHeight2 = (texture2D(texture,texturePosition + vec2(steps.x,steps.y))).b;") + "fHeight3 = (texture2D(texture,texturePosition + vec2(0.,steps.x))).b;") + "fHeight4 = (texture2D(texture,texturePosition + vec2(-steps.x,steps.y))).b;") + "fHeight5 = (texture2D(texture,texturePosition + vec2(-steps.x,0.))).b;") + "fHeight6 = (texture2D(texture,texturePosition + vec2(-steps.x,-steps.y))).b;") + "fHeight7 = (texture2D(texture,texturePosition + vec2(0.,-steps.y))).b;") + "fHeight8 = (texture2D(texture,texturePosition + vec2(steps.x,-steps.y))).b;") + "}") + "else{") + "fHeight0 = (texture2D(texture,texturePosition)).a;") + "fHeight1 = (texture2D(texture,texturePosition + vec2(steps.x,0.))).a;") + "fHeight2 = (texture2D(texture,texturePosition + vec2(steps.x,steps.y))).a;") + "fHeight3 = (texture2D(texture,texturePosition + vec2(0.,steps.x))).a;") + "fHeight4 = (texture2D(texture,texturePosition + vec2(-steps.x,steps.y))).a;") + "fHeight5 = (texture2D(texture,texturePosition + vec2(-steps.x,0.))).a;") + "fHeight6 = (texture2D(texture,texturePosition + vec2(-steps.x,-steps.y))).a;") + "fHeight7 = (texture2D(texture,texturePosition + vec2(0.,-steps.y))).a;") + "fHeight8 = (texture2D(texture,texturePosition + vec2(steps.x,-steps.y))).a;") + "}") + "vec3 dir1 = vec3(steps.x, 0., (fHeight1 - fHeight0)*booster);") + "vec3 dir2 = vec3(steps.x, steps.y, (fHeight2 - fHeight0)*booster);") + "vec3 dir3 = vec3(0., steps.y, (fHeight3 - fHeight0)*booster);") + "vec3 dir4 = vec3(-steps.x, steps.y, (fHeight4 - fHeight0)*booster);") + "vec3 dir5 = vec3(-steps.x, 0., (fHeight5 - fHeight0)*booster);") + "vec3 dir6 = vec3(-steps.x, -steps.y, (fHeight6 - fHeight0)*booster);") + "vec3 dir7 = vec3(0., -steps.y, (fHeight7 - fHeight0)*booster);") + "vec3 dir8 = vec3(steps.x, -steps.y, (fHeight8 - fHeight0)*booster);") + "vec3 normal1 = cross(dir1,dir2);") + "vec3 normal2 = cross(dir2,dir3);") + "vec3 normal3 = cross(dir3,dir4);") + "vec3 normal4 = cross(dir4,dir5);") + "vec3 normal5 = cross(dir5,dir6);") + "vec3 normal6 = cross(dir6,dir7);") + "vec3 normal7 = cross(dir7,dir8);") + "vec3 normal8 = cross(dir8,dir1);") + "vec3 normal = normalize(normal1 + normal2 + normal3 + normal4") + "+ normal5 + normal6 + normal7 + normal8);") + "gl_FragColor = vec4(normal/2. + vec3(0.5),1.);") + "}";
var progCalculateNormalMap=null;
if (!(pDevice.computeNormalMapFromHeightMap)) {
var vertexShader=pDevice.createShader(pDevice.VERTEX_SHADER);
pDevice.shaderSource(vertexShader, vertexShaderSrc);
pDevice.compileShader(vertexShader);
var fragmentShader=pDevice.createShader(pDevice.FRAGMENT_SHADER);
pDevice.shaderSource(fragmentShader, fragmentShaderSrc);
pDevice.compileShader(fragmentShader);
progCalculateNormalMap = pDevice.createProgram();
pDevice.attachShader(progCalculateNormalMap, vertexShader);
pDevice.attachShader(progCalculateNormalMap, fragmentShader);
pDevice.linkProgram(progCalculateNormalMap);
pDevice.computeNormalMapFromHeightMap = progCalculateNormalMap;

}
else  {
progCalculateNormalMap = pDevice.computeNormalMapFromHeightMap;

}

pDevice.useProgram(progCalculateNormalMap);
progCalculateNormalMap.position = pDevice.getAttribLocation(progCalculateNormalMap, "position");
pDevice.enableVertexAttribArray(progCalculateNormalMap.position);
progCalculateNormalMap.steps = pDevice.getUniformLocation(progCalculateNormalMap, "steps");
progCalculateNormalMap.booster = pDevice.getUniformLocation(progCalculateNormalMap, "booster");
progCalculateNormalMap.texture = pDevice.getUniformLocation(progCalculateNormalMap, "texture");
progCalculateNormalMap.fChannel = pDevice.getUniformLocation(progCalculateNormalMap, "fChannel");
if (!(pDevice.getProgramParameter(progCalculateNormalMap, pDevice.LINK_STATUS))) {
alert("Could not initialise create normal map shaders");
return ;

}

var index=pDevice.createBuffer();
pDevice.bindBuffer(pDevice.ARRAY_BUFFER, index);
pDevice.bufferData(pDevice.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), pDevice.STREAM_DRAW);
var heightTexture=pDevice.createTexture();
pDevice.activeTexture(pDevice.TEXTURE0);
pDevice.bindTexture(pDevice.TEXTURE_2D, heightTexture);
pImage.convert(6408);
pDevice.texImage2D(3553, 0, 6408, pImage.getWidth(), pImage.getHeight(), 0, pImage.getFormatShort(), pImage.getType(), new Uint8Array(pImage.getData(0)));
pDevice.texParameteri(pDevice.TEXTURE_2D, pDevice.TEXTURE_WRAP_S, pDevice.CLAMP_TO_EDGE);
pDevice.texParameteri(pDevice.TEXTURE_2D, pDevice.TEXTURE_WRAP_T, pDevice.CLAMP_TO_EDGE);
pDevice.generateMipmap(pDevice.TEXTURE_2D);
var normalTexture=pDevice.createTexture();
pDevice.activeTexture(pDevice.TEXTURE1);
pDevice.bindTexture(pDevice.TEXTURE_2D, normalTexture);
pDevice.pixelStorei(pDevice.UNPACK_ALIGNMENT, 1);
pDevice.texImage2D(pDevice.TEXTURE_2D, 0, pDevice.RGB, pImage.getWidth(), pImage.getHeight(), 0, pDevice.RGB, pDevice.UNSIGNED_BYTE, null);
var normalTextureFrameBuffer=pDevice.createFramebuffer();
pDevice.bindFramebuffer(pDevice.FRAMEBUFFER, normalTextureFrameBuffer);
pDevice.framebufferTexture2D(pDevice.FRAMEBUFFER, pDevice.COLOR_ATTACHMENT0, pDevice.TEXTURE_2D, normalTexture, 0);
pDevice.uniform2f(progCalculateNormalMap.steps, 1 / (pImage.getWidth()), 1 / (pImage.getHeight()));
pDevice.uniform1f(progCalculateNormalMap.booster, fAmplitude / 255);
pDevice.uniform1f(progCalculateNormalMap.fChannel, iChannel);
pDevice.uniform1i(progCalculateNormalMap.texture, 0);
pDevice.vertexAttribPointer(progCalculateNormalMap.position, 2, pDevice.FLOAT, false, 0, 0);
pDevice.viewport(0, 0, pImage.getWidth(), pImage.getHeight());
pDevice.drawArrays(pDevice.TRIANGLE_STRIP, 0, 4);
pDevice.flush();
var pTemp=new Uint8Array((4 * (pImage.getWidth())) * (pImage.getHeight()));
pDevice.readPixels(0, 0, pImage.getWidth(), pImage.getHeight(), pDevice.RGBA, pDevice.UNSIGNED_BYTE, pTemp);
for (var i=0; i < ((pImage.getWidth()) * (pImage.getHeight())); i++) {
pNormalTable[i][0] = pTemp[4 * i];
pNormalTable[i][1] = pTemp[(4 * i) + 1];
pNormalTable[i][2] = pTemp[(4 * i) + 2];

}

pDevice.bindFramebuffer(pDevice.FRAMEBUFFER, null);
pDevice.deleteBuffer(index);
pDevice.deleteFramebuffer(normalTextureFrameBuffer);
pDevice.deleteTexture(heightTexture);
pDevice.activeTexture(pDevice.TEXTURE0);
pDevice.bindTexture(pDevice.TEXTURE_2D, null);
pDevice.deleteTexture(normalTexture);
pDevice.activeTexture(pDevice.TEXTURE1);
pDevice.bindTexture(pDevice.TEXTURE_2D, null);

}

;
a.computeNormalMap = computeNormalMap;
function createSingleStripGrid(iXVerts, iYVerts, iXStep, iYStep, iSride, iFlags) {
var iTotalStrips=iYVerts - 1;
var iTotalIndexesPerStrip=iXVerts << 1;
var iTotalIndexes=((iTotalStrips * iTotalIndexesPerStrip) + (iTotalStrips << 1)) - 2;
var pIndexValues=new Array(iTotalIndexes);
var iIndex=0;
var iStartVert=0;
var iLineStep=iYStep * iSride;
for (j = 0; j < iTotalStrips; ++j) {
var k=0;
var iVert=iStartVert;
for (k = 0; k < iXVerts; ++k) {
pIndexValues[iIndex++] = iVert;
pIndexValues[iIndex++] = iVert + iLineStep;
iVert += iXStep;

}

iStartVert += iLineStep;
if ((j + 1) < iTotalStrips) {
pIndexValues[iIndex++] = (iVert - iXStep) + iLineStep;
pIndexValues[iIndex++] = iStartVert;

}


}

return pIndexValues;

}

a.createSingleStripGrid = createSingleStripGrid;
if (!(window.requestAnimationFrame)) {
window.requestAnimationFrame = (function() {
return ((((window.webkitRequestAnimationFrame) || (window.mozRequestAnimationFrame)) || (window.oRequestAnimationFrame)) || (window.msRequestAnimationFrame)) || (function(callback, element) {
window.setTimeout(callback, 1000 / 60);

}
);

}
)();

}

a.requestAnimFrame = window.requestAnimationFrame;
a.cancelRequestAnimFrame = (function() {
return (((((window.cancelCancelRequestAnimationFrame) || (window.webkitCancelRequestAnimationFrame)) || (window.mozCancelRequestAnimationFrame)) || (window.oCancelRequestAnimationFrame)) || (window.msCancelRequestAnimationFrame)) || (window.clearTimeout);

}
)();
a.checkTextureRequirements = function(pContext, iWidth, iHeigth, iMipLevels, eUsage, eFormat, ePool) {
return true;

};
a.checkCubeTextureRequirements = function(pContext, iWidth, iHeigth, iMipLevels, eUsage, eFormat, ePool) {
return true;

};
a.createDevice = function(pCanvas) {
var pContext;
try {
pContext = (pCanvas.getContext("webgl")) || (pCanvas.getContext("experimental-webgl"));
if (WebGLDebugUtils) {
pContext = WebGLDebugUtils.makeDebugContext(pContext);

}


}
catch(e) {

}
if (!pContext) {
if (!0) {
var err=((((((("Error:: " + "Your browser does not support WebGL") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/PreLoad.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Your browser does not support WebGL");

}


}

;
return null;

}
else  {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/PreLoad.js") + "][") + "") + "]") + " WebGL successfully initialized.");

}

a.initDevice(pContext);
return pContext;

};
a.deleteDevice = function(pDevice) {

};
a.initDevice = function(pDevice) {
pDevice._eSrcBlend = 1;
pDevice._eDstBlend = 0;
pDevice.setRenderState = function(type, value) {
switch(type) {
case 19:
this._eSrcBlend = value;
this.blendFunc(this._eSrcBlend, this._eDstBlend);
break ;

case 20:
this._eDstBlend = value;
this.blendFunc(this._eSrcBlend, this._eDstBlend);
break ;

case 22:
break ;

case 26:
if (value) {
this.enable(this.DITHER);

}
else  {
this.disable(this.DITHER);

}

break ;

case 7:
if (value) {
this.enable(this.DEPTH_TEST);

}
else  {
this.disable(this.DEPTH_TEST);

}

break ;

case 14:
this.depthMask(value);
break ;

case 23:
var sTmp;
switch(value) {
case 1:
sTmp = this.NEVER;
break ;

case 2:
sTmp = this.LESS;
break ;

case 3:
sTmp = this.EQUAL;
break ;

case 5:
sTmp = this.GREATER;
break ;

case 6:
sTmp = this.NOTEQUAL;
break ;

case 7:
sTmp = this.GEQUAL;
break ;

case 8:
sTmp = this.ALWAYS;
break ;

default:
sTmp = this.LEQUAL;
break ;
}
this.depthFunc(sTmp);
break ;

default:
break ;
}
return ;

};
var pExtentions=$$enum_GRAPHICS_EXTENTIONS$_keys;
var pExtentionsList= {};
for (var i=0, pExt; i < (pExtentions.length); ++i) {
if (pExt = a.info.graphics.getExtention(pDevice, pExtentions[i])) {
pExtentionsList[pExtentions[i]] = pExt;
for (var j in pExt) {
if ((typeof (pExt[j])) == "function") {
pDevice[j] = function() {
pDevice[j] = new Function((((("var tmp = this.pExtentionsList[" + (pExtentions[i])) + "];") + "tmp.") + j) + ".apply(tmp, arguments);");

};

}
else  {
pDevice[j] = pExtentionsList[pExtentions[i]][j];

}


}


}
else  {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/PreLoad.js") + "][") + "") + "]") + ("cannot load extension: " + (pExtentions[i])));

}


}

pDevice.pExtentionsList = pExtentionsList;

};
a.UtilTimer = function(eCommand) {
if ((a.UtilTimer._isTimerInitialized) == false) {
a.UtilTimer._isTimerInitialized = true;
a.UtilTimer._fTicksPerSec = 1000;

}

var fTime=0;
var fElapsedTime=0;
var iTime;
if ((((a.UtilTimer._iStopTime) != 0) && (eCommand != (1))) && (eCommand != (4))) {
iTime = a.UtilTimer._iStopTime;

}
else  {
iTime = new Date().getTime();

}

if (eCommand == (6)) {
fElapsedTime = (iTime - (a.UtilTimer._iLastElapsedTime)) / (a.UtilTimer._fTicksPerSec);
a.UtilTimer._iLastElapsedTime = iTime;
return fElapsedTime;

}

if (eCommand == (5)) {
var fAppTime=(iTime - (a.UtilTimer._iBaseTime)) / (a.UtilTimer._fTicksPerSec);
return fAppTime;

}

if (eCommand == (0)) {
a.UtilTimer._iBaseTime = iTime;
a.UtilTimer._iLastElapsedTime = iTime;
a.UtilTimer._iStopTime = 0;
a.UtilTimer._isTimerStopped = false;
return 0;

}

if (eCommand == (1)) {
if (a.UtilTimer._isTimerStopped) {
a.UtilTimer._iBaseTime += iTime - (a.UtilTimer._iStopTime);

}

a.UtilTimer._iStopTime = 0;
a.UtilTimer._iLastElapsedTime = iTime;
a.UtilTimer._isTimerStopped = false;
return 0;

}

if (eCommand == (2)) {
if (!(a.UtilTimer._isTimerStopped)) {
a.UtilTimer._iStopTime = iTime;
a.UtilTimer._iLastElapsedTime = iTime;
a.UtilTimer._isTimerStopped = true;

}

return 0;

}

if (eCommand == (3)) {
a.UtilTimer._iStopTime += (a.UtilTimer._fTicksPerSec) / 10;
return 0;

}

if (eCommand == (4)) {
fTime = iTime / (a.UtilTimer._fTicksPerSec);
return fTime;

}

return -1;

};
a.UtilTimer._isTimerInitialized = false;
a.UtilTimer._isTimerStopped = true;
a.UtilTimer._fTicksPerSec = 0;
a.UtilTimer._iStopTime = 0;
a.UtilTimer._iLastElapsedTime = 0;
a.UtilTimer._iBaseTime = 0;
function Keymap(pMouseTarget, pKeyboardTarget) {
"use strict";
pKeyboardTarget = pKeyboardTarget || pMouseTarget;
this.pMap = new Array(256);
this.isAlt = false;
this.isCtrl = false;
this.isShift = false;
this.isMouseDown = false;
this.v2iMousePos = new Int16Array(2);
this.v2iMouseLastPos = new Int16Array(2);
for (var i=255; i--; ) {
this.pMap[i] = false;

}

;
if (pMouseTarget) {
this.setTarget(pMouseTarget, pKeyboardTarget);

}


}

Keymap.prototype.setTarget = function(pMouseTarget, pKeyboardTarget) {
"use strict";
pKeyboardTarget = pKeyboardTarget || pMouseTarget;
var me=this;
var fnCallback=function(e) {
me.dispatch(e);

};
if (pMouseTarget.addEventListener) {
pKeyboardTarget.addEventListener("keydown", fnCallback, false);
pKeyboardTarget.addEventListener("keyup", fnCallback, false);
pMouseTarget.addEventListener("mousemove", fnCallback, true);
pMouseTarget.addEventListener("mouseup", fnCallback, true);
pMouseTarget.addEventListener("mousedown", fnCallback, true);

}
else if (pMouseTarget.attachEvent) {
pKeyboardTarget.attachEvent("onkeydown", fnCallback);
pKeyboardTarget.attachEvent("onkeyup", fnCallback);
pMouseTarget.attachEvent("onmousemove", fnCallback);
pMouseTarget.attachEvent("onmouseup", fnCallback);
pMouseTarget.attachEvent("onmousedown", fnCallback);

}
else  {
pKeyboardTarget.onkeydown = pKeyboardTarget.onkeyup = fnCallback;
pMouseTarget.onmousemove = pMouseTarget.onmouseup = pMouseTarget.onmousedown = fnCallback;

}



};
Keymap.prototype.dispatch = function(pEvent) {
var e=pEvent || (window.event);
var code=e.keyCode;
if ((e.type) == "keydown") {
this.pMap[code] = true;
if (e.altKey) {
this.isAlt = true;

}

if (e.ctrlKey) {
this.isCtrl = true;

}

if (e.shiftKey) {
this.isShift = true;

}

if (((e.altKey) || (e.ctrlKey)) || (e.shiftKey)) {
this.pMap.splice(0);

}


}
else if ((e.type) == "keyup") {
this.pMap[code] = false;
if (code == (18)) {
this.isAlt = false;

}

if (code == (17)) {
this.isCtrl = false;

}

if (code == (16)) {
this.isShift = false;

}


}


if ((e.type) == "mousemove") {
this.v2iMousePos[0] = e.pageX;
this.v2iMousePos[1] = e.pageY;

}
else if ((e.type) == "mouseup") {
this.isMouseDown = false;

}
else if ((e.type) == "mousedown") {
this.isMouseDown = true;

}




};
Keymap.prototype.isKeyPress = function(iCode) {
return this.pMap[iCode];

};
Keymap.prototype.mouseSnapshot = function() {
this.v2iMouseLastPos[0] = this.v2iMousePos[0];
this.v2iMouseLastPos[1] = this.v2iMousePos[1];
return this.v2iMousePos;

};
Keymap.prototype.isMouseMoved = function() {
return ((this.v2iMouseLastPos[0]) != (this.v2iMousePos[0])) || ((this.v2iMouseLastPos[1]) != (this.v2iMousePos[1]));

};
Keymap.prototype.mouseShitfX = function() {
return (this.v2iMousePos[0]) - (this.v2iMouseLastPos[0]);

};
Keymap.prototype.mouseShitfY = function() {
return (this.v2iMousePos[1]) - (this.v2iMouseLastPos[1]);

};
Keymap.prototype.isMousePress = function() {
return this.isMouseDown;

};
a.Keymap = Keymap;
var Gamepad= {TYPICAL_BUTTON_COUNT: 16, TYPICAL_AXIS_COUNT: 4, ticking: false, collection: [], prevRawGamepadTypes: [], prevTimestamps: [], callbacks:  {connect: function(gamepad) {
console.log("connected gamepad: ", gamepad);

}
, disconnect: function(gamepad) {
console.log("disconnected gamepad: ", gamepad);

}
, update: function(gamepad) {
console.log("gamepad updated: ", gamepad);

}
}, on: function(event, callback) {
Gamepad.callbacks[event] = callback;

}
, init: function() {
var gamepadSupportAvailable=((!(!(navigator.webkitGetGamepads))) || (!(!(navigator.webkitGamepads)))) || ((navigator.userAgent.indexOf("Firefox/")) != (-1));
if (!gamepadSupportAvailable) {

}
else  {
window.addEventListener("MozGamepadConnected", Gamepad.onGamepadConnect, false);
window.addEventListener("MozGamepadDisconnected", Gamepad.onGamepadDisconnect, false);
if ((!(!(navigator.webkitGamepads))) || (!(!(navigator.webkitGetGamepads)))) {
Gamepad.startPolling();
return true;

}


}

return false;

}
, onGamepadConnect: function(event) {
Gamepad.collection.push(event.gamepad);
Gamepad.callbacks.connect(event.gamepad);
Gamepad.startPolling();

}
, onGamepadDisconnect: function(event) {
var gamepad;
for (var i in Gamepad.collection) {
if ((Gamepad.collection[i].index) == (event.gamepad.index)) {
gamepad = Gamepad.collection.splice(i, 1)[0];
Gamepad.callbacks.disconnect(gamepad);
break ;

}


}

if ((Gamepad.collection.length) == 0) {
Gamepad.stopPolling();

}


}
, startPolling: function() {
if (!(Gamepad.ticking)) {
Gamepad.ticking = true;
Gamepad.tick();

}


}
, stopPolling: function() {
Gamepad.ticking = false;

}
, tick: function() {
Gamepad.pollStatus();
Gamepad.scheduleNextTick();

}
, scheduleNextTick: function() {
if (Gamepad.ticking) {
if (window.requestAnimationFrame) {
window.requestAnimationFrame(Gamepad.tick);

}
else if (window.mozRequestAnimationFrame) {
window.mozRequestAnimationFrame(Gamepad.tick);

}
else if (window.webkitRequestAnimationFrame) {
window.webkitRequestAnimationFrame(Gamepad.tick);

}




}


}
, pollStatus: function() {
Gamepad.pollGamepads();
for (var i in Gamepad.collection) {
var gamepad=Gamepad.collection[i];
if ((gamepad.timestamp) && ((gamepad.timestamp) == (Gamepad.prevTimestamps[i]))) {
continue ;

}

Gamepad.prevTimestamps[i] = gamepad.timestamp;

}


}
, pollGamepads: function() {
var rawGamepads=((navigator.webkitGetGamepads) && (navigator.webkitGetGamepads())) || (navigator.webkitGamepads);
if (rawGamepads) {
Gamepad.collection = [];
var gamepadsChanged=false;
for (var i=0; i < (rawGamepads.length); i++) {
if ((typeof (rawGamepads[i])) != (Gamepad.prevRawGamepadTypes[i])) {
gamepadsChanged = true;
Gamepad.prevRawGamepadTypes[i] = typeof (rawGamepads[i]);
if (rawGamepads[i]) {
Gamepad.callbacks.update(rawGamepads[i]);

}


}

if (rawGamepads[i]) {
Gamepad.collection.push(rawGamepads[i]);

}


}


}


}
};
a.Gamepad = Gamepad;
function Timer() {
this._iStartTime = 0;
this._iStopTime = 0;
this._iTimeDelta = 0;
this._iElapsedCount = 0;
this._eState = 0;
this._setupTimerFrequency();

}

;
Timer.prototype._iSecondsFrequency = 0;
Timer.prototype._iMillisecondsFrequency = 0;
Timer.prototype._fInvSecFrequency = 0;
Timer.prototype.start = function() {
this._iStartTime = this._samplePerformanceCounter();
this._iElapsedCount = 0;
this._eState = 1;

};
Timer.prototype.stop = function() {
this._iElapsedCount = this.elapsedCount();
this._eState = 0;

};
Timer.prototype.suspend = function() {
if ((this._eState) == (1)) {
this._iElapsedCount = this.elapsedCount();
this._eState = 2;

}


};
Timer.prototype.resume = function() {
if ((this._eState) == (2)) {
this._iStartTime = this._samplePerformanceCounter();
this._iStartTime -= this._iTimeDelta;
this._iElapsedCount = 0;
this._eState = 1;

}


};
Timer.prototype.elapsedTime = function() {
if ((this._eState) != (1)) {
return (this._iElapsedCount) * (this._fInvSecFrequency);

}
else  {
this._iStopTime = this._samplePerformanceCounter();
this._iTimeDelta = (this._iStopTime) - (this._iStartTime);
var fReportedTime=(this._iTimeDelta) * (this._fInvSecFrequency);
return fReportedTime;

}


};
Timer.prototype.elapsedSeconds = function() {
if ((this._eState) != (1)) {
return (this._iElapsedCount) / (this._iSecondsFrequency);

}
else  {
this._iStopTime = this._samplePerformanceCounter();
this._iTimeDelta = (this._iStopTime) - (this._iStartTime);
var iReportedTime=(this._iTimeDelta) / (this._iSecondsFrequency);
return iReportedTime;

}


};
Timer.prototype.elapsedMilliseconds = function() {
if ((this._eState) != (1)) {
return (this._iElapsedCount) / (this._iMillisecondsFrequency);

}
else  {
this._iStopTime = this._samplePerformanceCounter();
this._iTimeDelta = (this._iStopTime) - (this._iStartTime);
var iReportedTime=(this._iTimeDelta) / (this._iMillisecondsFrequency);
return iReportedTime;

}


};
Timer.prototype.elapsedCount = function() {
if ((this._eState) != (1)) {
return this._iElapsedCount;

}
else  {
this._iStopTime = this._samplePerformanceCounter();
this._iTimeDelta = (this._iStopTime) - (this._iStartTime);
var iReportedTime=this._iTimeDelta;
return iReportedTime;

}


};
Timer.prototype._setupTimerFrequency = function() {
if (!(this._iSecondsFrequency)) {
this._iSecondsFrequency = 1000;
this._iMillisecondsFrequency = (this._iSecondsFrequency) / 1000;
this._fInvSecFrequency = 1 / (this._iSecondsFrequency);

}


};
Timer.prototype._samplePerformanceCounter = function() {
return new Date().getTime();

};
a.Timer = Timer;
function ApplicationTimer() {
ApplicationTimer.superclass.constructor.apply(this, arguments);

}

;
a.extend(ApplicationTimer, a.Timer);
ApplicationTimer.prototype.start = function() {
ApplicationTimer.superclass.start.apply(this, arguments);

};
ApplicationTimer.prototype.stop = function() {
ApplicationTimer.superclass.stop.apply(this, arguments);

};
a.ApplicationTimer = ApplicationTimer;
pApplicationTimer = new a.ApplicationTimer();
a.pApplicationTimer = pApplicationTimer;
function CodeTimer(sNameString) {
this._pNextProfile = null;
this._pLastProfile = this._pPreviousTimer;
this._fTotalTime = 0;
this._iTotalCalls = 0;
this._fMaximumTimeSample = 0;
this._fMinimumTimeSample = 3.4e+38;
this._fStartTime = 0;
if (!sNameString) {
var err=((((((("Error:: " + "A name must be provided to the code timer") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/timer/CodeTimer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("A name must be provided to the code timer");

}


}

;
this._sName = sNameString;
if ((this._pPreviousTimer) != null) {
this._pPreviousTimer._pNextProfile = this;

}

this._pPreviousTimer = this;

}

;
CodeTimer.prototype.pRootTimer = new CodeTimer("_ROOT_");
CodeTimer.prototype._pPreviousTimer = null;
CodeTimer.prototype.averageTime = function() {
if ((this._iTotalCalls) != 0) {
return (this._fTotalTime) / (this._iTotalCalls);

}

return 0;

};
CodeTimer.prototype.totalTime = function() {
return this._fTotalTime;

};
CodeTimer.prototype.totalCalls = function() {
return this._iTotalCalls;

};
CodeTimer.prototype.maximumTimeSample = function() {
return this._fMaximumTimeSample;

};
CodeTimer.prototype.minimumTimeSample = function() {
return this._fMinimumTimeSample;

};
CodeTimer.prototype.name = function() {
return this._sName;

};
CodeTimer.prototype.beginSession = function() {
this._iTotalCalls++;
if ((this._fStartTime) == 0) {
this._fStartTime = a.pApplicationTimer.elapsedTime();

}


};
CodeTimer.prototype.endSession = function() {
if ((this._fStartTime) != 0) {
var fEndTime=a.pApplicationTimer.elapsedTime();
if (!(fEndTime >= (this._fStartTime))) {
var err=((((((("Error:: " + "we moved backwards in time!!!?") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/timer/CodeTimer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("we moved backwards in time!!!?");

}


}

;
var fSample=fEndTime - (this._fStartTime);
this._fTotalTime += fSample;
this._fMaximumTimeSample = Math.max(this._fMaximumTimeSample, fSample);
this._fMinimumTimeSample = Math.min(this._fMinimumTimeSample, fSample);

}

this._fStartTime = 0;

};
CodeTimer.prototype.reset = function() {
this._fTotalTime = 0;
this._iTotalCalls = 0;
this._fMaximumTimeSample = 0;
this._fMinimumTimeSample = 3.4e+38;
this._fStartTime = 0;

};
CodeTimer.prototype.output = function() {
debug_assert(this._sName, this._fTotalTime, this._iTotalCalls, ((this._iTotalCalls) != 0? (this._fTotalTime) / (this._iTotalCalls) : 0), this._fMinimumTimeSample, this._fMaximumTimeSample);
this.reset();

};
CodeTimer.prototype.outputAllTimers = function(iMessageFlags) {
this.output(iMessageFlags);
if ((this._pNextProfile) != null) {
this._pNextProfile.outputAllTimers(iMessageFlags);

}


};
CodeTimer.prototype.resetAllTimers = function() {
this.reset();
if ((this._pNextProfile) != null) {
this._pNextProfile.resetAllTimers();

}


};
a.CodeTimer = CodeTimer;
function FunctionTimer(pTimer) {
this._pInternalTimerLink = pTimer;
if (!this._pInternalTimerLink) {
var err=((((((("Error:: " + "A timer link must be provided") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/timer/CodeTimer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("A timer link must be provided");

}


}

;
this._pInternalTimerLink.beginSession();

}

FunctionTimer.prototype.destructor = function() {
this._pInternalTimerLink.endSession();

};
a.FunctionTimer = FunctionTimer;
function Vec2() {
var v2fVec;
if (((this) === window) || ((this) === (window.AKRA))) {
v2fVec = Vec2._pStorage[Vec2._iIndex++];
if ((Vec2._iIndex) == (Vec2._nStorageSize)) {
Vec2._iIndex = 0;

}

if ((arguments.length) == 0) {
return v2fVec;

}


}
else  {
this.pData = new Float32Array(2);
v2fVec = this;

}

var nArgumentsLength=arguments.length;
if (nArgumentsLength == 1) {
return v2fVec.set(arguments[0]);

}
else if (nArgumentsLength == 2) {
return v2fVec.set(arguments[0], arguments[1]);

}
else  {
return v2fVec;

}



}

;
a.defineProperty(Vec2, "x", function() {
return this.pData[0];

}
, function(fValue) {
this.pData[0] = fValue;

}
);
a.defineProperty(Vec2, "y", function() {
return this.pData[1];

}
, function(fValue) {
this.pData[1] = fValue;

}
);
Vec2.prototype.set = function() {
"use strict";
var pData=this.pData;
if ((arguments.length) == 1) {
if ((typeof (arguments[0])) == "number") {
this.pData[0] = this.pData[1] = arguments[0];

}
else if ((arguments[0]) instanceof Vec2) {
var pData2=arguments[0].pData;
pData[0] = pData2[0];
pData[1] = pData2[1];

}
else  {
var pElements=arguments[0];
pData[0] = pElements[0];
pData[1] = pElements[1];

}



}
else  {
pData[0] = arguments[0];
pData[1] = arguments[1];

}

return this;

};
Vec2.prototype.add = function(v2fVec, v2fDestination) {
"use strict";
if (!v2fDestination) {
v2fDestination = this;

}

var pData1=this.pData;
var pData2=v2fVec.pData;
var pDataDestination=v2fDestination.pData;
pDataDestination[0] = (pData1[0]) + (pData2[0]);
pDataDestination[1] = (pData1[1]) + (pData2[1]);
return v2fDestination;

};
Vec2.prototype.subtract = function(v2fVec, v2fDestination) {
"use strict";
if (!v2fDestination) {
v2fDestination = this;

}

var pData1=this.pData;
var pData2=v2fVec.pData;
var pDataDestination=v2fDestination.pData;
pDataDestination[0] = (pData1[0]) - (pData2[0]);
pDataDestination[1] = (pData1[1]) - (pData2[1]);
return v2fDestination;

};
Vec2.prototype.negate = function(v2fDestination) {
"use strict";
if (!v2fDestination) {
v2fDestination = this;

}

var pData=this.pData;
var pDataDestination=v2fDestination.pData;
pDataDestination[0] = -(pData[0]);
pDataDestination[1] = -(pData[1]);
return v2fDestination;

};
Vec2.prototype.scale = function(fScale, v2fDestination) {
"use strict";
if (!v2fDestination) {
v2fDestination = this;

}

var pData=this.pData;
var pDataDestination=v2fDestination.pData;
pDataDestination[0] = (pData[0]) * fScale;
pDataDestination[1] = (pData[1]) * fScale;
return v2fDestination;

};
Vec2.prototype.normalize = function(v2fDestination) {
"use strict";
if (!v2fDestination) {
v2fDestination = this;

}

var pData=this.pData;
var pDataDestination=v2fDestination.pData;
var x, y;
x = pData[0];
y = pData[1];
var fLength=Math.sqrt((x * x) + (y * y));
if (fLength) {
x = x / fLength;
y = y / fLength;

}

pDataDestination[0] = x;
pDataDestination[1] = y;
return v2fDestination;

};
Vec2.prototype.length = function() {
"use strict";
var pData=this.pData;
var x=pData[0], y=pData[1];
return Math.sqrt((x * x) + (y * y));

};
Vec2.prototype.lengthSquare = function() {
"use strict";
var pData=this.pData;
var x=pData[0], y=pData[1];
return (x * x) + (y * y);

};
Vec2.prototype.dot = function(v2fVec) {
"use strict";
var pData1=this.pData;
var pData2=v2fVec.pData;
return ((pData1[0]) * (pData2[0])) + ((pData1[1]) * (pData2[1]));

};
Vec2.prototype.direction = function(v2fVec, v2fDestination) {
"use strict";
if (!v2fDestination) {
v2fDestination = this;

}

var pData1=this.pData;
var pData2=v2fVec.pData;
var pDataDestination=v2fDestination.pData;
var x, y;
x = (pData2[0]) - (pData1[0]);
y = (pData2[0]) - (pData1[0]);
var flength=Math.sqrt((x * x) + (y * y));
if (flength) {
x = x / fLength;
y = y / fLength;

}

pDataDestination[0] = x;
pDataDestination[1] = y;
return v2fDestination;

};
Vec2.prototype.mix = function(v2fVec, fA, v2fDestination) {
"use strict";
if (!v2fDestination) {
v2fDestination = this;

}

var pData1=this.pData;
var pData2=v2fVec.pData;
var pDataDestination=v2fDestination.pData;
fA = Math.max(0, Math.min(fA, 1));
var fA1=1 - fA;
var fA2=fA;
pDataDestination[0] = (fA1 * (pData1[0])) + (fA2 * (pData2[0]));
pDataDestination[1] = (fA1 * (pData1[1])) + (fA2 * (pData2[1]));
return v2fDestination;

};
Vec2.prototype.isEqual = function(v2fVec, fEps) {
"use strict";
var pData1=this.pData;
var pData2=v2fVec.pData;
fEps = (fEps === undefined? 0 : fEps);
if (fEps == 0) {
if (((pData1[0]) != (pData2[0])) || ((pData1[1]) != (pData2[1]))) {
return false;

}


}
else  {
if (((Math.abs((pData1[0]) - (pData2[0]))) > fEps) || ((Math.abs((pData1[1]) - (pData2[1]))) > fEps)) {
return false;

}


}

return true;

};
Vec2.prototype.isClear = function() {
"use strict";
var pData=this.pData;
if (((pData[0]) != 0) || ((pData[1]) != 0)) {
return false;

}

return true;

};
Vec2.prototype.clear = function() {
"use strict";
var pData=this.pData;
pData[0] = pData[1] = 0;
return this;

};
Vec2.prototype.toString = function() {
"use strict";
var pData=this.pData;
return ((("[" + (pData[0])) + ", ") + (pData[1])) + "]";

};
Vec2.prototype.mult = Vec2.prototype.multiply;
a.allocateStorage(Vec2, 100);
function Vec3() {
var v3fVec;
if (((this) === window) || ((this) === (window.AKRA))) {
v3fVec = Vec3._pStorage[Vec3._iIndex++];
if ((Vec3._iIndex) == (Vec3._nStorageSize)) {
Vec3._iIndex = 0;

}

if ((arguments.length) == 0) {
return v3fVec;

}


}
else  {
this.pData = new Float32Array(3);
v3fVec = this;

}

var nArgumentsLength=arguments.length;
if (nArgumentsLength == 1) {
return v3fVec.set(arguments[0]);

}
else if (nArgumentsLength == 2) {
return v3fVec.set(arguments[0], arguments[1]);

}
else if (nArgumentsLength == 3) {
return v3fVec.set(arguments[0], arguments[1], arguments[2]);

}
else  {
return v3fVec;

}




}

a.defineProperty(Vec3, "x", function() {
return this.pData[0];

}
, function(fValue) {
this.pData[0] = fValue;

}
);
a.defineProperty(Vec3, "y", function() {
return this.pData[1];

}
, function(fValue) {
this.pData[1] = fValue;

}
);
a.defineProperty(Vec3, "z", function() {
return this.pData[2];

}
, function(fValue) {
this.pData[2] = fValue;

}
);
Vec3.prototype.set = function() {
"use strict";
var pData=this.pData;
var nArgumentsLength=arguments.length;
if (nArgumentsLength == 1) {
if ((typeof (arguments[0])) == "number") {
pData[0] = pData[1] = pData[2] = arguments[0];

}
else if ((arguments[0]) instanceof Vec3) {
var pData2=arguments[0].pData;
pData[0] = pData2[0];
pData[1] = pData2[1];
pData[2] = pData2[2];

}
else  {
var pElements=arguments[0];
pData[0] = pElements[0];
pData[1] = pElements[1];
pData[2] = pElements[2];

}



}
else if (nArgumentsLength == 2) {
if ((typeof (arguments[0])) == "number") {
var pData2=arguments[1].pData;
pData[0] = arguments[0];
pData[1] = pData2[0];
pData[2] = pData2[1];

}
else  {
var pData2=arguments[0].pData;
pData[0] = pData2[0];
pData[1] = pData2[1];
pData[2] = arguments[1];

}


}
else  {
pData[0] = arguments[0];
pData[1] = arguments[1];
pData[2] = arguments[2];

}


return this;

};
Vec3.prototype.add = function(v3fVec, v3fDestination) {
"use strict";
if (!v3fDestination) {
v3fDestination = this;

}

var pData1=this.pData;
var pData2=v3fVec.pData;
var pDataDestination=v3fDestination.pData;
pDataDestination[0] = (pData1[0]) + (pData2[0]);
pDataDestination[1] = (pData1[1]) + (pData2[1]);
pDataDestination[2] = (pData1[2]) + (pData2[2]);
return v3fDestination;

};
Vec3.prototype.subtract = function(v3fVec, v3fDestination) {
"use strict";
if (!v3fDestination) {
v3fDestination = this;

}

var pData1=this.pData;
var pData2=v3fVec.pData;
var pDataDestination=v3fDestination.pData;
pDataDestination[0] = (pData1[0]) - (pData2[0]);
pDataDestination[1] = (pData1[1]) - (pData2[1]);
pDataDestination[2] = (pData1[2]) - (pData2[2]);
return v3fDestination;

};
Vec3.prototype.negate = function(v3fDestination) {
"use strict";
if (!v3fDestination) {
v3fDestination = this;

}

var pData=this.pData;
var pDataDestination=v3fDestination.pData;
pDataDestination[0] = -(pData[0]);
pDataDestination[1] = -(pData[1]);
pDataDestination[2] = -(pData[2]);
return v3fDestination;

};
Vec3.prototype.scale = function(fScale, v3fDestination) {
"use strict";
if (!v3fDestination) {
v3fDestination = this;

}

var pData=this.pData;
var pDataDestination=v3fDestination.pData;
pDataDestination[0] = (pData[0]) * fScale;
pDataDestination[1] = (pData[1]) * fScale;
pDataDestination[2] = (pData[2]) * fScale;
return v3fDestination;

};
Vec3.prototype.normalize = function(v3fDestination) {
"use strict";
if (!v3fDestination) {
v3fDestination = this;

}

var pData=this.pData;
var pDataDestination=v3fDestination.pData;
var x, y, z;
x = pData[0];
y = pData[1];
z = pData[2];
var fLength=Math.sqrt(((x * x) + (y * y)) + (z * z));
if (fLength) {
x = x / fLength;
y = y / fLength;
z = z / fLength;

}

pDataDestination[0] = x;
pDataDestination[1] = y;
pDataDestination[2] = z;
return v3fDestination;

};
Vec3.prototype.cross = function(v3fVec, v3fDestination) {
"use strict";
if (!v3fDestination) {
v3fDestination = this;

}

var pData1=this.pData;
var pData2=v3fVec.pData;
var pDataDestination=v3fDestination.pData;
var x1=pData1[0], y1=pData1[1], z1=pData1[2];
var x2=pData2[0], y2=pData2[1], z2=pData2[2];
pDataDestination[0] = (y1 * z2) - (z1 * y2);
pDataDestination[1] = (z1 * x2) - (x1 * z2);
pDataDestination[2] = (x1 * y2) - (y1 * x2);
return v3fDestination;

};
Vec3.prototype.length = function() {
"use strict";
var pData=this.pData;
var x=pData[0], y=pData[1], z=pData[2];
return Math.sqrt(((x * x) + (y * y)) + (z * z));

};
Vec3.prototype.lengthSquare = function() {
"use strict";
var pData=this.pData;
var x=pData[0], y=pData[1], z=pData[2];
return ((x * x) + (y * y)) + (z * z);

};
Vec3.prototype.dot = function(v3fVec) {
"use strict";
var pData1=this.pData;
var pData2=v3fVec.pData;
return (((pData1[0]) * (pData2[0])) + ((pData1[1]) * (pData2[1]))) + ((pData1[2]) * (pData2[2]));

};
Vec3.prototype.direction = function(v3fVec, v3fDestination) {
"use strict";
if (!v3fDestination) {
v3fDestination = this;

}

var pData1=this.pData;
var pData2=v3fVec.pData;
var pDataDestination=v3fDestination.pData;
var x=(pData2[0]) - (pData1[0]);
var y=(pData2[1]) - (pData1[1]);
var z=(pData2[2]) - (pData1[2]);
var fLength=Math.sqrt(((x * x) + (y * y)) + (z * z));
if (fLength) {
x = x / fLength;
y = y / fLength;
z = z / fLength;

}

pDataDestination[0] = x;
pDataDestination[1] = y;
pDataDestination[2] = z;
return v3fDestination;

};
Vec3.prototype.mix = function(v3fVec, fA, v3fDestination) {
"use strict";
if (!v3fDestination) {
v3fDestination = this;

}

var pData1=this.pData;
var pData2=v3fVec.pData;
var pDataDestination=v3fDestination.pData;
fA = Math.max(0, Math.min(fA, 1));
var fA1=1 - fA;
var fA2=fA;
pDataDestination[0] = (fA1 * (pData1[0])) + (fA2 * (pData2[0]));
pDataDestination[1] = (fA1 * (pData1[1])) + (fA2 * (pData2[1]));
pDataDestination[2] = (fA1 * (pData1[2])) + (fA2 * (pData2[2]));
return v3fDestination;

};
Vec3.prototype.toTranslationMatrix = function(m4fDestination) {
"use strict";
if (!m4fDestination) {
m4fDestination = new Mat4(1);

}
else  {
m4fDestination.identity();

}

var pData=this.pData;
var pDataDestination=m4fDestination.pData;
pDataDestination[12] = pData[0];
pDataDestination[13] = pData[1];
pDataDestination[14] = pData[2];
return m4fDestination;

};
Vec3.prototype.toString = function() {
"use strict";
var pData=this.pData;
return ((((("[" + (pData[0])) + ", ") + (pData[1])) + ", ") + (pData[2])) + "]";

};
Vec3.prototype.isEqual = function(v3fVec, fEps) {
"use strict";
var pData1=this.pData;
var pData2=v3fVec.pData;
fEps = (fEps === undefined? 0 : fEps);
if (fEps == 0) {
if ((((pData1[0]) != (pData2[0])) || ((pData1[1]) != (pData2[1]))) || ((pData1[2]) != (pData2[2]))) {
return false;

}


}
else  {
if ((((Math.abs((pData1[0]) - (pData2[0]))) > fEps) || ((Math.abs((pData1[1]) - (pData2[1]))) > fEps)) || ((Math.abs((pData1[2]) - (pData2[2]))) > fEps)) {
return false;

}


}

return true;

};
Vec3.prototype.isClear = function() {
"use strict";
var pData=this.pData;
if ((((pData[0]) != 0) || ((pData[1]) != 0)) || ((pData[2]) != 0)) {
return false;

}

return true;

};
Vec3.prototype.clear = function() {
"use strict";
var pData=this.pData;
pData[0] = pData[1] = pData[2] = 0;
return this;

};
Vec3.prototype.vec3TransformCoord = function(m4fTransformMatrix, v3fDestination) {
"use strict";
if (!v3fDestination) {
v3fDestination = new Vec3();

}

var pData1=this.pData;
var pData2=m4fTransformMatrix.pData;
var pDataDestination=v3fDestination.pData;
var x, y, z, w;
x = ((((pData2[0]) * (pData1[0])) + ((pData2[4]) * (pData1[1]))) + ((pData2[8]) * (pData1[2]))) + (pData2[12]);
y = ((((pData2[1]) * (pData1[0])) + ((pData2[5]) * (pData1[1]))) + ((pData2[9]) * (pData1[2]))) + (pData2[13]);
z = ((((pData2[2]) * (pData1[0])) + ((pData2[6]) * (pData1[1]))) + ((pData2[10]) * (pData1[2]))) + (pData2[14]);
w = ((((pData2[3]) * (pData1[0])) + ((pData2[7]) * (pData1[1]))) + ((pData2[11]) * (pData1[2]))) + (pData2[15]);
pDataDestination[0] = x / w;
pDataDestination[1] = y / w;
pDataDestination[2] = z / w;
return v3fDestination;

};
Vec3.prototype.mult = Vec3.prototype.multiply;
a.allocateStorage(Vec3, 100);
function Vec4() {
var v4fVec;
if (((this) === window) || ((this) === (window.AKRA))) {
v4fVec = Vec4._pStorage[Vec4._iIndex++];
if ((Vec4._iIndex) == (Vec4._nStorageSize)) {
Vec4._iIndex = 0;

}

if ((arguments.length) == 0) {
return v4fVec;

}


}
else  {
this.pData = new Float32Array(4);
v4fVec = this;

}

var nArgumentsLength=arguments.length;
if (nArgumentsLength == 1) {
return v4fVec.set(arguments[0]);

}
else if (nArgumentsLength == 2) {
return v4fVec.set(arguments[0], arguments[1]);

}
else if (nArgumentsLength == 3) {
return v4fVec.set(arguments[0], arguments[1], arguments[2]);

}
else if (nArgumentsLength == 4) {
return v4fVec.set(arguments[0], arguments[1], arguments[2], arguments[3]);

}
else  {
return v4fVec;

}





}

a.defineProperty(Vec4, "x", function() {
return this.pData[0];

}
, function(fValue) {
this.pData[0] = fValue;

}
);
a.defineProperty(Vec4, "y", function() {
return this.pData[1];

}
, function(fValue) {
this.pData[1] = fValue;

}
);
a.defineProperty(Vec4, "z", function() {
return this.pData[2];

}
, function(fValue) {
this.pData[2] = fValue;

}
);
a.defineProperty(Vec4, "w", function() {
return this.pData[3];

}
, function(fValue) {
this.pData[3] = fValue;

}
);
Vec4.prototype.set = function() {
"use strict";
var pData=this.pData;
if ((arguments.length) == 0) {
pData[0] = pData[1] = pData[2] = pData[3] = 0;

}
else if ((arguments.length) == 1) {
if ((typeof (arguments[0])) == "number") {
pData[0] = pData[1] = pData[2] = pData[3] = arguments[0];

}
else if ((arguments[0]) instanceof Vec4) {
var pData2=arguments[0].pData;
pData[0] = pData2[0];
pData[1] = pData2[1];
pData[2] = pData2[2];
pData[3] = pData2[3];

}
else  {
var pElements=arguments[0];
pData[0] = pElements[0];
pData[1] = pElements[1];
pData[2] = pElements[2];
pData[3] = pElements[3];

}



}
else if ((arguments.length) == 2) {
if ((typeof (arguments[0])) == "number") {
var pData2=arguments[1].pData;
pData[0] = arguments[0];
pData[1] = pData2[0];
pData[2] = pData2[1];
pData[3] = pData2[2];

}
else  {
if ((arguments[0].pData.length) == 2) {
var pData1=arguments[0].pData;
var pData2=arguments[1].pData;
pData[0] = pData1[0];
pData[1] = pData1[1];
pData[2] = pData2[0];
pData[3] = pData2[1];

}
else  {
var pData2=arguments[0].pData;
pData[0] = pData2[0];
pData[1] = pData2[1];
pData[2] = pData2[2];
pData[3] = arguments[1];

}


}


}
else if ((arguments.length) == 3) {
if ((typeof (arguments[0])) == "number") {
if ((typeof (arguments[1])) == "number") {
var pData2=arguments[2].pData;
pData[0] = arguments[0];
pData[1] = arguments[1];
pData[2] = pData2[0];
pData[3] = pData2[1];

}
else  {
var pData2=arguments[1].pData;
pData[0] = arguments[0];
pData[1] = pData2[0];
pData[2] = pData2[1];
pData[3] = arguments[2];

}


}
else  {
var pData2=arguments[0].pData;
pData[0] = pData2[0];
pData[1] = pData2[1];
pData[2] = arguments[1];
pData[3] = arguments[2];

}


}
else  {
pData[0] = arguments[0];
pData[1] = arguments[1];
pData[2] = arguments[2];
pData[3] = arguments[3];

}




return this;

};
Vec4.prototype.add = function(v4fVec, v4fDestination) {
"use strict";
if (!v4fDestination) {
v4fDestination = this;

}

var pData1=this.pData;
var pData2=v4fVec.pData;
var pDataDestination=v4fDestination.pData;
pDataDestination[0] = (pData1[0]) + (pData2[0]);
pDataDestination[1] = (pData1[1]) + (pData2[1]);
pDataDestination[2] = (pData1[2]) + (pData2[2]);
pDataDestination[3] = (pData1[3]) + (pData2[3]);
return v4fDestination;

};
Vec4.prototype.subtract = function(v4fVec, v4fDestination) {
"use strict";
if (!v4fDestination) {
v4fDestination = this;

}

var pData1=this.pData;
var pData2=v4fVec.pData;
var pDataDestination=v4fDestination.pData;
pDataDestination[0] = (pData1[0]) - (pData2[0]);
pDataDestination[1] = (pData1[1]) - (pData2[1]);
pDataDestination[2] = (pData1[2]) - (pData2[2]);
pDataDestination[3] = (pData1[3]) - (pData2[3]);
return v4fDestination;

};
Vec4.prototype.negate = function(v4fDestination) {
"use strict";
if (!v4fDestination) {
v4fDestination = this;

}

var pData=this.pData;
var pDataDestination=v4fDestination.pData;
pDataDestination[0] = -(pData[0]);
pDataDestination[1] = -(pData[1]);
pDataDestination[2] = -(pData[2]);
pDataDestination[3] = -(pData[3]);
return v4fDestination;

};
Vec4.prototype.scale = function(fScale, v4fDestination) {
"use strict";
if (!v4fDestination) {
v4fDestination = this;

}

var pData=this.pData;
var pDataDestination=v4fDestination.pData;
pDataDestination[0] = (pData[0]) * fScale;
pDataDestination[1] = (pData[1]) * fScale;
pDataDestination[2] = (pData[2]) * fScale;
pDataDestination[3] = (pData[3]) * fScale;
return v4fDestination;

};
Vec4.prototype.normalize = function(v4fDestination) {
"use strict";
if (!v4fDestination) {
v4fDestination = this;

}

var pData=this.pData;
var pDataDestination=v4fDestination.pData;
var x=pData[0];
var y=pData[1];
var z=pData[2];
var w=pData[3];
var fLength=Math.sqrt((((x * x) + (y * y)) + (z * z)) + (w * w));
if (fLength) {
x = x / fLength;
y = y / fLength;
z = z / fLength;
w = w / fLength;

}

pDataDestination[0] = x;
pDataDestination[1] = y;
pDataDestination[2] = z;
pDataDestination[3] = w;
return v4fDestination;

};
Vec4.prototype.length = function() {
"use strict";
var pData=this.pData;
var x=pData[0], y=pData[1], z=pData[2], w=pData[3];
return Math.sqrt((((x * x) + (y * y)) + (z * z)) + (w * w));

};
Vec4.prototype.lengthSquare = function() {
"use strict";
var pData=this.pData;
var x=pData[0], y=pData[1], z=pData[2], w=pData[3];
return (((x * x) + (y * y)) + (z * z)) + (w * w);

};
Vec4.prototype.dot = function(v4fVec) {
"use strict";
var pData1=this.pData;
var pData2=v4fVec.pData;
return ((((pData1[0]) * (pData2[0])) + ((pData1[1]) * (pData2[1]))) + ((pData1[2]) * (pData2[2]))) + ((pData1[3]) * (pData2[3]));

};
Vec4.prototype.direction = function(v4fVec, v4fDestination) {
"use strict";
if (!v4fDestination) {
v4fDestination = this;

}

var pData1=this.pData;
var pData2=v4fVec.pData;
var pDataDestination=v4fDestination.pData;
var x=(pData2[0]) - (pData1[0]);
var y=(pData2[1]) - (pData1[1]);
var z=(pData2[2]) - (pData1[2]);
var w=(pData2[3]) - (pData1[3]);
var fLength=Math.sqrt((((x * x) + (y * y)) + (z * z)) + (w * w));
if (fLength) {
x = x / fLength;
y = y / fLength;
z = z / fLength;
w = w / fLength;

}

pDataDestination[0] = x;
pDataDestination[1] = y;
pDataDestination[2] = z;
pDataDestination[3] = w;
return v4fDestination;

};
Vec4.prototype.mix = function(v4fVec, fA, v4fDestination) {
"use strict";
if (!v4fDestination) {
v4fDestination = this;

}

var pData1=this.pData;
var pData2=v4fVec.pData;
var pDataDestination=v4fDestination.pData;
var fA1=1 - fA;
var fA2=fA;
pDataDestination[0] = (fA1 * (pData1[0])) + (fA2 * (pData2[0]));
pDataDestination[1] = (fA1 * (pData1[1])) + (fA2 * (pData2[1]));
pDataDestination[2] = (fA1 * (pData1[2])) + (fA2 * (pData2[2]));
pDataDestination[3] = (fA1 * (pData1[3])) + (fA2 * (pData2[3]));
return v4fDestination;

};
Vec4.prototype.toString = function() {
"use strict";
var pData=this.pData;
return ((((((("[" + (pData[0])) + ", ") + (pData[1])) + ", ") + (pData[2])) + ", ") + (pData[3])) + "]";

};
Vec4.prototype.isEqual = function(v4fVec, fEps) {
"use strict";
var pData1=this.pData;
var pData2=v4fVec.pData;
fEps = (fEps === undefined? 0 : fEps);
if (fEps == 0) {
if (((((pData1[0]) != (pData2[0])) || ((pData1[1]) != (pData2[1]))) || ((pData1[2]) != (pData2[2]))) || ((pData1[3]) != (pData2[3]))) {
return false;

}


}
else  {
if (((((Math.abs((pData1[0]) - (pData2[0]))) > fEps) || ((Math.abs((pData1[1]) - (pData2[1]))) > fEps)) || ((Math.abs((pData1[2]) - (pData2[2]))) > fEps)) || ((Math.abs((pData1[3]) - (pData2[3]))) > fEps)) {
return false;

}


}

return true;

};
Vec4.prototype.isClear = function() {
"use strict";
var pData=this.pData;
if (((((pData[0]) != 0) || ((pData[1]) != 0)) || ((pData[2]) != 0)) || ((pData[3]) != 0)) {
return false;

}

return true;

};
Vec4.prototype.clear = function() {
"use strict";
var pData=this.pData;
pData[0] = pData[1] = pData[2] = pData[3] = 0;
return this;

};
Vec4.prototype.mult = Vec4.prototype.multiply;
a.allocateStorage(Vec4, 100);
function Mat3() {
var m3fMat;
if (((this) === window) || ((this) === (window.AKRA))) {
m3fMat = Mat3._pStorage[Mat3._iIndex++];
if ((Mat3._iIndex) == (Mat3._nStorageSize)) {
Mat3._iIndex = 0;

}

if ((arguments.length) == 0) {
return m3fMat;

}


}
else  {
this.pData = new Float32Array(9);
m3fMat = this;

}

var nArgumentsLength=arguments.length;
if (nArgumentsLength == 1) {
return m3fMat.set(arguments[0]);

}
else if (nArgumentsLength == 3) {
return m3fMat.set(arguments[0], arguments[1], arguments[2]);

}
else if (nArgumentsLength == 9) {
return m3fMat.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]);

}
else  {
return m3fMat;

}




}

Mat3.prototype.set = function() {
"use strict";
var pData=this.pData;
var nArgumentsLength=arguments.length;
if (nArgumentsLength == 0) {
pData[0] = pData[3] = pData[6] = 0;
pData[1] = pData[4] = pData[7] = 0;
pData[2] = pData[5] = pData[8] = 0;

}

if (nArgumentsLength == 1) {
if ((typeof (arguments[0])) == "number") {
var nValue=arguments[0];
pData[0] = nValue;
pData[3] = 0;
pData[6] = 0;
pData[1] = 0;
pData[4] = nValue;
pData[7] = 0;
pData[2] = 0;
pData[5] = 0;
pData[8] = nValue;

}
else if ((arguments[0]) instanceof Mat3) {
var pElements=arguments[0].pData;
pData[0] = pElements[0];
pData[3] = pElements[3];
pData[6] = pElements[6];
pData[1] = pElements[1];
pData[4] = pElements[4];
pData[7] = pElements[7];
pData[2] = pElements[2];
pData[5] = pElements[5];
pData[8] = pElements[8];

}
else if ((arguments[0]) instanceof Vec3) {
var pElements=arguments[0].pData;
pData[0] = pElements[0];
pData[3] = 0;
pData[6] = 0;
pData[1] = 0;
pData[4] = pElements[1];
pData[7] = 0;
pData[2] = 0;
pData[5] = 0;
pData[8] = pElements[2];

}
else  {
var pElements=arguments[0];
if ((pElements.length) == 3) {
pData[0] = pElements[0];
pData[3] = 0;
pData[6] = 0;
pData[1] = 0;
pData[4] = pElements[1];
pData[7] = 0;
pData[2] = 0;
pData[5] = 0;
pData[8] = pElements[2];

}
else  {
pData[0] = pElements[0];
pData[3] = pElements[3];
pData[6] = pElements[6];
pData[1] = pElements[1];
pData[4] = pElements[4];
pData[7] = pElements[7];
pData[2] = pElements[2];
pData[5] = pElements[5];
pData[8] = pElements[8];

}


}




}
else if (nArgumentsLength == 3) {
if ((typeof (arguments[0])) == "number") {
pData[0] = arguments[0];
pData[3] = 0;
pData[6] = 0;
pData[1] = 0;
pData[4] = arguments[1];
pData[7] = 0;
pData[2] = 0;
pData[5] = 0;
pData[8] = arguments[2];

}
else  {
var pData1, pData2, pData3;
if ((arguments[0]) instanceof Vec3) {
pData1 = arguments[0].pData;
pData2 = arguments[1].pData;
pData3 = arguments[2].pData;

}
else  {
pData1 = arguments[0];
pData2 = arguments[1];
pData3 = arguments[2];

}

pData[0] = pData1[0];
pData[3] = pData2[0];
pData[6] = pData3[0];
pData[1] = pData1[1];
pData[4] = pData2[1];
pData[7] = pData3[1];
pData[2] = pData1[2];
pData[5] = pData2[2];
pData[8] = pData3[2];

}


}
else if (nArgumentsLength == 9) {
pData[0] = arguments[0];
pData[3] = arguments[3];
pData[6] = arguments[6];
pData[1] = arguments[1];
pData[4] = arguments[4];
pData[7] = arguments[7];
pData[2] = arguments[2];
pData[5] = arguments[5];
pData[8] = arguments[8];

}



return this;

};
Mat3.prototype.identity = function() {
"use strict";
var pData=this.pData;
pData[0] = 1;
pData[3] = 0;
pData[6] = 0;
pData[1] = 0;
pData[4] = 1;
pData[7] = 0;
pData[2] = 0;
pData[5] = 0;
pData[8] = 1;
return this;

};
Mat3.prototype.transpose = function(m3fDestination) {
"use strict";
var pData=this.pData;
if (!m3fDestination) {
var a12=pData[3], a13=pData[6], a23=pData[7];
pData[3] = pData[1];
pData[6] = pData[2];
pData[1] = a12;
pData[7] = pData[5];
pData[2] = a13;
pData[5] = a23;
return this;

}

var pDataDestination=m3fDestination.pData;
pDataDestination[0] = pData[0];
pDataDestination[3] = pData[1];
pDataDestination[6] = pData[2];
pDataDestination[1] = pData[3];
pDataDestination[4] = pData[4];
pDataDestination[7] = pData[5];
pDataDestination[2] = pData[6];
pDataDestination[5] = pData[7];
pDataDestination[8] = pData[8];
return m3fDestination;

};
Mat3.prototype.toMat4 = function(m4fDestination) {
"use strict";
if (!m4fDestination) {
m4fDestination = new Mat4();

}

var pData=this.pData;
var pDataDestination=m4fDestination.pData;
pDataDestination[0] = pData[0];
pDataDestination[4] = pData[3];
pDataDestination[8] = pData[6];
pDataDestination[12] = 0;
pDataDestination[1] = pData[1];
pDataDestination[5] = pData[4];
pDataDestination[9] = pData[7];
pDataDestination[13] = 0;
pDataDestination[2] = pData[2];
pDataDestination[6] = pData[5];
pDataDestination[10] = pData[8];
pDataDestination[14] = 0;
pDataDestination[3] = 0;
pDataDestination[7] = 0;
pDataDestination[11] = 0;
pDataDestination[15] = 1;
return m4fDestination;

};
Mat3.prototype.multiply = function(pInput, pDestination) {
"use strict";
var pData1=this.pData;
var pData2=pInput.pData;
if ((pData2.length) === 3) {
if (!pDestination) {
pDestination = new Vec3();

}

var pDataDestination=pDestination.pData;
var x=pData2[0], y=pData2[1], z=pData2[2];
pDataDestination[0] = (((pData1[0]) * x) + ((pData1[3]) * y)) + ((pData1[6]) * z);
pDataDestination[1] = (((pData1[1]) * x) + ((pData1[4]) * y)) + ((pData1[7]) * z);
pDataDestination[2] = (((pData1[2]) * x) + ((pData1[5]) * y)) + ((pData1[8]) * z);

}
else  {
if (!pDestination) {
pDestination = this;

}

var pDataDestination=pDestination.pData;
var a11=pData1[0], a12=pData1[3], a13=pData1[6];
var a21=pData1[1], a22=pData1[4], a23=pData1[7];
var a31=pData1[2], a32=pData1[5], a33=pData1[8];
var b11=pData2[0], b12=pData2[3], b13=pData2[6];
var b21=pData2[1], b22=pData2[4], b23=pData2[7];
var b31=pData2[2], b32=pData2[5], b33=pData2[8];
pDataDestination[0] = ((a11 * b11) + (a12 * b21)) + (a13 * b31);
pDataDestination[3] = ((a11 * b12) + (a12 * b22)) + (a13 * b32);
pDataDestination[6] = ((a11 * b13) + (a12 * b23)) + (a13 * b33);
pDataDestination[1] = ((a21 * b11) + (a22 * b21)) + (a23 * b31);
pDataDestination[4] = ((a21 * b12) + (a22 * b22)) + (a23 * b32);
pDataDestination[7] = ((a21 * b13) + (a22 * b23)) + (a23 * b33);
pDataDestination[2] = ((a31 * b11) + (a32 * b21)) + (a33 * b31);
pDataDestination[5] = ((a31 * b12) + (a32 * b22)) + (a33 * b32);
pDataDestination[8] = ((a31 * b13) + (a32 * b23)) + (a33 * b33);

}

return pDestination;

};
Mat3.prototype.add = function(m3fMat, m3fDestination) {
"use strict";
if (!m3fDestination) {
m3fDestination = this;

}

var pData1=this.pData;
var pData2=m3fMat.pData;
var pDataDestination=m3fDestination.pData;
pDataDestination[0] = (pData1[0]) + (pData2[0]);
pDataDestination[3] = (pData1[3]) + (pData2[3]);
pDataDestination[6] = (pData1[6]) + (pData2[6]);
pDataDestination[1] = (pData1[1]) + (pData2[1]);
pDataDestination[4] = (pData1[4]) + (pData2[4]);
pDataDestination[7] = (pData1[7]) + (pData2[7]);
pDataDestination[2] = (pData1[2]) + (pData2[2]);
pDataDestination[5] = (pData1[5]) + (pData2[5]);
pDataDestination[8] = (pData1[8]) + (pData2[8]);
return m3fDestination;

};
Mat3.prototype.subtract = function(m3fMat, m3fDestination) {
"use strict";
if (!m3fDestination) {
m3fDestination = this;

}

var pData1=this.pData;
var pData2=m3fMat.pData;
var pDataDestination=m3fDestination.pData;
pDataDestination[0] = (pData1[0]) - (pData2[0]);
pDataDestination[3] = (pData1[3]) - (pData2[3]);
pDataDestination[6] = (pData1[6]) - (pData2[6]);
pDataDestination[1] = (pData1[1]) - (pData2[1]);
pDataDestination[4] = (pData1[4]) - (pData2[4]);
pDataDestination[7] = (pData1[7]) - (pData2[7]);
pDataDestination[2] = (pData1[2]) - (pData2[2]);
pDataDestination[5] = (pData1[5]) - (pData2[5]);
pDataDestination[8] = (pData1[8]) - (pData2[8]);
return m3fDestination;

};
Mat3.prototype.determinant = function() {
"use strict";
var pData=this.pData;
var a11=pData[0], a12=pData[3], a13=pData[6];
var a21=pData[1], a22=pData[4], a23=pData[7];
var a31=pData[2], a32=pData[5], a33=pData[8];
return ((a11 * ((a22 * a33) - (a23 * a32))) - (a12 * ((a21 * a33) - (a23 * a31)))) + (a13 * ((a21 * a32) - (a22 * a31)));

};
Mat3.prototype.inverse = function(m3fDestination) {
"use strict";
if (!m3fDestination) {
m3fDestination = this;

}

var pData=this.pData;
var pDataDestination=m3fDestination.pData;
var a11=pData[0], a12=pData[3], a13=pData[6];
var a21=pData[1], a22=pData[4], a23=pData[7];
var a31=pData[2], a32=pData[5], a33=pData[8];
var A11=(a22 * a33) - (a23 * a32);
var A12=(a21 * a33) - (a23 * a31);
var A13=(a21 * a32) - (a22 * a31);
var A21=(a12 * a33) - (a13 * a32);
var A22=(a11 * a33) - (a13 * a31);
var A23=(a11 * a32) - (a12 * a31);
var A31=(a12 * a23) - (a13 * a22);
var A32=(a11 * a23) - (a13 * a21);
var A33=(a11 * a22) - (a12 * a21);
var fDeterminant=((a11 * A11) - (a12 * A12)) + (a13 * A13);
if (fDeterminant == 0) {
if (!0) {
var err=((((((("Error:: " + ("обращение матрицы с нулевым детеминантом:\n" + (this.toString()))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Mat3.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("обращение матрицы с нулевым детеминантом:\n" + (this.toString())));

}


}

;
return m3fDestination.set(1);

}

var fInverseDeterminant=1 / fDeterminant;
pDataDestination[0] = A11 * fInverseDeterminant;
pDataDestination[3] = (-A21) * fInverseDeterminant;
pDataDestination[6] = A31 * fInverseDeterminant;
pDataDestination[1] = (-A12) * fInverseDeterminant;
pDataDestination[4] = A22 * fInverseDeterminant;
pDataDestination[7] = (-A32) * fInverseDeterminant;
pDataDestination[2] = A13 * fInverseDeterminant;
pDataDestination[5] = (-A23) * fInverseDeterminant;
pDataDestination[8] = A33 * fInverseDeterminant;
return m3fDestination;

};
Mat3.prototype.toQuat4 = function(q4fDestination) {
"use strict";
if (!q4fDestination) {
q4fDestination = new Quat4();

}

var pData=this.pData;
var pDataDestination=q4fDestination.pData;
var a11=pData[0], a12=pData[3], a13=pData[6];
var a21=pData[1], a22=pData[4], a23=pData[7];
var a31=pData[2], a32=pData[5], a33=pData[8];
var x2=(((a11 - a22) - a33) + 1) / 4;
var y2=(((a22 - a11) - a33) + 1) / 4;
var z2=(((a33 - a11) - a22) + 1) / 4;
var w2=(((a11 + a22) + a33) + 1) / 4;
var fMax=Math.max(x2, Math.max(y2, Math.max(z2, w2)));
if (fMax == x2) {
var x=Math.sqrt(x2);
pDataDestination[0] = x;
pDataDestination[1] = ((a21 + a12) / 4) / x;
pDataDestination[2] = ((a31 + a13) / 4) / x;
pDataDestination[3] = ((a32 - a23) / 4) / x;

}
else if (fMax == y2) {
var y=Math.sqrt(y2);
pDataDestination[0] = ((a21 + a12) / 4) / y;
pDataDestination[1] = y;
pDataDestination[2] = ((a32 + a23) / 4) / y;
pDataDestination[3] = ((a13 - a31) / 4) / y;

}
else if (fMax == z2) {
var z=Math.sqrt(z2);
pDataDestination[0] = ((a31 + a13) / 4) / z;
pDataDestination[1] = ((a32 + a23) / 4) / z;
pDataDestination[2] = z;
pDataDestination[3] = ((a21 - a12) / 4) / z;

}
else  {
var w=Math.sqrt(w2);
pDataDestination[0] = ((a32 - a23) / 4) / w;
pDataDestination[1] = ((a13 - a31) / 4) / w;
pDataDestination[2] = ((a21 - a12) / 4) / w;
pDataDestination[3] = w;

}



return q4fDestination;

};
Mat3.fromYawPitchRoll = function(fYaw, fPitch, fRoll, m3fDestination) {
"use strict";
if (!m3fDestination) {
m3fDestination = new Mat3();

}

var pDataDestination=m3fDestination.pData;
var fSin1=Math.sin(fYaw);
var fSin2=Math.sin(fPitch);
var fSin3=Math.sin(fRoll);
var fCos1=Math.cos(fYaw);
var fCos2=Math.cos(fPitch);
var fCos3=Math.cos(fRoll);
pDataDestination[0] = (fCos1 * fCos3) + ((fSin1 * fSin2) * fSin3);
pDataDestination[3] = ((fCos3 * fSin1) * fSin2) - (fCos1 * fSin3);
pDataDestination[6] = fCos2 * fSin1;
pDataDestination[1] = fCos2 * fSin3;
pDataDestination[4] = fCos2 * fCos3;
pDataDestination[7] = -fSin2;
pDataDestination[2] = ((fCos1 * fSin2) * fSin3) - (fCos3 * fSin1);
pDataDestination[5] = (fSin1 * fSin3) + ((fCos1 * fCos3) * fSin2);
pDataDestination[8] = fCos1 * fCos2;
return m3fDestination;

};
Mat3.prototype.toString = function() {
"use strict";
var pData=this.pData;
return ((((((((((((((((("[" + (pData[0])) + ", ") + (pData[3])) + ", ") + (pData[6])) + ",\n") + (+(pData[1]))) + ", ") + (pData[4])) + ", ") + (pData[7])) + ",\n") + (+(pData[2]))) + ", ") + (pData[5])) + ", ") + (pData[8])) + "]";

};
Mat3.prototype.isEqual = function(m3fMat, fEps) {
"use strict";
fEps = (fEps === undefined? 0 : fEps);
var pData1=this.pData;
var pData2=m3fMat.pData;
if (fEps == 0) {
if ((((((((((pData1[0]) != (pData2[0])) || ((pData1[3]) != (pData2[3]))) || ((pData1[6]) != (pData2[6]))) || ((pData1[1]) != (pData2[1]))) || ((pData1[4]) != (pData2[4]))) || ((pData1[7]) != (pData2[7]))) || ((pData1[2]) != (pData2[2]))) || ((pData1[5]) != (pData2[5]))) || ((pData1[8]) != (pData2[8]))) {
return false;

}


}
else  {
if ((((((((((Math.abs((pData1[0]) - (pData2[0]))) > fEps) || ((Math.abs((pData1[3]) - (pData2[3]))) > fEps)) || ((Math.abs((pData1[6]) - (pData2[6]))) > fEps)) || ((Math.abs((pData1[1]) - (pData2[1]))) > fEps)) || ((Math.abs((pData1[4]) - (pData2[4]))) > fEps)) || ((Math.abs((pData1[7]) - (pData2[7]))) > fEps)) || ((Math.abs((pData1[2]) - (pData2[2]))) > fEps)) || ((Math.abs((pData1[5]) - (pData2[5]))) > fEps)) || ((Math.abs((pData1[8]) - (pData2[8]))) > fEps)) {
return false;

}


}

return true;

};
Mat3.prototype.isDiagonal = function(fEps) {
"use strict";
fEps = (fEps === undefined? 0 : fEps);
var pData=this.pData;
if (fEps == 0) {
if (((((((pData[3]) != 0) || ((pData[6]) != 0)) || ((pData[1]) != 0)) || ((pData[7]) != 0)) || ((pData[2]) != 0)) || ((pData[5]) != 0)) {
return false;

}


}
else  {
if (((((((Math.abs(pData[3])) > fEps) || ((Math.abs(pData[6])) > fEps)) || ((Math.abs(pData[1])) > fEps)) || ((Math.abs(pData[7])) > fEps)) || ((Math.abs(pData[2])) > fEps)) || ((Math.abs(pData[5])) > fEps)) {
return false;

}


}

return true;

};
Mat3.prototype.mult = Mat3.prototype.multiply;
a.allocateStorage(Mat3, 100);
function Mat4() {
var m4fMat;
if (((this) === window) || ((this) === (window.AKRA))) {
m4fMat = Mat4._pStorage[Mat4._iIndex++];
if ((Mat4._iIndex) == (Mat4._nStorageSize)) {
Mat4._iIndex = 0;

}

if ((arguments.length) == 0) {
return m4fMat;

}


}
else if (((arguments.length) === 2) && ((arguments[1]) === true)) {
this.pData = arguments[0];
return this;

}
else  {
this.pData = new Float32Array(16);
m4fMat = this;

}


var nArgumentsLength=arguments.length;
if (nArgumentsLength == 1) {
return m4fMat.set(arguments[0]);

}
else if (nArgumentsLength == 4) {
return m4fMat.set(arguments[0], arguments[1], arguments[2], arguments[3]);

}
else if (nArgumentsLength == 16) {
return m4fMat.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9], arguments[10], arguments[11], arguments[12], arguments[13], arguments[14], arguments[15]);

}
else  {
return m4fMat;

}




}

Mat4.prototype.set = function() {
var pData=this.pData;
var nArgumentsLength=arguments.length;
if (nArgumentsLength == 0) {
pData[0] = pData[4] = pData[8] = pData[12] = 0;
pData[1] = pData[5] = pData[9] = pData[13] = 0;
pData[2] = pData[6] = pData[10] = pData[14] = 0;
pData[3] = pData[7] = pData[11] = pData[15] = 0;

}

if (nArgumentsLength == 1) {
if ((typeof (arguments[0])) == "number") {
var nValue=arguments[0];
pData[0] = nValue;
pData[4] = 0;
pData[8] = 0;
pData[12] = 0;
pData[1] = 0;
pData[5] = nValue;
pData[9] = 0;
pData[13] = 0;
pData[2] = 0;
pData[6] = 0;
pData[10] = nValue;
pData[14] = 0;
pData[3] = 0;
pData[7] = 0;
pData[11] = 0;
pData[15] = nValue;

}
else if ((arguments[0]) instanceof Mat4) {
var pElements=arguments[0].pData;
pData[0] = pElements[0];
pData[4] = pElements[4];
pData[8] = pElements[8];
pData[12] = pElements[12];
pData[1] = pElements[1];
pData[5] = pElements[5];
pData[9] = pElements[9];
pData[13] = pElements[13];
pData[2] = pElements[2];
pData[6] = pElements[6];
pData[10] = pElements[10];
pData[14] = pElements[14];
pData[3] = pElements[3];
pData[7] = pElements[7];
pData[11] = pElements[11];
pData[15] = pElements[15];

}
else if ((arguments[0]) instanceof Vec4) {
var pElements=arguments[0].pData;
pData[0] = pElements[0];
pData[4] = 0;
pData[8] = 0;
pData[12] = 0;
pData[1] = 0;
pData[5] = pElements[1];
pData[9] = 0;
pData[13] = 0;
pData[2] = 0;
pData[6] = 0;
pData[10] = pElements[2];
pData[14] = 0;
pData[3] = 0;
pData[7] = 0;
pData[11] = 0;
pData[15] = pElements[3];

}
else  {
var pElements=arguments[0];
if ((pElements.length) == 4) {
pData[0] = pElements[0];
pData[4] = 0;
pData[8] = 0;
pData[12] = 0;
pData[1] = 0;
pData[5] = pElements[1];
pData[9] = 0;
pData[13] = 0;
pData[2] = 0;
pData[6] = 0;
pData[10] = pElements[2];
pData[14] = 0;
pData[3] = 0;
pData[7] = 0;
pData[11] = 0;
pData[15] = pElements[3];

}
else  {
pData[0] = pElements[0];
pData[4] = pElements[4];
pData[8] = pElements[8];
pData[12] = pElements[12];
pData[1] = pElements[1];
pData[5] = pElements[5];
pData[9] = pElements[9];
pData[13] = pElements[13];
pData[2] = pElements[2];
pData[6] = pElements[6];
pData[10] = pElements[10];
pData[14] = pElements[14];
pData[3] = pElements[3];
pData[7] = pElements[7];
pData[11] = pElements[11];
pData[15] = pElements[15];

}


}




}
else if (nArgumentsLength == 4) {
if ((typeof (arguments[0])) == "number") {
pData[0] = arguments[0];
pData[4] = 0;
pData[8] = 0;
pData[12] = 0;
pData[1] = 0;
pData[5] = arguments[1];
pData[9] = 0;
pData[13] = 0;
pData[2] = 0;
pData[6] = 0;
pData[10] = arguments[2];
pData[14] = 0;
pData[3] = 0;
pData[7] = 0;
pData[11] = 0;
pData[15] = arguments[3];

}
else  {
var pData1, pData2, pData3, pData4;
if ((arguments[0]) instanceof Vec4) {
pData1 = arguments[0].pData;
pData2 = arguments[1].pData;
pData3 = arguments[2].pData;
pData4 = arguments[3].pData;

}
else  {
pData1 = arguments[0];
pData2 = arguments[1];
pData3 = arguments[2];
pData4 = arguments[3];

}

pData[0] = pData1[0];
pData[4] = pData2[0];
pData[8] = pData3[0];
pData[12] = pData4[0];
pData[1] = pData1[1];
pData[5] = pData2[1];
pData[9] = pData3[1];
pData[13] = pData4[1];
pData[2] = pData1[2];
pData[6] = pData2[2];
pData[10] = pData3[2];
pData[14] = pData4[2];
pData[3] = pData1[3];
pData[7] = pData2[3];
pData[11] = pData3[3];
pData[15] = pData4[3];

}


}
else if (nArgumentsLength == 16) {
pData[0] = arguments[0];
pData[4] = arguments[4];
pData[8] = arguments[8];
pData[12] = arguments[12];
pData[1] = arguments[1];
pData[5] = arguments[5];
pData[9] = arguments[9];
pData[13] = arguments[13];
pData[2] = arguments[2];
pData[6] = arguments[6];
pData[10] = arguments[10];
pData[14] = arguments[14];
pData[3] = arguments[3];
pData[7] = arguments[7];
pData[11] = arguments[11];
pData[15] = arguments[15];

}



return this;

};
Mat4.prototype.identity = function() {
"use strict";
var pData=this.pData;
pData[0] = 1;
pData[4] = 0;
pData[8] = 0;
pData[12] = 0;
pData[1] = 0;
pData[5] = 1;
pData[9] = 0;
pData[13] = 0;
pData[1] = 0;
pData[5] = 0;
pData[9] = 1;
pData[13] = 0;
pData[1] = 0;
pData[5] = 0;
pData[9] = 0;
pData[13] = 1;
return this;

};
Mat4.prototype.transpose = function(m4fDestination) {
"use strict";
var pData=this.pData;
if (!m4fDestination) {
var a12=pData[4], a13=pData[8], a14=pData[12];
var a23=pData[9], a24=pData[13];
var a34=pData[14];
pData[4] = pData[1];
pData[8] = pData[2];
pData[12] = pData[3];
pData[1] = a12;
pData[9] = pData[6];
pData[13] = pData[7];
pData[2] = a13;
pData[6] = a23;
pData[14] = pData[11];
pData[3] = a14;
pData[7] = a24;
pData[11] = a34;
return this;

}

var pDataDestination=m4fDestination.pData;
pDataDestination[0] = pData[0];
pDataDestination[4] = pData[1];
pDataDestination[8] = pData[2];
pDataDestination[12] = pData[3];
pDataDestination[1] = pData[4];
pDataDestination[5] = pData[5];
pDataDestination[9] = pData[6];
pDataDestination[13] = pData[7];
pDataDestination[2] = pData[8];
pDataDestination[6] = pData[9];
pDataDestination[10] = pData[10];
pDataDestination[14] = pData[11];
pDataDestination[3] = pData[12];
pDataDestination[7] = pData[13];
pDataDestination[11] = pData[14];
pDataDestination[15] = pData[15];
return m4fDestination;

};
Mat4.prototype.determinant = function() {
"use strict";
var pData=this.pData;
var a11=pData[0], a12=pData[4], a13=pData[8], a14=pData[12];
var a21=pData[1], a22=pData[5], a23=pData[9], a24=pData[13];
var a31=pData[2], a32=pData[6], a33=pData[10], a34=pData[14];
var a41=pData[3], a42=pData[7], a43=pData[11], a44=pData[15];
return (((((((((((((((((((((((((a41 * a32) * a23) * a14) - (((a31 * a42) * a23) * a14)) - (((a41 * a22) * a33) * a14)) + (((a21 * a42) * a33) * a14)) + (((a31 * a22) * a43) * a14)) - (((a21 * a32) * a43) * a14)) - (((a41 * a32) * a13) * a24)) + (((a31 * a42) * a13) * a24)) + (((a41 * a12) * a33) * a24)) - (((a11 * a42) * a33) * a24)) - (((a31 * a12) * a43) * a24)) + (((a11 * a32) * a43) * a24)) + (((a41 * a22) * a13) * a34)) - (((a21 * a42) * a13) * a34)) - (((a41 * a12) * a23) * a34)) + (((a11 * a42) * a23) * a34)) + (((a21 * a12) * a43) * a34)) - (((a11 * a22) * a43) * a34)) - (((a31 * a22) * a13) * a44)) + (((a21 * a32) * a13) * a44)) + (((a31 * a12) * a23) * a44)) - (((a11 * a32) * a23) * a44)) - (((a21 * a12) * a33) * a44)) + (((a11 * a22) * a33) * a44);

};
Mat4.prototype.inverse = function(m4fDestination) {
"use strict";
if (!m4fDestination) {
m4fDestination = this;

}

var pData=this.pData;
var pDataDestination=m4fDestination.pData;
var a11=pData[0], a12=pData[4], a13=pData[8], a14=pData[12];
var a21=pData[1], a22=pData[5], a23=pData[9], a24=pData[13];
var a31=pData[2], a32=pData[6], a33=pData[10], a34=pData[14];
var a41=pData[3], a42=pData[7], a43=pData[11], a44=pData[15];
var b00=(a11 * a22) - (a12 * a21);
var b01=(a11 * a23) - (a13 * a21);
var b02=(a11 * a24) - (a14 * a21);
var b03=(a12 * a23) - (a13 * a22);
var b04=(a12 * a24) - (a14 * a22);
var b05=(a13 * a24) - (a14 * a23);
var b06=(a31 * a42) - (a32 * a41);
var b07=(a31 * a43) - (a33 * a41);
var b08=(a31 * a44) - (a34 * a41);
var b09=(a32 * a43) - (a33 * a42);
var b10=(a32 * a44) - (a34 * a42);
var b11=(a33 * a44) - (a34 * a43);
var fDeterminant=(((((b00 * b11) - (b01 * b10)) + (b02 * b09)) + (b03 * b08)) - (b04 * b07)) + (b05 * b06);
if (fDeterminant == 0) {
if (!0) {
var err=((((((("Error:: " + ("обращение матрицы с нулевым детеминантом:\n" + (this.toString()))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Mat4.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("обращение матрицы с нулевым детеминантом:\n" + (this.toString())));

}


}

;
return m4fDestination.set(1);

}

var fInverseDeterminant=1 / fDeterminant;
pDataDestination[0] = (((a22 * b11) - (a23 * b10)) + (a24 * b09)) * fInverseDeterminant;
pDataDestination[4] = ((((-a12) * b11) + (a13 * b10)) - (a14 * b09)) * fInverseDeterminant;
pDataDestination[8] = (((a42 * b05) - (a43 * b04)) + (a44 * b03)) * fInverseDeterminant;
pDataDestination[12] = ((((-a32) * b05) + (a33 * b04)) - (a34 * b03)) * fInverseDeterminant;
pDataDestination[1] = ((((-a21) * b11) + (a23 * b08)) - (a24 * b07)) * fInverseDeterminant;
pDataDestination[5] = (((a11 * b11) - (a13 * b08)) + (a14 * b07)) * fInverseDeterminant;
pDataDestination[9] = ((((-a41) * b05) + (a43 * b02)) - (a44 * b01)) * fInverseDeterminant;
pDataDestination[13] = (((a31 * b05) - (a33 * b02)) + (a34 * b01)) * fInverseDeterminant;
pDataDestination[2] = (((a21 * b10) - (a22 * b08)) + (a24 * b06)) * fInverseDeterminant;
pDataDestination[6] = ((((-a11) * b10) + (a12 * b08)) - (a14 * b06)) * fInverseDeterminant;
pDataDestination[10] = (((a41 * b04) - (a42 * b02)) + (a44 * b00)) * fInverseDeterminant;
pDataDestination[14] = ((((-a31) * b04) + (a32 * b02)) - (a34 * b00)) * fInverseDeterminant;
pDataDestination[3] = ((((-a21) * b09) + (a22 * b07)) - (a23 * b06)) * fInverseDeterminant;
pDataDestination[7] = (((a11 * b09) - (a12 * b07)) + (a13 * b06)) * fInverseDeterminant;
pDataDestination[11] = ((((-a41) * b03) + (a42 * b01)) - (a43 * b00)) * fInverseDeterminant;
pDataDestination[15] = (((a31 * b03) - (a32 * b01)) + (a33 * b00)) * fInverseDeterminant;
return m4fDestination;

};
Mat4.prototype.multiply = function(pInput, pDestination) {
"use strict";
var pData1=this.pData;
var pData2=pInput.pData;
if ((pData2.length) == 3) {
if (!pDestination) {
pDestination = new Vec3();

}

var pDataDestination=pDestination.pData;
var x=pData2[0], y=pData2[1], z=pData2[2];
pDataDestination[0] = (((pData1[0]) * x) + ((pData1[4]) * y)) + ((pData1[8]) * z);
pDataDestination[1] = (((pData1[1]) * x) + ((pData1[5]) * y)) + ((pData1[9]) * z);
pDataDestination[2] = (((pData1[2]) * x) + ((pData1[6]) * y)) + ((pData1[10]) * z);

}
else if ((pData2.length) == 4) {
if (!pDestination) {
pDestination = new Vec4();

}

var pDataDestination=pDestination.pData;
var x=pData2[0], y=pData2[1], z=pData2[2], w=pData2[3];
pDataDestination[0] = ((((pData1[0]) * x) + ((pData1[4]) * y)) + ((pData1[8]) * z)) + ((pData1[12]) * w);
pDataDestination[1] = ((((pData1[1]) * x) + ((pData1[5]) * y)) + ((pData1[9]) * z)) + ((pData1[13]) * w);
pDataDestination[2] = ((((pData1[2]) * x) + ((pData1[6]) * y)) + ((pData1[10]) * z)) + ((pData1[14]) * w);
pDataDestination[3] = ((((pData1[3]) * x) + ((pData1[7]) * y)) + ((pData1[11]) * z)) + ((pData1[15]) * w);

}
else  {
if (!pDestination) {
pDestination = this;

}

var pDataDestination=pDestination.pData;
var a11=pData1[0], a12=pData1[4], a13=pData1[8], a14=pData1[12];
var a21=pData1[1], a22=pData1[5], a23=pData1[9], a24=pData1[13];
var a31=pData1[2], a32=pData1[6], a33=pData1[10], a34=pData1[14];
var a41=pData1[3], a42=pData1[7], a43=pData1[11], a44=pData1[15];
var b11=pData2[0], b12=pData2[4], b13=pData2[8], b14=pData2[12];
var b21=pData2[1], b22=pData2[5], b23=pData2[9], b24=pData2[13];
var b31=pData2[2], b32=pData2[6], b33=pData2[10], b34=pData2[14];
var b41=pData2[3], b42=pData2[7], b43=pData2[11], b44=pData2[15];
pDataDestination[0] = (((a11 * b11) + (a12 * b21)) + (a13 * b31)) + (a14 * b41);
pDataDestination[4] = (((a11 * b12) + (a12 * b22)) + (a13 * b32)) + (a14 * b42);
pDataDestination[8] = (((a11 * b13) + (a12 * b23)) + (a13 * b33)) + (a14 * b43);
pDataDestination[12] = (((a11 * b14) + (a12 * b24)) + (a13 * b34)) + (a14 * b44);
pDataDestination[1] = (((a21 * b11) + (a22 * b21)) + (a23 * b31)) + (a24 * b41);
pDataDestination[5] = (((a21 * b12) + (a22 * b22)) + (a23 * b32)) + (a24 * b42);
pDataDestination[9] = (((a21 * b13) + (a22 * b23)) + (a23 * b33)) + (a24 * b43);
pDataDestination[13] = (((a21 * b14) + (a22 * b24)) + (a23 * b34)) + (a24 * b44);
pDataDestination[2] = (((a31 * b11) + (a32 * b21)) + (a33 * b31)) + (a34 * b41);
pDataDestination[6] = (((a31 * b12) + (a32 * b22)) + (a33 * b32)) + (a34 * b42);
pDataDestination[10] = (((a31 * b13) + (a32 * b23)) + (a33 * b33)) + (a34 * b43);
pDataDestination[14] = (((a31 * b14) + (a32 * b24)) + (a33 * b34)) + (a34 * b44);
pDataDestination[3] = (((a41 * b11) + (a42 * b21)) + (a43 * b31)) + (a44 * b41);
pDataDestination[7] = (((a41 * b12) + (a42 * b22)) + (a43 * b32)) + (a44 * b42);
pDataDestination[11] = (((a41 * b13) + (a42 * b23)) + (a43 * b33)) + (a44 * b43);
pDataDestination[15] = (((a41 * b14) + (a42 * b24)) + (a43 * b34)) + (a44 * b44);

}


return pDestination;

};
Mat4.prototype.toString = function() {
"use strict";
var pData=this.pData;
return ((((((((((((((((((((((((((((((("[" + (pData[0])) + ", ") + (pData[4])) + ", ") + (pData[8])) + ", ") + (pData[12])) + ",\n") + (pData[1])) + ", ") + (pData[5])) + ", ") + (pData[9])) + ", ") + (pData[13])) + ",\n") + (pData[2])) + ", ") + (pData[6])) + ", ") + (pData[10])) + ", ") + (pData[14])) + ",\n") + (pData[3])) + ", ") + (pData[7])) + ", ") + (pData[11])) + ", ") + (pData[15])) + "]";

};
Mat4.prototype.isEqual = function(m4fMat, fEps) {
"use strict";
fEps = (fEps === undefined? 0 : fEps);
var pData1=this.pData;
var pData2=m4fMat.pData;
if (fEps == 0) {
if (((((((((((((((((pData1[0]) != (pData2[0])) || ((pData1[4]) != (pData2[4]))) || ((pData1[8]) != (pData2[8]))) || ((pData1[12]) != (pData2[12]))) || ((pData1[1]) != (pData2[1]))) || ((pData1[5]) != (pData2[5]))) || ((pData1[9]) != (pData2[9]))) || ((pData1[13]) != (pData2[13]))) || ((pData1[2]) != (pData2[2]))) || ((pData1[6]) != (pData2[6]))) || ((pData1[10]) != (pData2[10]))) || ((pData1[14]) != (pData2[14]))) || ((pData1[3]) != (pData2[3]))) || ((pData1[7]) != (pData2[7]))) || ((pData1[11]) != (pData2[11]))) || ((pData1[15]) != (pData2[15]))) {
return false;

}


}
else  {
if (((((((((((((((((Math.abs((pData1[0]) - (pData2[0]))) > fEps) || ((Math.abs((pData1[4]) - (pData2[4]))) > fEps)) || ((Math.abs((pData1[8]) - (pData2[8]))) > fEps)) || ((Math.abs((pData1[12]) - (pData2[12]))) > fEps)) || ((Math.abs((pData1[1]) - (pData2[1]))) > fEps)) || ((Math.abs((pData1[5]) - (pData2[5]))) > fEps)) || ((Math.abs((pData1[9]) - (pData2[9]))) > fEps)) || ((Math.abs((pData1[13]) - (pData2[13]))) > fEps)) || ((Math.abs((pData1[2]) - (pData2[2]))) > fEps)) || ((Math.abs((pData1[6]) - (pData2[6]))) > fEps)) || ((Math.abs((pData1[10]) - (pData2[10]))) > fEps)) || ((Math.abs((pData1[14]) - (pData2[14]))) > fEps)) || ((Math.abs((pData1[3]) - (pData2[3]))) > fEps)) || ((Math.abs((pData1[7]) - (pData2[7]))) > fEps)) || ((Math.abs((pData1[11]) - (pData2[11]))) > fEps)) || ((Math.abs((pData1[15]) - (pData2[15]))) > fEps)) {
return false;

}


}

return true;

};
Mat4.prototype.toRotationMatrix = function(m4fDestination) {
"use strict";
if (!m4fDestination) {
m4fDestination = new Mat4();

}

var pData=this.pData;
var pDataDestination=m4fDestination.pData;
pDataDestination[0] = pData[0];
pDataDestination[4] = pData[4];
pDataDestination[8] = pData[8];
pDataDestination[12] = 0;
pDataDestination[1] = pData[1];
pDataDestination[5] = pData[5];
pDataDestination[9] = pData[9];
pDataDestination[13] = 0;
pDataDestination[2] = pData[2];
pDataDestination[6] = pData[6];
pDataDestination[10] = pData[10];
pDataDestination[14] = 0;
pDataDestination[3] = 0;
pDataDestination[7] = 0;
pDataDestination[11] = 0;
pDataDestination[15] = 1;
return m4fDestination;

};
Mat4.prototype.toMat3 = function(m3fDestination) {
"use strict";
if (!m3fDestination) {
m3fDestination = new Mat3();

}

var pData=this.pData;
var pDataDestination=m3fDestination.pData;
pDataDestination[0] = pData[0];
pDataDestination[3] = pData[4];
pDataDestination[6] = pData[8];
pDataDestination[1] = pData[1];
pDataDestination[4] = pData[5];
pDataDestination[7] = pData[9];
pDataDestination[2] = pData[2];
pDataDestination[5] = pData[6];
pDataDestination[8] = pData[10];
return m3fDestination;

};
Mat4.prototype.translateRight = function(v3fVec, m4fDestination) {
"use strict";
var pData1=this.pData;
var pData2=v3fVec.pData;
var x=pData2[0], y=pData2[1], z=pData2[2];
if (!m4fDestination) {
pData1[12] = ((((pData1[0]) * x) + ((pData1[4]) * y)) + ((pData1[8]) * z)) + (pData1[12]);
pData1[13] = ((((pData1[1]) * x) + ((pData1[5]) * y)) + ((pData1[9]) * z)) + (pData1[13]);
pData1[14] = ((((pData1[2]) * x) + ((pData1[6]) * y)) + ((pData1[10]) * z)) + (pData1[14]);
pData1[15] = ((((pData1[3]) * x) + ((pData1[7]) * y)) + ((pData1[11]) * z)) + (pData1[15]);
return this;

}

var pDataDestination=m4fDestination.pData;
var a11=pData1[0], a12=pData1[4], a13=pData1[8];
var a21=pData1[0], a22=pData1[5], a23=pData1[9];
var a31=pData1[0], a32=pData1[6], a33=pData1[10];
var a41=pData1[0], a42=pData1[7], a43=pData1[11];
pDataDestination[0] = a11;
pDataDestination[4] = a12;
pDataDestination[8] = a13;
pDataDestination[12] = (((a11 * x) + (a12 * y)) + (a13 * z)) + (pData1[12]);
pDataDestination[1] = a21;
pDataDestination[5] = a22;
pDataDestination[9] = a23;
pDataDestination[13] = (((a21 * x) + (a22 * y)) + (a23 * z)) + (pData1[13]);
pDataDestination[2] = a31;
pDataDestination[6] = a32;
pDataDestination[10] = a33;
pDataDestination[14] = (((a31 * x) + (a32 * y)) + (a33 * z)) + (pData1[14]);
pDataDestination[3] = a41;
pDataDestination[7] = a42;
pDataDestination[11] = a43;
pDataDestination[15] = (((a41 * x) + (a42 * y)) + (a43 * z)) + (pData1[15]);
return m4fDestination;

};
Mat4.prototype.translateLeft = function(v3fVec, m4fDestination) {
"use strict";
var pData1=this.pData;
var pData2=v3fVec.pData;
var x=pData2[0], y=pData2[1], z=pData2[2];
if (!m4fDestination) {
pData1[12] = x + (pData1[12]);
pData1[13] = y + (pData1[13]);
pData1[14] = z + (pData1[14]);
return this;

}

var pDataDestination=m4fDestination.pData;
pDataDestination[0] = pData1[0];
pDataDestination[4] = pData1[4];
pDataDestination[8] = pData1[8];
pDataDestination[12] = x + (pData1[12]);
pDataDestination[1] = pData1[1];
pDataDestination[5] = pData1[5];
pDataDestination[9] = pData1[9];
pDataDestination[13] = y + (pData1[13]);
pDataDestination[2] = pData1[2];
pDataDestination[6] = pData1[6];
pDataDestination[10] = pData1[10];
pDataDestination[14] = z + (pData1[14]);
pDataDestination[3] = pData1[3];
pDataDestination[7] = pData1[7];
pDataDestination[11] = pData1[11];
pDataDestination[15] = pData1[15];
return m4fDestination;

};
Mat4.prototype.scaleRight = function(v3fVec, m4fDestination) {
"use strict";
var pData1=this.pData;
var pData2=v3fVec.pData;
var x=pData2[0], y=pData2[1], z=pData2[2];
if (!m4fDestination) {
pData1[0] *= x;
pData1[4] *= y;
pData1[8] *= z;
pData1[1] *= x;
pData1[5] *= y;
pData1[9] *= z;
pData1[2] *= x;
pData1[6] *= y;
pData1[10] *= z;
pData1[3] *= x;
pData1[7] *= y;
pData1[11] *= z;
return this;

}

var pDataDestination=m4fDestination.pData;
pDataDestination[0] = (pData1[0]) * x;
pDataDestination[4] = (pData1[4]) * y;
pDataDestination[8] = (pData1[8]) * z;
pDataDestination[12] = pData1[12];
pDataDestination[1] = (pData1[1]) * x;
pDataDestination[5] = (pData1[5]) * y;
pDataDestination[9] = (pData1[9]) * z;
pDataDestination[13] = pData1[13];
pDataDestination[2] = (pData1[2]) * x;
pDataDestination[6] = (pData1[6]) * y;
pDataDestination[10] = (pData1[10]) * z;
pDataDestination[14] = pData1[14];
pDataDestination[3] = (pData1[3]) * x;
pDataDestination[7] = (pData1[7]) * y;
pDataDestination[11] = (pData1[11]) * z;
pDataDestination[15] = pData1[15];
return m4fDestination;

};
Mat4.prototype.scaleLeft = function(v3fVec, m4fDestination) {
"use strict";
var pData1=this.pData;
var pData2=v3fVec.pData;
var x=pData2[0], y=pData2[1], z=pData2[2];
if (!m4fDestination) {
pData1[0] *= x;
pData1[4] *= x;
pData1[8] *= x;
pData1[12] *= x;
pData1[1] *= y;
pData1[5] *= y;
pData1[9] *= y;
pData1[13] *= y;
pData1[2] *= z;
pData1[6] *= z;
pData1[10] *= z;
pData1[14] *= z;
return this;

}

var pDataDestination=m4fDestination.pData;
pDataDestination[0] = (pData1[0]) * x;
pDataDestination[4] = (pData1[4]) * x;
pDataDestination[8] = (pData1[8]) * x;
pDataDestination[12] = (pData1[12]) * x;
pDataDestination[1] = (pData1[1]) * y;
pDataDestination[5] = (pData1[5]) * y;
pDataDestination[9] = (pData1[9]) * y;
pDataDestination[13] = (pData1[13]) * y;
pDataDestination[2] = (pData1[2]) * z;
pDataDestination[6] = (pData1[6]) * z;
pDataDestination[10] = (pData1[10]) * z;
pDataDestination[14] = (pData1[14]) * z;
pDataDestination[3] = pData1[3];
pDataDestination[7] = pData1[7];
pDataDestination[11] = pData1[11];
pDataDestination[15] = pData1[15];
return m4fDestination;

};
Mat4.prototype.rotateRight = function(fAngle, v3fAxis, m4fDestination) {
"use strict";
var pData1=this.pData;
var pData2=v3fAxis.pData;
var x=pData2[0], y=pData2[1], z=pData2[2];
var fLength=Math.sqrt(((x * x) + (y * y)) + (z * z));
if (fLength) {
x = x / fLength;
y = y / fLength;
z = z / fLength;

}
else  {
if (!fLength) {
var err=((((((("Error:: " + ((("попытка вращения вокруг оси нулевой длины. Угол " + fAngle) + ". Ось ") + (v3fAxis.toString()))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Mat4.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(((("попытка вращения вокруг оси нулевой длины. Угол " + fAngle) + ". Ось ") + (v3fAxis.toString())));

}


}

;
return this;

}

var a11=pData1[0], a12=pData1[4], a13=pData1[8];
var a21=pData1[1], a22=pData1[5], a23=pData1[9];
var a31=pData1[2], a32=pData1[6], a33=pData1[10];
var fSin=Math.sin(fAngle);
var fCos=Math.cos(fAngle);
var fTmp=1 - fCos;
var b11=fCos + ((fTmp * x) * x), b12=((fTmp * x) * y) - (fSin * z), b13=((fTmp * x) * z) + (fSin * y);
var b21=((fTmp * y) * z) + (fSin * z), b22=fCos + ((fTmp * y) * y), b23=((fTmp * y) * z) - (fSin * x);
var b31=((fTmp * z) * x) - (fSin * y), b32=((fTmp * z) * y) + (fSin * x), b33=fCos + ((fTmp * z) * z);
if (!m4fDestination) {
pData1[0] = ((a11 * b11) + (a12 * b21)) + (a13 * b31);
pData1[4] = ((a11 * b12) + (a12 * b22)) + (a13 * b32);
pData1[8] = ((a11 * b13) + (a12 * b23)) + (a13 * b33);
pData1[1] = ((a21 * b11) + (a22 * b21)) + (a23 * b31);
pData1[5] = ((a21 * b12) + (a22 * b22)) + (a23 * b32);
pData1[9] = ((a21 * b13) + (a22 * b23)) + (a23 * b33);
pData1[2] = ((a31 * b11) + (a32 * b21)) + (a33 * b31);
pData1[6] = ((a31 * b12) + (a32 * b22)) + (a33 * b32);
pData1[10] = ((a31 * b13) + (a32 * b23)) + (a33 * b33);
return this;

}

var pDataDestination=m4fDestination.pData;
pDataDestination[0] = ((a11 * b11) + (a12 * b21)) + (a13 * b31);
pDataDestination[4] = ((a11 * b12) + (a12 * b22)) + (a13 * b32);
pDataDestination[8] = ((a11 * b13) + (a12 * b23)) + (a13 * b33);
pDataDestination[12] = pData1[12];
pDataDestination[1] = ((a21 * b11) + (a22 * b21)) + (a23 * b31);
pDataDestination[5] = ((a21 * b12) + (a22 * b22)) + (a23 * b32);
pDataDestination[9] = ((a21 * b13) + (a22 * b23)) + (a23 * b33);
pDataDestination[13] = pData1[13];
pDataDestination[2] = ((a31 * b11) + (a32 * b21)) + (a33 * b31);
pDataDestination[6] = ((a31 * b12) + (a32 * b22)) + (a33 * b32);
pDataDestination[10] = ((a31 * b13) + (a32 * b23)) + (a33 * b33);
pDataDestination[14] = pData1[14];
pDataDestination[3] = pData1[3];
pDataDestination[7] = pData1[7];
pDataDestination[11] = pData1[11];
pDataDestination[15] = pData1[15];
return m4fDestination;

};
Mat4.prototype.rotateLeft = function(fAngle, v3fAxis, m4fDestination) {
"use strict";
var pData1=this.pData;
var pData2=v3fAxis.pData;
var x=pData2[0], y=pData2[1], z=pData2[2];
var fLength=Math.sqrt(((x * x) + (y * y)) + (z * z));
if (fLength) {
x = x / fLength;
y = y / fLength;
z = z / fLength;

}
else  {
if (!fLength) {
var err=((((((("Error:: " + ((("попытка вращения вокруг оси нулевой длины. Угол " + fAngle) + ". Ось ") + (v3fAxis.toString()))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Mat4.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(((("попытка вращения вокруг оси нулевой длины. Угол " + fAngle) + ". Ось ") + (v3fAxis.toString())));

}


}

;
return this;

}

var a11=pData1[0], a12=pData1[4], a13=pData1[8], a14=pData1[12];
var a21=pData1[1], a22=pData1[5], a23=pData1[9], a24=pData1[13];
var a31=pData1[2], a32=pData1[6], a33=pData1[10], a34=pData1[14];
var fSin=Math.sin(fAngle);
var fCos=Math.cos(fAngle);
var fTmp=1 - fCos;
var b11=fCos + ((fTmp * x) * x), b12=((fTmp * x) * y) - (fSin * z), b13=((fTmp * x) * z) + (fSin * y);
var b21=((fTmp * y) * z) + (fSin * z), b22=fCos + ((fTmp * y) * y), b23=((fTmp * y) * z) - (fSin * x);
var b31=((fTmp * z) * x) - (fSin * y), b32=((fTmp * z) * y) + (fSin * x), b33=fCos + ((fTmp * z) * z);
if (!m4fDestination) {
pData1[0] = ((b11 * a11) + (b12 * a21)) + (b13 * a31);
pData1[4] = ((b11 * a12) + (b12 * a22)) + (b13 * a32);
pData1[8] = ((b11 * a13) + (b12 * a23)) + (b13 * a33);
pData1[12] = ((b11 * a14) + (b12 * a24)) + (b13 * a34);
pData1[1] = ((b21 * a11) + (b22 * a21)) + (b23 * a31);
pData1[5] = ((b21 * a12) + (b22 * a22)) + (b23 * a32);
pData1[9] = ((b21 * a13) + (b22 * a23)) + (b23 * a33);
pData1[13] = ((b21 * a14) + (b22 * a24)) + (b23 * a34);
pData1[2] = ((b31 * a11) + (b32 * a21)) + (b33 * a31);
pData1[6] = ((b31 * a12) + (b32 * a22)) + (b33 * a32);
pData1[10] = ((b31 * a13) + (b32 * a23)) + (b33 * a33);
pData1[14] = ((b31 * a14) + (b32 * a24)) + (b33 * a34);
return this;

}

var pDataDestination=m4fDestination.pData;
pDataDestination[0] = ((b11 * a11) + (b12 * a21)) + (b13 * a31);
pDataDestination[4] = ((b11 * a12) + (b12 * a22)) + (b13 * a32);
pDataDestination[8] = ((b11 * a13) + (b12 * a23)) + (b13 * a33);
pDataDestination[12] = ((b11 * a14) + (b12 * a24)) + (b13 * a34);
pDataDestination[1] = ((b21 * a11) + (b22 * a21)) + (b23 * a31);
pDataDestination[5] = ((b21 * a12) + (b22 * a22)) + (b23 * a32);
pDataDestination[9] = ((b21 * a13) + (b22 * a23)) + (b23 * a33);
pDataDestination[13] = ((b21 * a14) + (b22 * a24)) + (b23 * a34);
pDataDestination[2] = ((b31 * a11) + (b32 * a21)) + (b33 * a31);
pDataDestination[6] = ((b31 * a12) + (b32 * a22)) + (b33 * a32);
pDataDestination[10] = ((b31 * a13) + (b32 * a23)) + (b33 * a33);
pDataDestination[14] = ((b31 * a14) + (b32 * a24)) + (b33 * a34);
pDataDestination[3] = pData1[3];
pDataDestination[7] = pData1[7];
pDataDestination[11] = pData1[11];
pDataDestination[15] = pData1[15];
return m4fDestination;

};
Mat4.prototype.rotateXRight = function(fAngle, m4fDestination) {
"use strict";
var pData=this.pData;
var fSin=Math.sin(fAngle);
var fCos=Math.cos(fAngle);
var a12=pData[4], a13=pData[8];
var a22=pData[5], a23=pData[9];
var a32=pData[6], a33=pData[10];
if (!m4fDestination) {
pData[4] = (a12 * fCos) + (a13 * fSin);
pData[8] = ((-a12) * fSin) + (a13 * fCos);
pData[5] = (a22 * fCos) + (a23 * fSin);
pData[9] = ((-a22) * fSin) + (a23 * fCos);
pData[6] = (a32 * fCos) + (a33 * fSin);
pData[10] = ((-a32) * fSin) + (a33 * fCos);
return this;

}

var pDataDestination=m4fDestination.pData;
pDataDestination[0] = pData[0];
pDataDestination[4] = (a12 * fCos) + (a13 * fSin);
pDataDestination[8] = ((-a12) * fSin) + (a13 * fCos);
pDataDestination[12] = pData[12];
pDataDestination[1] = pData[1];
pDataDestination[5] = (a22 * fCos) + (a23 * fSin);
pDataDestination[9] = ((-a22) * fSin) + (a23 * fCos);
pDataDestination[13] = pData[13];
pDataDestination[2] = pData[1];
pDataDestination[6] = (a32 * fCos) + (a33 * fSin);
pDataDestination[10] = ((-a32) * fSin) + (a33 * fCos);
pDataDestination[14] = pData[14];
pDataDestination[3] = pData[3];
pDataDestination[7] = pData[7];
pDataDestination[11] = pData[11];
pDataDestination[15] = pData[15];
return m4fDestination;

};
Mat4.prototype.rotateXLeft = function(fAngle, m4fDestination) {
"use strict";
var pData=this.pData;
var fSin=Math.sin(fAngle);
var fCos=Math.cos(fAngle);
var a21=pData[1], a22=pData[5], a23=pData[9], a24=pData[13];
var a31=pData[2], a32=pData[6], a33=pData[10], a34=pData[14];
if (!m4fDestination) {
pData[1] = (fCos * a21) - (fSin * a31);
pData[5] = (fCos * a22) - (fSin * a32);
pData[9] = (fCos * a23) - (fSin * a33);
pData[13] = (fCos * a24) - (fSin * a34);
pData[2] = (fSin * a21) + (fCos * a31);
pData[6] = (fSin * a22) + (fCos * a32);
pData[10] = (fSin * a23) + (fCos * a33);
pData[14] = (fSin * a24) + (fCos * a34);
return this;

}

var pDataDestination=m4fDestination.pData;
pDataDestination[0] = pData[0];
pDataDestination[4] = pData[4];
pDataDestination[8] = pData[8];
pDataDestination[12] = pData[12];
pDataDestination[1] = (fCos * a21) - (fSin * a31);
pDataDestination[5] = (fCos * a22) - (fSin * a32);
pDataDestination[9] = (fCos * a23) - (fSin * a33);
pDataDestination[13] = (fCos * a24) - (fSin * a34);
pDataDestination[2] = (fSin * a21) + (fCos * a31);
pDataDestination[6] = (fSin * a22) + (fCos * a32);
pDataDestination[10] = (fSin * a23) + (fCos * a33);
pDataDestination[14] = (fSin * a24) + (fCos * a34);
pDataDestination[3] = pData[3];
pDataDestination[7] = pData[7];
pDataDestination[11] = pData[11];
pDataDestination[15] = pData[15];
return m4fDestination;

};
Mat4.prototype.rotateYRight = function(fAngle, m4fDestination) {
"use strict";
var pData=this.pData;
var fSin=Math.sin(fAngle);
var fCos=Math.cos(fAngle);
var a11=pData[0], a13=pData[8];
var a21=pData[1], a23=pData[9];
var a31=pData[2], a33=pData[10];
if (!m4fDestination) {
pData[0] = (a11 * fCos) - (a13 * fSin);
pData[8] = (a11 * fSin) + (a13 * fCos);
pData[1] = (a21 * fCos) - (a23 * fSin);
pData[9] = (a21 * fSin) + (a23 * fCos);
pData[2] = (a31 * fCos) - (a33 * fSin);
pData[10] = (a31 * fSin) + (a33 * fCos);
return this;

}

var pDataDestination=m4fDestination.pData;
pDataDestination[0] = (a11 * fCos) - (a13 * fSin);
pDataDestination[4] = pData[4];
pDataDestination[8] = (a11 * fSin) + (a13 * fCos);
pDataDestination[12] = pData[12];
pDataDestination[1] = (a21 * fCos) - (a23 * fSin);
pDataDestination[5] = pData[5];
pDataDestination[9] = (a21 * fSin) + (a23 * fCos);
pDataDestination[13] = pData[13];
pDataDestination[2] = (a31 * fCos) - (a33 * fSin);
pDataDestination[6] = pData[6];
pDataDestination[10] = (a31 * fSin) + (a33 * fCos);
pDataDestination[14] = pData[14];
pDataDestination[3] = pData[3];
pDataDestination[7] = pData[7];
pDataDestination[11] = pData[11];
pDataDestination[15] = pData[15];
return m4fDestination;

};
Mat4.prototype.rotateYLeft = function(fAngle, m4fDestination) {
"use strict";
var pData=this.pData;
var fSin=Math.sin(fAngle);
var fCos=Math.cos(fAngle);
var a11=pData[0], a12=pData[4], a13=pData[8], a14=pData[12];
var a31=pData[2], a32=pData[6], a33=pData[10], a34=pData[14];
if (!m4fDestination) {
pData[0] = (fCos * a11) + (fSin * a31);
pData[4] = (fCos * a12) + (fSin * a32);
pData[8] = (fCos * a13) + (fSin * a33);
pData[12] = (fCos * a14) + (fSin * a34);
pData[2] = ((-fSin) * a11) + (fCos * a31);
pData[6] = ((-fSin) * a12) + (fCos * a32);
pData[10] = ((-fSin) * a13) + (fCos * a33);
pData[14] = ((-fSin) * a14) + (fCos * a34);
return this;

}

var pDataDestination=m4fDestination;
pDataDestination[0] = (fCos * a11) + (fSin * a31);
pDataDestination[4] = (fCos * a12) + (fSin * a32);
pDataDestination[8] = (fCos * a13) + (fSin * a33);
pDataDestination[8] = (fCos * a14) + (fSin * a34);
pDataDestination[1] = pData[1];
pDataDestination[5] = pData[5];
pDataDestination[9] = pData[9];
pDataDestination[13] = pData[13];
pDataDestination[2] = ((-fSin) * a11) + (fCos * a31);
pDataDestination[6] = ((-fSin) * a12) + (fCos * a32);
pDataDestination[10] = ((-fSin) * a13) + (fCos * a33);
pDataDestination[10] = ((-fSin) * a14) + (fCos * a34);
pDataDestination[3] = pData[3];
pDataDestination[7] = pData[7];
pDataDestination[11] = pData[11];
pDataDestination[15] = pData[15];
return m4fDestination;

};
Mat4.prototype.rotateZRight = function(fAngle, m4fDestination) {
"use strict";
var pData=this.pData;
var fSin=Math.sin(fAngle);
var fCos=Math.cos(fAngle);
var a11=pData[0], a12=pData[4];
var a21=pData[1], a22=pData[5];
var a31=pData[2], a32=pData[6];
if (!m4fDestination) {
pData[0] = (a11 * fCos) + (a12 * fSin);
pData[4] = ((-a11) * fSin) + (a12 * fCos);
pData[1] = (a21 * fCos) + (a22 * fSin);
pData[5] = ((-a21) * fSin) + (a22 * fCos);
pData[2] = (a31 * fCos) + (a32 * fSin);
pData[6] = ((-a31) * fSin) + (a32 * fCos);
return this;

}

var pDataDestination=m4fDestination.pData;
pDataDestination[0] = (a11 * fCos) + (a12 * fSin);
pDataDestination[4] = ((-a11) * fSin) + (a12 * fCos);
pDataDestination[8] = pData[8];
pDataDestination[12] = pData[12];
pDataDestination[1] = (a21 * fCos) + (a22 * fSin);
pDataDestination[5] = ((-a21) * fSin) + (a22 * fCos);
pDataDestination[9] = pData[9];
pDataDestination[13] = pData[13];
pDataDestination[2] = (a31 * fCos) + (a32 * fSin);
pDataDestination[6] = ((-a31) * fSin) + (a32 * fCos);
pDataDestination[10] = pData[10];
pDataDestination[14] = pData[14];
pDataDestination[3] = pData[3];
pDataDestination[7] = pData[7];
pDataDestination[11] = pData[11];
pDataDestination[15] = pData[15];
return m4fDestination;

};
Mat4.prototype.rotateZLeft = function(fAngle, m4fDestination) {
"use strict";
var pData=this.pData;
var fSin=Math.sin(fAngle);
var fCos=Math.cos(fAngle);
var a11=pData[0], a12=pData[4], a13=pData[8], a14=pData[12];
var a21=pData[1], a22=pData[5], a23=pData[9], a24=pData[13];
if (!m4fDestination) {
pData[0] = (fCos * a11) - (fSin * a21);
pData[4] = (fCos * a12) - (fSin * a22);
pData[8] = (fCos * a13) - (fSin * a23);
pData[12] = (fCos * a14) - (fSin * a24);
pData[1] = (fSin * a11) + (fCos * a21);
pData[5] = (fSin * a12) + (fCos * a22);
pData[9] = (fSin * a13) + (fCos * a23);
pData[13] = (fSin * a14) + (fCos * a24);
return this;

}

var pDataDestination=m4fDestination.pData;
pDataDestination[0] = (fCos * a11) - (fSin * a21);
pDataDestination[4] = (fCos * a12) - (fSin * a22);
pDataDestination[8] = (fCos * a13) - (fSin * a23);
pDataDestination[12] = (fCos * a14) - (fSin * a24);
pDataDestination[1] = (fSin * a11) + (fCos * a21);
pDataDestination[5] = (fSin * a12) + (fCos * a22);
pDataDestination[9] = (fSin * a13) + (fCos * a23);
pDataDestination[13] = (fSin * a14) + (fCos * a24);
pDataDestination[2] = pData[2];
pDataDestination[6] = pData[6];
pDataDestination[10] = pData[10];
pDataDestination[14] = pData[14];
pDataDestination[3] = pData[3];
pDataDestination[7] = pData[7];
pDataDestination[11] = pData[11];
pDataDestination[15] = pData[15];
return m4fDestination;

};
Mat4.prototype.row = function(iRow) {
"use strict";
var pData=this.pData;
switch(iRow) {
case 1:
return new Vec4(pData[0], pData[4], pData[8], pData[12]);

case 2:
return new Vec4(pData[1], pData[5], pData[9], pData[13]);

case 3:
return new Vec4(pData[2], pData[6], pData[10], pData[14]);

case 4:
return new Vec4(pData[3], pData[7], pData[11], pData[15]);
}

};
Mat4.prototype.column = function(iColumn) {
"use strict";
var pData=this.pData;
switch(iColumn) {
case 1:
return new Vec4(pData[0], pData[1], pData[2], pData[3]);

case 2:
return new Vec4(pData[4], pData[5], pData[6], pData[7]);

case 3:
return new Vec4(pData[8], pData[9], pData[10], pData[11]);

case 4:
return new Vec4(pData[12], pData[13], pData[14], pData[15]);
}

};
Mat4.prototype.toQuat4 = function(q4fDestination) {
"use strict";
if (!q4fDestination) {
q4fDestination = new Quat4();

}

var pData=this.pData;
var pDataDestination=q4fDestination.pData;
var a11=pData[0], a12=pData[4], a13=pData[8];
var a21=pData[1], a22=pData[5], a23=pData[9];
var a31=pData[2], a32=pData[6], a33=pData[10];
var x2=(((a11 - a22) - a33) + 1) / 4;
var y2=(((a22 - a11) - a33) + 1) / 4;
var z2=(((a33 - a11) - a22) + 1) / 4;
var w2=(((a11 + a22) + a33) + 1) / 4;
var fMax=Math.max(x2, Math.max(y2, Math.max(z2, w2)));
if (fMax == x2) {
var x=Math.sqrt(x2);
pDataDestination[0] = x;
pDataDestination[1] = ((a21 + a12) / 4) / x;
pDataDestination[2] = ((a31 + a13) / 4) / x;
pDataDestination[3] = ((a32 - a23) / 4) / x;

}
else if (fMax == y2) {
var y=Math.sqrt(y2);
pDataDestination[0] = ((a21 + a12) / 4) / y;
pDataDestination[1] = y;
pDataDestination[2] = ((a32 + a23) / 4) / y;
pDataDestination[3] = ((a13 - a31) / 4) / y;

}
else if (fMax == z2) {
var z=Math.sqrt(z2);
pDataDestination[0] = ((a31 + a13) / 4) / z;
pDataDestination[1] = ((a32 + a23) / 4) / z;
pDataDestination[2] = z;
pDataDestination[3] = ((a21 - a12) / 4) / z;

}
else  {
var w=Math.sqrt(w2);
pDataDestination[0] = ((a32 - a23) / 4) / w;
pDataDestination[1] = ((a13 - a31) / 4) / w;
pDataDestination[2] = ((a21 - a12) / 4) / w;
pDataDestination[3] = w;

}



return q4fDestination;

};
Mat4.prototype.setTranslation = function(v3fVec) {
var pData1=this.pData;
var pData2=v3fVec.pData;
pData1[12] = pData2[0];
pData1[13] = pData2[1];
pData1[14] = pData2[2];
return this;

};
Mat4.prototype.set3x3 = function(pMatrix) {
"use strict";
var pData=this.pData;
var pData2=pMatrix.pData;
if ((pData2.length) == 9) {
pData[0] = pData2[0];
pData[4] = pData2[3];
pData[8] = pData2[6];
pData[1] = pData2[1];
pData[5] = pData2[4];
pData[9] = pData2[7];
pData[2] = pData2[2];
pData[6] = pData2[5];
pData[10] = pData2[8];

}
else  {
pData[0] = pData2[0];
pData[4] = pData2[4];
pData[8] = pData2[8];
pData[1] = pData2[1];
pData[5] = pData2[5];
pData[9] = pData2[9];
pData[2] = pData2[2];
pData[6] = pData2[6];
pData[10] = pData2[10];

}

return this;

};
Mat4.prototype.toInverseMat3 = function(m3fDestination) {
"use strict";
if (!m3fDestination) {
m3fDestination = new Mat3();

}

var pData=this.pData;
var pDataDestination=m3fDestination.pData;
var a11=pData[0], a12=pData[4], a13=pData[8];
var a21=pData[1], a22=pData[5], a23=pData[9];
var a31=pData[2], a32=pData[6], a33=pData[10];
var A11=(a22 * a33) - (a23 * a32);
var A12=(a21 * a33) - (a23 * a31);
var A13=(a21 * a32) - (a22 * a31);
var A21=(a12 * a33) - (a13 * a32);
var A22=(a11 * a33) - (a13 * a31);
var A23=(a11 * a32) - (a12 * a31);
var A31=(a12 * a23) - (a13 * a22);
var A32=(a11 * a23) - (a13 * a21);
var A33=(a11 * a22) - (a12 * a21);
var fDeterminant=((a11 * A11) - (a12 * A12)) + (a13 * A13);
if (fDeterminant == 0) {
if (!0) {
var err=((((((("Error:: " + ("обращение матрицы с нулевым детеминантом:\n" + (this.toString()))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Mat4.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("обращение матрицы с нулевым детеминантом:\n" + (this.toString())));

}


}

;
return m3fDestination.set(1);

}

var fInverseDeterminant=1 / fDeterminant;
pDataDestination[0] = A11 * fInverseDeterminant;
pDataDestination[3] = (-A21) * fInverseDeterminant;
pDataDestination[6] = A31 * fInverseDeterminant;
pDataDestination[1] = (-A12) * fInverseDeterminant;
pDataDestination[4] = A22 * fInverseDeterminant;
pDataDestination[7] = (-A32) * fInverseDeterminant;
pDataDestination[2] = A13 * fInverseDeterminant;
pDataDestination[5] = (-A23) * fInverseDeterminant;
pDataDestination[8] = A33 * fInverseDeterminant;
return m3fDestination;

};
Mat4.prototype.multiplyLeft = function(m4fMat, m4fDestination) {
"use strict";
return m4fMat.multiply(this, m4fDestination || (this));

};
Mat4.prototype.decompose = function(q4fRotation, v3fScale, v3fTranslation) {
"use strict";
var pData=this.pData;
var m3fRotScale=this.toMat3(Mat3());
var m3fRotScaleTransposed=m3fRotScale.transpose(Mat3());
var isRotScale=true;
var m3fScaleRot, m3fScaleRotTransposed;
var scaleSign=((m3fRotScale.determinant()) >= 0? 1 : -1);
var m3fResult=m3fRotScaleTransposed.multiply(m3fRotScale);
if (!(m3fResult.isDiagonal(0.000001))) {
m3fScaleRot = m3fRotScale;
m3fScaleRotTransposed = m3fRotScaleTransposed;
m3fResult = m3fScaleRot.multiply(m3fScaleRotTransposed);

}

var pResultData=m3fResult.pData;
var x=pResultData[0];
var y=(pResultData[4]) * scaleSign;
var z=pResultData[8];
v3fScale.set(x, y, z);
var m3fInverseScale=Mat3(1 / x, 1 / y, 1 / z);
var m3fRot;
if (isRotScale) {
m3fRot = m3fRotScale.multiply(m3fInverseScale);
v3fTranslation.set(pData[12], pData[13], pData[14]);

}
else  {
m3fRot = m3fInverseScale.multiply(m3fScaleRot);
v3fTranslation.set((pData[12]) / x, (pData[13]) / y, (pData[14]) / z);

}

if (!isRotScale) {
var err=((((((("Error:: " + "порядок умножения scale rot в данный момент не поддерживается") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Mat4.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("порядок умножения scale rot в данный момент не поддерживается");

}


}

;
m3fRot.toQuat4(q4fRotation);

};
Mat4.prototype.isDiagonal = function(fEps) {
"use strict";
fEps = (fEps === undefined? 0 : fEps);
var pData=this.pData;
if (fEps == 0) {
if (((((((((((((pData[4]) != 0) || ((pData[8]) != 0)) || ((pData[12]) != 0)) || ((pData[1]) != 0)) || ((pData[9]) != 0)) || ((pData[13]) != 0)) || ((pData[2]) != 0)) || ((pData[6]) != 0)) || ((pData[14]) != 0)) || ((pData[3]) != 0)) || ((pData[7]) != 0)) || ((pData[11]) != 0)) {
return false;

}


}
else  {
if (((((((((((((Math.abs(pData[4])) > fEps) || ((Math.abs(pData[8])) > fEps)) || ((Math.abs(pData[12])) > fEps)) || ((Math.abs(pData[1])) > fEps)) || ((Math.abs(pData[9])) > fEps)) || ((Math.abs(pData[13])) > fEps)) || ((Math.abs(pData[2])) > fEps)) || ((Math.abs(pData[6])) > fEps)) || ((Math.abs(pData[14])) > fEps)) || ((Math.abs(pData[3])) > fEps)) || ((Math.abs(pData[7])) > fEps)) || ((Math.abs(pData[11])) > fEps)) {
return false;

}


}

return true;

};
Mat4.frustum = function(fLeft, fRight, fBottom, fTop, fNear, fFar, m4fDestination) {
"use strict";
if (!m4fDestination) {
m4fDestination = new Mat4();

}

var pDataDestination=m4fDestination.pData;
var fRL=fRight - fLeft;
var fTB=fTop - fBottom;
var fFN=fFar - fNear;
pDataDestination[0] = (2 * fNear) / fRL;
pDataDestination[4] = 0;
pDataDestination[8] = (fRight + fLeft) / fRL;
pDataDestination[12] = 0;
pDataDestination[1] = 0;
pDataDestination[5] = (2 * fNear) / fTB;
pDataDestination[9] = (fTop + fBottom) / fTB;
pDataDestination[13] = 0;
pDataDestination[2] = 0;
pDataDestination[6] = 0;
pDataDestination[10] = (-(fFar + fNear)) / fFN;
pDataDestination[14] = (((-2) * fFar) * fNear) / fFN;
pDataDestination[3] = 0;
pDataDestination[7] = 0;
pDataDestination[11] = -1;
pDataDestination[15] = 0;
return m4fDestination;

};
Mat4.perspective = function(fFOVy, fAspect, fNear, fFar, m4fDestination) {
"use strict";
var fTop=fNear * (Math.tan(fFOVy / 2));
var fRight=fTop * fAspect;
return Mat4.frustum(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);

};
Mat4.orthogonalProjectionAsymmetric = function(fLeft, fRight, fBottom, fTop, fNear, fFar, m4fDestination) {
"use strict";
if (!m4fDestination) {
m4fDestination = new Mat4();

}

var pDataDestination=m4fDestination.pData;
var fRL=fRight - fLeft;
var fTB=fTop - fBottom;
var fFN=fFar - fNear;
pDataDestination[0] = 2 / fRL;
pDataDestination[4] = 0;
pDataDestination[8] = 0;
pDataDestination[12] = (-(fRight + fLeft)) / fRL;
pDataDestination[1] = 0;
pDataDestination[5] = 2 / fTB;
pDataDestination[9] = 0;
pDataDestination[13] = (-(fTop + fBottom)) / fTB;
pDataDestination[2] = 0;
pDataDestination[6] = 0;
pDataDestination[10] = (-2) / fFN;
pDataDestination[14] = (-(fFar + fNear)) / fFN;
pDataDestination[3] = 0;
pDataDestination[7] = 0;
pDataDestination[11] = 0;
pDataDestination[15] = 1;
return m4fDestination;

};
Mat4.orthogonalProjection = function(fWidth, fHeight, fNear, fFar, m4fDestination) {
var fRight=fWidth / 2;
var fTop=fHeight / 2;
return Mat4.orthogonalProjectionAsymmetric(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);

};
Mat4.lookAt = function(v3fEye, v3fCenter, v3fUp, m4fDestination) {
"use strict";
if (!m4fDestination) {
m4fDestination = new Mat4(1);

}

var pData1=v3fEye.pData;
var pData2=v3fCenter.pData;
var pData3=v3fUp.pData;
var fEyeX=pData1[0], fEyeY=pData1[1], fEyeZ=pData1[2];
var fCenterX=pData2[0], fCenterY=pData2[1], fCenterZ=pData2[2];
var fUpX=pData3[0], fUpY=pData3[1], fUpZ=pData3[2];
if (((fEyeX == fCenterX) && (fEyeY == fCenterY)) && (fEyeZ == fCenterZ)) {
return m4fDestination;

}

var fXNewX, fXNewY, fXNewZ, fYNewX, fYNewY, fYNewZ, fZNewX, fZNewY, fZNewZ;
fZNewX = fEyeX - fCenterX;
fZNewY = fEyeY - fCenterY;
fZNewZ = fEyeZ - fCenterZ;
var fLength=Math.sqrt(((fZNewX * fZNewX) + (fZNewY * fZNewY)) + (fZNewZ * fZNewZ));
fZNewX = fZNewX / fLength;
fZNewY = fZNewY / fLength;
fZNewZ = fZNewZ / fLength;
fXNewX = (fUpY * fZNewZ) - (fUpZ * fZNewY);
fXNewY = (fUpZ * fZNewX) - (fUpX * fZNewZ);
fXNewZ = (fUpX * fZNewY) - (fUpY * fZNewX);
fLength = Math.sqrt(((fXNewX * fXNewX) + (fXNewY * fXNewY)) + (fXNewZ * fXNewZ));
if (fLength) {
fXNewX = fXNewX / fLength;
fXNewY = fXNewY / fLength;
fXNewZ = fXNewZ / fLength;

}

fYNewX = (fZNewY * fXNewZ) - (fZNewZ * fXNewY);
fYNewY = (fZNewZ * fXNewX) - (fZNewX * fXNewZ);
fYNewZ = (fZNewX * fXNewY) - (fZNewY * fXNewX);
var fEyeNewX=((fEyeX * fXNewX) + (fEyeY * fXNewY)) + (fEyeZ * fXNewZ);
var fEyeNewY=((fEyeX * fYNewX) + (fEyeY * fYNewY)) + (fEyeZ * fYNewZ);
var fEyeNewZ=((fEyeX * fZNewX) + (fEyeY * fZNewY)) + (fEyeZ * fZNewZ);
var pDataDestination=m4fDestination.pData;
pDataDestination[0] = fXNewX;
pDataDestination[4] = fXNewY;
pDataDestination[8] = fXNewZ;
pDataDestination[12] = -fEyeNewX;
pDataDestination[1] = fYNewX;
pDataDestination[5] = fYNewY;
pDataDestination[9] = fYNewZ;
pDataDestination[13] = -fEyeNewY;
pDataDestination[2] = fZNewX;
pDataDestination[6] = fZNewY;
pDataDestination[10] = fZNewZ;
pDataDestination[14] = -fEyeNewZ;
pDataDestination[3] = 0;
pDataDestination[7] = 0;
pDataDestination[11] = 0;
pDataDestination[15] = 1;
return m4fDestination;

};
Mat4.prototype.translate = Mat4.prototype.translateLeft;
Mat4.prototype.scale = Mat4.prototype.scaleLeft;
Mat4.prototype.rotate = Mat4.prototype.rotateLeft;
Mat4.prototype.rotateX = Mat4.prototype.rotateXLeft;
Mat4.prototype.rotateY = Mat4.prototype.rotateYLeft;
Mat4.prototype.rotateZ = Mat4.prototype.rotateZLeft;
Mat4.prototype.mult = Mat4.prototype.multiply;
Mat4.prototype.multLeft = Mat4.prototype.multiplyLeft;
Mat4.prototype.toSource = Mat4.prototype.toString;
Mat4.matrixPerspectiveFovRH = Mat4.perspective;
a.allocateStorage(Mat4, 100);
function Quat4() {
var qQuat;
if (((this) === window) || ((this) === (window.AKRA))) {
qQuat = Quat4._pStorage[Quat4._iIndex++];
if ((Quat4._iIndex) == (Quat4._nStorageSize)) {
Quat4._iIndex = 0;

}

if ((arguments.length) == 0) {
return qQuat;

}


}
else  {
this.pData = new Float32Array(4);
qQuat = this;

}

var nArgumentsLength=arguments.length;
if (nArgumentsLength == 1) {
return qQuat.set(arguments[0]);

}
else if (nArgumentsLength == 2) {
return qQuat.set(arguments[0], arguments[1]);

}
else if (nArgumentsLength == 4) {
return qQuat.set(arguments[0], arguments[1], arguments[2], arguments[3]);

}
else  {
qQuat.pData[3] = 1;
return qQuat;

}




}

a.defineProperty(Quat4, "x", function() {
return this.pData[0];

}
, function(fValue) {
this.pData[0] = fValue;

}
);
a.defineProperty(Quat4, "y", function() {
return this.pData[1];

}
, function(fValue) {
this.pData[1] = fValue;

}
);
a.defineProperty(Quat4, "z", function() {
return this.pData[2];

}
, function(fValue) {
this.pData[2] = fValue;

}
);
a.defineProperty(Quat4, "w", function() {
return this.pData[3];

}
, function(fValue) {
this.pData[3] = fValue;

}
);
Quat4.prototype.set = function() {
"use strict";
var pData=this.pData;
var nArgumentsLength=arguments.length;
if (nArgumentsLength == 0) {
pData[0] = pData[1] = pData[2] = 0;
pData[3] = 1;

}

if (nArgumentsLength == 1) {
if ((arguments[0]) instanceof Quat4) {
var pElements=arguments[0].pData;
pData[0] = pElements[0];
pData[1] = pElements[1];
pData[2] = pElements[2];
pData[3] = pElements[3];

}
else  {
var pElements=arguments[0];
pData[0] = pElements[0];
pData[1] = pElements[1];
pData[2] = pElements[2];
pData[3] = pElements[3];

}


}
else if (nArgumentsLength == 2) {
if ((typeof (arguments[0])) == "number") {
var fValue=arguments[0];
pData[0] = fValue;
pData[1] = fValue;
pData[2] = fValue;
pData[3] = arguments[1];

}
else  {
var pElements=arguments[0].pData;
pData[0] = pElements[0];
pData[1] = pElements[1];
pData[2] = pElements[2];
pData[3] = arguments[1];

}


}
else if (nArgumentsLength == 4) {
pData[0] = arguments[0];
pData[1] = arguments[1];
pData[2] = arguments[2];
pData[3] = arguments[3];

}



return this;

};
Quat4.prototype.calculateW = function(q4fDestination) {
"use strict";
var pData=this.pData;
var x=pData[0], y=pData[1], z=pData[2];
if (!q4fDestination) {
q4fDestination[3] = Math.sqrt(((1 - (x * x)) - (y * y)) - (z * z));
return this;

}

var pDataDestination=q4fDestination.pData;
pDataDestination[0] = x;
pDataDestination[1] = y;
pDataDestination[2] = z;
pDataDestination[3] = Math.sqrt(((1 - (x * x)) - (y * y)) - (z * z));
return q4fDestination;

};
Quat4.prototype.conjugate = function(q4fDestination) {
"use strict";
var pData=this.pData;
if (!q4fDestination) {
pData[0] = -(pData[0]);
pData[1] = -(pData[1]);
pData[2] = -(pData[2]);
return this;

}

var pDataDestination=q4fDestination.pData;
pDataDestination[0] = -(pData[0]);
pDataDestination[1] = -(pData[1]);
pDataDestination[2] = -(pData[2]);
pDataDestination[3] = pData[3];
return q4fDestination;

};
Quat4.prototype.inverse = function(q4fDestination) {
"use strict";
if (!q4fDestination) {
q4fDestination = this;

}

var pData=this.pData;
var pDataDestination=q4fDestination.pData;
var x=pData[0], y=pData[1], z=pData[2], w=pData[3];
var fSqLength=(((x * x) + (y * y)) + (z * z)) + (w * w);
if (fSqLength == 0) {
pDataDestination[0] = 0;
pDataDestination[1] = 0;
pDataDestination[2] = 0;
pDataDestination[3] = 0;

}
else  {
var fInv=1 / fSqLength;
pDataDestination[0] = (-x) * fInv;
pDataDestination[1] = (-y) * fInv;
pDataDestination[2] = (-z) * fInv;
pDataDestination[3] = w * fInv;

}

return q4fDestination;

};
Quat4.prototype.length = function() {
"use strict";
var pData=this.pData;
var x=pData[0], y=pData[1], z=pData[2], w=pData[3];
return Math.sqrt((((x * x) + (y * y)) + (z * z)) + (w * w));

};
Quat4.prototype.normalize = function(q4fDestination) {
"use strict";
if (!q4fDestination) {
q4fDestination = this;

}

var pData=this.pData;
var pDataDestination=q4fDestination.pData;
var x=pData[0], y=pData[1], z=pData[2], w=pData[3];
var fLength=Math.sqrt((((x * x) + (y * y)) + (z * z)) + (w * w));
if (fLength) {
x = x / fLength;
y = y / fLength;
z = z / fLength;
w = w / fLength;

}

pDataDestination[0] = x;
pDataDestination[1] = y;
pDataDestination[2] = z;
pDataDestination[3] = w;
return q4fDestination;

};
Quat4.prototype.multiply = function(q4fQuat, q4fDestination) {
"use strict";
if (!q4fDestination) {
q4fDestination = this;

}

var pData1=this.pData;
var pData2=q4fQuat.pData;
var x1=pData1[0], y1=pData1[1], z1=pData1[2], w1=pData1[3];
var x2=pData2[0], y2=pData2[1], z2=pData2[2], w2=pData2[3];
var pDataDestination=q4fDestination.pData;
pDataDestination[0] = (((x1 * w2) + (x2 * w1)) + (y1 * z2)) - (z1 * y2);
pDataDestination[1] = (((y1 * w2) + (y2 * w1)) + (z1 * x2)) - (x1 * z2);
pDataDestination[2] = (((z1 * w2) + (z2 * w1)) + (x1 * y2)) - (y1 * x2);
pDataDestination[3] = (((w1 * w2) - (x1 * x2)) - (y1 * y2)) - (z1 * z2);
return q4fDestination;

};
Quat4.prototype.multiplyVec3 = function(v3fVec, v3fDestination) {
"use strict";
if (!v3fDestination) {
v3fDestination = v3fVec;

}

var q4fVec=Quat4(v3fVec, 0);
var qInverse=this.inverse(Quat4());
var qResult=this.multiply(q4fVec.multiply(qInverse), Quat4());
var pData=qResult.pData;
var pDataDestination=v3fDestination.pData;
pDataDestination[0] = pData[0];
pDataDestination[1] = pData[1];
pDataDestination[2] = pData[2];
return v3fDestination;

};
Quat4.prototype.isEqual = function(q4fQuat, fEps, asMatrix) {
fEps = (fEps === undefined? 0 : fEps);
asMatrix = (asMatrix === undefined? false : asMatrix);
var pData1=this.pData;
var pData2=q4fQuat.pData;
var x1=pData1[0], y1=pData1[1], z1=pData1[2], w1=pData1[3];
var x2=pData2[0], y2=pData2[1], z2=pData2[2], w2=pData2[3];
var length1=Math.sqrt((((x1 * x1) + (y1 * y1)) + (z1 * z1)) + (w1 * w1));
var length2=Math.sqrt((((x2 * x2) + (y2 * y2)) + (z2 * z2)) + (w2 * w2));
if ((Math.abs(length1 - length2)) > fEps) {
return false;

}

var cosHalfTheta=(((((x1 * x2) + (y1 * y2)) + (z1 * z2)) + (w1 * w2)) / length1) / length2;
if (asMatrix) {
cosHalfTheta = Math.abs(cosHalfTheta);

}

if ((1 - cosHalfTheta) > fEps) {
return false;

}

return true;

};
Quat4.prototype.toYawPitchRoll = function(v3fDestination) {
"use strict";
if (!v3fDestination) {
v3fDestination = new Vec3();

}

var pData=this.pData;
var pDataDestination=v3fDestination.pData;
var fYaw, fPitch, fRoll;
var x=pData[0], y=pData[1], z=pData[2], w=pData[3];
var fx2=x * 2;
var fy2=y * 2;
var fz2=z * 2;
var fw2=w * 2;
var fSinPitch=Math.max((-1), Math.min(((fx2 * w) - (fy2 * z)), 1));
fPitch = Math.asin(fSinPitch);
if ((Math.abs(x)) == (Math.abs(w))) {
var wTemp=w * (Math.sqrt(2));
var yTemp=y * (Math.sqrt(2));
fYaw = (Math.atan2(yTemp, wTemp)) * 2;
fRoll = 0;
var pi=Math.PI;
if (fYaw > pi) {
fYaw -= pi;
fRoll = (x == w? -pi : pi);

}
else if (fYaw < (-pi)) {
fYaw += pi;
fRoll = (x == w? pi : -pi);

}



}
else  {
fYaw = Math.atan2((fx2 * z) + (fy2 * w), 1 - ((fx2 * x) + (fy2 * y)));
fRoll = Math.atan2((fx2 * y) + (fz2 * w), 1 - ((fx2 * x) + (fz2 * z)));

}

pDataDestination[0] = fYaw;
pDataDestination[1] = fPitch;
pDataDestination[2] = fRoll;
return v3fDestination;

};
Quat4.fromForwardUp = function(v3fForward, v3fUp, q4fDestination) {
"use strict";
if (!q4fDestination) {
q4fDestination = new Quat4();

}

var pDataDestination=q4fDestination.pData;
var pDataForward=v3fForward.pData;
var pDataUp=v3fUp.pData;
var fForwardX=pDataForward[0], fForwardY=pDataForward[1], fForwardZ=pDataForward[2];
var fUpX=pDataUp[0], fUpY=pData[1], fUpZ=pDataUp[2];
var m3fTemp=new Mat3();
var pTempData=m3fTemp.pData;
pTempData[0] = (fUpY * fForwardZ) - (fUpZ * fForwardY);
pTempData[3] = pDataUp[0];
pTempData[6] = pDataForward[0];
pTempData[1] = (fUpZ * fForwardX) - (fUpX * fForwardZ);
pTempData[4] = pDataUp[1];
pTempData[7] = pDataForward[1];
pTempData[2] = (fUpX * fForwardY) - (fUpY * fForwardX);
pTempData[5] = pDataUp[2];
pTempData[8] = pDataForward[2];
return pTempData.toQuat4(q4fDestination);

};
Quat4.fromAxisAngle = function(v3fAxis, fAngle, q4fDestination) {
"use strict";
if (!q4fDestination) {
q4fDestination = new Quat4();

}

var pDataDestination=q4fDestination.pData;
var pDataAxis=v3fAxis.pData;
var x=pDataAxis[0], y=pDataAxis[1], z=pDataAxis[2];
var fLength=Math.sqrt(((x * x) + (y * y)) + (z * z));
if (!fLength) {
pDataDestination[0] = pDataDestination[1] = pDataDestination[2] = 0;
pDataDestination[3] = 1;
return q4fDestination;

}

x = x / fLength;
y = y / fLength;
z = z / fLength;
var fSin=Math.sin(fAngle / 2);
var fCos=Math.cos(fAngle / 2);
pDataDestination[0] = x * fSin;
pDataDestination[1] = y * fSin;
pDataDestination[2] = z * fSin;
pDataDestination[3] = fCos;
return q4fDestination;

};
Quat4.fromYawPitchRoll = function(fYaw, fPitch, fRoll, q4fDestination) {
"use strict";
if (!q4fDestination) {
q4fDestination = new Quat4();

}

var pDataDestination=q4fDestination.pData;
var fHalfYaw=fYaw * 0.5;
var fHalfPitch=fPitch * 0.5;
var fHalfRoll=fRoll * 0.5;
var fCos1=Math.cos(fHalfYaw), fSin1=Math.sin(fHalfYaw);
var fCos2=Math.cos(fHalfPitch), fSin2=Math.sin(fHalfPitch);
var fCos3=Math.cos(fHalfRoll), fSin3=Math.sin(fHalfRoll);
pDataDestination[0] = ((fCos1 * fSin2) * fCos3) + ((fSin1 * fCos2) * fSin3);
pDataDestination[1] = ((fSin1 * fCos2) * fCos3) - ((fCos1 * fSin2) * fSin3);
pDataDestination[2] = ((fCos1 * fCos2) * fSin3) - ((fSin1 * fSin2) * fCos3);
pDataDestination[3] = ((fCos1 * fCos2) * fCos3) + ((fSin1 * fSin2) * fSin3);
return q4fDestination;

};
Quat4.prototype.toMat3 = function(m3fDestination) {
"use strict";
if (!m3fDestination) {
m3fDestination = new Mat3();

}

var pDataDestination=m3fDestination.pData;
var pData=this.pData;
var x=pData[0], y=pData[1], z=pData[2], w=pData[3];
pDataDestination[0] = 1 - (2 * ((y * y) + (z * z)));
pDataDestination[3] = 2 * ((x * y) - (z * w));
pDataDestination[6] = 2 * ((x * z) + (y * w));
pDataDestination[1] = 2 * ((x * y) + (z * w));
pDataDestination[4] = 1 - (2 * ((x * x) + (z * z)));
pDataDestination[7] = 2 * ((y * z) - (x * w));
pDataDestination[2] = 2 * ((x * z) - (y * w));
pDataDestination[5] = 2 * ((y * z) + (x * w));
pDataDestination[8] = 1 - (2 * ((x * x) + (y * y)));
return m3fDestination;

};
Quat4.prototype.toMat4 = function(m4fDestination) {
"use strict";
if (!m4fDestination) {
m4fDestination = new Mat4();

}

var pDataDestination=m4fDestination.pData;
var pData=this.pData;
var x=pData[0], y=pData[1], z=pData[2], w=pData[3];
pDataDestination[0] = 1 - (2 * ((y * y) + (z * z)));
pDataDestination[4] = 2 * ((x * y) - (z * w));
pDataDestination[8] = 2 * ((x * z) + (y * w));
pDataDestination[12] = 0;
pDataDestination[1] = 2 * ((x * y) + (z * w));
pDataDestination[5] = 1 - (2 * ((x * x) + (z * z)));
pDataDestination[9] = 2 * ((y * z) - (x * w));
pDataDestination[13] = 0;
pDataDestination[2] = 2 * ((x * z) - (y * w));
pDataDestination[6] = 2 * ((y * z) + (x * w));
pDataDestination[10] = 1 - (2 * ((x * x) + (y * y)));
pDataDestination[14] = 0;
pDataDestination[3] = 0;
pDataDestination[7] = 0;
pDataDestination[11] = 0;
pDataDestination[15] = 1;
return m4fDestination;

};
Quat4.prototype.toString = function() {
"use strict";
var pData=this.pData;
return ((((((("[" + (pData[0])) + ", ") + (pData[1])) + ", ") + (pData[2])) + ", ") + (pData[3])) + "]";

};
Quat4.prototype.slerp = function(q4fQuat, fA, q4fDestination, bShortestPath) {
"use strict";
if (!q4fDestination) {
q4fDestination = this;

}

bShortestPath = (bShortestPath === undefined? true : bShortestPath);
fA = Math.max(0, Math.min(fA, 1));
var pData1=this.pData;
var pData2=q4fQuat.pData;
var pDataDestination=q4fDestination.pData;
var fCos=((((pData1[0]) * (pData2[0])) + ((pData1[1]) * (pData2[1]))) + ((pData1[2]) * (pData2[2]))) + ((pData1[3]) * (pData2[3]));
if ((fCos < 0) && bShortestPath) {
fCos = -fCos;
pData2 = Quat4(-(pData2[0]), -(pData2[1]), -(pData2[2]), -(pData2[3])).pData;

}

var fEps=0.001;
if ((Math.abs(fCos)) < (1 - fEps)) {
var fSin=Math.sqrt(1 - (fCos * fCos));
var fInvSin=1 / fSin;
var fAngle=Math.atan2(fSin, fCos);
var k1=(Math.sin((1 - fA) * fAngle)) * fInvSin;
var k2=(Math.sin(fA * fAngle)) * fInvSin;
pDataDestination[0] = ((pData1[0]) * k1) + ((pData2[0]) * k2);
pDataDestination[1] = ((pData1[1]) * k1) + ((pData2[1]) * k2);
pDataDestination[2] = ((pData1[2]) * k1) + ((pData2[2]) * k2);
pDataDestination[3] = ((pData1[3]) * k1) + ((pData2[3]) * k2);

}
else  {
var k1=1 - fA;
var k2=fA;
var x=((pData1[0]) * k1) + ((pData2[0]) * k2);
var y=((pData1[1]) * k1) + ((pData2[1]) * k2);
var z=((pData1[2]) * k1) + ((pData2[2]) * k2);
var w=((pData1[3]) * k1) + ((pData2[3]) * k2);
var fLength=Math.sqrt((((x * x) + (y * y)) + (z * z)) + (w * w));
var fInvLen=1 / fLength;
pDataDestination[0] = x * fInvLen;
pDataDestination[1] = y * fInvLen;
pDataDestination[2] = z * fInvLen;
pDataDestination[3] = w * fInvLen;

}

return q4fDestination;

};
Quat4.prototype.mult = Quat4.prototype.multiply;
Quat4.fromYPR = Quat4.fromYawPitchRoll;
a.allocateStorage(Quat4, 100);
function lowestBitSet(nValue) {
var temp;
if (nValue == 0) {
return null;

}

for (temp = 0; temp <= 31; temp++) {
if (nValue & (1 << temp)) {
return temp;

}


}

return null;

}

Math.lowestBitSet = lowestBitSet;
function nearestPowerOfTwo(nValue) {
if (nValue <= 1) {
return 1;

}

var highestBit=(nValue == 0? null : (nValue < 0? 31 : ((Math.log(nValue)) / (Math.LN2)) << 0));
var roundingTest=nValue & (1 << (highestBit - 1));
if (roundingTest != 0) {
++highestBit;

}

return 1 << highestBit;

}

Math.nearestPowerOfTwo = nearestPowerOfTwo;
function ceilingPowerOfTwo(nValue) {
if (nValue <= 1) {
return 1;

}

var highestBit=(nValue == 0? null : (nValue < 0? 31 : ((Math.log(nValue)) / (Math.LN2)) << 0));
var mask=nValue & ((1 << highestBit) - 1);
highestBit += mask && 1;
return 1 << highestBit;

}

Math.ceilingPowerOfTwo = ceilingPowerOfTwo;
function floorPowerOfTwo(nValue) {
if (nValue <= 1) {
return 1;

}

var highestBit=(nValue == 0? null : (nValue < 0? 31 : ((Math.log(nValue)) / (Math.LN2)) << 0));
return 1 << highestBit;

}

Math.floorPowerOfTwo = floorPowerOfTwo;
function alignUp(iValue, iAlignment) {
var iRemainder=iValue - ((Math.floor(iValue / iAlignment)) * iAlignment);
if (iRemainder == 0) {
return iValue;

}

return iValue + (iAlignment - iRemainder);

}

Math.alignUp = alignUp;
function alignDown(iValue, iAlignment) {
var remainder=iValue - ((Math.floor(iValue / iAlignment)) * iAlignment);
if (remainder == 0) {
return iValue;

}

return iValue - remainder;

}

Math.alignDown = alignDown;
function nod(n, m) {
var p=n % m;
while (p != 0) {
n = m;
m = p;
p = n % m;

}
return m;

}

Math.nod = nod;
function nok(n, m) {
return (Math.abs(n * m)) / (Math.nod(n, m));

}

Math.nok = nok;
a.BitFlags =  {totalSet: function(value) {
var count=0;
var total=32;
for (var i=total; i; --i) {
count += value & 1;
value >>= 1;

}

return count;

}
};
function Ray2d() {
this.v2fPoint = new Vec2();
this.v2fNormal = new Vec2();

}

;
function Ray3d() {
this.v3fPoint = new Vec3();
this.v3fNormal = new Vec3();

}

;
function Segment2d() {
this.pRay = new Ray2d();
this.fDistance = 0;

}

;
a.defineProperty(Segment2d, "point", function() {
return this.pRay.v2fPoint;

}
, function(v2fPoint) {
this.pRay.v2fPoint.set(v2fPoint);

}
);
Object.defineProperty(Segment2d.prototype, "normal",  {set: function(v2fNormal) {
this.pRray.v2fNormal.set(v2fNormal);

}
, get: function() {
return this.pRay.v2fNormal;

}
});
function Segment3d() {
this.pRay = new Ray3d();
this.fDistance = 0;

}

;
Object.defineProperty(Segment3d.prototype, "point",  {set: function(v3fPoint) {
this.pRay.v3fPoint.set(v3fPoint);

}
, get: function() {
return this.pRay.v3fPoint;

}
});
Object.defineProperty(Segment3d.prototype, "normal",  {set: function(v3fNormal) {
this.pRay.v3fNormal.set(v3fNormal);

}
, get: function() {
return this.pRay.v3fNormal;

}
});
function Circle() {
this.fRadius = 0;
this.v2fCenter = null;
switch(arguments.length) {
case 0:
this.v2fCenter = new Vec2();
break ;

case 1:
this.v2fCenter = new Vec2(arguments[0].v2fCenter);
this.fRadius = arguments[0].fRadius;
break ;

case 2:
this.v2fCenter = new Vec2(arguments[0]);
this.fRadius = arguments[1];
break ;

case 3:
this.v2fCenter = new Vec2(arguments[0], arguments[1]);
this.fRadius = arguments[2];
break ;
}

}

;
Circle.prototype.isEqual = function(pCircle) {
;
return (this.v2fCenter.isEqual(pCircle.v2fCenter)) && ((this.fRadius) == (pCircle.fRadius));

};
Circle.prototype.eq = function(pCircle) {
;
this.v2fCenter.set(pCircle.v2fCenter);
this.fRadius = pCircle.fRadius;

};
Circle.prototype.clear = function() {
;
this.v2fCenter.clear();
this.fRadius = 0;

};
Circle.prototype.isClear = function() {
;
return (this.v2fCenter.isClear()) && (0 == (this.fRadius));

};
Circle.prototype.set = function() {
;
switch(arguments.length) {
case 1:
this.v2fCenter.set(arguments[0].v2fCenter);
this.fRadius = arguments[0].fRadius;
break ;

case 2:
this.v2fCenter.set(arguments[0]);
this.fRadius = arguments[1];
break ;

case 3:
this.v2fCenter.set(arguments[0], arguments[1]);
this.fRadius = arguments[2];
break ;
}

};
Circle.prototype.isValid = function() {
;
return (this.fRadius) >= 0;

};
Circle.prototype.assertValid = function() {
;
if (!((this.fRadius) >= 0)) {
var err=((((((("Error:: " + "sphere inverted") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("sphere inverted");

}


}

;

};
Circle.prototype.offset = function(v2fOffset) {
;
this.v2fCenter.add(v2fOffset);

};
Circle.prototype.expand = function(fInc) {
;
this.fRadius += fInc;

};
Circle.prototype.normalize = function() {
;
this.fRadius = Math.abs(this.fRadius);

};
function Sphere() {
this.fRadius = 0;
this.v3fCenter = null;
switch(arguments.length) {
case 0:
this.v3fCenter = new Vec3();
break ;

case 1:
this.v3fCenter = new Vec3(arguments[0].v3fCenter);
this.fRadius = arguments[0].fRadius;
break ;

case 2:
this.v3fCenter = new Vec3(arguments[0]);
this.fRadius = arguments[1];
break ;

case 4:
this.v3fCenter = new Vec3(arguments[0], arguments[1], arguments[2]);
this.fRadius = arguments[3];
break ;
}

}

;
Object.defineProperty(Sphere.prototype, "circle",  {set: function(pCircle) {
this.v3fCenter.pData[0] = pCircle.v2fCenter.pData[0];
this.v3fCenter.pData[1] = pCircle.v2fCenter.pData[1];
this.fRadius = pCircle.fRadius;

}
, get: function() {
return new Circle(this.v3fCenter.pData[0], this.v3fCenter.pData[1], this.fRadius);

}
});
Object.defineProperty(Sphere.prototype, "z",  {set: function(fZ) {
this.v3fCenter.pData[2] = fZ;

}
, get: function() {
return this.v3fCenter.pData[2];

}
});
Sphere.prototype.isEqual = function(pSphere) {
;
return (pSphere.v3fCenter.isEqual(this.v3fCenter)) && ((this.fRadius) == (pSphere.fRadius));

};
Sphere.prototype.eq = function(pSphere) {
;
this.v3fCenter.set(pSphere.v3fCenter);
this.fRadius = pSphere.fRadius;

};
Sphere.prototype.clear = function() {
;
this.v3fCenter.clear();
this.fRadius = 0;

};
Sphere.prototype.isClear = function() {
;
return (this.v3fCenter.isClear()) && (0 == (this.fRadius));

};
Sphere.prototype.set = function() {
;
switch(arguments.length) {
case 1:
this.v3fCenter.set(arguments[0].v3fCenter);
this.fRadius = arguments[0].fRadius;
break ;

case 2:
this.v3fCenter.set(arguments[0]);
this.fRadius = arguments[1];
break ;

case 4:
this.v3fCenter.set(arguments);
this.fRadius = arguments[3];
break ;
}

};
Sphere.prototype.isValid = function() {
;
return (this.fRadius) >= 0;

};
Sphere.prototype.assertValid = function() {
;
if (!((this.fRadius) >= 0)) {
var err=((((((("Error:: " + "sphere inverted") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("sphere inverted");

}


}

;

};
Sphere.prototype.offset = function(v3fOffset) {
;
this.v3fCenter.add(v3fOffset);

};
Sphere.prototype.expand = function(fInc) {
;
this.fRadius += fInc;

};
Sphere.prototype.normalize = function() {
;
this.fRadius = Math.abs(this.fRadius);

};
function Plane2d() {
this.fDistance = 0;
this.v2fNormal = null;
switch(arguments.length) {
case 0:
this.v2fNormal = new Vec2();
break ;

case 1:
this.v2fNormal = new Vec2(arguments[0].v2fNormal);
this.fDistance = arguments[0].fDistance;
break ;

case 2:
if ((typeof (arguments[1])) == "number") {
this.v2fNormal = new Vec2(arguments[0]);
this.fDistance = arguments[1];

}
else  {
this.v2fNormal = new Vec2();
var vec0=Vec2(arguments[1]).subtract(Vec2(arguments[0]), this.v2fNormal);
var x=vec0.pData[0];
var y=vec0.pData[1];
vec0.pData[0] = -y;
vec0.pData[1] = x;
this.fDistance = -(vec0.dot(Vec2(arguments[0])));

}

break ;
}

}

;
Plane2d.prototype.eq = function(pPlane) {
;
this.v2fNormal.set(pPlane);
this.fDistance = pPlane.fDistance;

};
Plane2d.prototype.isEqual = function(pPlane) {
;
return (this.v2fNormal.isEqual(pPlane.v2fNormal)) && ((this.fDistance) == (pPlane.fDistance));

};
Plane2d.prototype.solveForX = function(fY) {
;
if (this.v2fNormal.pData[0]) {
return (-(((this.v2fNormal.pData[1]) * fY) + (this.fDistance))) / (this.v2fNormal.pData[0]);

}

return 0;

};
Plane2d.prototype.solveForY = function(fX) {
;
if (this.v2fNormal.pData[1]) {
return (-(((this.v2fNormal.pData[0]) * fX) + (this.fDistance))) / (this.v2fNormal.pData[1]);

}

return 0;

};
Plane2d.prototype.projectPointToPlane = function(v2fPoint) {
;
var distance=(this.v2fNormal.dot(v2fPoint)) + (this.fDistance);
var v2fRes=new Vec2();
v2fRes.pData[0] = ((this.v2fNormal.pData[0]) * (-distance)) + (v2fPoint.pData[0]);
v2fRes.pData[1] = ((this.v2fNormal.pData[1]) * (-distance)) + (v2fPoint.pData[1]);
return v2fRes;

};
Plane2d.prototype.set = function(arg1, arg2) {
;
if ((typeof arg2) == "number") {
this.v2fNormal.set(arg1);
this.fDistance = arg2;

}
else  {
var line=arg2.subtract(arg1, this.v2fNormal);
var x=line.pData[0];
var y=line.pData[1];
line.pData[0] = -y;
line.pData[1] = x;
this.fDistance = -(line.dot(Vec2(arg1)));

}


};
Plane2d.prototype.signedDistance = function(v2fPoint) {
return (this.v2fNormal.dot(v2fPoint)) + (this.fDistance);

};
function Plane3d() {
this.fDistance = 0;
this.v3fNormal = null;
switch(arguments.length) {
case 0:
this.v3fNormal = new Vec3();
break ;

case 1:
this.v3fNormal.set(arguments[0].v3fNormal);
this.fDistance = arguments[0].fDistance;
break ;

case 2:
if ((typeof (arguments[1])) == "number") {
this.v3fNormal = new Vec3(arguments[0]);
this.fDistance = arguments[1];

}
else  {
this.v3fNormal = new Vec3(arguments[1]);
this.fDistance = -(arguments[0].dot(arguments[1]));

}

break ;

case 3:
var sideA=new Vec3();
var sideB=new Vec3();
arguments[1].subtract(arguments[0], sideA);
arguments[2].subtract(arguments[0], sideB);
sideB.cross(sideA);
sideB.normalize();
this.v3fNormal = new Vec3(sideB);
this.fDistance = -(this.v3fNormal.dot(Vec3(arguments[0])));
break ;
}

}

;
Plane3d.prototype.eq = function(pPlane) {
;
this.v3fNormal.set(pPlane.v3fNormal);
this.fDistance = pPlane.fDistance;

};
Plane3d.prototype.isEqual = function(pPlane) {
;
return (this.v3fNormal.isEqual(pPlane.v3fNormal)) && ((this.fDistance) == (pPlane.fDistance));

};
Plane3d.prototype.normalize = function() {
;
var len=1 / (this.v3fNormal.length());
this.v3fNormal.scale(len);
this.fDistance *= len;

};
Plane3d.prototype.solveForX = function(fY, fZ) {
;
if (this.v3fNormal.pData[0]) {
return (-((((this.v3fNormal.pData[1]) * fY) + ((this.v3fNormal.pData[2]) * fZ)) + (this.fDistance))) / (this.v3fNormal.pData[0]);

}

return 0;

};
Plane3d.prototype.solveForY = function(fX, fZ) {
;
if (this.v3fNormal.pData[1]) {
return (-((((this.v3fNormal.pData[0]) * fX) + ((this.v3fNormal.pData[2]) * fZ)) + (this.fDistance))) / (this.v3fNormal.pData[1]);

}

return 0;

};
Plane3d.prototype.solveForZ = function(fX, fY) {
;
if (this.v3fNormal.pData[2]) {
return (-((((this.v3fNormal.pData[1]) * fY) + ((this.v3fNormal.pData[0]) * fX)) + (this.fDistance))) / (this.v3fNormal.pData[2]);

}

return 0;

};
Plane3d.prototype.projectPointToPlane = function(v3fPoint) {
;
var distance=(this.v3fNormal.dot(v3fPoint)) + (this.fDistance);
var v3fRes=new Vec3();
v3fRes.pData[0] = ((this.v3fNormal.pData[0]) * (-distance)) + (v3fPoint.pData[0]);
v3fRes.pData[1] = ((this.v3fNormal.pData[1]) * (-distance)) + (v3fPoint.pData[1]);
v3fRes.pData[2] = ((this.v3fNormal.pData[2]) * (-distance)) + (v3fPoint.pData[2]);
return v3fRes;

};
Plane3d.prototype.set = function() {
;
switch(arguments.length) {
case 2:
if ((typeof (arguments[1])) == "number") {
this.v3fNormal.set(arguments[0]);
this.fDistance = arguments[1];

}
else  {
this.v3fNormal.set(arguments[1]);
this.fDistance = -(this.v3fNormal.dot(Vec3(arguments[0])));

}

break ;

case 3:
var sideA=new Vec3();
var sideB=this.v3fNormal;
Vec3(arguments[1]).subtract(arguments[0], sideA);
Vec3(arguments[2]).subtract(arguments[0], sideB);
sideB.cross(sideA);
sideB.normalize();
this.fDistance = -(this.v3fNormal.dot(arguments[0]));
break ;
}

};
Plane3d.prototype.xForm = function(m4fMatrix) {
;
this.v3fNormal.vec3TransformCoord(m4fMatrix, this.v3fNormal);
this.v3fNormal.normalize();
var point=new Vec3();
this.v3fNormal.scale(this.fDistance, point);
point.vec3TransformCoord(m4fMatrix, point);
this.fDistance = -(point.dot(this.v3fNormal));

};
Plane3d.prototype.signedDistance = function(v3fPoint) {
;
return (v3fPoint.dot(this.v3fNormal)) + (this.fDistance);

};
function Rect2d() {
this.fX0 = 0;
this.fX1 = 0;
this.fY0 = 0;
this.fY1 = 0;
switch(arguments.length) {
case 1:
if ((arguments[0]) instanceof Rect2d) {
this.fX0 = arguments[0].fX0;
this.fX1 = arguments[0].fX1;
this.fX0 = arguments[0].fY0;
this.fX1 = arguments[0].fY1;

}
else  {
this.fX1 = (arguments[0].pData[0]) * 0.5;
this.fX0 = -(this.fX1);
this.fY1 = (arguments[0].pData[1]) * 0.5;
this.fY0 = -(this.fY1);

}

break ;

case 2:
this.fX1 = (arguments[0]) * 0.5;
this.fX0 = -(this.fX1);
this.fY1 = (arguments[1]) * 0.5;
this.fY0 = -(this.fY1);
break ;

case 4:
this.fX0 = arguments[0];
this.fX1 = arguments[1];
this.fY0 = arguments[2];
this.fY1 = arguments[3];
break ;
}

}

;
Rect2d.prototype.isEqual = function(pRect) {
return ((((this.fX0) == (pRect.fX0)) && ((this.fX1) == (pRect.fX1))) && ((this.fY0) == (pRect.fY0))) && ((this.fY1) == (pRect.fY1));

};
Rect2d.prototype.eq = function(pRect) {
this.fX0 = pRect.fX0;
this.fX1 = pRect.fX1;
this.fY0 = pRect.fY0;
this.fY1 = pRect.fY1;

};
Rect2d.prototype.addSelf = function(value) {
if ((typeof value) == "number") {
this.fX0 += value;
this.fX1 += value;
this.fY0 += value;
this.fY1 += value;

}
else  {
this.fX0 += value.pData[0];
this.fX1 += value.pData[0];
this.fY0 += value.pData[1];
this.fY1 += value.pData[1];

}


};
Rect2d.prototype.neg = function() {
return new Rect2d(-(this.fX0), -(this.fX1), -(this.fY0), -(this.fY1));

};
Rect2d.prototype.subSelf = function(value) {
if ((typeof value) == "number") {
this.fX0 -= value;
this.fX1 -= value;
this.fY0 -= value;
this.fY1 -= value;

}
else  {
this.fX0 -= value.pData[0];
this.fX1 -= value.pData[0];
this.fY0 -= value.pData[1];
this.fY1 -= value.pData[1];

}


};
Rect2d.prototype.divSelf = function(value) {
if ((typeof value) == "number") {
if (!(value != 0)) {
var err=((((((("Error:: " + "divide by zero error") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("divide by zero error");

}


}

;
this.fX0 /= value;
this.fX1 /= value;
this.fY0 /= value;
this.fY1 /= value;

}
else  {
if (!((value.pData[0]) != 0)) {
var err=((((((("Error:: " + "divide by zero error") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("divide by zero error");

}


}

;
if (!((value.pData[1]) != 0)) {
var err=((((((("Error:: " + "divide by zero error") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("divide by zero error");

}


}

;
this.fX0 /= value.pData[0];
this.fX1 /= value.pData[0];
this.fY0 /= value.pData[1];
this.fY1 /= value.pData[1];

}


};
Rect2d.prototype.multSelf = function(value) {
if ((typeof value) == "number") {
this.fX0 *= value;
this.fX1 *= value;
this.fY0 *= value;
this.fY1 *= value;

}
else  {
this.fX0 *= value.pData[0];
this.fX1 *= value.pData[0];
this.fY0 *= value.pData[1];
this.fY1 *= value.pData[1];

}


};
Rect2d.prototype.clear = function() {
this.fX0 = 0;
this.fX1 = 0;
this.fY0 = 0;
this.fY1 = 0;

};
Rect2d.prototype.isClear = function() {
return (((0 == (this.fX0)) && (0 == (this.fX1))) && (0 == (this.fY0))) && (0 == (this.fY1));

};
Rect2d.prototype.set = function() {
switch(arguments.length) {
case 1:
if ((arguments[0]) instanceof Rect2d) {
this.fX0 = arguments[0].fX0;
this.fX1 = arguments[0].fX1;
this.fY0 = arguments[0].fY0;
this.fY1 = arguments[0].fY1;

}
else  {
this.fX1 = (arguments[0].pData[0]) * 0.5;
this.fX0 = -(this.fX1);
this.fY1 = (arguments[0].pData[1]) * 0.5;
this.fY0 = -(this.fY1);

}

break ;

case 2:
this.fX1 = (arguments[0]) * 0.5;
this.fX0 = -(this.fX1);
this.fY1 = (arguments[1]) * 0.5;
this.fY0 = -(this.fY1);
break ;

case 4:
this.fX0 = arguments[0];
this.fX1 = arguments[1];
this.fY0 = arguments[2];
this.fY1 = arguments[3];
break ;
}

};
Rect2d.prototype.setFloor = function(pRect) {
this.fX0 = Math.floor(pRect.fX0);
this.fX1 = Math.floor(pRect.fX1);
this.fY0 = Math.floor(pRect.fY0);
this.fY1 = Math.floor(pRect.fY1);

};
Rect2d.prototype.setCeiling = function(pRect) {
this.fX0 = Math.ceil(pRect.fX0);
this.fX1 = Math.ceil(pRect.fX1);
this.fY0 = Math.ceil(pRect.fY0);
this.fY1 = Math.ceil(pRect.fY1);

};
Rect2d.prototype.isValid = function() {
return ((this.fX0) <= (this.fX1)) && ((this.fY0) <= (this.fY1));

};
Rect2d.prototype.assertValid = function() {
if (!((this.fX0) <= (this.fX1))) {
var err=((((((("Error:: " + "rectangle inverted on X axis") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("rectangle inverted on X axis");

}


}

;
if (!((this.fY0) <= (this.fY1))) {
var err=((((((("Error:: " + "rectangle inverted on Y axis") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("rectangle inverted on Y axis");

}


}

;

};
Rect2d.prototype.resizeX = function(fSize) {
this.fX1 = (((this.fX1) + (this.fX0)) + fSize) * 0.5;
this.fX0 = (this.fX1) - fSize;

};
Rect2d.prototype.resizeY = function(fSize) {
this.fY1 = (((this.fY1) + (this.fY0)) + fSize) * 0.5;
this.fY0 = (this.fY1) - fSize;

};
Rect2d.prototype.resize = function(v2fSize) {
this.fX1 = (((this.fX1) + (this.fX0)) + (v2fSize[0])) * 0.5;
this.fX0 = (this.fX1) - (v2fSize.pData[0]);
this.fY1 = (((this.fY1) + (this.fY0)) + (v2fSize[1])) * 0.5;
this.fY0 = (this.fY1) - (v2fSize.pData[1]);

};
Rect2d.prototype.resizeMaxX = function(fSpan) {
this.fX1 = (this.fX0) + fSpan;

};
Rect2d.prototype.resizeMaxY = function(fSpan) {
this.fY1 = (this.fY0) + fSpan;

};
Rect2d.prototype.resizeMax = function(v2fSize) {
this.fX1 = (this.fX0) + (v2fSize.pData[0]);
this.fY1 = (this.fY0) + (v2fSize.pData[1]);

};
Rect2d.prototype.resizeMinX = function(fSpan) {
this.fX0 = (this.fX1) - fSpan;

};
Rect2d.prototype.resizeMinY = function(fSpan) {
this.fY0 = (this.fY1) - fSpan;

};
Rect2d.prototype.resizeMin = function(v2fSize) {
this.fX0 = (this.fX1) - (v2fSize.pData[0]);
this.fY0 = (this.fY1) - (v2fSize.pData[1]);

};
Rect2d.prototype.midX = function() {
return ((this.fX0) + (this.fX1)) * 0.5;

};
Rect2d.prototype.midY = function() {
return ((this.fY0) + (this.fY1)) * 0.5;

};
Rect2d.prototype.midpoint = function() {
var v2fPoint=new Vec2();
v2fPoint.pData[0] = ((this.fX0) + (this.fX1)) * 0.5;
v2fPoint.pData[1] = ((this.fY0) + (this.fY1)) * 0.5;
return v2fPoint;

};
Rect2d.prototype.sizeX = function() {
return (this.fX1) - (this.fX0);

};
Rect2d.prototype.sizeY = function() {
return (this.fY1) - (this.fY0);

};
Rect2d.prototype.size = function() {
var v2fSize=new Vec2();
v2fSize.pData[0] = (this.fX1) - (this.fX0);
v2fSize.pData[1] = (this.fY1) - (this.fY0);
return v2fSize;

};
Rect2d.prototype.minPoint = function() {
var v2fPoint=new Vec2();
v2fPoint.pData[0] = this.fX0;
v2fPoint.pData[1] = this.fY0;
return v2fPoint;

};
Rect2d.prototype.maxPoint = function() {
var v2fPoint=new Vec2();
v2fPoint.pData[0] = this.fX1;
v2fPoint.pData[1] = this.fY1;
return v2fPoint;

};
Rect2d.prototype.area = function() {
return ((this.fX1) - (this.fX0)) * ((this.fY1) - (this.fY0));

};
Rect2d.prototype.unionPoint = function(v2fPoint) {
this.fX0 = Math.min(this.fX0, point.pData[0]);
this.fY0 = Math.min(this.fY0, point.pData[1]);
this.fX1 = Math.max(this.fX1, point.pData[0]);
this.fY1 = Math.max(this.fY1, point.pData[1]);

};
Rect2d.prototype.unionRect = function(pRect) {
this.assertValid();
pRect.assertValid();
this.fX0 = Math.min(this.fX0, pRect.fX0);
this.fY0 = Math.min(this.fY0, pRect.fY0);
this.fX1 = Math.max(this.fX1, pRect.fX1);
this.fY1 = Math.max(this.fY1, pRect.fY1);

};
Rect2d.prototype.offset = function(v2fOffset) {
this.fX0 += v2fOffset.pData[0];
this.fX1 += v2fOffset.pData[0];
this.fY0 += v2fOffset.pData[1];
this.fY1 += v2fOffset.pData[1];

};
Rect2d.prototype.expand = function(value) {
if ((typeof value) == "number") {
this.fX0 -= value;
this.fX1 += value;
this.fY0 -= value;
this.fY1 += value;

}
else  {
this.fX0 -= value.pData[0];
this.fX1 += value.pData[0];
this.fY0 -= value.pData[1];
this.fY1 += value.pData[1];

}


};
Rect2d.prototype.expandX = function(fN) {
this.fX0 -= fN;
this.fX1 += fN;

};
Rect2d.prototype.expandY = function(fN) {
this.fY0 -= fN;
this.fY1 += fN;

};
Rect2d.prototype.normalize = function() {
var temp;
if ((this.fX0) > (this.fX1)) {
temp = this.fX0;
this.fX0 = this.fX1;
this.fX1 = temp;

}

if ((this.fY0) > (this.fY1)) {
temp = this.fY0;
this.fY0 = this.fY1;
this.fY1 = temp;

}


};
Rect2d.prototype.corner = function(index) {
if (!((index >= 0) && (index < 4))) {
var err=((((((("Error:: " + "invalid index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid index");

}


}

;
var v2fPoint=new Vec2();
v2fPoint.pData[0] = (index & 1? this.fX0 : this.fX1);
v2fPoint.pData[1] = (index & 2? this.fY0 : this.fY1);
return v2fPoint;

};
Rect2d.prototype.isPointInRect = function(v2fPoint) {
return ((((v2fPoint.pData[0]) >= (this.fX0)) && ((v2fPoint.pData[1]) >= (this.fY0))) && ((v2fPoint[0]) <= (Rect3d.fX1))) && ((v2fPoint[1]) <= (this.fY1));

};
Rect2d.prototype.createBoundingCircle = function() {
return new Circle(((this.fX0) + (this.fX1)) * 0.5, ((this.fY0) + (this.fY1)) * 0.5, ((((this.fX1) - (this.fX0)) + (this.fY1)) - (this.fY0)) * 0.5);

};
function Rect3d() {
if ((((this) === window) || (!(this))) || ((this) === (window.AKRA))) {
Rect3d._iIndex = ((Rect3d._iIndex) === ((Rect3d._nStorageSize) - 1)? 0 : Rect3d._iIndex);
return Rect3d._pStorage[Rect3d._iIndex++];

}

;
this.fX0 = 0;
this.fX1 = 0;
this.fY0 = 0;
this.fY1 = 0;
this.fZ0 = 0;
this.fZ1 = 0;
switch(arguments.length) {
case 1:
if ((arguments[0]) instanceof Rect3d) {
this.fX0 = arguments[0].fX0;
this.fX1 = arguments[0].fX1;
this.fY0 = arguments[0].fY0;
this.fY1 = arguments[0].fY1;
this.fZ0 = arguments[0].fZ0;
this.fZ1 = arguments[0].fZ1;

}
else  {
this.fX1 = (arguments[0].pData[0]) * 0.5;
this.fX0 = -(this.fX1);
this.fY1 = (arguments[0].pData[1]) * 0.5;
this.fY0 = -(this.fY1);
this.fZ1 = (arguments[0].pData[2]) * 0.5;
this.fZ0 = -(this.fZ1);

}

break ;

case 3:
this.fX1 = (arguments[0]) * 0.5;
this.fX0 = -(this.fX1);
this.fY1 = (arguments[1]) * 0.5;
this.fY0 = -(this.fY1);
this.fZ1 = (arguments[2]) * 0.5;
this.fZ0 = -(this.fZ1);
break ;

case 6:
this.fX0 = arguments[0];
this.fX1 = arguments[1];
this.fY0 = arguments[2];
this.fY1 = arguments[3];
this.fZ0 = arguments[4];
this.fZ1 = arguments[5];
break ;
}

}

a.allocateStorage(Rect3d, 16);
Object.defineProperty(Rect3d.prototype, "pRect2d",  {set: function(pRect2d) {
this.fX0 = pRect2d.fX0;
this.fX1 = pRect2d.fX1;
this.fY0 = pRect2d.fY0;
this.fY1 = pRect2d.fY1;

}
, get: function() {
return new Rect2d(this.fX0, this.fX1, this.fY0, this.fY1);

}
});
Rect3d.prototype.isEqual = function(pRect) {
return ((((((this.fX0) == (pRect.fX0)) && ((this.fX1) == (pRect.fX1))) && ((this.fY0) == (pRect.fY0))) && ((this.fY1) == (pRect.fY1))) && ((this.fZ0) == (pRect.fZ0))) && ((this.fZ1) == (pRect.fZ1));

};
Rect3d.prototype.eq = function(pRect) {
this.fX0 = pRect.fX0;
this.fX1 = pRect.fX1;
this.fY0 = pRect.fY0;
this.fY1 = pRect.fY1;
this.fZ0 = pRect.fZ0;
this.fZ1 = pRect.fZ1;

};
Rect3d.prototype.neg = function() {
return new Rect3d(-(this.fX0), -(this.fX1), -(this.fY0), -(this.fY1), -(this.fZ0), -(this.fZ1));

};
Rect3d.prototype.addSelf = function(value) {
if ((typeof value) == "number") {
this.fX0 += value;
this.fX1 += value;
this.fY0 += value;
this.fY1 += value;
this.fZ0 += value;
this.fZ1 += value;

}
else  {
this.fX0 += value.pData[0];
this.fX1 += value.pData[0];
this.fY0 += value.pData[1];
this.fY1 += value.pData[1];
this.fZ0 += value.pData[2];
this.fZ1 += value.pData[2];

}


};
Rect3d.prototype.subSelf = function(value) {
if ((typeof value) == "number") {
this.fX0 -= value;
this.fX1 -= value;
this.fY0 -= value;
this.fY1 -= value;
this.fZ0 -= value;
this.fZ1 -= value;

}
else  {
value = value.pData;
this.fX0 -= value[0];
this.fX1 -= value[0];
this.fY0 -= value[1];
this.fY1 -= value[1];
this.fZ0 -= value[2];
this.fZ1 -= value[2];

}


};
Rect3d.prototype.divSelf = function(value) {
if ((typeof value) == "number") {
if (!(value != 0)) {
var err=((((((("Error:: " + "divide by zero error") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("divide by zero error");

}


}

;
this.fX0 /= value;
this.fX1 /= value;
this.fY0 /= value;
this.fY1 /= value;
this.fZ0 /= value;
this.fZ1 /= value;

}
else  {
if (!((value.pData[0]) != 0)) {
var err=((((((("Error:: " + "divide by zero error") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("divide by zero error");

}


}

;
if (!((value.pData[1]) != 0)) {
var err=((((((("Error:: " + "divide by zero error") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("divide by zero error");

}


}

;
if (!((value.pData[2]) != 0)) {
var err=((((((("Error:: " + "divide by zero error") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("divide by zero error");

}


}

;
this.fX0 /= value.pData[0];
this.fX1 /= value.pData[0];
this.fY0 /= value.pData[1];
this.fY1 /= value.pData[1];
this.fZ0 /= value.pData[2];
this.fZ1 /= value.pData[2];

}


};
Rect3d.prototype.multSelf = function(value) {
if ((typeof value) == "number") {
this.fX0 *= value;
this.fX1 *= value;
this.fY0 *= value;
this.fY1 *= value;
this.fZ0 *= value;
this.fZ1 *= value;

}
else  {
this.fX0 *= value.pData[0];
this.fX1 *= value.pData[0];
this.fY0 *= value.pData[1];
this.fY1 *= value.pData[1];
this.fZ0 *= value.pData[2];
this.fZ1 *= value.pData[2];

}


};
Rect3d.prototype.clear = function() {
this.fX0 = 0;
this.fX1 = 0;
this.fY0 = 0;
this.fY1 = 0;
this.fZ0 = 0;
this.fZ1 = 0;

};
Rect3d.prototype.isClear = function() {
return (((((0 == (this.fX0)) && (0 == (this.fX1))) && (0 == (this.fY0))) && (0 == (this.fY1))) && (0 == (this.fZ0))) && (0 == (this.fZ1));

};
Rect3d.prototype.set = function() {
switch(arguments.length) {
case 1:
if ((arguments[0]) instanceof Rect3d) {
this.fX0 = arguments[0].fX0;
this.fX1 = arguments[0].fX1;
this.fY0 = arguments[0].fY0;
this.fY1 = arguments[0].fY1;
this.fZ0 = arguments[0].fZ0;
this.fZ1 = arguments[0].fZ1;

}
else  {
this.fX1 = (arguments[0].pData[0]) * 0.5;
this.fX0 = -(this.fX1);
this.fY1 = (arguments[0].pData[1]) * 0.5;
this.fY0 = -(this.fY1);
this.fZ1 = (arguments[0].pData[2]) * 0.5;
this.fZ0 = -(this.fZ1);

}

break ;

case 3:
this.fX1 = (arguments[0]) * 0.5;
this.fX0 = -(this.fX1);
this.fY1 = (arguments[1]) * 0.5;
this.fY0 = -(this.fY1);
this.fZ1 = (arguments[2]) * 0.5;
this.fZ0 = -(this.fZ1);
break ;

case 6:
this.fX0 = arguments[0];
this.fX1 = arguments[1];
this.fY0 = arguments[2];
this.fY1 = arguments[3];
this.fZ0 = arguments[4];
this.fZ1 = arguments[5];
break ;
}

};
Rect3d.prototype.setFloor = function(pRect) {
this.fX0 = Math.floor(pRect.fX0);
this.fX1 = Math.floor(pRect.fX1);
this.fY0 = Math.floor(pRect.fY0);
this.fY1 = Math.floor(pRect.fY1);
this.fZ0 = Math.floor(pRect.fZ0);
this.fZ1 = Math.floor(pRect.fZ1);

};
Rect3d.prototype.setCeiling = function(pRect) {
this.fX0 = Math.ceil(pRect.fX0);
this.fX1 = Math.ceil(pRect.fX1);
this.fY0 = Math.ceil(pRect.fY0);
this.fY1 = Math.ceil(pRect.fY1);
this.fZ0 = Math.ceil(pRect.fZ0);
this.fZ1 = Math.ceil(pRect.fZ1);

};
Rect3d.prototype.isValid = function() {
return (((this.fX0) <= x1) && ((this.fY0) <= y1)) && ((this.fZ0) <= z1);

};
Rect3d.prototype.assertValid = function() {
if (!((this.fX0) <= (this.fX1))) {
var err=((((((("Error:: " + "rectangle inverted on X axis") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("rectangle inverted on X axis");

}


}

;
if (!((this.fY0) <= (this.fY1))) {
var err=((((((("Error:: " + "rectangle inverted on Y axis") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("rectangle inverted on Y axis");

}


}

;
if (!((this.fZ0) <= (this.fZ1))) {
var err=((((((("Error:: " + "rectangle inverted on Z axis") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("rectangle inverted on Z axis");

}


}

;

};
Rect3d.prototype.resizeX = function(fSize) {
this.fX1 = (((this.fX0) + (this.fX1)) + fSize) * 0.5;
this.fX0 = (this.fX1) - fSize;

};
Rect3d.prototype.resizeY = function(fSize) {
this.fY1 = (((this.fY0) + (this.fY1)) + fSize) * 0.5;
this.fY0 = (this.fY1) - fSize;

};
Rect3d.prototype.resizeZ = function(fSize) {
this.fZ1 = (((this.fZ0) + (this.fZ1)) + fSize) * 0.5;
this.fZ0 = (this.fZ1) - fSize;

};
Rect3d.prototype.resize = function(v3fSize) {
this.fX1 = (((this.fX0) + (this.fX1)) + (v3fSize.pData[0])) * 0.5;
this.fX0 = (this.fX1) - (v2fSize[0]);
this.fY1 = (((this.fY0) + (this.fY1)) + (v3fSize.pData[1])) * 0.5;
this.fY0 = (this.fY1) - (v2fSize[1]);
this.fZ1 = (((this.fZ0) + (this.fZ1)) + (v3fSize.pData[2])) * 0.5;
this.fZ0 = (this.fZ1) - fSize;

};
Rect3d.prototype.resizeMaxX = function(fSpan) {
this.fX1 = (this.fX0) + fSpan;

};
Rect3d.prototype.resizeMaxY = function(fSpan) {
this.fY1 = (this.fY0) + fSpan;

};
Rect3d.prototype.resizeMaxZ = function(fSpan) {
this.fZ1 = (this.fZ0) + fSpan;

};
Rect3d.prototype.resizeMax = function(v3fSize) {
this.fX1 = (this.fX0) + (v3fSize.pData[0]);
this.fY1 = (this.fY0) + (v3fSize.pData[1]);
this.fZ1 = (this.fZ0) + (v3fSize.pData[2]);

};
Rect3d.prototype.resizeMinX = function(fSpan) {
this.fX0 = (this.fX1) - fSpan;

};
Rect3d.prototype.resizeMinY = function(fSpan) {
this.fY0 = (this.fY1) - fSpan;

};
Rect3d.prototype.resizeMinZ = function(fSpan) {
this.fZ0 = (this.fZ1) - fSpan;

};
Rect3d.prototype.resizeMin = function(v3fSize) {
this.fX0 = (this.fX1) - (v3fSize.pData[0]);
this.fY0 = (this.fY1) - (v3fSize.pData[1]);
this.fZ0 = (this.fZ1) - (v3fSize.pData[2]);

};
Rect3d.prototype.midX = function() {
return ((this.fX0) + (this.fX1)) * 0.5;

};
Rect3d.prototype.midY = function() {
return ((this.fY0) + (this.fY1)) * 0.5;

};
Rect3d.prototype.midZ = function() {
return ((this.fZ0) + (this.fZ1)) * 0.5;

};
Rect3d.prototype.midPoint = function() {
return new Vec3(((this.fX0) + (this.fX1)) * 0.5, ((this.fY0) + (this.fY1)) * 0.5, ((this.fZ0) + (this.fZ1)) * 0.5);

};
Rect3d.prototype.sizeX = function() {
return (this.fX1) - (this.fX0);

};
Rect3d.prototype.sizeY = function() {
return (this.fY1) - (this.fY0);

};
Rect3d.prototype.sizeZ = function() {
return (this.fZ1) - (this.fZ0);

};
Rect3d.prototype.size = function() {
return new Vec3((this.fX1) - (this.fX0), (this.fY1) - (this.fY0), (this.fZ1) - (this.fZ0));

};
Rect3d.prototype.minPoint = function() {
return new Vec3(this.fX0, this.fY0, this.fZ0);

};
Rect3d.prototype.maxPoint = function() {
return new Vec3(this.fX1, this.fY1, this.fZ1);

};
Rect3d.prototype.area = function() {
return (((this.fX1) - (this.fX0)) * ((this.fY1) - (this.fY0))) * ((this.fZ1) - (this.fZ0));

};
Rect3d.prototype.unionPoint = function(v3fPoint) {
this.fX0 = Math.min(this.fX0, v3fPoint.pData[0]);
this.fY0 = Math.min(this.fY0, v3fPoint.pData[1]);
this.fZ0 = Math.min(this.fZ0, v3fPoint.pData[2]);
this.fX1 = Math.max(this.fX1, v3fPoint.pData[0]);
this.fY1 = Math.max(this.fY1, v3fPoint.pData[1]);
this.fZ1 = Math.max(this.fZ1, v3fPoint.pData[2]);

};
Rect3d.prototype.unionRect = function(pRect) {
this.assertValid();
pRect.assertValid();
this.fX0 = Math.min(this.fX0, pRect.fX0);
this.fY0 = Math.min(this.fY0, pRect.fY0);
this.fZ0 = Math.min(this.fZ0, pRect.fZ0);
this.fX1 = Math.max(this.fX1, pRect.fX1);
this.fY1 = Math.max(this.fY1, pRect.fY1);
this.fZ1 = Math.max(this.fZ1, pRect.fZ1);

};
Rect3d.prototype.offset = function(v3fOffset) {
this.fX0 += v3fOffset.pData[0];
this.fX1 += v3fOffset.pData[0];
this.fY0 += v3fOffset.pData[1];
this.fY1 += v3fOffset.pData[1];
this.fZ0 += v3fOffset.pData[2];
this.fZ1 += v3fOffset.pData[2];

};
Rect3d.prototype.expand = function(value) {
if ((typeof value) == "number") {
this.fX0 -= value;
this.fX1 += value;
this.fY0 -= value;
this.fY1 += value;
this.fZ0 -= value;
this.fZ1 += value;

}
else  {
this.fX0 -= value.pData[0];
this.fX1 += value.pData[0];
this.fY0 -= value.pData[1];
this.fY1 += value.pData[1];
this.fZ0 -= value.pData[2];
this.fZ1 += value.pData[2];

}


};
Rect3d.prototype.expandX = function(fN) {
this.fX0 -= fN;
this.fX1 += fN;

};
Rect3d.prototype.expandY = function(fN) {
this.fY0 -= fN;
this.fY1 += fN;

};
Rect3d.prototype.expandZ = function(fN) {
this.fZ0 -= fN;
this.fZ1 += fN;

};
Rect3d.prototype.normalize = function() {
var temp;
if ((this.fX0) > (this.fX1)) {
temp = this.fX0;
this.fX0 = this.fX1;
this.fX1 = temp;

}

if ((this.fY0) > (this.fY1)) {
temp = this.fY0;
this.fY0 = this.fY1;
this.fY1 = temp;

}

if ((this.fZ0) > (this.fZ1)) {
temp = this.fZ0;
this.fZ0 = this.fZ1;
this.fZ1 = temp;

}


};
Rect3d.prototype.corner = function(index) {
if (!((index >= 0) && (index < 8))) {
var err=((((((("Error:: " + "invalid index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid index");

}


}

;
return new Vec3((index & 1? this.fX0 : this.fX1), (index & 2? this.fY0 : this.fY1), (index & 4? this.fZ0 : this.fZ1));

};
Rect3d.prototype.unionPointCoord = function(fX, fY, fZ) {
this.fX0 = Math.min(this.fX0, fX);
this.fY0 = Math.min(this.fY0, fY);
this.fZ0 = Math.min(this.fZ0, fZ);
this.fX1 = Math.max(this.fX1, fX);
this.fY1 = Math.max(this.fY1, fY);
this.fZ1 = Math.max(this.fZ1, fZ);

};
Rect3d.prototype.transform = function(m4fMatrix) {
var pData=m4fMatrix.pData;
var a11=pData[0], a12=pData[4], a13=pData[8], a14=pData[12];
var a21=pData[1], a22=pData[5], a23=pData[9], a24=pData[13];
var a31=pData[2], a32=pData[6], a33=pData[10], a34=pData[14];
var fX0=this.fX0, fX1=this.fX1;
var fY0=this.fY0, fY1=this.fY1;
var fZ0=this.fZ0, fZ1=this.fZ1;
var fBaseX=(((a11 * fX0) + (a12 * fY0)) + (a13 * fZ0)) + a14;
var fBaseY=(((a21 * fX0) + (a22 * fY0)) + (a23 * fZ0)) + a24;
var fBaseZ=(((a31 * fX0) + (a32 * fY0)) + (a33 * fZ0)) + a34;
var fXNewX=a11 * (fX1 - fX0);
var fXNewY=a21 * (fX1 - fX0);
var fXNewZ=a31 * (fX1 - fX0);
var fYNewX=a12 * (fY1 - fY0);
var fYNewY=a22 * (fY1 - fY0);
var fYNewZ=a32 * (fY1 - fY0);
var fZNewX=a13 * (fZ1 - fZ0);
var fZNewY=a23 * (fZ1 - fZ0);
var fZNewZ=a33 * (fZ1 - fZ0);
var fXMultX=(fXNewX > 0? 1 : 0);
var fYMultX=(fYNewX > 0? 1 : 0);
var fZMultX=(fZNewX > 0? 1 : 0);
var fXMultY=(fXNewY > 0? 1 : 0);
var fYMultY=(fYNewY > 0? 1 : 0);
var fZMultY=(fZNewY > 0? 1 : 0);
var fXMultZ=(fXNewZ > 0? 1 : 0);
var fYMultZ=(fYNewZ > 0? 1 : 0);
var fZMultZ=(fZNewZ > 0? 1 : 0);
this.fX1 = ((fBaseX + (fXMultX * fXNewX)) + (fYMultX * fYNewX)) + (fZMultX * fZNewX);
this.fY1 = ((fBaseY + (fXMultY * fXNewY)) + (fYMultY * fYNewY)) + (fZMultY * fZNewY);
this.fZ1 = ((fBaseZ + (fXMultZ * fXNewZ)) + (fYMultZ * fYNewZ)) + (fZMultZ * fZNewZ);
this.fX0 = ((fBaseX + ((!fXMultX) * fXNewX)) + ((!fYMultX) * fYNewX)) + ((!fZMultX) * fZNewX);
this.fY0 = ((fBaseY + ((!fXMultY) * fXNewY)) + ((!fYMultY) * fYNewY)) + ((!fZMultY) * fZNewY);
this.fZ0 = ((fBaseZ + ((!fXMultZ) * fXNewZ)) + ((!fYMultZ) * fYNewZ)) + ((!fZMultZ) * fZNewZ);

};
Rect3d.prototype.isPointInRect = function(v3fPoint) {
return ((((((v3fPoint.x) >= (this.fX0)) && ((v3fPoint.y) >= (this.fY0))) && ((v3fPoint.z) >= (this.fZ0))) && ((v3fPoint.x) <= (this.fX1))) && ((v3fPoint.y) <= (this.fY1))) && ((v3fPoint.z) <= (this.fZ1));

};
Rect3d.prototype.createBoundingSphere = function() {
return new Sphere(((this.fX0) + (this.fX1)) * 0.5, ((this.fY0) + (this.fY1)) * 0.5, ((this.fZ0) + (this.fZ1)) * 0.5, ((((((this.fX1) - (this.fX0)) + (this.fY1)) - (this.fY0)) + (this.fZ1)) - (this.fZ0)) * 0.5);

};
Rect3d.prototype.toString = function() {
"use strict";
return (((((((((((("(" + (this.fX0.toFixed(3))) + ", ") + (this.fY0.toFixed(3))) + ", ") + (this.fZ0.toFixed(3))) + ") --> ") + "(") + (this.fX1.toFixed(3))) + ", ") + (this.fY1.toFixed(3))) + ", ") + (this.fZ1.toFixed(3))) + ")";

};
function Frustum() {
switch(arguments.length) {
case 1:
this.leftPlane = new a.Plane3d(arguments[0].leftPlane);
this.rightPlane = new a.Plane3d(arguments[0].rightPlane);
this.topPlane = new a.Plane3d(arguments[0].topPlane);
this.bottomPlane = new a.Plane3d(arguments[0].bottomPlane);
this.nearPlane = new a.Plane3d(arguments[0].nearPlane);
this.farPlane = new a.Plane3d(arguments[0].farPlane);
break ;

default:
this.leftPlane = new a.Plane3d();
this.rightPlane = new a.Plane3d();
this.topPlane = new a.Plane3d();
this.bottomPlane = new a.Plane3d();
this.nearPlane = new a.Plane3d();
this.farPlane = new a.Plane3d();
}

}

;
Frustum.prototype.eq = function(pSrc) {
this.leftPlane.eq(pSrc.leftPlane);
this.rightPlane.eq(pSrc.rightPlane);
this.topPlane.eq(pSrc.topPlane);
this.bottomPlane.eq(pSrc.bottomPlane);
this.nearPlane.eq(pSrc.nearPlane);
this.farPlane.eq(pSrc.farPlane);

};
Frustum.prototype.isEqual = function(pSrc) {
return (((((this.leftPlane.isEqual(pSrc.leftPlane)) && (this.rightPlane.isEqual(pSrc.rightPlane))) && (this.topPlane.isEqual(pSrc.topPlane))) && (this.bottomPlane.isEqual(pSrc.bottomPlane))) && (this.nearPlane.isEqual(pSrc.nearPlane))) && (this.farPlane.isEqual(pSrc.farPlane));

};
Frustum.prototype.extractFromMatrix = function(m4fMatrix, isNormalizePlanes) {
var pNormData;
var pMatData=m4fMatrix.pData;
pNormData = this.leftPlane.v3fNormal.pData;
pNormData[0] = (pMatData[3]) + (pMatData[0]);
pNormData[1] = (pMatData[7]) + (pMatData[4]);
pNormData[2] = (pMatData[11]) + (pMatData[8]);
this.leftPlane.fDistance = (pMatData[15]) + (pMatData[12]);
pNormData = this.rightPlane.v3fNormal.pData;
pNormData[0] = (pMatData[3]) - (pMatData[0]);
pNormData[1] = (pMatData[7]) - (pMatData[4]);
pNormData[2] = (pMatData[11]) - (pMatData[8]);
this.rightPlane.fDistance = (pMatData[15]) - (pMatData[12]);
pNormData = this.topPlane.v3fNormal.pData;
pNormData[0] = (pMatData[3]) - (pMatData[1]);
pNormData[1] = (pMatData[7]) - (pMatData[5]);
pNormData[2] = (pMatData[11]) - (pMatData[9]);
this.topPlane.fDistance = (pMatData[15]) - (pMatData[13]);
pNormData = this.bottomPlane.v3fNormal.pData;
pNormData[0] = (pMatData[3]) + (pMatData[1]);
pNormData[1] = (pMatData[7]) + (pMatData[5]);
pNormData[2] = (pMatData[11]) + (pMatData[9]);
this.bottomPlane.fDistance = (pMatData[15]) + (pMatData[13]);
pNormData = this.nearPlane.v3fNormal.pData;
pNormData[0] = pMatData[2];
pNormData[1] = pMatData[6];
pNormData[2] = pMatData[10];
this.nearPlane.fDistance = pMatData[14];
pNormData = this.farPlane.v3fNormal.pData;
pNormData[0] = (pMatData[3]) - (pMatData[2]);
pNormData[1] = (pMatData[7]) - (pMatData[6]);
pNormData[2] = (pMatData[11]) - (pMatData[10]);
this.farPlane.fDistance = (pMatData[15]) - (pMatData[14]);
if (isNormalizePlanes) {
this.leftPlane.normalize();
this.rightPlane.normalize();
this.topPlane.normalize();
this.bottomPlane.normalize();
this.nearPlane.normalize();
this.farPlane.normalize();

}


};
Frustum.prototype.extractPlane = function(pPlane, m4fMat, iRow) {
var iScale=(iRow < 0? -1 : 1);
iRow = (Math.abs(iRow)) - 1;
var pNormData=pPlane.v3fNormal.pData;
pNormData[0] = (m4fMat.pData[3]) + (iScale * (m4fMat.pData[iRow]));
pNormData[1] = (m4fMat.pData[7]) + (iScale * (m4fMat.pData[iRow + 4]));
pNormData[2] = (m4fMat.pData[11]) + (iScale * (m4fMat.pData[iRow + 8]));
pPlane.fDistance = (m4fMat.pData[15]) + (iScale * (m4fMat.pData[iRow + 12]));
var fLength=pPlane.v3fNormal.length();
pPlane.v3fNormal.scale(1 / fLength);
pPlane.fDistance /= fLength;

};
Frustum.prototype.extractFromMatrixGL = function(m4fMatrix, isNormalizePlanes) {
this.extractPlane(this.leftPlane, m4fMatrix, 1);
this.extractPlane(this.rightPlane, m4fMatrix, -1);
this.extractPlane(this.bottomPlane, m4fMatrix, 2);
this.extractPlane(this.topPlane, m4fMatrix, -2);
this.extractPlane(this.nearPlane, m4fMatrix, 3);
this.extractPlane(this.farPlane, m4fMatrix, -3);
if (isNormalizePlanes) {
this.leftPlane.normalize();
this.rightPlane.normalize();
this.topPlane.normalize();
this.bottomPlane.normalize();
this.nearPlane.normalize();
this.farPlane.normalize();

}


};
Frustum.prototype.testPoint = function(v3fPoint) {
if (((((((this.leftPlane.signedDistance(v3fPoint)) < 0) || ((this.rightPlane.signedDistance(v3fPoint)) < 0)) || ((this.topPlane.signedDistance(v3fPoint)) < 0)) || ((this.bottomPlane.signedDistance(v3fPoint)) < 0)) || ((this.nearPlane.signedDistance(v3fPoint)) < 0)) || ((this.farPlane.signedDistance(v3fPoint)) < 0)) {
return false;

}

return true;

};
Frustum.prototype.testRect = function(pRect) {
if (((((((planeClassify_Rect3d_Plane(pRect, this.leftPlane)) == (1)) || ((planeClassify_Rect3d_Plane(pRect, this.rightPlane)) == (1))) || ((planeClassify_Rect3d_Plane(pRect, this.topPlane)) == (1))) || ((planeClassify_Rect3d_Plane(pRect, this.bottomPlane)) == (1))) || ((planeClassify_Rect3d_Plane(pRect, this.nearPlane)) == (1))) || ((planeClassify_Rect3d_Plane(pRect, this.farPlane)) == (1))) {
return false;

}

return true;

};
Frustum.prototype.testSphere = function(pSphere) {
if (((((((planeClassify_Sphere_Plane(pSphere, this.leftPlane)) == (1)) || ((planeClassify_Sphere_Plane(pSphere, this.rightPlane)) == (1))) || ((planeClassify_Sphere_Plane(pSphere, this.topPlane)) == (1))) || ((planeClassify_Sphere_Plane(pSphere, this.bottomPlane)) == (1))) || ((planeClassify_Sphere_Plane(pSphere, this.nearPlane)) == (1))) || ((planeClassify_Sphere_Plane(pSphere, this.farPlane)) == (1))) {
return false;

}

return true;

};
function intersect_Plane3d_Ray3d(pPlane, pRay) {
var fResult;
var NdotV=pPlane.v3fnormal.dot(ray.v3fNormal);
if (NdotV != 0) {
fResult = (pPlane.v3fnormal.dot(ray.v3fPoint)) + (pPlane.fDistance);
fResult /= NdotV;
if (fResult >= 0) {
return fResult;

}


}

return -1;

}

;
function intersect_Plane2d_Ray2d(pPlane, pRay) {
var fResult;
var NdotV=pPlane.v2fnormal.dot(ray.v2fNormal);
if (NdotV != 0) {
fResult = (pPlane.v2fnormal.dot(ray.v2fPoint)) + (pPlane.fDistance);
fResult /= NdotV;
if (fResult >= 0) {
return fResult;

}


}

return -1;

}

;
function intersect_Sphere_Ray3d(pSphere, pRay) {
var vecQ=new Vec3();
vecQ.pData[0] = (pRay.v3fPoint.pData[0]) - (pSphere.v3fCenter.pData[0]);
vecQ.pData[1] = (pRay.v3fPoint.pData[1]) - (pSphere.v3fCenter.pData[1]);
vecQ.pData[2] = (pRay.v3fPoint.pData[2]) - (pSphere.v3fCenter.pData[2]);
var c=(vecQ.lengthSquare()) - ((pSphere.fRadius) * (pSphere.fRadius));
if (c < 0) {
return 0;

}

var b=vecQ.dot(pRay.v3fNormal);
if (b > 0) {
return -1;

}

var n=1;
var d=(b * b) - ((4 * n) * c);
if (d < 0) {
return -1;

}

var fResult=((-b) - (Math.sqrt(d))) / n;
if (fResult < 0) {
fResult = -1;

}

return fResult;

}

;
function intersect_Circle_Ray2d(pCircle, pRay) {
var vecQ=new Vec2();
vecQ.pData[0] = (pRay.v2fPoint.pData[0]) - (pCircle.v2fCenter.pData[0]);
vecQ.pData[1] = (pRay.v2fPoint.pData[1]) - (pCircle.v2fCenter.pData[1]);
var c=(vecQ.lengthSquare()) - ((pCircle.fRadius) * (pCircle.fRadius));
if (c < 0) {
return 0;

}

var b=vecQ.dot(pRay.v2fNormal);
if (b > 0) {
return -1;

}

var n=1;
var d=(b * b) - ((4 * n) * c);
if (d < 0) {
return -1;

}

var fResult=((-b) - (Math.sqrt(d))) / n;
if (fResult < 0) {
fResult = -1;

}

return fResult;

}

;
function intersect_Rect3d_Ray3d(pRect, pRay) {
if (((((((pRay.v3fpoint.pData[0]) >= (pRect.fX0)) && ((pRay.v3fpoint.pData[0]) <= (pRect.fX1))) && ((pRay.v3fpoint.pData[1]) >= (pRect.fY0))) && ((pRay.v3fpoint.pData[1]) <= (pRect.fY1))) && ((pRay.v3fpoint.pData[2]) >= (pRect.fZ0))) && ((pRay.v3fpoint.pData[2]) <= (pRect.fZ1))) {
return 0;

}

var maxT=Number.NEGATIVE_INFINITY;
var t=0;
if ((pRay.v3fnormal.pData[0]) > 0) {
t = ((pRect.fX0) - (pRay.v3fpoint.pData[0])) / (pRay.v3fnormal.pData[0]);
maxT = Math.max(maxT, t);

}
else if ((pRay.v3fnormal.pData[0]) < 0) {
t = ((pRect.fX1) - (pRay.v3fpoint.pData[0])) / (pRay.v3fnormal.pData[0]);
maxT = Math.max(maxT, t);

}


if ((pRay.v3fnormal.pData[1]) > 0) {
t = ((pRect.fY0) - (pRay.v3fpoint.pData[1])) / (pRay.v3fnormal.pData[1]);
maxT = Math.max(maxT, t);

}
else if ((pRay.v3fnormal.pData[1]) < 0) {
t = ((pRect.fY1) - (pRay.v3fpoint.pData[1])) / (pRay.v3fnormal.pData[1]);
maxT = Math.max(maxT, t);

}


if ((pRay.v3fnormal.pData[2]) > 0) {
t = ((pRect.fZ0) - (pRay.v3fpoint.pData[2])) / (pRay.v3fnormal.pData[2]);
maxT = Math.max(maxT, t);

}
else if ((pRay.v3fnormal.pData[2]) < 0) {
t = ((pRect.fZ1) - (pRay.v3fpoint.pData[2])) / (pRay.v3fnormal.pData[2]);
maxT = Math.max(maxT, t);

}


if (maxT < 0) {
maxT = -1;

}

return maxT;

}

;
function intersect_Rect2d_Ray2d(pRect, pRay) {
if (((((pRay.v3fpoint.pData[0]) >= (pRect.fX0)) && ((pRay.v3fpoint.pData[0]) <= (pRect.fX1))) && ((pRay.v3fpoint.pData[1]) >= (pRect.fY0))) && ((pRay.v3fpoint.pData[1]) <= (pRect.fY1))) {
return 0;

}

var maxT=Number.NEGATIVE_INFINITY;
var t=0;
if ((pRay.v3fnormal.pData[0]) > 0) {
t = ((pRect.fX0) - (pRay.v3fpoint.pData[0])) / (pRay.v3fnormal.pData[0]);
maxT = Math.max(maxT, t);

}
else if ((pRay.v3fnormal.pData[0]) < 0) {
t = ((pRect.fX1) - (pRay.v3fpoint.pData[0])) / (pRay.v3fnormal.pData[0]);
maxT = Math.max(maxT, t);

}


if ((pRay.v3fnormal.pData[1]) > 0) {
t = ((pRect.fY0) - (pRay.v3fpoint.pData[1])) / (pRay.v3fnormal.pData[1]);
maxT = Math.max(maxT, t);

}
else if ((pRay.v3fnormal.pData[1]) < 0) {
t = ((pRect.fY1) - (pRay.v3fpoint.pDataY)) / (pRay.v3fnormal.pData[1]);
maxT = Math.max(maxT, t);

}


if (maxT < 0) {
maxT = -1;

}

return maxT;

}

;
function intersect_Circle_Circle(pSphereA, pSphereB) {
var rx=(pSphereA.v2fCenter.pData[0]) - (pSphereB.v2fCenter.pData[0]);
var ry=(pSphereA.v2fCenter.pData[1]) - (pSphereB.v2fCente.pDatar[1]);
return ((rx * rx) + (ry * ry)) < ((pSphereA.fRadius) + (pSphereB.fRadius));

}

;
function intersect_Sphere_Sphere(pSphereA, pSphereB) {
var rx=(pSphereA.v3fCenter.pData[0]) - (pSphereB.v3fCenter.pData[0]);
var ry=(pSphereA.v3fCenter.pData[1]) - (pSphereB.v3fCenter.pData[1]);
var rz=(pSphereA.v3fCenter.pData[2]) - (pSphereB.v3fCenter.pData[2]);
return (((rx * rx) + (ry * ry)) + (rz * rz)) < ((pSphereA.fRadius) + (pSphereB.fRadius));

}

;
function intersect_Rect2d_Circle(pRect, pSphere) {
var offset=new Vec2();
var interior_count=0;
if ((pSphere.v2fCenter[0]) < (pRect.fX0)) {
offset.pData[0] = (pRect.fX0) - (pSphere.v2fCenter.pData[0]);

}
else if ((pSphere.v2fCenter.pData[0]) >= (pRect.fX1)) {
offset.pData[0] = (pSphere.v2fCenter.pData[0]) - (pRect.fX1);

}
else  {
++interior_count;

}


if ((pSphere.v2fCenter.pData[1]) < (pRect.fY0)) {
offset.pData[1] = (pRect.fY0) - (pSphere.v2fCenter.pData[1]);

}
else if ((pSphere.v2fCenter.pData[1]) >= (pRect.fY1)) {
offset.pData[1] = (pSphere.v2fCenter.pData[1]) - (pRect.fY1);

}
else  {
++interior_count;

}


if (interior_count == 2) {
return true;

}

var distance_squared=offset.lengthSquare();
var radius_squared=(pSphere.radius) * (pSphere.radius);
return distance_squared < radius_squared;

}

;
function intersect_Rect3d_Sphere(pRect, pSphere) {
var offset=new Vec3();
var interior_count=0;
if ((pSphere.v3fCenter[0]) < (pRect.fX0)) {
offset.pData[0] = (pRect.fX0) - (pSphere.v3fCenter.pData[0]);

}
else if ((pSphere.v3fCenter[0]) >= (pRect.fX1)) {
offset.pData[0] = (pSphere.v3fCenter.pData[0]) - (pRect.fX1);

}
else  {
++interior_count;

}


if ((pSphere.v3fCenter.pData[1]) < (pRect.fY0)) {
offset.pData[1] = (pRect.fY0) - (pSphere.v3fCenter.pData[1]);

}
else if ((pSphere.v3fCenter.pData[1]) >= (pRect.fY1)) {
offset.pData[1] = (pSphere.v3fCenter.pData[1]) - (pRect.fY1);

}
else  {
++interior_count;

}


if ((pSphere.v3fCenter.pData[2]) < (pRect.fZ0)) {
offset.pData[2] = (pRect.fZ0) - (pSphere.v3fCenter.pData[2]);

}
else if ((pSphere.v3fCenter.pData[2]) >= (pRect.fZ1)) {
offset.pData[2] = (pSphere.v3fCenter.pData[2]) - (pRect.fZ1);

}
else  {
++interior_count;

}


if (interior_count == 3) {
return true;

}

var distance_squared=offset.lengthSquare();
var radius_squared=(pSphere.radius) * (pSphere.radius);
return distance_squared < radius_squared;

}

;
function intersect_Rect2d_Rect2d(pRectA, pRectB, pResult) {
if (!pResult) {
var err=((((((("Error:: " + "a result address must be provided") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("a result address must be provided");

}


}

;
pResult.fX0 = Math.max(pRectA.fX0, pRectB.fX0);
pResult.fX1 = Math.min(pRectA.fX1, pRectB.fX1);
if ((pResult.fX0) < (pResult.fX1)) {
pResult.fY0 = Math.max(pRectA.fY0, pRectB.fY0);
pResult.fY1 = Math.min(pRectA.fY1, pRectB.fY1);
if ((pResult.fY0) < (pResult.fY1)) {
return true;

}


}

return false;

}

;
function intersect_Rect3d_Rect3d(pRectA, pRectB, pResult) {
if (!pResult) {
var err=((((((("Error:: " + "a result address must be provided") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("a result address must be provided");

}


}

;
pResult.fX0 = Math.max(pRectA.fX0, pRectB.fX0);
pResult.fX1 = Math.min(pRectA.fX1, pRectB.fX1);
if ((pResult.fX0) < (pResult.fX1)) {
pResult.fY0 = Math.max(pRectA.fY0, pRectB.fY0);
pResult.fY1 = Math.min(pRectA.fY1, pRectB.fY1);
if ((pResult.fY0) < (pResult.fY1)) {
pResult.fZ0 = Math.max(pRectA.fZ0, pRectB.fZ0);
pResult.fZ1 = Math.min(pRectA.fZ1, pRectB.fZ1);
if ((pResult.fZ0) < (pResult.fZ1)) {
return true;

}


}


}

return false;

}

;
function intersect() {
var arg1=arguments[0];
var arg2=arguments[1];
if ((arguments.length) == 3) {
var arg3=arguments[2];
if (arg3 instanceof Rect2d) {
return intersect_Rect2d_Rect2d(arg1, arg2, arg3);

}
else if (arg3 instanceof Rect3d) {
return intersect_Rect3d_Rect3d(arg1, arg2, arg3);

}



}
else if ((arguments.length) == 2) {
if (arg2 instanceof Ray3d) {
if (arg1 instanceof Plane3d) {
return intersect_Plane3d_Ray3d(arg1, arg2);

}
else if (arg1 instanceof Sphere) {
return intersect_Sphere_Ray3d(arg1, arg2);

}
else if (arg1 instanceof Rect3d) {
return intersect_Rect3d_Ray3d(arg1, arg2);

}




}
else if (arg2 instanceof Ray2d) {
if (arg1 instanceof Plane2d) {
return intersect_Plane2d_Ray2d(arg1, arg2);

}
else if (arg1 instanceof Circle) {
return intersect_Circle_Ray2d(arg1, arg2);

}
else if (arg1 instanceof Rect2d) {
return intersect_Rect2d_Ray2d(arg1, arg2);

}




}
else if ((arg1 instanceof Circle) && (arg2 instanceof Circle)) {
return intersect_Circle_Circle(arg1, arg2);

}
else if ((arg1 instanceof Sphere) && (arg2 instanceof Sphere)) {
return intersect_Sphere_Sphere(arg1, arg2);

}
else if ((arg1 instanceof Rect2d) && (arg2 instanceof Circle)) {
return intersect_Rect2d_Circle(arg1, arg2);

}
else if ((arg1 instanceof Rect3d) && (arg2 instanceof Sphere)) {
return intersect_Rect3d_Sphere(arg1, arg2);

}







}
else  {
if (!false) {
var err=((((((("Error:: " + "Incorrect number of arguments") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/math/Geometry.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Incorrect number of arguments");

}


}

;

}



}

;
function planeClassify_Circle_Plane(pCircle, pPlane) {
var d=pPlane.signedDistance(pCircle.v2fCenter);
if ((Math.abs(d)) < (pCircle.fRadius)) {
return 2;

}
else if (d) {
return 0;

}


return 1;

}

;
function planeClassify_Sphere_Plane(pSphere, pPlane) {
var d=pPlane.signedDistance(pCircle.v3fCenter);
if ((Math.abs(d)) < (pCircle.fRadius)) {
return 2;

}
else if (d) {
return 0;

}


return 1;

}

;
function planeClassify_Rect2d_Plane(pRect, pPlane) {
var minPoint=new Vec2();
var maxPoint=new Vec2();
if ((pPlane.v2fNormal.pData[0]) > 0) {
minPoint.pData[0] = pRect.fX0;
maxPoint.pData[0] = pRect.fX1;

}
else  {
minPoint.pData[0] = pRect.fX1;
maxPoint.pData[0] = pRect.fX0;

}

if ((pPlane.v2fNormal.pData[1]) > 0) {
minPoint.pData[1] = pRect.fY0;
maxPoint.pData[1] = pRect.fY1;

}
else  {
minPoint.pData[1] = pRect.fY1;
maxPoint.pData[1] = pRect.fY0;

}

var dmin=pPlane.signedDistance(minPoint);
var dmax=pPlane.signedDistance(maxPoint);
if ((dmin * dmax) < 0) {
return 2;

}
else if (dmin) {
return 0;

}


return 1;

}

;
function planeClassify_Rect3d_Plane(pRect, pPlane) {
var minPoint=Vec3();
var maxPoint=Vec3();
var pNormData=pPlane.v3fNormal.pData;
if ((pNormData[0]) > 0) {
minPoint.pData[0] = pRect.fX0;
maxPoint.pData[0] = pRect.fX1;

}
else  {
minPoint.pData[0] = pRect.fX1;
maxPoint.pData[0] = pRect.fX0;

}

if ((pNormData[1]) > 0) {
minPoint.pData[1] = pRect.fY0;
maxPoint.pData[1] = pRect.fY1;

}
else  {
minPoint.pData[1] = pRect.fY1;
maxPoint.pData[1] = pRect.fY0;

}

if ((pNormData[2]) > 0) {
minPoint.pData[2] = pRect.fZ0;
maxPoint.pData[2] = pRect.fZ1;

}
else  {
minPoint.pData[2] = pRect.fZ1;
maxPoint.pData[2] = pRect.fZ0;

}

var dmin=pPlane.signedDistance(minPoint);
var dmax=pPlane.signedDistance(maxPoint);
if ((dmin * dmax) < 0) {
return 2;

}
else if (dmin < 0) {
return 0;

}


return 1;

}

;
function planeClassify(value, plane) {
if (plane instanceof Plane2d) {
if (value instanceof Circle) {
return planeClassify_Circle_Plane(value, plane);

}
else if (value instanceof Rect2d) {
return planeClassify_Rect2d_Plane(value, plane);

}



}
else if (plane instanceof Plane3d) {
if (value instanceof Sphere) {
return planeClassify_Sphere_Rect(value, plane);

}
else if (value instanceof Rect3d) {
return planeClassify_Rect3d_Plane(value, plane);

}



}



}

;
function intersectRect2d(pRectA, pRectB, pResult) {
pResult.fX0 = Math.max(pRectA.fX0, pRectB.fX0);
pResult.fY0 = Math.max(pRectA.fY0, pRectB.fY0);
pResult.fX1 = Math.min(pRectA.fX1, pRectB.fX1);
pResult.fY1 = Math.min(pRectA.fY1, pRectB.fY1);
return ((pResult.fX0) <= (pResult.fX1)) && ((pResult.fY0) <= (pResult.fY1));

}

;
function intersectRect3d(pRectA, pRectB, pResult) {
pResult.fX0 = Math.max(pRectA.fX0, pRectB.fX0);
pResult.fX1 = Math.min(pRectA.fX1, pRectB.fX1);
pResult.fY0 = Math.max(pRectA.fY0, pRectB.fY0);
pResult.fY1 = Math.min(pRectA.fY1, pRectB.fY1);
pResult.fZ0 = Math.max(pRectA.fZ0, pRectB.fZ0);
pResult.fZ1 = Math.min(pRectA.fZ1, pRectB.fZ1);
return (((pResult.fX0) <= (pResult.fX1)) && ((pResult.fY0) <= (pResult.fY1))) && ((pResult.fZ0) <= (pResult.fZ1));

}

;
function classifyRect2d(pRectA, pRectB, pResult) {
if (pRectA.isEqual(pRectB)) {
return 1;

}

if (intersectRect2d(pRectA, pRectB, pResult)) {
if (pRectB.isEqual(pResult)) {
return 2;

}

if (pRectA.isEqual(pResult)) {
return 3;

}

return 4;

}

return 0;

}

;
function classifyRect3d(pRectA, pRectB, pResult) {
if (pRectA.isEqual(pRectB)) {
return 1;

}

if (intersectRect3d(pRectA, pRectB, pResult)) {
if (pRectB.isEqual(pResult)) {
return 2;

}

if (pRectA.isEqual(pResult)) {
return 3;

}

return 4;

}

return 0;

}

a.Ray2d = Ray2d;
a.Ray2d = Ray2d;
a.Segment2d = Segment2d;
a.Segment3d = Segment3d;
a.Circle = Circle;
a.Sphere = Sphere;
a.Plane2d = Plane2d;
a.Plane3d = Plane3d;
a.Rect2d = Rect2d;
a.Rect3d = Rect3d;
a.Frustum = Frustum;
a.intersect = intersect;
a.planeClassify = planeClassify;
a.intersectRect3d = intersectRect3d;
a.classifyRect3d = classifyRect3d;
a.intersectRect2d = intersectRect2d;
a.classifyRect2d = classifyRect2d;
function PerlinNoise() {
;
this.m_pv2fTable = new Array(256);
this.m_piLut = new Uint8Array(256);
this.setup();

}

;
PerlinNoise.prototype.setup = function() {
var fStep=((Math.PI) * 2) / (256);
var fVal=0;
for (var i=0; i < (256); ++i) {
this.m_pv2fTable[i] = Vec2.create();
this.m_pv2fTable[i][0] = Math.sin(fVal);
this.m_pv2fTable[i][1] = Math.cos(fVal);
fVal += fStep;
this.m_piLut[i] = (Math.random()) * (255);

}


};
PerlinNoise.prototype.getVec = function(iX, iY) {
var iA=this.m_piLut[iX & (255)];
var iB=this.m_piLut[iY & (255)];
var iVal=this.m_piLut[(iA + iB) & (255)];
return this.m_pv2fTable[iVal];

};
PerlinNoise.prototype.noise = function(fX, fY, fScale) {
var v2fPos=Vec2.create();
Vec2.set(fX * fScale, fY * fScale, v2fPos);
var fX0=Math.floor(v2fPos[0]);
var fX1=fX0 + 1;
var fY0=Math.floor(v2fPos[1]);
var fY1=fY0 + 1;
var v0=this.getVec(fX0, fY0);
var v1=this.getVec(fX0, fY1);
var v2=this.getVec(fX1, fY0);
var v3=this.getVec(fX1, fY1);
var d0=Vec2.create();
Vec2.set((v2fPos[0]) - fX0, (v2fPos[1]) - fY0, d0);
var d1=Vec2.create();
Vec2.set((v2fPos[0]) - fX0, (v2fPos[1]) - fY1, d1);
var d2=Vec2.create();
Vec2.set((v2fPos[0]) - fX1, (v2fPos[1]) - fY0, d2);
var d3=Vec2.create();
Vec2.set((v2fPos[0]) - fX1, (v2fPos[1]) - fY1, d3);
var fH0=((d0[0]) * (v0[0])) + ((d0[1]) * (v0[1]));
var fH1=((d1[0]) * (v1[0])) + ((d1[1]) * (v1[1]));
var fH2=((d2[0]) * (v2[0])) + ((d2[1]) * (v2[1]));
var fH3=((d3[0]) * (v3[0])) + ((d3[1]) * (v3[1]));
var fSx, fSy;
fSx = ((6 * (Math.pow(d0[0], 5))) - (15 * (Math.pow(d0[0], 4)))) + (10 * (Math.pow(d0[0], 3)));
fSy = ((6 * (Math.pow(d0[1], 5))) - (15 * (Math.pow(d0[1], 4)))) + (10 * (Math.pow(d0[1], 3)));
var fAvgX0=fH0 + (fSx * (fH2 - fH0));
var fAvgX1=fH1 + (fSx * (fH3 - fH1));
var fResult=fAvgX0 + (fSy * (fAvgX1 - fAvgX0));
return fResult;

};
a.PerlinNoise = PerlinNoise;
if (!(a["NET"]))a["NET"] =  {};

;
var WEBSOCKET_PORT=1337;
if (!a) {
var a= {};

}

if (!(a.NET)) {
a.NET =  {};

}

if (!error) {
var error=function(e) {
throw new Error(e);

};

}

if (!trace) {
var trace=function() {

};

}

var PIPE_TYPE_WEBSOCKET=0;
var PIPE_TYPE_WEBWORKER=1;
window.WebSocket = (window.WebSocket) || (window.MozWebSocket);
function Pipe(sAddr, fnCallback) {
this._pAddr = null;
this._fnMessage = null;
this._nMesg = 0;
this._eType = 0;
if (arguments.length) {
this.open(sAddr, fnCallback);

}


}

Pipe.prototype.open = function(sAddr, fnCallback) {
"use strict";
fnCallback = fnCallback || null;
var pAddr, pConnect, me=this, eType;
if ((arguments.length) > 0) {
pAddr = new URI(sAddr);
pConnect = null;

}
else  {
if (this.isCreated()) {
this.close();

}

pAddr = this._pAddr;
pConnect = null;

}

if ((pAddr.protocol) === "ws") {
if (!(pAddr.port)) {
pAddr.port = WEBSOCKET_PORT;

}

if (!WebSocket) {
if (!0) {
var err=((((((("Error:: " + "You browser does not support webSocket api.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/network/Pipe.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You browser does not support webSocket api.");

}


}

;
return false;

}

pConnect = new WebSocket(pAddr.toString());
pConnect.onopen = fnCallback || (function() {
trace("created pipe to: " + (pAddr.toString()));

}
);
pConnect.onerror = function(pErr) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/network/Pipe.js") + "][") + "") + "]") + "pipe error...");
trace(pErr);

};
pConnect.binaryType = "arraybuffer";
eType = PIPE_TYPE_WEBSOCKET;

}
else if ((a.pathinfo(pAddr.path).ext) === "js") {
if (!Worker) {
if (!0) {
var err=((((((("Error:: " + "You browser does not support webWorker api.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/network/Pipe.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You browser does not support webWorker api.");

}


}

;
return false;

}

pConnect = new Worker(pAddr.toString());
eType = PIPE_TYPE_WEBWORKER;

}
else  {
if (!0) {
var err=((((((("Error:: " + "Pipe supported only websockets/webworkers.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/network/Pipe.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Pipe supported only websockets/webworkers.");

}


}

;
return false;

}


this._pConnect = pConnect;
this._pAddr = pAddr;
this._eType = eType;
if (!self) {
window.onunload = function() {
me.close();

};

}

return this;

};
Pipe.prototype.on = function(eState, fnCallback) {
"use strict";
switch(eState) {
case "open":
;

case "error":
;

case "close":
this._pConnect["on" + eState] = fnCallback;
return true;

case "msg":
;

case "message":
this._pConnect.onmessage = function(pMessage) {
if ((pMessage.data) instanceof ArrayBuffer) {
fnCallback(pMessage.data, "binary");

}
else  {
fnCallback(pMessage.data, "string");

}


};
return true;
}
return false;

};
Pipe.prototype.isOpened = function() {
"use strict";
switch(this._eType) {
case PIPE_TYPE_WEBSOCKET:
return (this._pConnect.readyState) === 1;

case PIPE_TYPE_WEBWORKER:
return (this._pConnect) !== null;
}
return false;

};
Pipe.prototype.isCreated = function() {
"use strict";
return (this._pConnect) !== null;

};
Pipe.prototype.isClosed = function() {
"use strict";
switch(this._eType) {
case PIPE_TYPE_WEBSOCKET:
return (this._pConnect.readyState) === 3;

case PIPE_TYPE_WEBWORKER:
return (this._pConnect) == null;
}
return false;

};
Pipe.prototype.close = function() {
"use strict";
if (this.isOpened()) {
switch(this._eType) {
case PIPE_TYPE_WEBSOCKET:
this._pConnect.onmessage = null;
this._pConnect.onerror = null;
this._pConnect.onopen = null;
this._pConnect.close();
break ;

case PIPE_TYPE_WEBWORKER:
this._pConnect.terminate();
this._pConnect = null;
}

}


};
Pipe.prototype.send = function(pValue) {
"use strict";
if (this.isOpened()) {
this._nMesg++;
switch(this._eType) {
case PIPE_TYPE_WEBSOCKET:
if ((typeof pValue) === "object") {
pValue = JSON.stringify(pValue);

}

return this._pConnect.send(pValue);

case PIPE_TYPE_WEBWORKER:
if (pValue.byteLength) {
this._pConnect.postMessage(pValue, [pValue]);

}
else  {
this._pConnect.postMessage(pValue);

}

return true;
}

}

return false;

};
Pipe.prototype.write = Pipe.prototype.send;
a.NET.Pipe = Pipe;
if (!a) {
var a= {NET:  {}};

}

if (!error) {
var error=console.error.bind(console);

}

var RPC_TYPE_FAILURE=0;
var RPC_TYPE_CALL=1;
var RPC_TYPE_RESPONSE=2;
function RPC(pUri, pContext, fnCallback) {
this.pPipe = null;
this.pContext = (pContext || self) || window;
this.pOptions =  {defferedCallsLimit: 1024, callbacksLimit: 2048};
this._pDefferedCalls = [];
this._pCallbacks = [];
this._nCalls = 0;
this._iReconnect = -1;
if ((arguments.length) > 0) {
this.connect(pUri, fnCallback);

}


}

RPC.prototype.connect = function(pUri, fnCallback) {
var pPipe=this.pPipe;
var me=this;
if (!pPipe) {
pPipe = new a.NET.Pipe(pUri);

}
else  {
pPipe.open();

}

pPipe.on("msg", function(pMessage, sType) {
if (sType !== "binary") {
me.parse(JSON.parse(pMessage));

}
else  {
pMessage = new Uint8Array(pMessage);
me.parseBinary(pMessage);

}


}
);
pPipe.on("open", function() {
var pDeffered=me._pDefferedCalls;
if (pDeffered.length) {
for (var i=0; i < (pDeffered.length); ++i) {
pPipe.send(pDeffered[i]);

}

me._pDefferedCalls = [];

}

me.proc("proc_list", function(pList) {
if (pList && (pList instanceof Array)) {
for (var i=0; i < (pList.length); ++i) {
(function(sMethod) {
me[sMethod] = function() {
var argv=[sMethod];
for (var j=0; j < (arguments.length); ++j) {
argv.push(arguments[j]);

}

return me.proc.apply(me, argv);

};

}
)(String(pList[i]));

}


}

if (fnCallback) {
fnCallback.call(me);

}


}
);

}
);
pPipe.on("error", function() {
me.reconnect();

}
);
this.pPipe = pPipe;

};
RPC.prototype.reconnect = function() {
"use strict";
var me=this;
clearTimeout(this._iReconnect);
if (this.pPipe.isOpened()) {
return true;

}

if (this.pPipe.isClosed()) {
trace("attempt to reconnecting...");

}

this.connect();
this._iReconnect = setTimeout(function() {
me.reconnect();

}
, 5000);

};
RPC.prototype.parse = function(pObject) {
var pRes=pObject;
var pStack=this._pCallbacks;
if ((pRes.n) === undefined) {
trace(pObject);
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/network/RPC.js") + "][") + "") + "]") + "message droped, because serial not recognized...");
return ;

}

return this.response(pRes.n, pRes.type, pRes.res);

};
RPC.prototype.parseBinary = function(pBuffer) {
var pRes=pBuffer;
var nMsg=new Uint32Array(pBuffer.subarray(0, 4).buffer, 0, 4)[0];
var eType=pBuffer[4];
var pResult=pBuffer.buffer.slice(8, pBuffer.length);
return this.response(nMsg, eType, pResult);

};
RPC.prototype.response = function(nSerial, eType, pResult) {
"use strict";
var pStack=this._pCallbacks;
if (eType === RPC_TYPE_RESPONSE) {
for (var i=(pStack.length) - 1; i >= 0; i--) {
if ((pStack[i].n) === nSerial) {
pStack[i].fn.call(this, pResult);
pStack.splice(i, 1);
return ;

}


}

;

}
else if (eType === RPC_TYPE_FAILURE) {
if (!0) {
var err=((((((("Error:: " + (("detected FAILURE on " + nSerial) + "package.")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/network/RPC.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("detected FAILURE on " + nSerial) + "package."));

}


}

;

}
else  {
if (!0) {
var err=((((((("Error:: " + ("unsupported response type detected: " + eType)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/network/RPC.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("unsupported response type detected: " + eType));

}


}

;

}



};
RPC.prototype.free = function() {
"use strict";
this._pDefferedCalls = [];
this._pCallbacks = [];

};
RPC.prototype.proc = function() {
"use strict";
var iCallback=(arguments.length) - 1;
var fnCallback=((typeof (arguments[iCallback])) === "function"? arguments[iCallback] : null);
var pArgv=new Array((arguments.length) - ((fnCallback? 2 : 1)));
var pPipe=this.pPipe;
for (var i=0; i < (pArgv.length); ++i) {
pArgv[i] = arguments[i + 1];

}

;
var pProc= {type: RPC_TYPE_CALL, proc: String(arguments[0]), argv: pArgv, n: this._nCalls++};
if (fnCallback) {
this._pCallbacks.push( {n: pProc.n, fn: fnCallback});

}

if ((!pPipe) || (!(pPipe.isOpened()))) {
this._pDefferedCalls.push(pProc);
return false;

}

return this.pPipe.send(pProc);

};
a.NET.RPC = RPC;
a["NET"]["Pipe"] = Pipe;
function pipe() {
var pUri=a.uri(arguments[0]);
var fnCallback=arguments[1];
var pPipe=new a.NET.Pipe();
return (pPipe.open(pUri, fnCallback)) || null;

}

a["NET"]["pipe"] = pipe;
a.get = function(sUrl, pData, fnSuccess, eDataType) {
return a.ajax( {url: sUrl, data: pData, success: fnSuccess, dataType: eDataType});

};
a.require = function(sUrl) {
eval(a.ajax( {url: sUrl, async: false}).data);

};
a.queryString = function(pObj, sPrefix) {
if ((typeof pObj) == "string") {
return pObj;

}

var str=[];
for (var p in pObj) {
var k=(sPrefix? ((sPrefix + "[") + p) + "]" : p), v=pObj[p];
str.push(((typeof v) == "object"? a.queryString(v, k) : ((encodeURIComponent(k)) + "=") + (encodeURIComponent(v))));

}

return str.join("&");

};
a.ajax = function(pSettings, pRequest) {
var sUrl=(pSettings.url === undefined? "" : pSettings.url);
var isAsync=(pSettings.async === undefined? true : pSettings.async);
var pStatusCode=(pSettings.statusCode === undefined?  {} : pSettings.statusCode);
var fnSuccess=(pSettings.success === undefined? null : pSettings.success);
var fnError=(pSettings.error === undefined? null : pSettings.error);
var fnBeforeSend=(pSettings.beforeSend === undefined? null : pSettings.beforeSend);
var pData=(pSettings.data === undefined?  {} : pSettings.data), sQueryString;
var useCache=(pSettings.cache === undefined? false : pSettings.cache);
var sContentType=(pSettings.contentType === undefined? "application/x-www-form-urlencoded" : pSettings.contentType);
var eDataType=(pSettings.dataType === undefined? 0 : pSettings.dataType);
var eMethod=(pSettings.type === undefined? 1 : pSettings.type);
var nTimeout=(pSettings.timeout === undefined? 0 : pSettings.timeout);
var iTimeoutId=null;
var isAborted=false;
if ((typeof eMethod) == "string") {
eMethod = eMethod.toLowerCase();
if (eMethod == "get") {
eMethod = 1;

}
else if (eMethod == "post") {
eMethod = 2;

}



}

if ((typeof eDataType) == "string") {
eDataType = eDataType.toLowerCase();
switch(eDataType) {
case "json":
eDataType = 1;
break ;

case "blob":
eDataType = 2;
break ;

case "html":
;

case "document":
eDataType = 4;
break ;

case "array_buffer":
;

case "arraybuffer":
eDataType = 3;
break ;

default:
eDataType = 0;
}

}

var fnInitRequest=function() {
if (window.XMLHttpRequest) {
return new XMLHttpRequest();

}
else if (window.ActiveXObject) {
return new ActiveXObject("Microsoft.XMLHTTP");

}


return null;

};
var fnConvData=function(pReq) {
switch(eDataType) {
case 0:
return window.String(pReq.responseText);

case 1:
return a.parseJSON(pReq.responseText);

case 2:
return (isAsync? pReq.response : new BlobBuilder().append(pReq.responseText));

case 3:
return (isAsync? pReq.response : pReq.responseText);

case 4:
return (isAsync? pReq.response : a.toDOM(pReq.responseText));
}

};
var fnProcRequest=function() {
if (isAborted) {
return ;

}

if ((pRequest.readyState) == (this.HEADERS_RECEIVED)) {
if (nTimeout > 0) {
clearTimeout(iTimeoutId);

}


}

if ((pRequest.readyState) == (this.DONE)) {
var iStatusCode=pRequest.status;
var fnStatusHandler=pStatusCode[iStatusCode];
if (fnStatusHandler) {
fnStatusHandler();

}

fnBeforeResult();
if (iStatusCode == (200)) {
if (fnSuccess) {
fnSuccess(fnConvData(pRequest), pRequest.textStatus, pRequest);

}


}
else if (!fnStatusHandler) {
fnCauseError(pRequest, new Error("Request is not completed " + "successfully"));

}



}


};
var fnCauseError=function(pReq, pErr) {
if (!fnError) {
throw pErr;

}
else  {
fnError(pReq, (pReq? pReq.textStatus : null), pErr);

}


};
var fnResponseType=function(eDataType) {
switch(eDataType) {
case 2:
return "blob";

case 3:
return "arraybuffer";

case 4:
return "document";

case 0:
return "text";
}
return "";

};
var fnBeforeResult=function() {
if (iTimeoutId !== null) {
clearTimeout(iTimeoutId);

}


};
pRequest = pRequest || (fnInitRequest());
pRequest.onreadystatechange = fnProcRequest;
if (!pRequest) {
fnCauseError(null, new Error("Invalid request object."));

}

if (nTimeout > 0) {
iTimeoutId = setTimeout(function() {
isAborted = true;
pRequest.abort();
fnCauseError(pRequest, new Error("Timeout is over."));

}
, nTimeout);

}

if (fnBeforeSend) {
if (!(fnBeforeSend(pRequest, pSettings))) {
return null;

}


}

if (!useCache) {
pData["TIMESTAMP"] = new Date().getTime();

}

sQueryString = a.queryString(pData);
if (isAborted) {
return null;

}

if (isAsync) {
try {
(eMethod == (1)? function() {
pRequest.open("GET", sUrl + ((sQueryString.length? "?" + sQueryString : "")), true);
pRequest.responseType = fnResponseType(eDataType);
pRequest.send(null);

}
 : function() {
pRequest.open("POST", sUrl, true);
pRequest.setRequestHeader("Content-Type", sContentType);
pRequest.responseType = fnResponseType(eDataType);
pRequest.send(sQueryString);

}
)();

}
catch(e) {
fnCauseError(pRequest, e);

}

}
else  {
return (eMethod == (1)? function() {
pRequest.open("GET", (sUrl + "?") + sQueryString, false);
pRequest.send(null);
fnBeforeResult();
return  {data: fnConvData(pRequest), textStatus: pRequest.textStatus, xhr: pRequest};

}
 : function() {
pRequest.open("POST", sUrl, false);
pRequest.setRequestHeader("Content-type", sContentType);
pRequest.send(sQueryString);
fnBeforeResult();
return  {data: fnConvData(pRequest), textStatus: pRequest.textStatus, xhr: pRequest};

}
)();

}

return null;

};
function BinTemplate(pData) {
this._pData =  {};
this._nTypes = 0;
this._pNum2Tpl =  {};
this._pTpl2Num =  {};
if (pData) {
this.set(pData);

}


}

BinTemplate.prototype.getType = function(iType) {
"use strict";
if (!((this._pNum2Tpl[iType]) !== undefined)) {
var err=((((((("Error:: " + ("unknown type detected: " + iType)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinTemplate.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("unknown type detected: " + iType));

}


}

;
return this._pNum2Tpl[iType];

};
BinTemplate.prototype.getTypeId = function(sType) {
"use strict";
if (!((this._pTpl2Num[sType]) !== undefined)) {
var err=((((((("Error:: " + ("unknown type detected: " + sType)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinTemplate.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("unknown type detected: " + sType));

}


}

;
return this._pTpl2Num[sType];

};
BinTemplate.prototype.set = function(pTemplate) {
var iType;
for (var i in pTemplate) {
this._pData[i] = pTemplate[i];
iType = this._nTypes++;
this._pNum2Tpl[iType] = i;
this._pTpl2Num[i] = iType;

}


};
BinTemplate.prototype.detectType = function(pObject) {
"use strict";
return a.getClass(pObject);

};
BinTemplate.prototype.properties = function(sType) {
"use strict";
var pProperties=this._pData[sType];
if ((typeof pProperties) === "string") {
return this.properties(this.resolveType(sType));

}

return pProperties;

};
BinTemplate.prototype.resolveType = function(sType) {
"use strict";
var pTemplates=this._pData;
var pProperties=pTemplates[sType];
while ((typeof pProperties) === "string") {
sType = pProperties;
pProperties = pTemplates[sType];

}
if (!((typeof pProperties) !== "string")) {
var err=((((((("Error:: " + ("cannot resolve type: " + sType)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinTemplate.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("cannot resolve type: " + sType));

}


}

;
return sType;

};
BinTemplate.prototype.data = function() {
"use strict";
return this._pData;

};
a["BinTemplate"] = BinTemplate;
a.binaryTemplate = new a.BinTemplate();
function BinReaderBase(pBuffer, pOptions) {
var iByteOffset=(pOptions && (pOptions.byteOffset)? pOptions.byteOffset : 0);
var iByteLength=(pOptions && (pOptions.byteLength)? pOptions.byteLength : pBuffer.byteLength);
this._pDataView = new DataView(pBuffer, iByteOffset, iByteLength);
this.iPosition = 0;

}

BinReaderBase.prototype.string = function(str) {
var iStringLength=this.uint32();
if (iStringLength == 2147483647) {
return (str? str : null);

}

var iBitesToAdd=((4 - (iStringLength % 4)) == 4? 0 : 4 - (iStringLength % 4));
iStringLength += iBitesToAdd;
if (!((((this.iPosition) + iStringLength) - 1) < this._pDataView.byteLength)) {
var err=((((((("Error:: " + "Выход за пределы массива") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinReader.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Выход за пределы массива");

}


}

;
var pBuffer=new Uint8Array(iStringLength);
for (var i=0; i < iStringLength; i++) {
pBuffer[i] = this._pDataView.getUint8((this.iPosition) + i, true);

}

this.iPosition += iStringLength;
var sString="", charCode, code;
for (var n=0; n < (pBuffer.length); ++n) {
code = pBuffer[n];
if (code == 0) {
break ;

}

charCode = String.fromCharCode(code);
sString = sString + charCode;

}

sString = sString.fromUTF8();
return sString;

};
BinReaderBase.prototype.uint32 = function() {
var i=this._pDataView.getUint32(this.iPosition, true);
this.iPosition += 4;
return i;

};
BinReaderBase.prototype.uint16 = function() {
var i=this._pDataView.getUint16(this.iPosition, true);
this.iPosition += 4;
return i;

};
BinReaderBase.prototype.uint8 = function() {
var i=this._pDataView.getUint8(this.iPosition, true);
this.iPosition += 4;
return i;

};
BinReaderBase.prototype.bool = function() {
return (this.uint8()? true : false);

};
BinReaderBase.prototype.int32 = function() {
var i=this._pDataView.getInt32(this.iPosition, true);
this.iPosition += 4;
return i;

};
BinReaderBase.prototype.int16 = function() {
var i=this._pDataView.getInt16(this.iPosition, true);
this.iPosition += 4;
return i;

};
BinReaderBase.prototype.int8 = function() {
var i=this._pDataView.getInt8(this.iPosition, true);
this.iPosition += 4;
return i;

};
BinReaderBase.prototype.float32 = function() {
var f=this._pDataView.getFloat32(this.iPosition, true);
this.iPosition += 4;
return f;

};
BinReaderBase.prototype.float64 = function() {
var f=this._pDataView.getFloat64(this.iPosition, true);
this.iPosition += 8;
return f;

};
BinReaderBase.prototype.stringArray = function() {
var iLength=this.uint32();
if (iLength == 2147483647) {
return null;

}

var pArray=new Array(iLength);
for (var i=0; i < iLength; i++) {
pArray[i] = this.string();

}

return pArray;

};
BinReaderBase.prototype._uintXArray = function(iX) {
var iLength=this.uint32();
if (iLength == 2147483647) {
return null;

}

var iBytes=iX / 8;
var pArray;
switch(iBytes) {
case 1:
pArray = new Uint8Array(iLength);
for (var i=0; i < iLength; i++) {
pArray[i] = this._pDataView.getUint8((this.iPosition) + (i * iBytes), true);

}

break ;

case 2:
pArray = new Uint16Array(iLength);
for (var i=0; i < iLength; i++) {
pArray[i] = this._pDataView.getUint16((this.iPosition) + (i * iBytes), true);

}

break ;

case 4:
pArray = new Uint32Array(iLength);
for (var i=0; i < iLength; i++) {
pArray[i] = this._pDataView.getUint32((this.iPosition) + (i * iBytes), true);

}

break ;

default:
if (!0) {
var err=((((((("Error:: " + ("unsupported array length detected: " + iBytes)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinReader.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("unsupported array length detected: " + iBytes));

}


}

;
}
var iByteLength=iBytes * iLength;
iByteLength += (-iByteLength) & 3;
this.iPosition += iByteLength;
return pArray;

};
BinReaderBase.prototype.uint8Array = function() {
return this._uintXArray(8);

};
BinReaderBase.prototype.uint16Array = function() {
return this._uintXArray(16);

};
BinReaderBase.prototype.uint32Array = function() {
return this._uintXArray(32);

};
BinReaderBase.prototype._intXArray = function(iX) {
var iLength=this.uint32();
if (iLength == 2147483647) {
return null;

}

var iBytes=iX / 8;
var pArray;
switch(iBytes) {
case 1:
pArray = new Int8Array(iLength);
for (var i=0; i < iLength; i++) {
pArray[i] = this._pDataView.getInt8((this.iPosition) + (i * iBytes), true);

}

break ;

case 2:
pArray = new Int16Array(iLength);
for (var i=0; i < iLength; i++) {
pArray[i] = this._pDataView.getInt16((this.iPosition) + (i * iBytes), true);

}

break ;

case 4:
pArray = new Int32Array(iLength);
for (var i=0; i < iLength; i++) {
pArray[i] = this._pDataView.getInt32((this.iPosition) + (i * iBytes), true);

}

break ;

default:
if (!0) {
var err=((((((("Error:: " + ("unsupported array length detected: " + iBytes)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinReader.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("unsupported array length detected: " + iBytes));

}


}

;
}
var iByteLength=iBytes * iLength;
iByteLength += (-iByteLength) & 3;
this.iPosition += iByteLength;
return pArray;

};
BinReaderBase.prototype.int8Array = function() {
return this._intXArray(8);

};
BinReaderBase.prototype.int16Array = function() {
return this._intXArray(16);

};
BinReaderBase.prototype.int32Array = function() {
return this._intXArray(32);

};
BinReaderBase.prototype._floatXArray = function(iX) {
var iLength=this.uint32();
if (iLength == 2147483647) {
return null;

}

var iBytes=iX / 8;
var pArray;
switch(iBytes) {
case 4:
pArray = new Float32Array(iLength);
for (var i=0; i < iLength; i++) {
pArray[i] = this._pDataView.getFloat32((this.iPosition) + (i * iBytes), true);

}

break ;

case 8:
pArray = new Float64Array(iLength);
for (var i=0; i < iLength; i++) {
pArray[i] = this._pDataView.getFloat64((this.iPosition) + (i * iBytes), true);

}

break ;

default:
if (!0) {
var err=((((((("Error:: " + ("unsupported array length detected: " + iBytes)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinReader.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("unsupported array length detected: " + iBytes));

}


}

;
}
var iByteLength=iBytes * iLength;
iByteLength += (-iByteLength) & 3;
this.iPosition += iByteLength;
return pArray;

};
BinReaderBase.prototype.float32Array = function() {
return this._floatXArray(32);

};
BinReaderBase.prototype.float64Array = function() {
return this._floatXArray(64);

};
function BinReader(pBuffer, pOptions) {
var _pCtorValue=BinReader.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pHashTable = null;
this._pTemplate = a.binaryTemplate;
this._pPositions = [];
this._pOptions = null;
if (pOptions) {
this.setOptions(pOptions);

}


}

a.extend(BinReader, BinReaderBase);
a.defineProperty(BinReader, "template", function() {
return this._pTemplate;

}
, function(pTemplate) {
this._pTemplate = pTemplate;

}
);
a.defineProperty(BinReader, "options", function() {
return this._pOptions;

}
);
BinReader.prototype.setOptions = function(pOptions) {
"use strict";
this._pOptions = pOptions;

};
BinReader.prototype.pushPosition = function(iPosition) {
"use strict";
this._pPositions.push(this.iPosition);
this.iPosition = iPosition;

};
BinReader.prototype.popPosition = function() {
"use strict";
this.iPosition = this._pPositions.pop();

};
BinReader.prototype.setupHashTable = function() {
"use strict";
if (!(this._pHashTable)) {
this._pHashTable =  {};

}


};
BinReader.prototype.memof = function(pObject, iAddr) {
"use strict";
this._pHashTable[iAddr] = pObject;

};
BinReader.prototype.memread = function(iAddr) {
"use strict";
return (this._pHashTable[iAddr]) || null;

};
BinReader.prototype.readPtr = function(iAddr, sType, pObject) {
"use strict";
pObject = pObject || null;
if (iAddr === 4294967295) {
return null;

}

var pTmp=this.memread(iAddr);
var isReadNext=false;
var iType=-1;
var fnReader=null;
var iPosition;
var pTemplate=this.template;
var pProperties;
var pBaseClasses=null;
var pMembers=null;
var pType;
var pValue;
if (pTmp) {
return pTmp;

}

if (iAddr === (this.iPosition)) {
isReadNext = true;

}
else  {
this.pushPosition(iAddr);

}

pProperties = pTemplate.properties(sType);
if (!pProperties) {
var err=((((((("Error:: " + (("unknown object <" + sType) + "> type cannot be readed")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinReader.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("unknown object <" + sType) + "> type cannot be readed"));

}


}

;
fnReader = pProperties.read;
if (fnReader) {
pTmp = fnReader.call(this, pObject);
this.memof(pTmp, iAddr);
if (!isReadNext) {
this.popPosition();

}

return pTmp;

}

if (!pObject) {
var pCtor=pProperties.ctor;
if (((typeof pCtor) === "string") || (!pCtor)) {
eval(("pObject = new " + (pCtor || sType)) + ";");

}
else  {
pObject = pCtor.call(this);

}


}

pBaseClasses = pProperties.base;
if (pBaseClasses) {
for (var i=0; i < (pBaseClasses.length); ++i) {
iAddr = this.iPosition;
this.readPtr(iAddr, pBaseClasses[i], pObject);

}


}

this.memof(pObject, iAddr);
pMembers = pProperties.members;
if (pMembers) {
for (var sName in pMembers) {
if ((((pMembers[sName]) === null) || ((typeof (pMembers[sName])) === "string")) || ((typeof (pMembers[sName].read)) === "string")) {
pObject[sName] = this.read();
continue ;

}

pValue = pMembers[sName].read.call(this, pObject);
if (pValue !== undefined) {
pObject[sName] = pValue;

}


}


}

if (!isReadNext) {
this.popPosition();

}

return pObject;

};
BinReader.prototype.read = function() {
"use strict";
this.setupHashTable();
var iAddr=this.uint32();
if (iAddr === 4294967295) {
return null;

}

var iType=this.uint32();
var sType=this.template.getType(iType);
return this.readPtr(iAddr, sType);

};
BinReader.prototype.extractHeader = function(iAddr) {
"use strict";
if ((this.iPosition) === 4) {
if (iAddr !== 8) {
this.pushPosition(8);
this.header(this.read());
this.popPosition();

}


}


};
BinReader.prototype.header = function(pData) {
"use strict";
if ((typeof pData) === "string") {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinReader.js") + "][") + "") + "]") + "загрузка шаблонов извне не поддержвиаетя");
return ;

}

this.template = new a.BinTemplate(pData);

};
function undump(pBuffer, pOptions) {
if (!pBuffer) {
return null;

}

var pReader=new a.BinReader(pBuffer, pOptions);
return pReader.read();

}

a.undump = undump;
a.BinReader = BinReader;
function BinWriter() {
this._pArrData = [];
this._iCountData = 0;
this._pHashTable = null;
this._pBlackList =  {};
this._pBlackListStack = [];
this._pTemplate = a.binaryTemplate;
this._pOptions = null;
this._iInitialAddr = 0;

}

a.defineProperty(BinWriter, "byteLength", function() {
return this._iCountData;

}
);
a.defineProperty(BinWriter, "template", function() {
return this._pTemplate;

}
);
a.defineProperty(BinWriter, "initialAddress", function() {
return this._iInitialAddr;

}
);
a.defineProperty(BinWriter, "options", function() {
return this._pOptions;

}
);
BinWriter.prototype.setOptions = function(pOptions) {
"use strict";
this._pOptions = pOptions;

};
BinWriter.prototype.getOption = function(sOpt) {
"use strict";
if (!(this._pOptions)) {
return null;

}

return this._pOptions[sOpt];

};
BinWriter.prototype.setupHashTable = function() {
"use strict";
if (!(this._pHashTable)) {
this._pHashTable =  {};

}


};
BinWriter.prototype.memof = function(pObject, iAddr, sType) {
"use strict";
var pTable=this._pHashTable;
var pCell=pTable[sType];
if (!pCell) {
pCell = pTable[sType] = [];

}

pCell.push(pObject, iAddr);

};
BinWriter.prototype.addr = function(pObject, sType) {
"use strict";
var pTable=this._pHashTable;
var iAddr;
var pCell=pTable[sType];
if (pCell) {
for (var i=0, n=(pCell.length) / 2; i < n; ++i) {
var j=2 * i;
if ((pCell[j]) === pObject) {
return pCell[j + 1];

}


}


}

return -1;

};
BinWriter.prototype.nullPtr = function() {
"use strict";
return this.uint32(4294967295);

};
BinWriter.prototype.jump = function(iAddr) {
"use strict";
this._iInitialAddr = iAddr;

};
BinWriter.prototype.rollback = function(n) {
n = n || 1;
if (n === (-1)) {
n = this._pArrData.length;

}

var pRollback=new Array(n);
var iRollbackLength=0;
for (var i=0; i < n; ++i) {
pRollback[i] = this._pArrData.pop();
iRollbackLength += pRollback[i].byteLength;

}

this._iCountData -= iRollbackLength;
pRollback.byteLength = iRollbackLength;
return pRollback;

};
BinWriter.prototype.append = function(pData) {
"use strict";
if (pData instanceof Array) {
for (var i=0; i < (pData.length); ++i) {
this._pArrData.push(pData[i]);
this._iCountData += pData[i].byteLength;

}


}
else  {
if (pData instanceof ArrayBuffer) {
pData = new Uint8Array(pData);

}

this._pArrData.push(pData);
this._iCountData += pData.byteLength;

}


};
BinWriter.prototype.string = function(str) {
if ((str === null) || (str === undefined)) {
this.uint32(4294967295);
return ;

}

str = String(str);
var sUTF8String=str.toUTF8();
var iStrLen=sUTF8String.length;
var arrUTF8string=BinWriter.rawStringToBuffer(sUTF8String);
if (!(iStrLen <= ((Math.pow(2, 32)) - 1))) {
var err=((((((("Error:: " + "Это значение не влезет в тип string") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Это значение не влезет в тип string");

}


}

;
this.uint32(iStrLen);
var iBitesToAdd=((4 - (iStrLen % 4)) == 4? 0 : 4 - (iStrLen % 4));
this._pArrData[this._pArrData.length] = arrUTF8string;
this._iCountData += iStrLen + iBitesToAdd;

};
BinWriter.prototype._uintX = function(iValue, iX) {
if (iValue === null) {
iValue = 0;

}

if (!((typeof iValue) == "number")) {
var err=((((((("Error:: " + ("Не является числом: " + iValue)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("Не является числом: " + iValue));

}


}

;
if (!((0 <= iValue) && (iValue <= (Math.pow(2, iX))))) {
var err=((((((("Error:: " + ("Это значение не влезет в тип uint" + iX)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("Это значение не влезет в тип uint" + iX));

}


}

;
switch(iX) {
case 8:
var arrTmpBuf=new Uint8Array(4);
arrTmpBuf[0] = iValue;
break ;

case 16:
var arrTmpBuf=new Uint16Array(2);
arrTmpBuf[0] = iValue;
break ;

case 32:
var arrTmpBuf=new Uint32Array(1);
arrTmpBuf[0] = iValue;
break ;

default:
if (!0) {
var err=((((((("Error:: " + "Передано недопустимое значение длинны. Допустимые значения 8, 16, 32.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Передано недопустимое значение длинны. Допустимые значения 8, 16, 32.");

}


}

;
break ;
}
this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
this._iCountData += 4;

};
BinWriter.prototype.uint8 = function(iValue) {
this._uintX(iValue, 8);

};
BinWriter.prototype.uint16 = function(iValue) {
this._uintX(iValue, 16);

};
BinWriter.prototype.uint32 = function(iValue) {
this._uintX(iValue, 32);

};
BinWriter.prototype.bool = function(bValue) {
this._uintX((bValue? 1 : 0), 8);

};
BinWriter.prototype._writeArrayElementUintX = function(iValue, iX) {
if (iValue === null) {
iValue = 0;

}

if (!((typeof iValue) == "number")) {
var err=((((((("Error:: " + ("Не является числом: " + iValue)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("Не является числом: " + iValue));

}


}

;
if (!((0 <= iValue) && (iValue <= (Math.pow(2, iX))))) {
var err=((((((("Error:: " + ("Это значение не влезет в тип uint" + iX)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("Это значение не влезет в тип uint" + iX));

}


}

;
switch(iX) {
case 8:
var arrTmpBuf=new Uint8Array(1);
arrTmpBuf[0] = iValue;
break ;

case 16:
var arrTmpBuf=new Uint16Array(1);
arrTmpBuf[0] = iValue;
break ;

case 32:
var arrTmpBuf=new Uint32Array(1);
arrTmpBuf[0] = iValue;
break ;

default:
if (!0) {
var err=((((((("Error:: " + "Передано недопустимое значение длинны. Допустимые значения 8, 16, 32.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Передано недопустимое значение длинны. Допустимые значения 8, 16, 32.");

}


}

;
break ;
}
if (iX == 8) {
this._pArrData[this._pArrData.length] = arrTmpBuf;

}
else  {
this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);

}

this._iCountData += iX / 8;

};
BinWriter.prototype._intX = function(iValue, iX) {
if (iValue === null) {
iValue = 0;

}

if (!((typeof iValue) == "number")) {
var err=((((((("Error:: " + ("Не является числом: " + iValue)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("Не является числом: " + iValue));

}


}

;
if (!(((-(Math.pow(2, iX - 1))) <= iValue) && (iValue <= ((Math.pow(2, iX - 1)) - 1)))) {
var err=((((((("Error:: " + ("Это значение не влезет в тип int" + iX)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("Это значение не влезет в тип int" + iX));

}


}

;
switch(iX) {
case 8:
var arrTmpBuf=new Int8Array(4);
arrTmpBuf[0] = iValue;
break ;

case 16:
var arrTmpBuf=new Int16Array(2);
arrTmpBuf[0] = iValue;
break ;

case 32:
var arrTmpBuf=new Int32Array(1);
arrTmpBuf[0] = iValue;
break ;

default:
if (!0) {
var err=((((((("Error:: " + "Передано недопустимое значение длинны. Допустимые значения 8, 16, 32.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Передано недопустимое значение длинны. Допустимые значения 8, 16, 32.");

}


}

;
break ;
}
this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
this._iCountData += 4;

};
BinWriter.prototype.int8 = function(iValue) {
this._intX(iValue, 8);

};
BinWriter.prototype.int16 = function(iValue) {
this._intX(iValue, 16);

};
BinWriter.prototype.int32 = function(iValue) {
this._intX(iValue, 32);

};
BinWriter.prototype._writeArrayElementIntX = function(iValue, iX) {
if (iValue === null) {
iValue = 0;

}

if (!((typeof iValue) == "number")) {
var err=((((((("Error:: " + ("Не является числом: " + iValue)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("Не является числом: " + iValue));

}


}

;
if (!(((-(Math.pow(2, iX - 1))) <= iValue) && (iValue <= ((Math.pow(2, iX - 1)) - 1)))) {
var err=((((((("Error:: " + ("Это значение не влезет в тип int" + iX)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("Это значение не влезет в тип int" + iX));

}


}

;
switch(iX) {
case 8:
var arrTmpBuf=new Int8Array(1);
arrTmpBuf[0] = iValue;
break ;

case 16:
var arrTmpBuf=new Int16Array(1);
arrTmpBuf[0] = iValue;
break ;

case 32:
var arrTmpBuf=new Int32Array(1);
arrTmpBuf[0] = iValue;
break ;

default:
if (!0) {
var err=((((((("Error:: " + "Передано недопустимое значение длинны. Допустимые значения 8, 16, 32.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Передано недопустимое значение длинны. Допустимые значения 8, 16, 32.");

}


}

;
break ;
}
this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
this._iCountData += iX / 8;

};
BinWriter.prototype._floatX = function(fValue, iX) {
if (fValue === null) {
fValue = 0;

}

if (!((typeof fValue) == "number")) {
var err=((((((("Error:: " + ("Не является числом: " + fValue)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("Не является числом: " + fValue));

}


}

;
switch(iX) {
case 32:
var arrTmpBuf=new Float32Array(1);
arrTmpBuf[0] = fValue;
break ;

case 64:
var arrTmpBuf=new Float64Array(1);
arrTmpBuf[0] = fValue;
break ;

default:
if (!0) {
var err=((((((("Error:: " + "Передано недопустимое значение длинны. Допустимые значения 32, 64.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Передано недопустимое значение длинны. Допустимые значения 32, 64.");

}


}

;
break ;
}
this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
this._iCountData += iX / 8;

};
BinWriter.prototype.float32 = function(fValue) {
this._floatX(fValue, 32);

};
BinWriter.prototype.float64 = function(fValue) {
this._floatX(fValue, 64);

};
BinWriter.prototype.stringArray = function(arrString) {
if ((arrString === null) || (arrString === undefined)) {
this.uint32(4294967295);
return ;

}

this.uint32(arrString.length);
for (var i=0; i < (arrString.length); i++) {
this.string(arrString[i]);

}


};
BinWriter.prototype._uintXArray = function(arrUint, iX) {
if ((arrUint === null) || (arrUint === undefined)) {
this.uint32(4294967295);
return ;

}

var iUintArrLength=arrUint.length;
switch(iX) {
case 8:
var iBitesToAdd=((4 - (iUintArrLength % 4)) == 4? 0 : 4 - (iUintArrLength % 4));
if ((iBitesToAdd > 0) || (!(arrUint instanceof Uint8Array))) {
var arrTmpUint=new Uint8Array(iUintArrLength + iBitesToAdd);
arrTmpUint.set(arrUint);

}
else  {
arrTmpUint = arrUint;

}

break ;

case 16:
var iBitesToAdd=((2 - (iUintArrLength % 2)) == 2? 0 : 2 - (iUintArrLength % 2));
if ((iBitesToAdd > 0) || (!(arrUint instanceof Uint16Array))) {
var arrTmpUint=new Uint16Array(iUintArrLength + iBitesToAdd);
arrTmpUint.set(arrUint);

}
else  {
arrTmpUint = arrUint;

}

break ;

case 32:
if (!(arrUint instanceof Uint32Array)) {
arrTmpUint = new Uint32Array(arrUint);

}
else  {
arrTmpUint = arrUint;

}

break ;
}
this.uint32(iUintArrLength);
for (var i=0; i < (arrTmpUint.length); i++) {
this._writeArrayElementUintX(arrTmpUint[i], iX);

}


};
BinWriter.prototype.uint8Array = function(arrUint) {
this._uintXArray(arrUint, 8);

};
BinWriter.prototype.uint16Array = function(arrUint) {
this._uintXArray(arrUint, 16);

};
BinWriter.prototype.uint32Array = function(arrUint) {
this._uintXArray(arrUint, 32);

};
BinWriter.prototype._intXArray = function(arrInt, iX) {
if ((arrInt === null) || (arrInt === undefined)) {
this.uint32(4294967295);
return ;

}

var iIntArrLength=arrInt.length;
switch(iX) {
case 8:
var iBitesToAdd=((4 - (iIntArrLength % 4)) == 4? 0 : 4 - (iIntArrLength % 4));
if ((iBitesToAdd > 0) || (!(arrInt instanceof Int8Array))) {
var arrTmpInt=new Int8Array(iIntArrLength + iBitesToAdd);
arrTmpInt.set(arrInt);

}
else  {
arrTmpInt = arrInt;

}

break ;

case 16:
var iBitesToAdd=((2 - (iIntArrLength % 2)) == 2? 0 : 2 - (iIntArrLength % 2));
if ((iBitesToAdd > 0) || (!(arrInt instanceof Int16Array))) {
var arrTmpInt=new Int16Array(iIntArrLength + iBitesToAdd);
arrTmpInt.set(arrInt);

}
else  {
arrTmpInt = arrInt;

}

break ;

case 32:
if (!(arrInt instanceof Int32Array)) {
arrTmpInt = new Int32Array(arrInt);

}
else  {
arrTmpInt = arrInt;

}

break ;
}
this.uint32(iIntArrLength);
for (var i=0; i < (arrTmpInt.length); i++) {
this._writeArrayElementIntX(arrTmpInt[i], iX);

}


};
BinWriter.prototype.int8Array = function(arrInt) {
this._intXArray(arrInt, 8);

};
BinWriter.prototype.int16Array = function(arrInt) {
this._intXArray(arrInt, 16);

};
BinWriter.prototype.int32Array = function(arrInt) {
this._intXArray(arrInt, 32);

};
BinWriter.prototype._floatXArray = function(arrFloat, iX) {
if ((arrFloat === null) || (arrFloat === undefined)) {
this.uint32(4294967295);
return ;

}

switch(iX) {
case 32:
if (!(arrFloat instanceof Float32Array)) {
arrFloat = new Float32Array(arrFloat);

}

break ;

case 64:
if (!(arrFloat instanceof Float64Array)) {
arrFloat = new Float64Array(arrFloat);

}

break ;
}
var iFloatArrLength=arrFloat.length;
this.uint32(iFloatArrLength);
for (var i=0; i < (arrFloat.length); i++) {
this._floatX(arrFloat[i], iX);

}


};
BinWriter.prototype.float32Array = function(arrFloat) {
this._floatXArray(arrFloat, 32);

};
BinWriter.prototype.float64Array = function(arrFloat) {
this._floatXArray(arrFloat, 64);

};
BinWriter.prototype.data = function() {
var tmpArrBuffer=new Uint8Array(this._iCountData);
for (var i=0, k=0; i < (this._pArrData.length); i++) {
for (var n=0; n < (this._pArrData[i].length); n++) {
tmpArrBuffer[k++] = this._pArrData[i][n];

}


}

return tmpArrBuffer.buffer;

};
BinWriter.prototype.dataAsString = function() {
var tmpArrBuffer=new Uint8Array(this._iCountData);
for (var i=0, k=0; i < (this._pArrData.length); i++) {
for (var n=0; n < (this._pArrData[i].length); n++) {
tmpArrBuffer[k++] = this._pArrData[i][n];

}


}

var sString="";
for (var n=0; n < (tmpArrBuffer.length); ++n) {
var charCode=String.fromCharCode(tmpArrBuffer[n]);
sString = sString + charCode;

}

return sString;

};
BinWriter.prototype.dataAsUint8Array = function() {
var arrUint8=new Uint8Array(this._iCountData);
for (var i=0, k=0; i < (this._pArrData.length); i++) {
for (var n=0; n < (this._pArrData[i].length); n++) {
arrUint8[k++] = this._pArrData[i][n];

}


}

return arrUint8;

};
BinWriter.rawStringToBuffer = function(str) {
var idx;
var len=str.length;
var iBitesToAdd=((4 - (len % 4)) == 4? 0 : 4 - (len % 4));
var arr=new Array(len + iBitesToAdd);
for (idx = 0; idx < len; ++idx) {
arr[idx] = str.charCodeAt(idx);

}

return new Uint8Array(arr);

};
BinWriter.prototype.pushBlackList = function(pList) {
"use strict";
this._pBlackListStack.push(this._pBlackList);
var pBlackList= {};
if (pList) {
for (var i in pList) {
pBlackList[i] = pList[i];

}


}

for (var i in this._pBlackList) {
pBlackList[i] = this._pBlackList[i];

}

this._pBlackList = pBlackList;
return this;

};
BinWriter.prototype.popBlackList = function() {
"use strict";
this._pBlackList = this._pBlackListStack.pop();
return this;

};
BinWriter.prototype.blackList = function() {
"use strict";
return this._pBlackList;

};
BinWriter.prototype.isInBlacklist = function(sType) {
"use strict";
return (this._pBlackList[sType]) !== undefined;

};
BinWriter.prototype.writeData = function(pObject, sType) {
"use strict";
var pTemplate=this.template;
var pProperties=pTemplate.properties(sType);
var fnWriter=null;
var pBaseClasses;
var pBlackList;
var pMembers;
this.pushBlackList(pProperties.blacklist);
pBlackList = this.blackList();
if (pBlackList && ((pBlackList[sType]) !== undefined)) {
if ((pBlackList[sType]) === null) {
return false;

}
else if ((typeof (pBlackList[sType])) === "function") {
pObject = pBlackList[sType].call(this, pObject);

}



}

fnWriter = pProperties.write;
if (fnWriter) {
if ((fnWriter.call(this, pObject)) === false) {
if (!0) {
var err=((((((("Error:: " + ("cannot write type: " + sType)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("cannot write type: " + sType));

}


}

;

}

this.popBlackList();
return true;

}

if (!pProperties) {
var err=((((((("Error:: " + (("unknown object <" + sType) + "> type cannot be writed")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("unknown object <" + sType) + "> type cannot be writed"));

}


}

;
pBaseClasses = pProperties.base;
if (pBaseClasses) {
for (var i=0; i < (pBaseClasses.length); ++i) {
if (!((pBlackList[pBaseClasses[i]]) === undefined)) {
var err=((((((("Error:: " + "you cannot add to black list your parent classes") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/binary/BinWriter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("you cannot add to black list your parent classes");

}


}

;
this.writeData(pObject, pBaseClasses[i]);

}


}

pMembers = pProperties.members;
if (pMembers) {
for (var sName in pMembers) {
if (((pMembers[sName]) === null) || ((typeof (pMembers[sName])) === "string")) {
this.write(pObject[sName], pMembers[sName]);
continue ;

}

if ((typeof (pMembers[sName].write)) === "string") {
this.write(pObject[sName], pMembers[sName].write);
continue ;

}
else if (!(pMembers[sName].write)) {
this.write(pObject[sName], null);

}
else  {
pMembers[sName].write.call(this, pObject);

}



}


}

this.popBlackList();
return true;

};
BinWriter.prototype.write = function(pObject, sType, pHeader) {
"use strict";
var pProperties;
var iAddr, iType;
var pTemplate=this.template;
this.setupHashTable();
if (!sType) {
sType = pTemplate.detectType(pObject);

}

if (!(this.isInBlacklist(sType))) {
pProperties = pTemplate.properties(sType);
iType = pTemplate.getTypeId(sType);

}
else  {
pObject = null;

}

if (((pObject === null) || (pObject === undefined)) || (iType === undefined)) {
this.nullPtr();
return false;

}

iAddr = this.addr(pObject, sType);
if (iAddr < 0) {
iAddr = 0;
if (pHeader) {
iAddr += pHeader.byteLength;

}

iAddr += (((this.byteLength) + 4) + 4) + (this.initialAddress);
this.uint32(iAddr);
this.uint32(iType);
if (pHeader) {
this.append(pHeader);

}

if (this.writeData(pObject, sType)) {
this.memof(pObject, iAddr, sType);

}
else  {
this.rollback(2);
this.nullPtr();

}


}
else  {
this.uint32(iAddr);
this.uint32(iType);

}

return true;

};
BinWriter.prototype.header = function() {
"use strict";
var pHeader=this.getOption("header");
if (!pHeader) {
return null;

}

var pWriter=new a.BinWriter();
if (pHeader === true) {
pHeader = this.template.data();

}

pWriter.jump(8);
pWriter.write(pHeader);
return pWriter.data();

};
function dump(pObject, pOptions) {
var pWriter=new a.BinWriter();
pOptions = pOptions || ( {});
if (pOptions && ((pOptions.header) === undefined)) {
pOptions["header"] = true;

}

pWriter.setOptions(pOptions);
pWriter.write(pObject, null, pWriter.header());
return pWriter.data();

}

a.dump = dump;
a.BinWriter = BinWriter;
(function(f) {
a.binaryTemplate.set(f);

}
)( {"Float32Array":  {write: function(pData) {
this.float32Array(pData);

}
, read: function() {
return this.float32Array();

}
}, "Float64Array":  {write: function(pData) {
this.float64Array(pData);

}
, read: function() {
return this.float64Array();

}
}, "Int32Array":  {write: function(pData) {
this.int32Array(pData);

}
, read: function() {
return this.int32Array();

}
}, "Int16Array":  {write: function(pData) {
this.int16Array(pData);

}
, read: function() {
return this.int16Array();

}
}, "Int8Array":  {write: function(pData) {
this.int8Array(pData);

}
, read: function() {
return this.int8Array();

}
}, "Uint32Array":  {write: function(pData) {
this.uint32Array(pData);

}
, read: function() {
return this.uint32Array();

}
}, "Uint16Array":  {write: function(pData) {
this.uint16Array(pData);

}
, read: function() {
return this.uint16Array();

}
}, "Uint8Array":  {write: function(pData) {
this.uint8Array(pData);

}
, read: function() {
return this.uint8Array();

}
}, "String":  {write: function(str) {
this.string(str);

}
, read: function() {
return this.string();

}
}, "Float64":  {write: function(val) {
this.float64(val);

}
, read: function() {
return this.float64();

}
}, "Float32":  {write: function(val) {
this.float32(val);

}
, read: function() {
return this.float32();

}
}, "Int32":  {write: function(val) {
this.int32(val);

}
, read: function() {
return this.int32();

}
}, "Int16":  {write: function(val) {
this.int16(val);

}
, read: function() {
return this.int16();

}
}, "Int8":  {write: function(val) {
this.int8(val);

}
, read: function() {
return this.int8();

}
}, "Uint32":  {write: function(val) {
this.uint32(val);

}
, read: function() {
return this.uint32();

}
}, "Uint16":  {write: function(val) {
this.uint16(val);

}
, read: function() {
return this.uint16();

}
}, "Uint8":  {write: function(val) {
this.uint8(val);

}
, read: function() {
return this.uint8();

}
}, "Boolean":  {write: function(b) {
this.bool(b);

}
, read: function() {
return this.bool();

}
}, "Object":  {write: function(object) {
if (object instanceof Array) {
this.bool(true);
this.uint32(object.length);
for (var i=0; i < (object.length); ++i) {
this.write(object[i]);

}


}
else  {
this.bool(false);
this.stringArray(Object.keys(object));
for (var key in object) {
this.write(object[key]);

}


}


}
, read: function(object) {
var is_array=this.bool();
var keys;
var n;
if (is_array) {
n = this.uint32();
object = object || (new Array(n));
for (var i=0; i < n; ++i) {
object[i] = this.read();

}


}
else  {
object = object || ( {});
keys = this.stringArray();
for (var i=0; i < (keys.length); ++i) {
object[keys[i]] = this.read();

}


}

return object;

}
}, "Function":  {write: function(fn) {
this.string(fn.toString());

}
, read: function() {
var str=this.string();
eval(("var fn = " + str) + ";");
return fn;

}
}, "MathType":  {members:  {"pData": "Float32Array"}}, "Mat4": "MathType", "Vec4": "MathType", "Vec3": "MathType", "Vec2": "MathType", "Quat4": "MathType", "Number": "Float32", "Float": "Float32", "Int": "Int32", "Uint": "Uint32", "Array": "Object"});
if (!a) {
    var a = {};
}

/**
 * @property URI(String sURI)
 * @memberof URI
 * @param sURI Строка uri.
 */

/**
 * Класс для работы с URI (Uniform Resource Identifier)
 * @note Like this:  http://odserve.org/w/index.php?title=URI&stable=0#.D0.9E.D1.81.D0.BD.D0.BE.D0.B2.D1.8B
 * @ctor
 */
function URI () {
    /**
     * Схема.
     * @type String
     */
    this.sScheme = null;

    /**
     * Строка UserInfo.
     * @type String
     */
    this.sUserinfo = null;

    /**
     * Имя хоста.
     * @type String
     */
    this.sHost = null;

    /**
     * Порт.
     * @type String.
     */
    this.nPort = null;

    /**
     * Строка Path. Путь.
     * @type String
     */
    this.sPath = null;

    /**
     * QueryString.
     * @type String.
     */
    this.sQuery = null;

    /**
     * Фрагмент.
     */
    this.sFragment = null;

    if (arguments.length) {
        this.set(arguments[0]);
    }
}


//------------------------------------------------------------------//
//----- Validate a URI -----//
//------------------------------------------------------------------//
//- The different parts are kept in their own groups and can be recombined
//  depending on the scheme:
//  - http as $1://$3:$4$5?$7#$8
//  - ftp as $1://$2@$3:$4$5
//  - mailto as $1:$6?$7
//- groups are as follows:
//  1   == scheme
//  2   == userinfo
//  3   == host
//  4   == port
//  5,6 == path (5 if it has an authority, 6 if it doesn't)
//  7   == query
//  8   == fragment


URI.prototype.regexpUri =
    /^([a-z0-9+.-]+:)?(?:\/\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\d*))?(\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$/i;

/*
 composed as follows:
 ^
 ([a-z0-9+.-]+):							#scheme
 (?:
 //							#it has an authority:
 (?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?	#userinfo
 ((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)		#host
 (?::(\d*))?						#port
 (/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?	#path
 |
 #it doesn't have an authority:
 (/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?	#path
 )
 (?:
 \?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)	#query string
 )?
 (?:
 #((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)	#fragment
 )?
 $
 */

URI.prototype.set = function (sData) {
    if (typeof sData == 'string') {

        var pUri = this.regexpUri.exec(sData);

        if (!pUri) {
            throw new Error('Invalid URI format used.\nused uri: ' + sData);
        }
    
        this.sScheme = pUri[1] || null;
        this.sUserinfo = pUri[2] || null;
        this.sHost = pUri[3] || null;
        this.nPort = parseInt(pUri[4]) || null;
        this.sPath = pUri[5] || pUri[6] || null;
        this.sQuery = pUri[7] || null;
        this.sFragment = pUri[8] || null;
    }
    else if (sData instanceof URI) {
        this.set(sData.toString());
    }
    else {
        throw new TypeError('Unexpected data type was used.');
    }
};
URI.prototype.toString = function () {

    return this.url + this.urn;
}
Object.defineProperty(URI.prototype, "urn", {
    get: function () {
        return (this.sPath ? this.sPath : '') +
            (this.sQuery ? '?' + this.sQuery : '') +
            (this.sFragment ? '#' + this.sFragment : '');
    }
});
Object.defineProperty(URI.prototype, "url", {
    get: function () {
        return (this.sScheme ? this.sScheme : '') + this.authority;
    }
});
Object.defineProperty(URI.prototype, "authority", {
    get: function () {
        return (this.sHost ? '//' + (this.sUserinfo ? this.sUserinfo + '@' : '') +
            this.sHost + (this.nPort ? ':' + this.nPort : '') : '');
    }
});
Object.defineProperty(URI.prototype, "scheme", {
    get: function () {
        return this.sScheme;
    }
});
Object.defineProperty(URI.prototype, "protocol", {
    get: function () {
        if (!this.sScheme) {
            return this.sScheme;
        }

        return (this.sScheme.substr(0, this.sScheme.lastIndexOf(':')));
    }
});
Object.defineProperty(URI.prototype, "userinfo", {
    get: function () {
        return this.sUserinfo;
    }
});
Object.defineProperty(URI.prototype, "host", {
    get: function () {
        return this.sHost;
    }
});
Object.defineProperty(URI.prototype, 'port', {
    get: function () {
        return this.nPort;
    },
    set: function (iPort) {
        this.nPort = parseInt(iPort);
    }
});
Object.defineProperty(URI.prototype, "path", {
    get: function () {
        return this.sPath;
    }
});
Object.defineProperty(URI.prototype, "query", {
    get: function () {
        return this.sQuery;
    }
});
Object.defineProperty(URI.prototype, "fragment", {
    get: function () {
        return this.sFragment;
    }
});

a.URI = URI;
a.uri = function (sUri) {
    return new a.URI(sUri);
};
if (!a) {
    var a = {};
}


function Pathinfo () {
    this.sDirname = null;
    this.sExtension = null;
    this.sFilename = null;

    if (arguments.length) {
        this.set(arguments[0]);
    }
}

Pathinfo.prototype.set = function (sPath) {
    if (typeof sPath == 'string') {
        var pParts = sPath.replace('\\', '/').split('/');
        this.basename = pParts.pop();

        this.sDirname = pParts.join('/');
    }
    else if (sPath instanceof Pathinfo) {
        this.sDirname = sPath.sDirname;
        this.sFilename = sPath.sFilename;
        this.sExtension = sPath.sExtension;
    }
    else {
        throw new TypeError('Unexpected data type was used.');
    }
};

Pathinfo.prototype.toString = function () {
    return (this.sDirname ? this.sDirname + '/' : '') + (this.basename);
};

Object.defineProperty(Pathinfo.prototype, "data", {
    get: function () {
        return this.toString();
    },
    set: function (sPath) {
        this.set(sPath);
    }
});

Object.defineProperty(Pathinfo.prototype, "path", {
    get: function () {
        return this.toString();
    },
    set: function (sPath) {
        this.set(sPath);
    }
});

Object.defineProperty(Pathinfo.prototype, "dirname", {
    get: function () {
        return this.sDirname;
    }
});

Object.defineProperty(Pathinfo.prototype, "filename", {
    get: function () {
        return this.sFilename;
    },
    set: function (sFilename) {
        this.basename = sFilename + '.' + this.sExtension;
    }
});

Object.defineProperty(Pathinfo.prototype, "ext", {
    get: function () {
        return this.sExtension;
    }
});

Object.defineProperty(Pathinfo.prototype, "extention", {
    get: function () {
        return this.sExtension;
    },
    set: function (sExt) {
        this.basename = this.sFilename + '.' + sExt;
    }
});

Object.defineProperty(Pathinfo.prototype, "basename", {
    get: function () {
        return (this.sFilename ? this.sFilename + (this.sExtension ?
            '.' + this.sExtension : '') : '');
    },
    set: function (sBasename) {
        var nPos = sBasename.lastIndexOf('.');
        if (nPos < 0) {
            this.sFilename = sBasename.substr(0);
            this.sExtension = null;
        }
        else {
            this.sFilename = sBasename.substr(0, nPos);
            this.sExtension = sBasename.substr(nPos + 1);
        }
    }
});

Pathinfo.prototype.isAbsolute = function () {
    'use strict';
    
    return this.sDirname[0] === '/'? true: false;
};

a.Pathinfo = Pathinfo;
a.pathinfo = function (sPath) {
    return new a.Pathinfo(sPath);
};
a.io =  {};
a.io.stringTomode = function(sMode) {
switch(sMode.toLowerCase()) {
case "a+t":
return (((1) | (2)) | (8)) | (64);

case "w+t":
return (((1) | (2)) | (16)) | (64);

case "r+t":
return ((1) | (2)) | (64);

case "at":
return (8) | (64);

case "wt":
return (2) | (64);

case "rt":
return (1) | (64);

case "a+b":
return (((1) | (2)) | (8)) | (32);

case "w+b":
return (((1) | (2)) | (16)) | (32);

case "r+b":
return ((1) | (2)) | (32);

case "ab":
return (8) | (32);

case "wb":
return (2) | (32);

case "rb":
return (1) | (32);

case "a+":
return ((1) | (2)) | (8);

case "w+":
return ((1) | (2)) | (16);

case "r+":
return (1) | (2);

case "a":
return (8) | (2);

case "w":
return 2;

case "r":
;

default:
return 1;
}

};
function ThreadManager(sScript, pWorker) {
;
this._sScript = sScript || null;
this._pWorkers = [];
this._pWorkerStatus = [];
for (var i=0; i < (4); ++i) {
this.createThread(sScript, pWorker);

}


}

ThreadManager.prototype.createThread = function(sScript, pWorker) {
sScript = sScript || (this._sScript);
if ((this._pWorkers.length) == (512)) {
if (!0) {
var err=((((((("Error:: " + "Reached limit the number of threads.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Reached limit the number of threads.");

}


}

;

}

var pWorker;
pWorker = new (pWorker || Worker)(sScript);
pWorker.postMessage = (pWorker.webkitPostMessage) || (pWorker.postMessage);
this._pWorkers.push(pWorker);
this._pWorkerStatus.push(1);

};
ThreadManager.prototype.occupyThread = function() {
for (var i=0, n=this._pWorkers.length; i < n; ++i) {
if ((this._pWorkerStatus[i]) == (1)) {
this._pWorkerStatus[i] = 0;
return i;

}


}

this.createThread();
return this.occupyThread();

};
ThreadManager.prototype.releaseThread = function(i) {
this._pWorkerStatus[i] = 1;
return ;

};
ThreadManager.prototype.thread = function(id) {
return this._pWorkers[id];

};
function FileThread() {
;
this._eFileMode = ((typeof (arguments[1])) == "string"? a.io.stringTomode(arguments[1]) : (arguments[1]) || (1));
this._pFileName = (a.uri(arguments[0])) || null;
this._pFile = null;
this._nSeek = 0;
this._iThread = -1;
this._eTransferMode = (a.info.support.api.transferableObjects? 1 : ((a.info.browser.sBrowser) == "Opera"? 2 : 0));
if ((arguments.length) > 2) {
this.open(arguments[0], arguments[1], arguments[2], arguments[3]);

}


}

FileThread.prototype._thread = function(fnSuccess, fnError) {
var pFile=this;
var pManager=pFile._manager();
var iThread=pManager.occupyThread();
pFile._iThread = iThread;
function release() {
pManager.releaseThread(pFile._iThread);
pFile._iThread = -1;

}

function setup(pThread) {
var me= {};
me.onmessage = fnSuccess || null;
me.onerror = fnError || null;
pThread.onmessage = function(e) {
release();
if (me.onmessage) {
me.onmessage.call(pFile, e.data);

}


};
pThread.onerror = function(e) {
console.log("release thread(err)", e);
release();
if (me.onerror) {
me.onerror.call(pFile, e.data);

}


};
me.send = function(data) {
pThread.postMessage(data);

};
return me;

}

return setup(pManager.thread(this._iThread));

};
FileThread.prototype._manager = function() {
return this._pThreadManager;

};
FileThread.prototype._pThreadManager = null;
FileThread.prototype.open = function() {
if (!(((arguments.length) >= 0) && ((arguments.length) < 5))) {
var err=((((((("Error:: " + (("Invalid number(" + (arguments.length)) + ") of parameters.")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("Invalid number(" + (arguments.length)) + ") of parameters."));

}


}

;
var fnSuccess, fnError, hasMode=(typeof (arguments[1])) != "function";
if ((arguments.length) < 3) {
if ((typeof (arguments[0])) == "string") {
this._pFileName = arguments[0];
fnSuccess = arguments[1];
fnError = null;

}
else if ((typeof (arguments[0])) == "number") {
this._eFileMode = arguments[0];
fnSuccess = arguments[1];
fnError = null;

}
else  {
fnSuccess = arguments[0];
fnError = (arguments[1]) || null;

}


if (!this._pFileName) {
var err=((((((("Error:: " + "No filename provided.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("No filename provided.");

}


}

;
this.open(this._pFileName, this._eFileMode, fnSuccess, fnError);
return ;

}

fnSuccess = arguments[(hasMode? 2 : 1)];
fnError = (arguments[(hasMode? 3 : 2)]) || null;
if (this.isOpened()) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "][") + "") + "]") + "file already opened.");
fnSuccess(this._pFile);

}

this._pFileName = a.uri(arguments[0]);
this._eFileMode = (hasMode? ((typeof (arguments[1])) == "string"? a.io.stringTomode(arguments[1]) : arguments[1]) : this._eFileMode);
this._update(function() {
if ((this._eFileMode & (1 << 3)) != 0) {
this.position = this.size;

}

fnSuccess.call(this);

}
, fnError);

};
Object.defineProperty(FileThread.prototype, "path",  {get: function() {
if (!this._pFile) {
var err=((((((("Error:: " + "There is no file handle open.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is no file handle open.");

}


}

;
return this._pFileName.toString();

}
});
FileThread.prototype.close = function() {
this._pFileName = null;
this._eFileMode = (1) | (2);
this._nLength = 0;
this._nSeek = 0;
 {
if (this._pFile) {
if (this._pFile.destructor) {
this._pFile.destructor();

}

delete this._pFile;
this._pFile = null;

}


};

};
FileThread.prototype.clear = function(fnSuccess, fnError) {
if (!(this._pFile)) {
var pArgs=arguments;
this.open(function() {
this.clear.apply(this, pArgs);

}
, fnError);
return ;

}

if (!((this._iThread) < 0)) {
var err=((((((("Error:: " + ((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread)));

}


}

;
this._thread(fnSuccess, fnError).send( {act: 4, name: this._pFileName.toString(), mode: this._eFileMode});

};
Object.defineProperty(FileThread.prototype, "name",  {get: function() {
return a.pathinfo(this._pFileName.path).basename;

}
, set: function(sFileName) {
if (!(!(this._pFile))) {
var err=((((((("Error:: " + "There is file handle open.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is file handle open.");

}


}

;
var pPath=a.pathinfo(this._pFileName.path);
pPath.basename = sFileName;
this._pFileName.sPath = pPath.toString();

}
});
FileThread.prototype.isOpened = function() {
return (this._pFile) != null;

};
Object.defineProperty(FileThread.prototype, "mode",  {set: function(pMode) {
this._eFileMode = ((typeof pMode) == "string"? a.io.stringTomode(pMode) : pMode);

}
, get: function() {
return this._eFileMode;

}
});
Object.defineProperty(FileThread.prototype, "onread",  {set: function(fn) {
this.read(fn);

}
});
Object.defineProperty(FileThread.prototype, "onopen",  {set: function(fn) {
this.read(fn);

}
});
FileThread.prototype._update = function(fnSuccess, fnError) {
var pThread=this._thread();
var me=this;
pThread.onmessage = function(e) {
me._pFile = e;
fnSuccess.call(me);

};
pThread.onerror = fnError;
pThread.send( {act: 1, name: this._pFileName.toString(), mode: this._eFileMode});

};
FileThread.prototype.read = function(fnSuccess, fnError) {
if (!(this._pFile)) {
var pArgs=arguments;
this.open(function() {
this.read.apply(this, pArgs);

}
, fnError);
return ;

}

if (!((this._iThread) < 0)) {
var err=((((((("Error:: " + ((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread)));

}


}

;
var pThread=this._thread();
var me=this;
if (!(this._eFileMode & (1 << 0)) != 0) {
var err=((((((("Error:: " + "The file is not readable.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The file is not readable.");

}


}

;
pThread.onerror = fnError;
pThread.onmessage = function(e) {
if (((me._eTransferMode) == (2)) && ((this._eFileMode & (1 << 5)) != 0)) {
e = new Uint8Array(e).buffer;

}

me.atEnd();
fnSuccess.call(me, e);

};
pThread.send( {act: 2, name: this._pFileName.toString(), mode: this._eFileMode, pos: this._nSeek, transfer: this._eTransferMode});

};
FileThread.prototype.write = function(pData, fnSuccess, fnError, sContentType) {
if (!(this._pFile)) {
var pArgs=arguments;
this.open(function() {
this.write.apply(this, pArgs);

}
, fnError);
return ;

}

if (!((this._iThread) < 0)) {
var err=((((((("Error:: " + ((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread)));

}


}

;
var pThread=this._thread();
var me=this;
var iMode=this._eFileMode;
if (!(iMode & (1 << 1)) != 0) {
var err=((((((("Error:: " + "The file is not writable.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The file is not writable.");

}


}

;
pThread.onerror = fnError;
pThread.onmessage = function(e) {
me._pFile = e;
me._nSeek += ((typeof pData) == "string"? pData.length : pData.byteLength);
if (fnSuccess)fnSuccess.apply(me, arguments);


};
sContentType = sContentType || (((iMode & (1 << 5)) != 0? "application/octet-stream" : "text/plain"));
pThread.send( {act: 3, name: this._pFileName.toString(), mode: this._eFileMode, data: pData, contentType: sContentType, pos: this._nSeek});

};
FileThread.prototype.atEnd = function() {
this.position = this.size;

};
Object.defineProperty(FileThread.prototype, "position",  {get: function() {
if (!this._pFile) {
var err=((((((("Error:: " + "There is no file handle open.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is no file handle open.");

}


}

;
return this._nSeek;

}
, set: function(iOffset) {
if (!this._pFile) {
var err=((((((("Error:: " + "There is no file handle open.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is no file handle open.");

}


}

;
this._nSeek = iOffset;

}
});
Object.defineProperty(FileThread.prototype, "size",  {get: function() {
if (!this._pFile) {
var err=((((((("Error:: " + "There is no file handle open.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is no file handle open.");

}


}

;
return this._pFile.size;

}
});
FileThread.prototype.seek = function(iOffset) {
if (!this._pFile) {
var err=((((((("Error:: " + "There is no file handle open.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is no file handle open.");

}


}

;
var nSeek=(this._nSeek) + iOffset;
if (nSeek < 0) {
nSeek = (this.size) - ((Math.abs(nSeek)) % (this.size));

}

if (!((nSeek >= 0) && (nSeek <= (this.size)))) {
var err=((((((("Error:: " + "Invalid offset parameter") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Invalid offset parameter");

}


}

;
this._nSeek = nSeek;

};
FileThread.prototype.isExists = function(fnSuccess, fnError) {
this._thread(fnSuccess, fnError).send( {act: 5, name: this._pFileName.toString(), mode: this._eFileMode});

};
FileThread.prototype.move = function(pFileName, fnSuccess, fnError) {
var me=this;
this.copy(pFileName, function() {
me.remove(fnSuccess, fnError);

}
, fnError);

};
FileThread.prototype.rename = function(pFileName, fnSuccess, fnError) {
var pName=a.pathinfo(pFileName);
if (!(!(pName.dirname))) {
var err=((((((("Error:: " + "only filename can be specified.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("only filename can be specified.");

}


}

;
this.move(((a.pathinfo(this._pFileName.path).sDirname) + "/") + (pName.basename), fnSuccess, fnError);

};
FileThread.prototype.copy = function(pFileName, fnSuccess, fnError) {
var iMode=((1) | (2)) | (16);
if ((this._eFileMode & (1 << 5)) != 0) {
iMode |= 32;

}

var me=this;
var pFile=new this.constructor(pFileName, iMode, function() {
me.read(function(pData) {
pFile.write(pData, fnSuccess, fnError);

}
);

}
, fnError);

};
FileThread.prototype.getMetadata = function(fnSuccess, fnError) {
if (!(this._pFile)) {
var pArgs=arguments;
this.open(function() {
this.getMetadata.apply(this, pArgs);

}
, fnError);
return ;

}

if (!((this._iThread) < 0)) {
var err=((((((("Error:: " + ((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread)));

}


}

;
fnSuccess( {lastModifiedDate: this._pFile.lastModifiedDate});

};
FileThread.prototype.remove = function(fnSuccess, fnError) {
if (!(this._pFile)) {
var pArgs=arguments;
this.open(function() {
this.remove.apply(this, pArgs);

}
, fnError);
return ;

}

if (!((this._iThread) < 0)) {
var err=((((((("Error:: " + ((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/FileUtils.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread)));

}


}

;
var pThread=this._thread();
var me=this;
pThread.onerror = fnError;
pThread.onmessage = function(e) {
me.close();
if (fnSuccess) {
fnSuccess.call(me, e);

}


};
pThread.send( {act: 6, name: this._pFileName.toString(), mode: this._eFileMode});

};
a.FileThread = FileThread;
function BrowserInfo() {
this.sBrowser = null;
this.sVersion = null;
this.sOS = null;
this._sVersionSearch = null;
this.dataBrowser = [ {string: navigator.userAgent, subString: "Chrome", identity: "Chrome"},  {string: navigator.userAgent, subString: "OmniWeb", versionSearch: "OmniWeb/", identity: "OmniWeb"},  {string: navigator.vendor, subString: "Apple", identity: "Safari", versionSearch: "Version"},  {prop: window.opera, identity: "Opera", versionSearch: "Version"},  {string: navigator.vendor, subString: "iCab", identity: "iCab"},  {string: navigator.vendor, subString: "KDE", identity: "Konqueror"},  {string: navigator.userAgent, subString: "Firefox", identity: "Firefox"},  {string: navigator.vendor, subString: "Camino", identity: "Camino"},  {string: navigator.userAgent, subString: "Netscape", identity: "Netscape"},  {string: navigator.userAgent, subString: "MSIE", identity: "Explorer", versionSearch: "MSIE"},  {string: navigator.userAgent, subString: "Gecko", identity: "Mozilla", versionSearch: "rv"},  {string: navigator.userAgent, subString: "Mozilla", identity: "Netscape", versionSearch: "Mozilla"}];
this.dataOS = [ {string: navigator.platform, subString: "Win", identity: "Windows"},  {string: navigator.platform, subString: "Mac", identity: "Mac"},  {string: navigator.userAgent, subString: "iPhone", identity: "iPhone/iPod"},  {string: navigator.platform, subString: "Linux", identity: "Linux"}];
this.init();

}

BrowserInfo.prototype.init = function() {
this.sBrowser = (this._searchString(this.dataBrowser)) || "An unknown browser";
this.sVersion = ((this._searchVersion(navigator.userAgent)) || (this._searchVersion(navigator.appVersion))) || "an unknown version";
this.sOS = (this._searchString(this.dataOS)) || "an unknown OS";

};
BrowserInfo.prototype._searchString = function(sDataBrowser) {
for (var i=0; i < (sDataBrowser.length); i++) {
var sData=sDataBrowser[i].string;
var dataProp=sDataBrowser[i].prop;
this._sVersionSearch = (sDataBrowser[i].versionSearch) || (sDataBrowser[i].identity);
if (sData) {
if ((sData.indexOf(sDataBrowser[i].subString)) != (-1)) {
return sDataBrowser[i].identity;

}


}
else if (dataProp) {
return sDataBrowser[i].identity;

}



}

return null;

};
BrowserInfo.prototype._searchVersion = function(sData) {
var iStartIndex=sData.indexOf(this._sVersionSearch);
if (iStartIndex == (-1)) {
return null;

}

iStartIndex = sData.indexOf("/", iStartIndex + 1);
if (iStartIndex == (-1)) {
return null;

}

var iEndIndex=sData.indexOf(" ", iStartIndex + 1);
if (iEndIndex == (-1)) {
iEndIndex = sData.indexOf(";", iStartIndex + 1);
if (iEndIndex == (-1)) {
return null;

}

return sData.slice(iStartIndex + 1);

}
else  {
return sData.slice(iStartIndex + 1, iEndIndex);

}


};
a.defineProperty(BrowserInfo, "name", function() {
return this.sBrowser;

}
);
a.defineProperty(BrowserInfo, "version", function() {
return this.sVersion;

}
);
a.defineProperty(BrowserInfo, "os", function() {
return this.sOS;

}
);
window.URL = (window.URL? window.URL : (window.webkitURL? window.webkitURL : null));
window.BlobBuilder = ((window.WebKitBlobBuilder) || (window.MozBlobBuilder)) || (window.BlobBuilder);
window.requestFileSystem = (window.requestFileSystem) || (window.webkitRequestFileSystem);
window.requestAnimationFrame = ((window.requestAnimationFrame) || (window.webkitRequestAnimationFrame)) || (window.mozRequestAnimationFrame);
window.WebSocket = (window.WebSocket) || (window.MozWebSocket);
function ApiInfo() {
this.webgl = ((window.WebGLRenderingContext) || (this.checkWebGL())? true : false);
this.webAudio = ((window.AudioContext) && (window.webkitAudioContext)? true : false);
this.file = ((((window.File) && (window.FileReader)) && (window.FileList)) && (window.Blob)? true : false);
this.fileSystem = (((this.file) && (window.URL)) && (window.requestFileSystem)? true : false);
this.webWorker = (typeof Worker) !== "undefined";
this.transferableObjects = ((this.webWorker) && (this.chechTransferableObjects())? true : false);
this.localStorage = (typeof localStorage) !== "undefined";
this.webSocket = (typeof (window.WebSocket)) !== "undefined";

}

ApiInfo.prototype.checkWebGL = function() {
try {
var pCanvas=document.createElement("canvas");
var pContext=(pCanvas.getContext("webgl")) || (pCanvas.getContext("experimental-webgl"));
if (pContext) {
return true;

}


}
catch(e) {

}
return false;

};
ApiInfo.prototype.chechTransferableObjects = function() {
var pWorker=new Worker(("/akra-engine-core/src/" + "files/threads/") + "EmptyThread.thread.js");
pWorker.postMessage = (pWorker.webkitPostMessage) || (pWorker.postMessage);
var ab=new ArrayBuffer(1);
try {
pWorker.postMessage(ab, [ab]);

}
catch(e) {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/utils/SystemInfo.js") + "][") + "") + "]") + "transferable objects not supported in your browser...");

}
pWorker.terminate();
if (ab.byteLength) {
return false;

}

return true;

};
a.browser = new BrowserInfo();
a.info =  {canvas: function(id) {
var pCanvas=((typeof id) == "string"? document.getElementById(id) : id);
return  {width: (pCanvas.width? pCanvas.width : pCanvas.style.width), height: (pCanvas.height? pCanvas.height : pCanvas.style.height), id: pCanvas.id};

}
, browser: a.browser, screen:  {width: function() {
return screen.width;

}
, height: function() {
return screen.height;

}
}, uri: a.uri(document.location.href), path:  {modules: "/akra-engine-core/src/"}, is:  {online: function() {
return navigator.onLine;

}
, mobile: /mobile|iphone|ipad|ipod|android|blackberry|mini|windows\sce|palm/i.test(navigator.userAgent.toLowerCase()), linux: (a.browser.os) == "Linux", windows: (a.browser.os) == "Windows", mac: (a.browser.os) == "Mac", iPhone: (a.browser.os) == "iPhone"}, uri: a.uri(document.location.href), path:  {modules: "/akra-engine-core/src/"}, is:  {online: function() {
return navigator.onLine;

}
, mobile: /mobile|iphone|ipad|ipod|android|blackberry|mini|windows\sce|palm/i.test(navigator.userAgent.toLowerCase()), linux: (a.browser.os) == "Linux", windows: (a.browser.os) == "Windows", mac: (a.browser.os) == "Mac", iPhone: (a.browser.os) == "iPhone"}, support:  {}, graphics:  {maxTextureSize: function(pContext) {
return pContext.getParameter(pContext.MAX_TEXTURE_SIZE);

}
, maxCubeMapTextureSize: function(pContext) {
return pContext.getParameter(pContext.MAX_CUBE_MAP_TEXTURE_SIZE);

}
, maxViewPortSize: function(pContext) {
return pContext.getParameter(pContext.MAX_VIEWPORT_DIMS);

}
, stencilBits: function(pContext) {
return pContext.getParameter(pContext.STENCIL_BITS);

}
, colorBits: function(pContext) {
return [pContext.getParameter(pContext.RED_BITS), pContext.getParameter(pContext.GREEN_BITS), pContext.getParameter(pContext.BLUE_BITS)];

}
, alphaBits: function(pContext) {
return pContext.getParameter(pContext.ALPHA_BITS);

}
, colorBits: function(pContext) {
return [pContext.getParameter(pContext.RED_BITS), pContext.getParameter(pContext.GREEN_BITS), pContext.getParameter(pContext.BLUE_BITS)];

}
, multisampleType: function(pContext) {
return pContext.getParameter(pContext.SAMPLE_COVERAGE_VALUE);

}
, maxTextureImageUnits: function(pContext) {
return pContext.getParameter(pContext.MAX_TEXTURE_IMAGE_UNITS);

}
, maxVertexAttributes: function(pContext) {
return 16;

}
, maxVertexTextureImageUnits: function(pContext) {
return pContext.getParameter(pContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS);

}
, maxCombinedTextureImageUnits: function(pContext) {
return pContext.getParameter(pContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS);

}
, shaderVersion: function(pContext) {
var sVersion=pContext.getParameter(pContext.SHADING_LANGUAGE_VERSION);
var iTmp=sVersion.indexOf(sVersion.match(/\d/)[0]);
return parseFloat(sVersion.substr(iTmp));

}
, getExtention: function(pContext, eExtention) {
var pExtentions, sExtention, result=false;
pExtentions = pContext.getSupportedExtensions();
for (var i in pExtentions) {
sExtention = pExtentions[i];
if ((sExtention.search(eExtention)) != (-1)) {
result = pContext.getExtension(sExtention);
trace("extension successfuly loaded: " + sExtention);

}


}

return result;

}
, checkFormat: function(pContext, eFormat) {
switch(eFormat) {
case 33776:
;

case 33777:
;

case 33780:
;

case 33778:
;

case 33781:
;

case 33779:
for (var i in pContext) {
if (((typeof (pContext[i])) == "number") && ((pContext[i]) == eFormat)) {
return true;

}


}

return false;

case 6407:
;

case 6408:
;

case 32854:
;

case 32855:
;

case 36194:
return true;

default:
return false;
}

}
}};
a.info.support.api = new ApiInfo();
Object.defineProperty(a.info.is, "online",  {get: function() {
return navigator.onLine;

}
});
Object.defineProperty(a.info.support, "webgl",  {get: function() {
return a.info.support.api.webgl;

}
});
Object.defineProperty(a.info.support, "webSocket",  {get: function() {
return a.info.support.api.webSocket;

}
});
Object.defineProperty(a.info.support, "webAudio",  {get: function() {
return a.info.support.api.webAudio;

}
});
Object.defineProperty(a.info.support, "fs",  {get: function() {
return a.info.support.api.fileSystem;

}
});
Object.defineProperty(a.info.screen, "width",  {get: function() {
return screen.width;

}
});
Object.defineProperty(a.info.screen, "height",  {get: function() {
return screen.height;

}
});
if (a.info.support.api.webWorker) {
function RemoteFileThread() {
RemoteFileThread.superclass.constructor.apply(this, arguments);

}

a.extend(RemoteFileThread, a.FileThread);
RemoteFileThread.prototype._pThreadManager = new ThreadManager(("/akra-engine-core/src/" + "files/threads/") + "RemoteFile.thread.js");
a.RemoteFile = RemoteFileThread;
if (a.info.support.api.fileSystem) {
function LocalFileThread() {
LocalFileThread.superclass.constructor.apply(this, arguments);

}

a.extend(LocalFileThread, a.FileThread);
LocalFileThread.prototype._pThreadManager = new ThreadManager(("/akra-engine-core/src/" + "files/threads/") + "LocalFile.thread.js");
a.LocalFile = LocalFileThread;

}
else if (a.info.support.api.localStorage) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/files/File.js") + "][") + "") + "]") + "used simplified realisation for local files, based on local storage");
function LocalFileSimplified() {
LocalFileSimplified.superclass.constructor.apply(this, arguments);

}

a.extend(LocalFileSimplified, a.FileThread);
LocalFileSimplified.prototype.clear = function(fnSuccess) {
if (!(this._pFile)) {
var pArgs=arguments;
this.open(function() {
this.clear.apply(this, pArgs);

}
, fnError);
return ;

}

if (!((this._iThread) < 0)) {
var err=((((((("Error:: " + ((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFileSimplified.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread)));

}


}

;
localStorage.setItem(this.path, "");
this._pFile.size = 0;
if (fnSuccess) {
fnSuccess.apply(this);

}


};
LocalFileSimplified.prototype._read = function() {
var pFile=this._pFile;
var pData=localStorage.getItem(this.path);
if (pData == null) {
pData = "";
if ((pData & (1 << 1)) != 0) {
localStorage.setItem(this.path, pData);

}


}

if ((this._eFileMode & (1 << 5)) != 0) {
pData = a.str2buf(pData);
pFile.size = pData.byteLength;

}
else  {
pFile.size = pData.length;

}

return pData;

};
LocalFileSimplified.prototype._update = function(fnSuccess) {
this._pFile =  {};
this._read();
fnSuccess.apply(this);

};
LocalFileSimplified.prototype.read = function(fnSuccess, fnError) {
if (!(this._pFile)) {
var pArgs=arguments;
this.open(function() {
this.read.apply(this, pArgs);

}
, fnError);
return ;

}

if (!((this._iThread) < 0)) {
var err=((((((("Error:: " + ((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFileSimplified.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread)));

}


}

;
if (!(this._eFileMode & (1 << 0)) != 0) {
var err=((((((("Error:: " + "The file is not readable.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFileSimplified.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The file is not readable.");

}


}

;
var pData=this._read();
var nPos=this._nSeek;
if (nPos) {
if ((this._eFileMode & (1 << 5)) != 0) {
pData = new Uint8Array(new Uint8Array(pData).subarray(nPos)).buffer;

}
else  {
pData = pData.substr(nPos);

}


}

this.atEnd();
if (fnSuccess) {
fnSuccess.apply(this, [pData]);

}


};
LocalFileSimplified.prototype.write = function(pData, fnSuccess, fnError, sContentType) {
if (!(this._pFile)) {
var pArgs=arguments;
this.open(function() {
this.write.apply(this, pArgs);

}
, fnError);
return ;

}

if (!((this._iThread) < 0)) {
var err=((((((("Error:: " + ((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFileSimplified.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(((("File(" + (this.name)) + ") already in use. \n thread: ") + (this._iThread)));

}


}

;
var iMode=this._eFileMode;
if (!(iMode & (1 << 1)) != 0) {
var err=((((((("Error:: " + "The file is not writable.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFileSimplified.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The file is not writable.");

}


}

;
sContentType = sContentType || (((iMode & (1 << 5)) != 0? "application/octet-stream" : "text/plain"));
var sData=this._read();
if ((typeof sData) == "object") {
sData = a.buf2str(sData);

}

var nSeek=((typeof pData) == "string"? pData.length : pData.byteLength);
if ((typeof pData) == "object") {
pData = a.buf2str(pData);

}

pData = ((sData.substr(0, this._nSeek)) + pData) + (sData.substr((this._nSeek) + (pData.length)));
try {
localStorage.setItem(this.path, pData);

}
catch(e) {
if (fnError) {
fnError.apply(this, [e]);

}
else  {
throw e;

}


}
this._pFile.size = pData.length;
this._nSeek += nSeek;
if (fnSuccess) {
fnSuccess.apply(this);

}


};
LocalFileSimplified.prototype.isExists = function(fnSuccess) {
fnSuccess.apply(this, [(localStorage.getItem(this.path)) == null]);

};
LocalFileSimplified.prototype.remove = function(fnSuccess) {
localStorage.removeItem(this.path);
fnSuccess.apply(this);

};
a.LocalFile = LocalFileSimplified;

}
else  {
if (!0) {
var err=((((((("Error:: " + "Your browser not support file system!") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/File.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Your browser not support file system!");

}


}

;

}



}
else if (a.info.support.api.fileSystem) {
;
function LocalFile() {
this._eFileMode = ((typeof (arguments[1])) == "string"? a.io.stringTomode(arguments[1]) : (arguments[1]) || (1));
this._pFileName = (a.pathinfo(arguments[0])) || null;
this._pFile = null;
this._pFileReader = new FileReader();
this._nSeek = 0;
this._pFileHandle = null;
if ((arguments.length) > 2) {
this.open(arguments[0], arguments[1], arguments[2], arguments[3]);

}


}

function LocalFS() {
this._pFileSystem = null;
this._pCallbackQueue = [];

}

LocalFS.prototype.get = function(fnCallback) {
if (this._pFileSystem) {
fnCallback(this._pFileSystem);
return ;

}

var me=this;
var pQueue=me._pCallbackQueue;
pQueue.push(fnCallback);
if ((pQueue.length) > 1) {
return ;

}

var fnErrorHandler=function(e) {
var msg="Init filesystem: ";
switch(e.code) {
case FileError.QUOTA_EXCEEDED_ERR:
msg += "QUOTA_EXCEEDED_ERR";
break ;

case FileError.NOT_FOUND_ERR:
msg += "NOT_FOUND_ERR";
break ;

case FileError.SECURITY_ERR:
msg += "SECURITY_ERR";
break ;

case FileError.INVALID_MODIFICATION_ERR:
msg += "INVALID_MODIFICATION_ERR";
break ;

case FileError.INVALID_STATE_ERR:
msg += "INVALID_STATE_ERR";
break ;

default:
msg += "Unknown Error";
break ;
}
if (!0) {
var err=((((((("Error:: " + msg) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(msg);

}


}

;

};
window.requestFileSystem = (window.requestFileSystem) || (window.webkitRequestFileSystem);
window.webkitStorageInfo.requestQuota(window.TEMPORARY, (32 * 1024) * 1024, function(nGrantedBytes) {
window.requestFileSystem(window.TEMPORARY, nGrantedBytes, function(pFs) {
me._pFileSystem = pFs;
if (pQueue.length) {
for (var i=0; i < (pQueue.length); ++i) {
pQueue[i](pFs);

}


}


}
, fnErrorHandler);

}
);

};
LocalFile.prototype._pFileSystem = new LocalFS();
LocalFile.prototype._fs = function(fn) {
this._pFileSystem.get(fn);

};
Object.defineProperty(LocalFile.prototype, "mode",  {set: function(pMode) {
this._eFileMode = ((typeof pMode) == "string"? a.io.stringTomode(pMode) : pMode);

}
, get: function() {
return this._eFileMode;

}
});
LocalFile.prototype._errorHandler = function(e) {
var msg="";
switch(e.code) {
case FileError.QUOTA_EXCEEDED_ERR:
msg += "QUOTA_EXCEEDED_ERR";
break ;

case FileError.NOT_FOUND_ERR:
msg += "NOT_FOUND_ERR";
break ;

case FileError.SECURITY_ERR:
msg += "SECURITY_ERR";
break ;

case FileError.INVALID_MODIFICATION_ERR:
msg += "INVALID_MODIFICATION_ERR";
break ;

case FileError.INVALID_STATE_ERR:
msg += "INVALID_STATE_ERR";
break ;

default:
msg += "Unknown Error";
break ;
}
if (!0) {
var err=((((((("Error:: " + msg) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(msg);

}


}

;

};
LocalFile.prototype.open = function() {
if (!(((arguments.length) >= 0) && ((arguments.length) < 5))) {
var err=((((((("Error:: " + (("Invalid number(" + (arguments.length)) + ") of parameters.")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("Invalid number(" + (arguments.length)) + ") of parameters."));

}


}

;
var fnSuccess, fnError, hasMode=(typeof (arguments[1])) != "function";
if ((arguments.length) < 3) {
if ((typeof (arguments[0])) == "string") {
this._pFileName = arguments[0];
fnSuccess = arguments[1];
fnError = null;

}
else if ((typeof (arguments[0])) == "number") {
this._eFileMode = arguments[0];
fnSuccess = arguments[1];
fnError = null;

}
else  {
fnSuccess = arguments[0];
fnError = (arguments[1]) || null;

}


if (!this._pFileName) {
var err=((((((("Error:: " + "No filename provided.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("No filename provided.");

}


}

;
this.open(this._pFileName, this._eFileMode, fnSuccess, fnError);
return ;

}

fnSuccess = arguments[(hasMode? 2 : 1)];
fnError = (arguments[(hasMode? 3 : 2)]) || null;
if (this.isOpened()) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "][") + "") + "]") + "file already opened.");
fnSuccess(this._pFile);

}

var me=this;
var pFileSystem=null;
this._pFileName = a.pathinfo(arguments[0]);
this._eFileMode = (hasMode? ((typeof (arguments[1])) == "string"? a.io.stringTomode(arguments[1]) : arguments[1]) : this._eFileMode);
var fnErrorHandler=function(e) {
var fn=(!fnError? me._errorHandler : fnError);
if (((e.code) == (FileError.NOT_FOUND_ERR)) && ((me._eFileMode & (1 << 1)) != 0)) {
LocalFile.createDir(pFileSystem.root, me._pFileName.dirname.split("/"), function() {
fnFSInited.apply(me, [pFileSystem]);

}
, function() {
fn.apply(me, arguments);

}
);

}
else  {
fn.apply(me, arguments);

}


};
var fnFSInited=function(pFs) {
if (!pFs) {
var err=((((((("Error:: " + "Local file system not initialized.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Local file system not initialized.");

}


}

;
pFileSystem = pFs;
pFs.root.getFile(this._pFileName,  {create: (this._eFileMode & (1 << 1)) != 0, exclusive: false}, function(fileEntry) {
me._pFileHandle = fileEntry;
fileEntry.file(function(file) {
me._pFile = file;
if (((me._eFileMode & (1 << 4)) != 0) && (me.size)) {
me.clear(function() {
fnSuccess.apply(me, [file]);

}
, fnError);
return ;

}

if ((me._eFileMode & (1 << 3)) != 0) {
me.position = me.size;

}

fnSuccess.apply(me, [file]);

}
, fnErrorHandler);

}
, fnErrorHandler);

};
this._fs(function(pFileSystem) {
fnFSInited.apply(me, [pFileSystem]);

}
);

};
Object.defineProperty(LocalFile.prototype, "path",  {get: function() {
if (!this._pFile) {
var err=((((((("Error:: " + "There is no file handle open.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is no file handle open.");

}


}

;
return this._pFileName.toString();

}
});
LocalFile.prototype.close = function() {
this._pFileName = null;
this._eFileMode = (1) | (2);
this._nLength = 0;
this._nSeek = 0;
 {
if (this._pFile) {
if (this._pFile.destructor) {
this._pFile.destructor();

}

delete this._pFile;
this._pFile = null;

}


};

};
LocalFile.prototype.clear = function(fnSuccess, fnError) {
if (!this._pFile) {
var err=((((((("Error:: " + "There is no file handle open") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is no file handle open");

}


}

;
var me=this;
me._pFileHandle.createWriter(function(pWriter) {
pWriter.seek(0);
if (fnSuccess) {
pWriter.onwriteend = function() {
fnSuccess.apply(me, arguments);

};

}

pWriter.truncate(0);

}
, function() {
var fn=fnError || (this._errorHandler);
fn.apply(me.arguments);

}
);

};
Object.defineProperty(LocalFile.prototype, "name",  {get: function() {
return this._pFileName.basename;

}
, set: function(sFileName) {
if (!(!(this._pFile))) {
var err=((((((("Error:: " + "There is file handle open.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is file handle open.");

}


}

;
this._pFileName.basename = sFileName;

}
});
LocalFile.prototype.isOpened = function() {
return (this._pFile? true : false);

};
LocalFile.prototype.write = function(pData, fnSuccess, fnError, sContentType) {
if (!(this._pFile)) {
var pArgs=arguments;
this.open(function() {
this.write.apply(this, pArgs);

}
, fnError || null);
return ;

}

;
var iMode=this._eFileMode;
if (!(iMode & (1 << 1)) != 0) {
var err=((((((("Error:: " + "The file is not writable.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The file is not writable.");

}


}

;
sContentType = sContentType || (((iMode & (1 << 5)) != 0? "application/octet-stream" : "text/plain"));
var me=this;
me._pFileHandle.createWriter(function(pWriter) {
pWriter.seek(me._nSeek);
pWriter.onerror = function() {
if (fnError) {
fnError.apply(me, arguments);

}
else  {
if (!0) {
var err=((((((("Error:: " + ("Write failed: " + (e.toString()))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("Write failed: " + (e.toString())));

}


}

;

}


};
if (fnSuccess) {
pWriter.onwriteend = function() {
if ((iMode & (1 << 5)) != 0) {
me.seek(pData.byteLength);

}
else  {
me.seek(pData.length);

}

fnSuccess.apply(me, arguments);

};

}

var bb=new Blob();
bb.append(pData);
pWriter.write(bb.getBlob(sContentType));

}
, function() {
(fnError || (this._errorHandler)).apply(me, arguments);

}
);

};
LocalFile.prototype.atEnd = function() {
this.position = this.size;

};
LocalFile.prototype.read = function(fnSuccess, fnError) {
if (!(this._eFileMode & (1 << 0)) != 0) {
var err=((((((("Error:: " + "The file is not readable.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The file is not readable.");

}


}

;
if (!(this._pFile)) {
var pArgs=arguments;
this.open(function() {
this.read.apply(this, pArgs);

}
, fnError || null);
return ;

}

;
var reader=this._pFileReader;
var me=this;
reader.onloadend = function(e) {
var pData=e.target.result;
var nPos=me._nSeek;
if (nPos) {
if ((me._eFileMode & (1 << 5)) != 0) {
pData = new Uint8Array(new Uint8Array(pData).subarray(nPos)).buffer;

}
else  {
pData = pData.substr(nPos);

}


}

me.atEnd();
fnSuccess.apply(me, [pData]);

};
if ((me._eFileMode & (1 << 5)) != 0) {
reader.readAsArrayBuffer(this._pFile);

}
else  {
reader.readAsText(this._pFile);

}


};
Object.defineProperty(LocalFile.prototype, "position",  {get: function() {
if (!this._pFile) {
var err=((((((("Error:: " + "There is no file handle open.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is no file handle open.");

}


}

;
return this._nSeek;

}
, set: function(iOffset) {
if (!this._pFile) {
var err=((((((("Error:: " + "There is no file handle open.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is no file handle open.");

}


}

;
this._nSeek = iOffset;

}
});
Object.defineProperty(LocalFile.prototype, "size",  {get: function() {
if (!this._pFile) {
var err=((((((("Error:: " + "There is no file handle open.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is no file handle open.");

}


}

;
return this._pFile.size;

}
});
LocalFile.prototype.seek = function(iOffset) {
if (!this._pFile) {
var err=((((((("Error:: " + "There is no file handle open.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is no file handle open.");

}


}

;
var nSeek=(this._nSeek) + iOffset;
if (nSeek < 0) {
nSeek = (this.size) - ((Math.abs(nSeek)) % (this.size));

}

if (!((nSeek >= 0) && (nSeek <= (this.size)))) {
var err=((((((("Error:: " + "Invalid offset parameter") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Invalid offset parameter");

}


}

;
this._nSeek = nSeek;

};
LocalFile.prototype.isExists = function(fnSuccess, fnError) {
var me=this;
this.open(function() {
fnSuccess(true);

}
, function(e) {
if ((e.code) == (FileError.NOT_FOUND_ERR)) {
fnSuccess.apply(me, [false]);

}
else  {
if (fnError) {
fnError.apply(me, arguments);

}
else  {
throw e;

}


}


}
);

};
LocalFile.prototype.move = function(pFileName, fnSuccess, fnError) {
var me=this;
this.copy(pFileName, function() {
me.remove(fnSuccess, fnError);

}
, fnError);

};
LocalFile.prototype.rename = function(pFileName, fnSuccess, fnError) {
var pName=a.pathinfo(pFileName);
if (!(!(pName.dirname))) {
var err=((((((("Error:: " + "only filename can be specified.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("only filename can be specified.");

}


}

;
this.move(((this._pFileName.sDirname) + "/") + (pName.basename), fnSuccess, fnError);

};
LocalFile.prototype.copy = function(pFileName, fnSuccess, fnError) {
var iMode=((1) | (2)) | (16);
if ((this._eFileMode & (1 << 5)) != 0) {
iMode |= 32;

}

var me=this;
var pFile=new LocalFile(pFileName, iMode, function() {
me.read(function(pData) {
pFile.write(pData, fnSuccess, fnError);

}
);

}
, fnError);

};
LocalFile.prototype.getMetadata = function(fnSuccess, fnError) {
if (!this._pFile) {
var err=((((((("Error:: " + "There is no file handle open.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There is no file handle open.");

}


}

;
fnSuccess( {lastModifiedDate: this._pFile.lastModifiedDate});

};
LocalFile.prototype.remove = function(fnSuccess, fnError) {
if (!(this._pFile)) {
var pArgs=arguments;
this.open(function() {
this.remove.apply(this, pArgs);

}
, fnError || null);
return ;

}

;
var me=this;
var fnErr=(fnError? function() {
fnError.apply(this, arguments);

}
 : undefined);
this._pFileHandle.remove(function() {
me.close();
if (fnSuccess) {
fnSuccess.apply(me, arguments);

}


}
, fnErr);

};
LocalFile.isSupported = function() {
return (window.requestFileSystem !== undefined) || (window.webkitRequestFileSystem !== undefined);

};
LocalFile.createDir = function(pRootDirEntry, pFolders, fnSuccess, fnError) {
if (((pFolders[0]) == ".") || ((pFolders[0]) == "")) {
pFolders = pFolders.slice(1);

}

pRootDirEntry.getDirectory(pFolders[0],  {create: true}, function(dirEntry) {
if (pFolders.length) {
a.LocalFile.createDir(dirEntry, pFolders.slice(1), fnSuccess, fnError);

}
else if (fnSuccess) {
fnSuccess();

}



}
, fnError || (function(e) {
if (!0) {
var err=((((((("Error:: " + (("createDir:: cannot create folder. error code(" + (e.code)) + ")")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("createDir:: cannot create folder. error code(" + (e.code)) + ")"));

}


}

;

}
));

};
LocalFile.copy = function(pRootDirEntry, sFrom, sTo, fnSuccess, fnError) {
pRootDirEntry.getFile(sFrom,  {}, function(fileEntry) {
pRootDirEntry.getDirectory(sTo,  {}, function(dirEntry) {
fileEntry.copyTo(dirEntry, fnSuccess, fnError);

}
, fnError || (function(e) {
if (!0) {
var err=((((((("Error:: " + (((("copy:: cannot get directory(" + sTo) + "). error code(") + (e.code)) + ")")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((((("copy:: cannot get directory(" + sTo) + "). error code(") + (e.code)) + ")"));

}


}

;

}
));

}
, fnError || (function(e) {
if (!0) {
var err=((((((("Error:: " + (((("copy:: cannot get file(" + sFrom) + "). error code(") + (e.code)) + ")")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/LocalFile.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((((("copy:: cannot get file(" + sFrom) + "). error code(") + (e.code)) + ")"));

}


}

;

}
));

};
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/files/File.js") + "][") + "") + "]") + "Not-thread remote file not implemented yet.");

}
else  {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/files/File.js") + "][") + "") + "]") + "Your browser not support local files.");

}


a.fopen = function(sUri) {
var pMode=(arguments[1]) || (1);
var pUri=a.uri(sUri);
if ((pUri.protocol) == "filesystem") {
pUriLocal = a.uri(pUri.path);
if (!(!((pUriLocal.protocol) && ((pUriLocal.host) != (a.info.uri.host))))) {
var err=((((((("Error:: " + "Поддерживаются только локальные файлы в пределах текущего домена.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/File.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Поддерживаются только локальные файлы в пределах текущего домена.");

}


}

;
var pFolders=pUriLocal.path.split("/");
if (((pFolders[0]) == "") || ((pFolders[0]) == ".")) {
pFolders = pFolders.slice(1);

}

if (!((pUri.host) == "temporary")) {
var err=((((((("Error:: " + "Поддерживаются только файловые системы типа \"temporary\".") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/files/File.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Поддерживаются только файловые системы типа \"temporary\".");

}


}

;
return new a.LocalFile(pFolders.join("/"), pMode);

}

return new a.RemoteFile(sUri, pMode);

};
function HashBase() {
"use strict";
this._eOptions = 0;
this._isHashObject = true;

}

HashBase.prototype.getOptions = function() {
"use strict";
return this._eOptions;

};
HashBase.prototype.getOption = function(eOption) {
"use strict";
return (this._eOptions & (1 << eOption)) != 0;

};
HashBase.prototype.setOption = function(eOption, bValue) {
"use strict";
(bValue? this._eOptions |= 1 << eOption : this._eOptions &= ~(1 << eOption));

};
HashBase.prototype.changeable = function(bValue) {
"use strict";
(bValue? this._eOptions |= 1 << 0 : this._eOptions &= ~(1 << 0));

};
HashBase.prototype.isChangeable = function() {
"use strict";
return (this._eOptions & (1 << 0)) != 0;

};
HashBase.prototype.setup = function(pData) {
"use strict";
return false;

};
a["HashBase"] = HashBase;
function StringHash() {
"use strict";
var _pCtorValue=StringHash.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._sHash = null;

}

a.extend(StringHash, a.HashBase);
StringHash.prototype.toString = function() {
"use strict";
return this._sHash;

};
StringHash.prototype.setup = function(sHash) {
"use strict";
if (((this._sHash) === null) || (this.isChangeable())) {
if (this.getOption(16)) {
sHash = sHash.md5();

}

this._sHash = sHash;
return true;

}

return false;

};
a["StringHash"] = StringHash;
function Unique() {
"use strict";
var sHash=this.computeHash(arguments);
var pHashMap=this.constructor._pHashMap;
if (!pHashMap) {
pHashMap = this.constructor._pHashMap =  {};

}
else if (pHashMap[sHash]) {
return pHashMap[sHash];

}


this._sHash = sHash;
pHashMap[sHash] = this;

}

a["Unique"] = Unique;
(function() {
function utf8_encode(argString) {
if ((argString === null) || ((typeof argString) === "undefined")) {
return "";

}

var string=argString + "";
var utftext="", start, end, stringl=0;
start = end = 0;
stringl = string.length;
for (var n=0; n < stringl; n++) {
var c1=string.charCodeAt(n);
var enc=null;
if (c1 < 128) {
end++;

}
else if ((c1 > 127) && (c1 < 2048)) {
enc = (String.fromCharCode((c1 >> 6) | 192)) + (String.fromCharCode((c1 & 63) | 128));

}
else  {
enc = ((String.fromCharCode((c1 >> 12) | 224)) + (String.fromCharCode(((c1 >> 6) & 63) | 128))) + (String.fromCharCode((c1 & 63) | 128));

}


if (enc !== null) {
if (end > start) {
utftext += string.slice(start, end);

}

utftext += enc;
start = end = n + 1;

}


}

if (end > start) {
utftext += string.slice(start, stringl);

}

return utftext;

}

function utf8_decode(str_data) {
var tmp_arr=[], i=0, ac=0, c1=0, c2=0, c3=0;
str_data += "";
while (i < (str_data.length)) {
c1 = str_data.charCodeAt(i);
if (c1 < 128) {
tmp_arr[ac++] = String.fromCharCode(c1);
i++;

}
else if ((c1 > 191) && (c1 < 224)) {
c2 = str_data.charCodeAt(i + 1);
tmp_arr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
i += 2;

}
else  {
c2 = str_data.charCodeAt(i + 1);
c3 = str_data.charCodeAt(i + 2);
tmp_arr[ac++] = String.fromCharCode((((c1 & 15) << 12) | ((c2 & 63) << 6)) | (c3 & 63));
i += 3;

}



}
return tmp_arr.join("");

}

;
String.prototype.toUTF8 = function() {
return utf8_encode(this);

};
String.prototype.fromUTF8 = function() {
return utf8_decode(this);

};
function md5(str) {
var xl, a, b, c, d, e;
var rotateLeft=function(lValue, iShiftBits) {
return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));

};
var addUnsigned=function(lX, lY) {
var lX4, lY4, lX8, lY8, lResult;
lX8 = lX & 2147483648;
lY8 = lY & 2147483648;
lX4 = lX & 1073741824;
lY4 = lY & 1073741824;
lResult = (lX & 1073741823) + (lY & 1073741823);
if (lX4 & lY4) {
return ((lResult ^ 2147483648) ^ lX8) ^ lY8;

}

if (lX4 | lY4) {
if (lResult & 1073741824) {
return ((lResult ^ 3221225472) ^ lX8) ^ lY8;

}
else  {
return ((lResult ^ 1073741824) ^ lX8) ^ lY8;

}


}
else  {
return (lResult ^ lX8) ^ lY8;

}


};
var _F=function(x, y, z) {
return (x & y) | ((~x) & z);

};
var _G=function(x, y, z) {
return (x & z) | (y & (~z));

};
var _H=function(x, y, z) {
return (x ^ y) ^ z;

};
var _I=function(x, y, z) {
return y ^ (x | (~z));

};
var _FF=function(a, b, c, d, x, s, ac) {
a = addUnsigned(a, addUnsigned(addUnsigned(_F(b, c, d), x), ac));
return addUnsigned(rotateLeft(a, s), b);

};
var _GG=function(a, b, c, d, x, s, ac) {
a = addUnsigned(a, addUnsigned(addUnsigned(_G(b, c, d), x), ac));
return addUnsigned(rotateLeft(a, s), b);

};
var _HH=function(a, b, c, d, x, s, ac) {
a = addUnsigned(a, addUnsigned(addUnsigned(_H(b, c, d), x), ac));
return addUnsigned(rotateLeft(a, s), b);

};
var _II=function(a, b, c, d, x, s, ac) {
a = addUnsigned(a, addUnsigned(addUnsigned(_I(b, c, d), x), ac));
return addUnsigned(rotateLeft(a, s), b);

};
var convertToWordArray=function(str) {
var lWordCount;
var lMessageLength=str.length;
var lNumberOfWords_temp1=lMessageLength + 8;
var lNumberOfWords_temp2=(lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
var lNumberOfWords=(lNumberOfWords_temp2 + 1) * 16;
var lWordArray=new Array(lNumberOfWords - 1);
var lBytePosition=0;
var lByteCount=0;
while (lByteCount < lMessageLength) {
lWordCount = (lByteCount - (lByteCount % 4)) / 4;
lBytePosition = (lByteCount % 4) * 8;
lWordArray[lWordCount] = (lWordArray[lWordCount]) | ((str.charCodeAt(lByteCount)) << lBytePosition);
lByteCount++;

}
lWordCount = (lByteCount - (lByteCount % 4)) / 4;
lBytePosition = (lByteCount % 4) * 8;
lWordArray[lWordCount] = (lWordArray[lWordCount]) | (128 << lBytePosition);
lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
return lWordArray;

};
var wordToHex=function(lValue) {
var wordToHexValue="", wordToHexValue_temp="", lByte, lCount;
for (lCount = 0; lCount <= 3; lCount++) {
lByte = (lValue >>> (lCount * 8)) & 255;
wordToHexValue_temp = "0" + (lByte.toString(16));
wordToHexValue = wordToHexValue + (wordToHexValue_temp.substr((wordToHexValue_temp.length) - 2, 2));

}

return wordToHexValue;

};
var x=[], k, AA, BB, CC, DD, a, b, c, d, S11=7, S12=12, S13=17, S14=22, S21=5, S22=9, S23=14, S24=20, S31=4, S32=11, S33=16, S34=23, S41=6, S42=10, S43=15, S44=21;
str = utf8_encode(str);
x = convertToWordArray(str);
a = 1732584193;
b = 4023233417;
c = 2562383102;
d = 271733878;
xl = x.length;
for (k = 0; k < xl; k += 16) {
AA = a;
BB = b;
CC = c;
DD = d;
a = _FF(a, b, c, d, x[k + 0], S11, 3614090360);
d = _FF(d, a, b, c, x[k + 1], S12, 3905402710);
c = _FF(c, d, a, b, x[k + 2], S13, 606105819);
b = _FF(b, c, d, a, x[k + 3], S14, 3250441966);
a = _FF(a, b, c, d, x[k + 4], S11, 4118548399);
d = _FF(d, a, b, c, x[k + 5], S12, 1200080426);
c = _FF(c, d, a, b, x[k + 6], S13, 2821735955);
b = _FF(b, c, d, a, x[k + 7], S14, 4249261313);
a = _FF(a, b, c, d, x[k + 8], S11, 1770035416);
d = _FF(d, a, b, c, x[k + 9], S12, 2336552879);
c = _FF(c, d, a, b, x[k + 10], S13, 4294925233);
b = _FF(b, c, d, a, x[k + 11], S14, 2304563134);
a = _FF(a, b, c, d, x[k + 12], S11, 1804603682);
d = _FF(d, a, b, c, x[k + 13], S12, 4254626195);
c = _FF(c, d, a, b, x[k + 14], S13, 2792965006);
b = _FF(b, c, d, a, x[k + 15], S14, 1236535329);
a = _GG(a, b, c, d, x[k + 1], S21, 4129170786);
d = _GG(d, a, b, c, x[k + 6], S22, 3225465664);
c = _GG(c, d, a, b, x[k + 11], S23, 643717713);
b = _GG(b, c, d, a, x[k + 0], S24, 3921069994);
a = _GG(a, b, c, d, x[k + 5], S21, 3593408605);
d = _GG(d, a, b, c, x[k + 10], S22, 38016083);
c = _GG(c, d, a, b, x[k + 15], S23, 3634488961);
b = _GG(b, c, d, a, x[k + 4], S24, 3889429448);
a = _GG(a, b, c, d, x[k + 9], S21, 568446438);
d = _GG(d, a, b, c, x[k + 14], S22, 3275163606);
c = _GG(c, d, a, b, x[k + 3], S23, 4107603335);
b = _GG(b, c, d, a, x[k + 8], S24, 1163531501);
a = _GG(a, b, c, d, x[k + 13], S21, 2850285829);
d = _GG(d, a, b, c, x[k + 2], S22, 4243563512);
c = _GG(c, d, a, b, x[k + 7], S23, 1735328473);
b = _GG(b, c, d, a, x[k + 12], S24, 2368359562);
a = _HH(a, b, c, d, x[k + 5], S31, 4294588738);
d = _HH(d, a, b, c, x[k + 8], S32, 2272392833);
c = _HH(c, d, a, b, x[k + 11], S33, 1839030562);
b = _HH(b, c, d, a, x[k + 14], S34, 4259657740);
a = _HH(a, b, c, d, x[k + 1], S31, 2763975236);
d = _HH(d, a, b, c, x[k + 4], S32, 1272893353);
c = _HH(c, d, a, b, x[k + 7], S33, 4139469664);
b = _HH(b, c, d, a, x[k + 10], S34, 3200236656);
a = _HH(a, b, c, d, x[k + 13], S31, 681279174);
d = _HH(d, a, b, c, x[k + 0], S32, 3936430074);
c = _HH(c, d, a, b, x[k + 3], S33, 3572445317);
b = _HH(b, c, d, a, x[k + 6], S34, 76029189);
a = _HH(a, b, c, d, x[k + 9], S31, 3654602809);
d = _HH(d, a, b, c, x[k + 12], S32, 3873151461);
c = _HH(c, d, a, b, x[k + 15], S33, 530742520);
b = _HH(b, c, d, a, x[k + 2], S34, 3299628645);
a = _II(a, b, c, d, x[k + 0], S41, 4096336452);
d = _II(d, a, b, c, x[k + 7], S42, 1126891415);
c = _II(c, d, a, b, x[k + 14], S43, 2878612391);
b = _II(b, c, d, a, x[k + 5], S44, 4237533241);
a = _II(a, b, c, d, x[k + 12], S41, 1700485571);
d = _II(d, a, b, c, x[k + 3], S42, 2399980690);
c = _II(c, d, a, b, x[k + 10], S43, 4293915773);
b = _II(b, c, d, a, x[k + 1], S44, 2240044497);
a = _II(a, b, c, d, x[k + 8], S41, 1873313359);
d = _II(d, a, b, c, x[k + 15], S42, 4264355552);
c = _II(c, d, a, b, x[k + 6], S43, 2734768916);
b = _II(b, c, d, a, x[k + 13], S44, 1309151649);
a = _II(a, b, c, d, x[k + 4], S41, 4149444226);
d = _II(d, a, b, c, x[k + 11], S42, 3174756917);
c = _II(c, d, a, b, x[k + 2], S43, 718787259);
b = _II(b, c, d, a, x[k + 9], S44, 3951481745);
a = addUnsigned(a, AA);
b = addUnsigned(b, BB);
c = addUnsigned(c, CC);
d = addUnsigned(d, DD);

}

var temp=(((wordToHex(a)) + (wordToHex(b))) + (wordToHex(c))) + (wordToHex(d));
return temp.toLowerCase();

}

;
function sha1(str) {
var rotate_left=function(n, s) {
var t4=(n << s) | (n >>> (32 - s));
return t4;

};
var cvt_hex=function(val) {
var str="";
var i;
var v;
for (i = 7; i >= 0; i--) {
v = (val >>> (i * 4)) & 15;
str += v.toString(16);

}

return str;

};
var blockstart;
var i, j;
var W=new Array(80);
var H0=1732584193;
var H1=4023233417;
var H2=2562383102;
var H3=271733878;
var H4=3285377520;
var A, B, C, D, E;
var temp;
str = utf8_encode(str);
var str_len=str.length;
var word_array=[];
for (i = 0; i < (str_len - 3); i += 4) {
j = ((((str.charCodeAt(i)) << 24) | ((str.charCodeAt(i + 1)) << 16)) | ((str.charCodeAt(i + 2)) << 8)) | (str.charCodeAt(i + 3));
word_array.push(j);

}

switch(str_len % 4) {
case 0:
i = 2147483648;
break ;

case 1:
i = ((str.charCodeAt(str_len - 1)) << 24) | 8388608;
break ;

case 2:
i = (((str.charCodeAt(str_len - 2)) << 24) | ((str.charCodeAt(str_len - 1)) << 16)) | 32768;
break ;

case 3:
i = ((((str.charCodeAt(str_len - 3)) << 24) | ((str.charCodeAt(str_len - 2)) << 16)) | ((str.charCodeAt(str_len - 1)) << 8)) | 128;
break ;
}
word_array.push(i);
while (((word_array.length) % 16) != 14) {
word_array.push(0);

}
word_array.push(str_len >>> 29);
word_array.push((str_len << 3) & 4294967295);
for (blockstart = 0; blockstart < (word_array.length); blockstart += 16) {
for (i = 0; i < 16; i++) {
W[i] = word_array[blockstart + i];

}

for (i = 16; i <= 79; i++) {
W[i] = rotate_left((((W[i - 3]) ^ (W[i - 8])) ^ (W[i - 14])) ^ (W[i - 16]), 1);

}

A = H0;
B = H1;
C = H2;
D = H3;
E = H4;
for (i = 0; i <= 19; i++) {
temp = (((((rotate_left(A, 5)) + ((B & C) | ((~B) & D))) + E) + (W[i])) + 1518500249) & 4294967295;
E = D;
D = C;
C = rotate_left(B, 30);
B = A;
A = temp;

}

for (i = 20; i <= 39; i++) {
temp = (((((rotate_left(A, 5)) + ((B ^ C) ^ D)) + E) + (W[i])) + 1859775393) & 4294967295;
E = D;
D = C;
C = rotate_left(B, 30);
B = A;
A = temp;

}

for (i = 40; i <= 59; i++) {
temp = (((((rotate_left(A, 5)) + (((B & C) | (B & D)) | (C & D))) + E) + (W[i])) + 2400959708) & 4294967295;
E = D;
D = C;
C = rotate_left(B, 30);
B = A;
A = temp;

}

for (i = 60; i <= 79; i++) {
temp = (((((rotate_left(A, 5)) + ((B ^ C) ^ D)) + E) + (W[i])) + 3395469782) & 4294967295;
E = D;
D = C;
C = rotate_left(B, 30);
B = A;
A = temp;

}

H0 = (H0 + A) & 4294967295;
H1 = (H1 + B) & 4294967295;
H2 = (H2 + C) & 4294967295;
H3 = (H3 + D) & 4294967295;
H4 = (H4 + E) & 4294967295;

}

temp = ((((cvt_hex(H0)) + (cvt_hex(H1))) + (cvt_hex(H2))) + (cvt_hex(H3))) + (cvt_hex(H4));
return temp.toLowerCase();

}

;
function crc32(str) {
str = utf8_encode(str);
var table="00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";
var crc=0;
var x=0;
var y=0;
crc = crc ^ (-1);
for (var i=0, iTop=str.length; i < iTop; i++) {
y = (crc ^ (str.charCodeAt(i))) & 255;
x = "0x" + (table.substr(y * 9, 8));
crc = (crc >>> 8) ^ x;

}

return crc ^ (-1);

}

;
String.prototype.md5 = function() {
return md5(this);

};
String.prototype.sha1 = function() {
return sha1(this);

};
String.prototype.crc32 = function() {
return crc32(this);

};
String.prototype.replaceAt = function(n, chr) {
return ((this.substr(0, n)) + chr) + (this.substr(n + (chr.length)));

};
Number.prototype.toHex = function(iLength) {
"use strict";
var sValue=this.toString(16);
for (var i=0; i < (iLength - (sValue.length)); ++i) {
sValue = "0" + sValue;

}

return sValue;

};
Object.defineProperty(Array.prototype, "last",  {enumerable: false, configurable: true, get: function() {
return this[(this.length) - 1];

}
, set: undefined});
Object.defineProperty(Array.prototype, "el",  {enumerable: false, configurable: true, value: function(i) {
i = i || 0;
return this[(i < 0? (this.length) + i : i)];

}
});
Object.defineProperty(Array.prototype, "clear",  {enumerable: false, configurable: true, value: function() {
this.length = 0;

}
});
Object.defineProperty(Array.prototype, "swap",  {enumerable: false, configurable: true, value: function(i, j) {
if ((i < (this.length)) && (j < (this.length))) {
var t=this[i];
this[i] = this[j];
this[j] = t;

}


}
});
Object.defineProperty(Array.prototype, "insert",  {enumerable: false, configurable: true, value: function(pElement) {
if ((typeof (pElement.length)) === "number") {
for (var i=0, n=pElement.length; i < n; ++i) {
this.push(pElement[i]);

}

;

}
else  {
this.push(pElement);

}

return this;

}
});
Number.prototype.printBinary = function(isPretty) {
var res="";
for (i = 0; i < 32; ++i) {
if ((i && ((i % 4) == 0)) && isPretty) {
res = " " + res;

}

(((this) >> i) & 1? res = "1" + res : res = "0" + res);

}

return res;

};
ArrayBuffer.prototype.toTypedArray = function(eType) {
switch(eType) {
case 5126:
return new Float32Array(this);

case 5122:
return new Int16Array(this);

case 5123:
return new Uint16Array(this);

case 5124:
return new Int32Array(this);

case 5125:
return new Uint32Array(this);

case 5120:
return new Int8Array(this);

default:
;

case 5121:
return new Uint8Array(this);
}

};

}
)();
function DebugWindow(sCaption) {
this.win = window.open("", (sCaption? sCaption : "console"), "width=640,height=230,resizable=no,scrollbars=yes,status=no,menubar=no,location=no");
this.win.focus();
var me=this;
window.onunload = function() {
me.win.close();

};
this.print("<!DOCTYPE html><html><head>", 1);
this.print(("<title>" + ((sCaption? sCaption : "console"))) + "</title>", 1);
this.print("</head>", 1);
this.print("<body id='log' style=\"text-align:left;padding: 2px;margin:0px;\">", 1);
this.print("</body></html>", 1);
this.log = this.win.document.getElementById("log");

}

;
DebugWindow.prototype.print = function(sData, isHtml) {
if (isHtml) {
this.win.document.write(sData);

}
else  {
this.log.innerHTML += sData + "<div style=\"border-top: 1px dotted #999;width:100%;margin:0px;\" ></div>";

}


};
a.DebugWindow = DebugWindow;
function ReferenceCounter() {
this._nReferenceCount = 0;

}

ReferenceCounter.prototype.destructor = function() {
if (!((this._nReferenceCount) == 0)) {
var err=((((((("Error:: " + "") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ReferenceCounter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("");

}


}

;

};
ReferenceCounter.prototype.addRef = function() {
if (!((this._nReferenceCount) != (Number.MAX_VALUE))) {
var err=((((((("Error:: " + "reference fail :(") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ReferenceCounter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("reference fail :(");

}


}

;
this._nReferenceCount++;
return this._nReferenceCount;

};
ReferenceCounter.prototype.release = function() {
if (!((this._nReferenceCount) > 0)) {
var err=((((((("Error:: " + "") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ReferenceCounter.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("");

}


}

;
this._nReferenceCount--;
return this._nReferenceCount;

};
ReferenceCounter.prototype.referenceCount = function() {
return this._nReferenceCount;

};
ReferenceCounter.prototype.eq = function(pSrc) {
return this;

};
a.ReferenceCounter = ReferenceCounter;
function BufferMap(pEngine) {
this._pEngine = pEngine;
this._pFlows = null;
this._pMappers = null;
this._pIndex = null;
this._nLength = 0;
this._ePrimitiveType = 4;
this._pCompleteFlows = null;
this._nCompleteFlows = 0;
this._nCompleteVideoBuffers = 0;
this._pCompleteVideoBuffers = null;
this._nUsedFlows = 0;
this._nStartIndex = 0;
this._pBuffersCompatibleMap = null;
this.reset();

}

a.extend(BufferMap, a.ReferenceCounter);
a.defineProperty(BufferMap, "primType", function() {
return (this._pIndex? this._pIndex.getPrimitiveType() : this._ePrimitiveType);

}
, function(eType) {
this._ePrimitiveType = eType;

}
);
a.defineProperty(BufferMap, "primCount", function() {
switch(this._ePrimitiveType) {
case 4:
return (this.length) / 3;

case 0:
return this.length;

case 5:
;
}
return undefined;

}
);
a.defineProperty(BufferMap, "index", function() {
return this._pIndex;

}
, function(pIndexData) {
if ((this._pIndex) === pIndexData) {
return ;

}

this.draw = this.drawElements = pIndexData.drawElements;
this._pIndex = pIndexData;
this.update();

}
);
a.defineProperty(BufferMap, "limit", function() {
return this._pFlows.length;

}
);
a.defineProperty(BufferMap, "length", function() {
return (this._pIndex? this._pIndex.getCount() : this._nLength);

}
, function(nLength) {
this._nLength = Math.min(this._nLength, nLength);

}
);
a.defineProperty(BufferMap, "startIndex", function() {
return this._nStartIndex;

}
);
a.defineProperty(BufferMap, "size", function() {
return this._nCompleteFlows;

}
);
a.defineProperty(BufferMap, "flows", function() {
return this._pCompleteFlows;

}
);
a.defineProperty(BufferMap, "mappers", function() {
return this._pMappers;

}
);
a.defineProperty(BufferMap, "offset", function() {
return (this._pIndex? this._pIndex.getOffset() : 0);

}
);
BufferMap.prototype.getFlow = function(iFlow, bComplete) {
"use strict";
bComplete = (bComplete === undefined? true : bComplete);
if ((typeof (arguments[0])) === "string") {
var nTotal;
var pFlows;
if (bComplete) {
pFlows = this._pCompleteFlows;
nTotal = this._nCompleteFlows;

}
else  {
pFlows = this._pFlows;
nTotal = this._pFlows.length;

}

for (var i=0; i < nTotal; ++i) {
if (!(pFlows[i].pData)) {
continue ;

}

if (pFlows[i].pData.hasSemantics(arguments[0])) {
return pFlows[i];

}


}

return null;

}

if (bComplete) {
for (var i=0, pFlows=this._pCompleteFlows; i < (this._nCompleteFlows); ++i) {
if ((pFlows[i].iFlow) == iFlow) {
return pFlows[i];

}


}

return null;

}

return this._pFlows[iFlow];

};
BufferMap.prototype.reset = function() {
this._pIndex = null;
this._ePrimitiveType = 4;
var pDevice=this._pEngine.pDevice;
var nFlowLimit=Math.min(16, a.info.graphics.maxVertexAttributes(pDevice));
this._pMappers = [];
this._pFlows = new Array(nFlowLimit);
for (var i=0; i < nFlowLimit; i++) {
this._pFlows[i] =  {iFlow: i, pData: null, eType: 0, pMapper: null};

}

this._nLength = 2147483647;
this._pCompleteFlows = new Array(nFlowLimit);
this._nCompleteFlows = 0;
this._nStartIndex = 2147483647;
this._pDevice = this._pEngine.pDevice;
this._pBuffersCompatibleMap =  {};
this._pCompleteVideoBuffers = new Array(nFlowLimit);
this._nCompleteVideoBuffers = 0;
this._nUsedFlows = 0;
this.draw = this.drawArrays;

};
BufferMap.prototype.flow = function(iFlow, pVertexData) {
"use strict";
var pFlow;
if ((arguments.length) < 2) {
pVertexData = arguments[0];
iFlow = this._nUsedFlows++;

}

pFlow = this._pFlows[iFlow];
if (!(iFlow < (this.limit))) {
var err=((((((("Error:: " + (("Invalid strem. Maximum allowable number of stream " + (this.limit)) + ".")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/BufferMap.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("Invalid strem. Maximum allowable number of stream " + (this.limit)) + "."));

}


}

;
if ((!pVertexData) || ((pFlow.pData) === pVertexData)) {
return -1;

}

if ((pVertexData.buffer) instanceof (a.VertexBuffer)) {
pFlow.eType = 0;
this.length = pVertexData.getCount();
if (!this.checkData(pVertexData)) {
var err=((((((("Error:: " + "You can use several unmappable data flows from one buffer.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/BufferMap.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You can use several unmappable data flows from one buffer.");

}


}

;
this._pushEtalon(pVertexData);

}
else  {
pFlow.eType = 1;

}

pFlow.pData = pVertexData;
return (this.update()? iFlow : -1);

};
BufferMap.prototype.checkData = function(pData) {
var pEtalon=this._pBuffersCompatibleMap[pData.resourceHandle()];
if ((!pEtalon) || ((pEtalon.offset) === (pData.offset))) {
return true;

}

return false;

};
BufferMap.prototype.findMapping = function(pMap, eSemantics, iAddition) {
if (!this.checkData(pMap)) {
var err=((((((("Error:: " + "You can use several different maps from one buffer.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/BufferMap.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You can use several different maps from one buffer.");

}


}

;
for (var i=0, pMappers=this._pMappers, pExistsMap; i < (pMappers.length); i++) {
pExistsMap = pMappers[i].pData;
if (pExistsMap === pMap) {
if (((pMappers[i].eSemantics) === eSemantics) && ((pMappers[i].iAddition) == iAddition)) {
return pMappers[i];

}


}
else  {
if (!((pExistsMap.getStartIndex()) === (pMap.getStartIndex()))) {
var err=((((((("Error:: " + "You can not use maps with different indexing") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/BufferMap.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You can not use maps with different indexing");

}


}

;

}


}

return null;

};
BufferMap.prototype.mapping = function(iFlow, pMap, eSemantics, iAddition) {
iAddition = iAddition || 0;
var pMapper=this.findMapping(pMap, eSemantics, iAddition);
var pFlow=this._pFlows[iFlow];
if (!((pFlow.pData) && ((pFlow.eType) === (1)))) {
var err=((((((("Error:: " + "Cannot mapping empty/unmappable flow.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/BufferMap.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Cannot mapping empty/unmappable flow.");

}


}

;
if (!pMap) {
var err=((((((("Error:: " + "Passed empty mapper.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/BufferMap.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Passed empty mapper.");

}


}

;
if (!eSemantics) {
eSemantics = pMap.getVertexDeclaration()[0].eUsage;

}
else if ((pMap.hasSemantics(eSemantics)) === false) {
if (!0) {
var err=((((((("Error:: " + (("Passed mapper does not have semantics: " + eSemantics) + ".")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/BufferMap.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("Passed mapper does not have semantics: " + eSemantics) + "."));

}


}

;
return false;

}


if (pMapper) {
if ((pFlow.pMapper) === pMapper) {
return (((pMapper.eSemantics) === eSemantics) && ((pMapper.iAddition) === iAddition)? true : false);

}


}
else  {
pMapper =  {pData: pMap, eSemantics: eSemantics, iAddition: iAddition};
this._pMappers.push(pMapper);
this.length = pMap.getCount();
this._pushEtalon(pMap);

}

pFlow.pMapper = pMapper;
return this.update();

};
BufferMap.prototype._pushEtalon = function(pData) {
"use strict";
this._pBuffersCompatibleMap[pData.resourceHandle()] = pData;

};
BufferMap.prototype.update = function() {
"use strict";
var pFlows=this._pFlows;
var pFlow, pMapper;
var isMappable=false;
var pCompleteFlows=this._pCompleteFlows;
var nCompleteFlows=0;
var pCompleteVideoBuffers=this._pCompleteVideoBuffers;
var nCompleteVideoBuffers=0;
var nUsedFlows=0;
var pVideoBuffer;
var isVideoBufferAdded=false;
var nStartIndex=2147483647, nCurStartxIndex;
for (var i=0; i < (pFlows.length); i++) {
pFlow = pFlows[i];
pMapper = pFlow.pMapper;
isMappable = (pFlow.eType) === (1);
if (pFlow.pData) {
nUsedFlows++;

}

if (((pFlow.pData) === null) || (isMappable && (pMapper === null))) {
continue ;

}

pCompleteFlows[nCompleteFlows++] = pFlow;
if (isMappable) {
nCurStartxIndex = pMapper.pData.getStartIndex();
pVideoBuffer = pFlow.pData.buffer;
for (var j=0; j < nCompleteVideoBuffers; j++) {
if ((pCompleteVideoBuffers[j]) === pVideoBuffer) {
isVideoBufferAdded = true;
break ;

}


}

if (!isVideoBufferAdded) {
pCompleteVideoBuffers[nCompleteVideoBuffers++] = pVideoBuffer;

}


}
else  {
nCurStartxIndex = pFlow.pData.getStartIndex();

}

if (nStartIndex === 2147483647) {
nStartIndex = nCurStartxIndex;
continue ;

}

if (!(nStartIndex == nCurStartxIndex)) {
var err=((((((("Error:: " + "You can not use a maps or unmappable buffers having different starting index.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/BufferMap.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You can not use a maps or unmappable buffers having different starting index.");

}


}

;

}

this._nStartIndex = nStartIndex;
this._nCompleteFlows = nCompleteFlows;
this._nCompleteVideoBuffers = nCompleteVideoBuffers;
this._nUsedFlows = nUsedFlows;
return true;

};
BufferMap.prototype.draw = function() {

};
BufferMap.prototype.drawElements = function() {

};
BufferMap.prototype.drawArrays = function() {
this._pDevice.drawArrays(this._ePrimitiveType, this._nStartIndex, this._nLength);

};
BufferMap.prototype.clone = function(bWithMapping) {
"use strict";
bWithMapping = (bWithMapping === undefined? true : bWithMapping);
var pMap=new a.BufferMap(this._pEngine);
for (var i=0, pFlows=this._pFlows; i < (pFlows.length); ++i) {
if ((pFlows[i].pData) === null) {
continue ;

}

if ((pMap.flow(pFlows[i].iFlow, pFlows[i].pData)) < 0) {
pMap = null;
return null;

}

if (!bWithMapping) {
continue ;

}

if (pFlows[i].pMapper) {
pMap.mapping(pFlows[i].iFlow, pFlows[i].pMapper.pData, pFlows[i].pMapper.eSemantics, pFlows[i].pMapper.iAddition);

}


}

return pMap;

};
BufferMap.prototype.toString = function() {
"use strict";
function _an(sValue, n, bBackward) {
sValue = String(sValue);
bBackward = bBackward || false;
if ((sValue.length) < n) {
for (var i=0, l=sValue.length; i < (n - l); ++i) {
if (!bBackward) {
sValue += " ";

}
else  {
sValue = " " + sValue;

}


}


}

return sValue;

}

var s="\n\n", t;
s += "      Complete Flows     : OFFSET / SIZE   |   BUFFER / OFFSET   :      Mapping  / Shift    : OFFSET |    Additional    \n";
t = "-------------------------:-----------------+---------------------:--------------------------:--------+------------------\n";
s += t;
for (var i=0; i < (this._nCompleteFlows); ++i) {
var pFlow=this._pCompleteFlows[i];
var pMapper=pFlow.pMapper;
var pVertexData=pFlow.pData;
var pDecl=pVertexData.getVertexDeclaration();
s += ((((((((((((("#" + (_an(pFlow.iFlow, 2))) + " ") + (_an(("[ " + (((pDecl[0].eUsage) !== ("\u000D")? pDecl[0].eUsage : "<end>"))) + " ]", 20))) + " : ") + (_an(pDecl[0].iOffset, 6, true))) + " / ") + (_an(pDecl[0].iSize, 6))) + " | ") + (_an(pVertexData.resourceHandle(), 8, true))) + " / ") + (_an(pVertexData.getOffset(), 8))) + " : ") + ((pMapper? ((((_an(pMapper.eSemantics, 15, true)) + " / ") + (_an(pMapper.iAddition, 7))) + ": ") + (_an(pMapper.pData.getVertexDeclaration().element(pMapper.eSemantics).iOffset, 6)) : ((_an("-----", 25)) + ": ") + (_an("-----", 6))))) + " |                  \n";
for (var j=1; j < (pDecl.length); ++j) {
s += ((((("    " + (_an(("[ " + (((pDecl[j].eUsage) !== ("\u000D")? pDecl[j].eUsage : "<end>"))) + " ]", 20))) + " : ") + (_an(pDecl[j].iOffset, 6, true))) + " / ") + (_an(pDecl[j].iSize, 6))) + " |                     :                          :        |                  \n";

}

s += t;

}

;
s += "=================================================================\n";
s += (("      PRIMITIVE TYPE : " + "0x") + (this.primType.toString(16))) + "\n";
s += ("     PRIMITIVE COUNT : " + (this.primCount)) + "\n";
s += ("         START INDEX : " + (this.startIndex)) + "\n";
s += ("              LENGTH : " + (this.length)) + "\n";
s += ("  USING INDEX BUFFER : " + ((this.index? "TRUE" : "FALSE"))) + "\n";
s += "=================================================================\n";
return s + "\n\n";

};
a["BufferMap"] = BufferMap;
function ObjModel() {
this._pVertices = [];
this._pNormals = [];
this._pFaces = [];
this._pTextureCoords = [];
this._pIndexes = [];
this._pTextureIndexes = [];
this._pNormalIndexes = [];
this._isObjectHasUV = false;
this._isObjectHasNormals = false;
this._isPolyReaded = false;
this._pModel =  {};

}

ObjModel.prototype.load = function(sFilename, fnCallback) {
if (!sFilename) {
return ;

}

var me=this;
a.fopen(sFilename).read(function(pData) {
me.parse(pData);
if (!(me._pIndexes.length)) {
me._fillIndexes();

}

if (!(me._pNormals.length)) {
me.calcNormals();

}

me._isObjectHasNormals = true;
if (me._pTextureCoords.length) {
me._isObjectHasUV = true;

}

fnCallback.call(me, true);

}
, function() {
fnCallback.call(me, false);

}
);

};
ObjModel.prototype.hasNormals = function() {
return this._isObjectHasNormals;

};
ObjModel.prototype.hasTexCoords = function() {
return this._isObjectHasUV;

};
ObjModel.prototype.parse = function(pData) {
var c, p=0;
pData = pData.split("\n");
while (p != (pData.length)) {
c = pData[p].charAt(0);
switch(c) {
case "v":
if (this._isPolyReaded) {
this._fillInObjectInfo();

}

this._readVertexInfo(pData[p]);
break ;

case "f":
this._readFaceInfo(pData[p]);
break ;
}
p++;

}

};
ObjModel.prototype._fillIndexes = function() {
for (var i=0; i < (this._pVertices.length); ++i) {
this._pIndexes[i] = i;

}


};
ObjModel.prototype._readVertexInfo = function(s) {
var ch=s.charAt(1), pm;
if (ch == " ") {
pm = s.match(/^v[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)([\s]+[-+]?[\d]*[\.|\,]?[\de-]*?)?[\s]*$/i);
this._correctIndex(pm);
this._pVertices.push(pm[1], pm[2], pm[3]);

}
else if (ch == "t") {
pm = s.match(/^vt[\s]+([-+]?[\d]*[\.|\,][\d]*?)[\s]+([-+]?[\d]*[\.|\,][\d]*?)[\s]*.*$/i);
this._correctIndex(pm);
this._pTextureCoords.push(pm[1], pm[2]);
this._isObjectHasUV = true;

}
else if (ch == "n") {
pm = s.match(/^vn[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]*$/i);
this._correctIndex(pm);
this._pNormals.push(pm[1], pm[2], pm[3]);
this._isObjectHasNormals = true;

}




};
ObjModel.prototype._correctIndex = function(pm, d) {
d = d || 0;
for (var i=1; i < (pm.length); ++i) {
if (pm[i]) {
pm[i] = (parseFloat(pm[i].replace(/,/g, "."))) - d;

}


}


};
ObjModel.prototype._readFaceInfo = function(s) {
var pm;
if ((this._isObjectHasUV) && (!(this._isObjectHasNormals))) {
pm = s.match(/^f[\s]+([\d]+)\/([\d]*)[\s]+([\d]+)\/([\d]*)[\s]+([\d]+)\/([\d]*)[\s]*$/i);
this._correctIndex(pm, 1);
this._pIndexes.push(pm[1], pm[3], pm[5]);
this._pTextureIndexes.push(pm[2], pm[4], pm[6]);

}
else if ((!(this._isObjectHasUV)) && (this._isObjectHasNormals)) {
pm = s.match(/^f[\s]+([\d]+)\/\/([\d]*)[\s]+([\d]+)\/\/([\d]*)[\s]+([\d]+)\/\/([\d]*)[\s]*$/i);
if (!pm) {
this._isObjectHasNormals = false;
this._readFaceInfo(s);
return ;

}

this._correctIndex(pm, 1);
this._pIndexes.push(pm[1], pm[3], pm[5]);
this._pNormalIndexes.push(pm[2], pm[4], pm[6]);

}
else if ((this._isObjectHasUV) && (this._isObjectHasNormals)) {
pm = s.match(/^f[\s]+([\d]+)\/([\d]*)\/([\d]*)[\s]+([\d]+)\/([\d]*)\/([\d]*)[\s]+([\d]+)\/([\d]*)\/([\d]*)[\s]*$/i);
this._correctIndex(pm, 1);
this._pIndexes.push(pm[1], pm[4], pm[7]);
this._pTextureIndexes.push(pm[2], pm[5], pm[8]);
this._pNormalIndexes.push(pm[3], pm[6], pm[9]);

}
else  {
pm = s.match(/^f[\s]+([\d]+)[\s]+([\d]+)[\s]+([\d]+)[\s]*$/i);
this._correctIndex(pm, 1);
this._pIndexes.push(pm[1], pm[2], pm[3]);

}



this._pFaces.push(pm.slice(1));
this._isPolyReaded = true;

};
ObjModel.prototype._fillInObjectInfo = function(model) {

};
ObjModel.prototype.getVertices = function() {
return this._pVertices;

};
ObjModel.prototype.getNormals = function() {
return this._pNormals;

};
ObjModel.prototype.getIndexes = function() {
return this._pIndexes;

};
ObjModel.prototype.getFaces = function() {
return this._pFaces;

};
ObjModel.prototype.calcNormals = function(useSmoothing) {
useSmoothing = useSmoothing || true;
var v=new Array(3), p=new Vec3(), q=new Vec3(), i, j, n=new Vec3(), k;
for (i = 0; i < (this._pVertices.length); ++i) {
this._pNormals[i] = 0;

}

for (i = 0; i < (this._pIndexes.length); i += 3) {
for (k = 0; k < 3; ++k) {
j = (this._pIndexes[i + k]) * 3;
v[k] = Vec3.create([this._pVertices[j], this._pVertices[j + 1], this._pVertices[j + 2]]);

}

Vec3.subtract(v[1], v[2], p);
Vec3.subtract(v[0], v[2], q);
Vec3.cross(p, q, n);
Vec3.normalize(n);
for (k = 0; k < 3; ++k) {
j = (this._pIndexes[i + k]) * 3;
this._pNormals[j] = n[0];
this._pNormals[j + 1] = n[1];
this._pNormals[j + 2] = n[2];

}


}

this._isObjectHasNormals = true;

};
a.loadMeshFromOBJ = function(pEngine, sFilename, eMeshOptions, fnCallback) {
if (!(eMeshOptions == 0)) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/utils/ObjModel.js") + "][") + "") + "]") + "loadMeshFromOBJ:: Опции еще не поддерживаются");

}

;
var pModel=new a.ObjModel();
pModel.load(sFilename, function(isLoaded) {
if (!isLoaded) {
fnCallback(null);

}

var name=a.pathinfo(sFilename).filename;
var pMesh=new a.Mesh(pEngine);
var sTempName=(("obj_model_" + name) + "_") + (a.sid());
var pVertexBuffer=pEngine.displayManager().vertexBufferPool().createResource(sTempName);
var pIndexBuffer=pEngine.displayManager().indexBufferPool().createResource(sTempName);
var pVertexDescription=[new a.VertexDeclaration(3, "POSITION", 5126, "POSITION")];
var pVertices=this.getVertices();
var pIndexes=this.getIndexes();
var pNormals=null;
var pTexCoords=null;
var iStride=3;
var count=(pVertices.length) / 3;
var iElSize=a.getTypeSize(5126);
var nFaces=this.getFaces().length;
if (this.hasNormals()) {
pVertexDescription.push(new a.VertexDeclaration(3, "NORMAL", 5126, "NORMAL"));
pNormals = this.getNormals();
iStride += 3;

}

if (this.hasTexCoords()) {
pVertexDescription.push(new a.VertexDeclaration(2, "TEXCOORD", 5126, "TEXCOORD"));
pTexCoords = this.getTexCoords();
iStride += 2;

}

if (!(this.hasTexCoords())) {
pVertexDescription.push(new a.VertexDeclaration(2, "TEXCOORD", 5126, "TEXCOORD"));
pTexCoords = [];
for (var i=0; i < (count / 100); ++i) {
for (var j=0; j < 100; ++j) {
pTexCoords.push(i / (count / 100));
pTexCoords.push(j / 100);

}


}

iStride += 2;

}

var pData=new Float32Array(count * iStride);
var i, j, n;
for (i = 0, n = 0; i < count; ++i) {
for (var j=0; j < 3; ++j) {
pData[n] = pVertices[(i * 3) + j];
++n;

}

if (pNormals) {
for (j = 0; j < 3; ++j) {
pData[n] = pNormals[(i * 3) + j];
++n;

}


}

if (pTexCoords) {
for (j = 0; j < 2; ++j) {
pData[n] = pTexCoords[(i * 3) + j];
++n;

}


}


}

;
pVertexBuffer.create(count, iStride * iElSize, 1 << a.VertexBuffer.RamBackupBit, pData);
pVertexBuffer.setVertexDescription(pVertexDescription);
pIndexBuffer.create(5, pIndexes.length, 1 << 3, pIndexes, 2);
pMesh._nFaces = nFaces;
pMesh._nVertices = count;
pMesh._eOptions = eMeshOptions;
pMesh._pVertexBuffer = pVertexBuffer;
pMesh._pIndexBuffer = pIndexBuffer;
pMesh._pVertexDeclaration = pVertexDescription;
pMesh._pAreaTable = [new a.MeshArea(0, 0, nFaces, 0, count)];
pMesh._nBytesPerVertex = iStride * iElSize;
fnCallback(pMesh);

}
);

};
a.createFrameFromOBJMesh = function(pMesh, sName) {
var pFrame=new a.Frame(sName);
var pMeshContainer=new a.MeshContainer();
pMeshContainer.create(sName, new a.MeshData(a.MESHDATATYPE.MESH, pMesh), null, null, null);
pFrame.pMeshContainer = pMeshContainer;
return pFrame;

};
a.ObjModel = ObjModel;
function COLLADA(pEngine, pSettings) {
var sFilename=(pSettings.file) || null;
var sContent=(pSettings.content) || null;
var fnCallback=(pSettings.success) || null;
var useSharedBuffer=(pSettings.sharedBuffer === undefined? false : pSettings.sharedBuffer);
var useAnimation=(pSettings.animation === undefined? true : pSettings.animation);
var useScene=(pSettings.scene === undefined? true : pSettings.scene);
var useWireframe=(pSettings.wireframe === undefined? false : pSettings.wireframe);
var bDrawJoints=(pSettings.drawJoints === undefined? false : pSettings.drawJoints);
var pModelResource=(pSettings.modelResource === undefined? null : pSettings.modelResource);
var bAnimationWithPose=(pSettings.animationWithPose === undefined? false : pSettings.animationWithPose);
var bExtractInitialPoses=(pSettings.extractPoses === undefined? false : pSettings.extractPoses);
var pPoseSkeletons=(pSettings.skeletons === undefined? null : pSettings.skeletons);
var sBasename=(sFilename? a.pathinfo(sFilename).filename : "unknown");
var pSupportedVertexFormat=[ {sName: "X", sType: "float"},  {sName: "Y", sType: "float"},  {sName: "Z", sType: "float"}];
var pSupportedTextureFormat=[ {sName: "S", sType: "float"},  {sName: "T", sType: "float"},  {sName: "P", sType: "float"}];
var pSupportedWeightFormat=[ {sName: "WEIGHT", sType: "float"}];
var pSupportedJointFormat=[ {sName: "JOINT", sType: ["Name", "IDREF"]}];
var pSupportedInvBindMatrixFormat=[ {sName: "TRANSFORM", sType: "float4x4"}];
var pSupportedInterpolationFormat=[ {sName: "INTERPOLATION", sType: "Name"}];
var pSupportedInputFormat=[ {sName: "TIME", sType: "float"}];
var pSupportedOutputFormat=[ {sName: ["TRANSFORM", "X", "ANGLE", null], sType: ["float4x4", "float"]},  {sName: "Y", sType: "float"},  {sName: "Z", sType: "float"}];
var pSupportedTangentFormat=[ {sName: "X", sType: "float"},  {sName: "Y", sType: "float"},  {sName: "X", sType: "float"},  {sName: "Y", sType: "float"},  {sName: "X", sType: "float"},  {sName: "Y", sType: "float"},  {sName: "X", sType: "float"},  {sName: "Y", sType: "float"},  {sName: "X", sType: "float"},  {sName: "Y", sType: "float"}];
var pFormatStrideTable= {"float": 1, "float2": 2, "float3": 3, "float4": 4, "float3x3": 9, "float4x4": 16, "int": 1, "name": 1, "Name": 1, "IDREF": 1};
var pConvFormats= {"int": [Int32Array, string2IntArray], "float": [Float32Array, string2FloatArray], "bool": [Array, string2BoolArray], "string": [Array, string2StringArray]};
var pLinks= {};
var pLib= {};
var pCache= {"@mesh":  {}, "@sharedBuffer": null};
var pSceneTemplate=[ {sLib: "library_images", sElement: "image", fn: COLLADAImage},  {sLib: "library_effects", sElement: "effect", fn: COLLADAEffect},  {sLib: "library_materials", sElement: "material", fn: COLLADAMaterial},  {sLib: "library_geometries", sElement: "geometry", fn: COLLADAGeometrie},  {sLib: "library_controllers", sElement: "controller", fn: COLLADAController},  {sLib: "library_visual_scenes", sElement: "visual_scene", fn: COLLADAVisualScene}];
var pAnimationTemplate=[ {sLib: "library_animations", sElement: "animation", fn: COLLADAAnimation}];
function getSupportedFormat(sSemantic) {
switch(sSemantic) {
case "TEXTANGENT":
;

case "TEXBINORMAL":
;

case "VERTEX":
;

case "NORMAL":
;

case "TANGENT":
;

case "BINORMAL":
;

case "POSITION":
return pSupportedVertexFormat;

case "TEXCOORD":
return pSupportedTextureFormat;

case "WEIGHT":
return pSupportedWeightFormat;

case "JOINT":
return pSupportedJointFormat;

case "INV_BIND_MATRIX":
return pSupportedInvBindMatrixFormat;

case "INTERPOLATION":
return pSupportedInterpolationFormat;

case "IN_TANGENT":
return pSupportedTangentFormat;

case "INPUT":
return pSupportedInputFormat;

case "OUT_TANGENT":
return pSupportedTangentFormat;

case "OUTPUT":
return pSupportedOutputFormat;

case "UV":
;

case "MORPH_WEIGHT":
;

case "MORPH_TARGET":
;

case "LINEAR_STEPS":
;

case "IMAGE":
;

case "CONTINUITY":
;

case "COLOR":
return null;
}
if (!0) {
var err=((((((("Error:: " + ("unknown semantics founded: " + sSemantic)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("unknown semantics founded: " + sSemantic));

}


}

;
return null;

}

function sharedBuffer(pBuffer) {
"use strict";
if (pBuffer) {
pCache["@sharedBuffer"] = pBuffer;

}

return (useSharedBuffer? pCache["@sharedBuffer"] : null);

}

function calcFormatStride(pFormat) {
var iStride=0;
var s=0;
for (var i=0; i < (pFormat.length); ++i) {
s = ((typeof (pFormat[i].sType)) === "string"? pFormat[i].sType : pFormat[i].sType[0]);
iStride += pFormatStrideTable[s];

}

return iStride;

}

function link(id, pTarget) {
if ((typeof id) !== "string") {
pTarget = id;
id = pTarget.id;

}

pLinks["#" + id] = pTarget;

}

function source(key) {
if ((key.charAt(0)) !== "#") {
key = "#" + key;

}

var pElement=pLinks[key];
if (!pElement) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "][") + "") + "]") + ("cannot find element with id: " + key));

}

return pElement || null;

}

function target(sPath) {
var iPos;
var pObject= {pValue: null};
var pSource;
var pValue;
var pMatches;
var jPos=0;
iPos = sPath.lastIndexOf("/");
if (iPos >= 0) {
pObject.pSource = source(sPath.substr(0, iPos));

}

iPos = sPath.lastIndexOf(".");
if (iPos < 0) {
iPos = sPath.indexOf("(");
jPos = -1;

}

if (iPos < 0) {
pObject.pObject = source(sPath);
return pObject;

}

pSource = source(sPath.substr(0, iPos));
sValue = sPath.substr((iPos + jPos) + 1);
pObject.pObject = pSource;
if (!pSource) {
return null;

}

switch(sValue) {
case "X":
pObject.pValue = pSource.pValue[0];
break ;

case "Y":
pObjec.pValue = pSource.pValue[1];
break ;

case "Z":
pObject.pValue = pSource.pValue[2];
break ;

case "W":
pObject.pValue = pSource.pValue[3];
break ;

case "ANGLE":
pObject.pValue = pSource.pValue.pData[0];
break ;
}
if (pObject.pValue) {
return pObject;

}

pMatches = sValue.match(/^\((\d+)\)$/);
if (pMatches) {
pObject.pValue = Number(pMatches[1]);

}

pMatches = sValue.match(/^\((\d+)\)\((\d+)\)$/);
if (pMatches) {
pObject.pValue = ((Number(pMatches[1])) * 4) + (Number(pMatches[2]));

}

if (!((pObject.pValue) !== undefined)) {
var err=((((((("Error:: " + ("unsupported target value founded: " + sValue)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("unsupported target value founded: " + sValue));

}


}

;
return pObject;

}

function printArray(pArr, nRow, nCol) {
var s="\n";
for (var i=0; i < (pArr.length); ++i) {
if ((i % nCol) == 0) {
s += "  ";

}

s += (pArr[i]) + ", ";
if (((i + 1) % nRow) == 0) {
s += "\n";

}


}

return s;

}

function parseBool(sValue) {
return sValue === "true";

}

function retrieve(pSrc, pDst, iStride, iFrom, iCount, iOffset, iLen) {
iStride = iStride || 1;
iOffset = iOffset || 0;
iLen = iLen || (iStride - iOffset);
iFrom = iFrom || 0;
iCount = iCount || (((pSrc.length) / iStride) - iFrom);
if ((iOffset + iLen) > iStride) {
iLen = iStride - iOffset;

}

var iBegin=iFrom * iStride;
var n=0;
for (var i=0; i < iCount; ++i) {
for (var j=0; j < iLen; ++j) {
pDst[n++] = pSrc[((iBegin + (i * iStride)) + iOffset) + j];

}


}

return n;

}

function string2Array(sData, ppData, fnConv, iFrom) {
fnConv = fnConv || parseFloat;
iFrom = iFrom || 0;
var pData=sData.split(/[\s]+/g);
for (var i=0, n=pData.length, j=0; i < n; ++i) {
if ((pData[i]) != "") {
ppData[iFrom + j] = fnConv(pData[i]);
j++;

}


}

return n;

}

function string2FloatArray(sData, ppData, iFrom) {
return string2Array(sData, ppData, parseFloat, iFrom);

}

function string2IntArray(sData, ppData, iFrom) {
return string2Array(sData, ppData, parseInt, iFrom);

}

function string2BoolArray(sData, ppData, iFrom) {
return string2Array(sData, ppData, parseBool, iFrom);

}

function string2StringArray(sData, ppData, iFrom) {
return string2Array(sData, ppData, String, iFrom);

}

function eachChild(pXML, fnCallback) {
eachNode(pXML.childNodes, fnCallback);

}

function eachByTag(pXML, sTag, fnCallback, nMax) {
eachNode(pXML.getElementsByTagName(sTag), fnCallback, nMax);

}

function eachNode(pXMLList, fnCallback, nMax) {
var n=pXMLList.length;
nMax = (nMax? (nMax < n? nMax : n) : n);
var n=0, i=0;
while (n < (pXMLList.length)) {
if ((pXMLList[n++].nodeType) === 3) {
continue ;

}

var pXMLData=pXMLList[n - 1];
fnCallback(pXMLData, pXMLData.nodeName);
i++;
if (nMax === i) {
break ;

}


}

}

function firstChild(pXML, sTag) {
if (!sTag) {
for (var i=0; i < (pXML.childNodes.length); i++) {
if ((pXML.childNodes[i].nodeType) === 1) {
return pXML.childNodes[i];

}


}


}

return pXML.getElementsByTagName(sTag)[0];

}

function stringData(pXML) {
return (pXML? pXML.textContent : null);

}

function attr(pXML, sName) {
return pXML.getAttribute(sName);

}

function sortArrayByProperty(pData, pProperty) {
pProperty = pProperty || 0;
var tmp;
for (var i=(pData.length) - 1; i > 0; i--) {
for (var j=0; j < i; j++) {
if ((pData[j][pProperty]) > (pData[j + 1][pProperty])) {
tmp = pData[j];
pData[j] = pData[j + 1];
pData[j + 1] = tmp;

}


}


}

return pData;

}

function lastElement(pInput) {
return pInput[(pInput.length) - 1];

}

function COLLADATransform(pXML, id) {
var pTransform= {sid: attr(pXML, "sid"), pValue: null, sName: String(pXML.nodeName)};
if (id && (pTransform.sid)) {
link((id + "/") + (pTransform.sid), pTransform);

}
else  {
link((id + "/") + (pTransform.sName), pTransform);

}

var v4f, m4f;
switch(pTransform.sName) {
case "rotate":
v4f = new Vec4();
string2FloatArray(stringData(pXML), v4f.pData);
v4f.w *= (Math.PI) / 180;
pTransform.pValue = v4f;
break ;

case "translate":
;

case "scale":
pTransform.pValue = new Vec3();
string2FloatArray(stringData(pXML), pTransform.pValue.pData);
break ;

case "matrix":
m4f = new Mat4();
string2FloatArray(stringData(pXML), m4f.pData);
m4f.transpose();
pTransform.pValue = m4f;
break ;

default:
if (!0) {
var err=((((((("Error:: " + ("unsupported transform detected: " + sName)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("unsupported transform detected: " + sName));

}


}

;
}
return pTransform;

}

function COLLADAScaleMatrix(pXML) {
var v3fScale=new Vec3();
string2FloatArray(stringData(pXML), v3fScale.pData);
return new Mat4(v3fScale.x, v3fScale.y, v3fScale.z, 1);

}

function COLLADATranslateMatrix(pXML) {
var v3fTranslate=new Vec3();
string2FloatArray(stringData(pXML), v3fTranslate.pData);
return v3fTranslate.toTranslationMatrix();

}

function COLLADARotateMatrix(pXML) {
var v4f=new Vec4();
var m4f=new Mat4(1);
string2FloatArray(stringData(pXML), v4f.pData);
return m4f.rotate(((v4f.w) * (Math.PI)) / 180, v4f);

}

function COLLADASampler2D(pXML) {
var pSampler= {sSource: stringData(firstChild(pXML, "source")), sWrapS: stringData(firstChild(pXML, "wrap_s")), sWrapT: stringData(firstChild(pXML, "wrap_t")), sMinFilter: stringData(firstChild(pXML, "minfilter")), sMipFilter: stringData(firstChild(pXML, "mipfilter")), sMagFilter: stringData(firstChild(pXML, "magfilter"))};
return pSampler;

}

function COLLADASurface(pXML) {
var pSurface= {sInitFrom: stringData(firstChild(pXML, "init_from"))};
return pSurface;

}

function COLLADAData(pXML) {
var sName=pXML.nodeName, pData;
var fnData=function(n, sType, isArray) {
var pData=new pConvFormats[sType][0](n);
pConvFormats[sType][1](stringData(pXML), pData);
if ((n == 1) && (!isArray)) {
return pData[0];

}

return pData;

};
switch(sName) {
case "bool":
return fnData(1, "bool");

case "int":
return fnData(1, "int");

case "float":
return fnData(1, "float");

case "float2":
return fnData(2, "float");

case "float3":
return fnData(3, "float");

case "float4":
;

case "color":
return fnData(4, "float");

case "rotate":
return COLLADARotateMatrix(pXML);

case "translate":
return COLLADATranslateMatrix(pXML);

case "scale":
return COLLADAScaleMatrix(pXML);

case "bind_shape_matrix":
;

case "matrix":
return new Mat4(fnData(16, "float"), true).transpose();

case "float_array":
return fnData(parseInt(attr(pXML, "count")), "float", true);

case "int_array":
return fnData(parseInt(attr(pXML, "count")), "int", true);

case "bool_array":
return fnData(parseInt(attr(pXML, "count")), "bool", true);

case "Name_array":
;

case "name_array":
;

case "IDREF_array":
return fnData(parseInt(attr(pXML, "count")), "string", true);

case "sampler2D":
return COLLADASampler2D(pXML);

case "surface":
return COLLADASurface(pXML);

default:
if (!0) {
var err=((((((("Error:: " + (("unsupported COLLADA data type <" + sName) + " />")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("unsupported COLLADA data type <" + sName) + " />"));

}


}

;
}
return null;

}

function COLLADAAccessor(pXML) {
var pAccessor= {sSource: attr(pXML, "source"), iCount: parseInt(attr(pXML, "count")), iStride: parseInt((attr(pXML, "stride")) || 1), pParam: []};
eachChild(pXML, function(pXMLData, sName) {
pAccessor.pParam.push( {sName: attr(pXMLData, "name"), sType: attr(pXMLData, "type")});

}
);
return pAccessor;

}

function COLLADAInput(pXML, iOffset) {
var pInput= {sSemantic: attr(pXML, "semantic"), sSource: attr(pXML, "source"), iOffset: null, iSet: attr(pXML, "set")};
if (pXML.hasAttribute("offset")) {
pInput.iOffset = parseInt(attr(pXML, "offset"));

}

if (iOffset && ((pInput.iOffset) === null)) {
pInput.iOffset = iOffset;

}

return pInput;

}

function COLLADATechniqueCommon(pXML) {
var pTechniqueCommon= {pAccessor: null};
eachChild(pXML, function(pXMLData, sName) {
switch(sName) {
case "accessor":
pTechniqueCommon.pAccessor = COLLADAAccessor(pXMLData);
break ;
}

}
);
return pTechniqueCommon;

}

function COLLADASource(pXML) {
var pSource= {pArray:  {}, pTechniqueCommon: null, id: attr(pXML, "id"), name: attr(pXML, "name")};
link(pSource);
eachChild(pXML, function(pXMLData, sName) {
var tmp, id;
switch(sName.toLowerCase()) {
case "int_array":
;

case "bool_array":
;

case "float_array":
;

case "idref_array":
;

case "name_array":
tmp = COLLADAData(pXMLData);
id = attr(pXMLData, "id");
pSource.pArray[id] = tmp;
link(id, tmp);
break ;

case "technique_common":
pSource.pTechniqueCommon = COLLADATechniqueCommon(pXMLData);
break ;
}

}
);
return pSource;

}

function COLLADAVertices(pXML) {
var pVertices= {id: attr(pXML, "id"), pInput:  {}};
eachByTag(pXML, "input", function(pXMLData) {
var sSemantic=attr(pXMLData, "semantic");
pVertices.pInput[sSemantic] = COLLADAInput(pXMLData);

}
);
if (!pVertices.pInput["POSITION"]) {
var err=((((((("Error:: " + "semantics POSITION must be in the <vertices /> tag") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("semantics POSITION must be in the <vertices /> tag");

}


}

;
return pVertices;

}

function COLLADAJoints(pXML) {
var pJoints= {pInput:  {}};
var pArrayBuffer;
var pMatrixArray;
var iCount;
var pInput;
var pInvMatrixArray;
eachByTag(pXML, "input", function(pXMLData) {
switch(attr(pXMLData, "semantic")) {
case "JOINT":
pJoints.pInput["JOINT"] = COLLADAInput(pXMLData);
break ;

case "INV_BIND_MATRIX":
pInput = COLLADAInput(pXMLData);
pJoints.pInput["INV_BIND_MATRIX"] = pInput;
break ;

default:
if (!0) {
var err=((((((("Error:: " + "semantics are different from JOINT/INV_BIND_MATRIX is not supported in the <joints /> tag") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("semantics are different from JOINT/INV_BIND_MATRIX is not supported in the <joints /> tag");

}


}

;
}

}
);
for (var i in pJoints.pInput) {
prepareInput(pJoints.pInput[i]);
if (i === "INV_BIND_MATRIX") {
pInvMatrixArray = new Float32Array(pJoints.pInput[i].pArray);
iCount = (pInvMatrixArray.length) / 16;
pMatrixArray = new Array(iCount);
for (var j=0, n=0; j < (pInvMatrixArray.length); j += 16) {
pMatrixArray[n++] = new Mat4(new Float32Array(pInvMatrixArray.buffer, j * (Float32Array.BYTES_PER_ELEMENT), 16), true).transpose();

}

pJoints.pInput[i].pArray = pMatrixArray;

}


}

return pJoints;

}

function polygonToTriangles(pXML, iStride) {
return trifanToTriangles(pXML, iStride);

}

function trifanToTriangles(pXML, iStride) {
var pFans2Tri=[0, 0, 0];
var pData=[];
var tmp=new Array(iStride), n;
var pIndexes=[];
eachByTag(pXML, "p", function(pXMLData) {
n = string2IntArray(stringData(pXMLData), pData);
for (var i=0; i < 3; i++) {
retrieve(pData, tmp, iStride, i, 1);
for (var j=0; j < iStride; ++j) {
pIndexes.push(tmp[j]);

}


}

for (var i=3, m=n / iStride; i < m; i++) {
pFans2Tri[1] = i - 1;
pFans2Tri[2] = i;
for (var j=0; j < (pFans2Tri.length); ++j) {
for (var k=0; k < iStride; ++k) {
pIndexes.push(pData[((pFans2Tri[j]) * iStride) + k]);

}


}


}


}
);
return pIndexes;

}

function tristripToTriangles(pXML, iStride) {
var pStrip2Tri=[0, 0, 0];
var pData=[];
var tmp=new Array(iStride), n;
var pIndexes=[];
eachByTag(pXML, "p", function(pXMLData) {
n = string2IntArray(stringData(pXMLData), pData);
for (var i=0; i < 3; i++) {
retrieve(pData, tmp, iStride, i, 1);
for (var j=0; j < iStride; ++j) {
pIndexes.push(tmp[j]);

}


}

for (var i=3, m=n / iStride; i < m; i++) {
pStrip2Tri[0] = i - 1;
pStrip2Tri[1] = i - 2;
pStrip2Tri[2] = i;
for (var j=0; j < (pStrip2Tri.length); ++j) {
for (var k=0; k < iStride; ++k) {
pIndexes.push(pData[((pStrip2Tri[j]) * iStride) + k]);

}


}


}


}
);
return pIndexes;

}

function polylistToTriangles(pXML, iStride) {
var pXMLvcount=firstChild(pXML, "vcount");
var pXMLp=firstChild(pXML, "p");
var pVcount=new Array(parseInt(attr(pXML, "count")));
var pData, pIndexes, n, h=0;
var tmp=new Array(128);
var buf=new Array(256);
var pPoly2Tri=[0, 0, 0];
string2IntArray(stringData(pXMLvcount), pVcount);
var nElements=0, nTotalElement=0;
for (var i=0; i < (pVcount.length); i++) {
nElements += pVcount[i];
nTotalElement += ((pVcount[i]) - 2) * 3;

}

pIndexes = new Array(iStride * nTotalElement);
pData = new Array(iStride * nElements);
string2IntArray(stringData(pXMLp), pData);
for (var i=0, m=0; i < (pVcount.length); i++) {
n = retrieve(pData, tmp, iStride, m, pVcount[i]);
for (var j=0; j < 3; j++) {
retrieve(tmp, buf, iStride, j, 1);
for (var k=0; k < iStride; ++k) {
pIndexes[h++] = buf[k];

}


}

for (var x=3, t=n / iStride; x < t; x++) {
pPoly2Tri[1] = x - 1;
pPoly2Tri[2] = x;
for (var j=0; j < (pPoly2Tri.length); ++j) {
for (var k=0; k < iStride; ++k) {
pIndexes[h++] = pData[((m + (pPoly2Tri[j])) * iStride) + k];

}


}


}

m += pVcount[i];

}

return pIndexes;

}

function COLLADAPolygons(pXML, sType) {
var pPolygons= {pInput: [], p: null, sMaterial: attr(pXML, "material"), sName: null};
var iOffset=0, n=0;
var iCount=parseInt(attr(pXML, "count"));
var iStride;
eachByTag(pXML, "input", function(pXMLData) {
pPolygons.pInput.push(COLLADAInput(pXMLData, iOffset));
iOffset++;

}
);
sortArrayByProperty(pPolygons.pInput, "iOffset");
iStride = (lastElement(pPolygons.pInput).iOffset) + 1;
switch(sType) {
case "polylist":
pPolygons.p = polylistToTriangles(pXML, iStride);
break ;

case "polygons":
pPolygons.p = polygonToTriangles(pXML, iStride);
eachByTag(pXML, "ph", function(pXMLData) {
if (!0) {
var err=((((((("Error:: " + "unsupported polygon[polygon] subtype founded: <ph>") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("unsupported polygon[polygon] subtype founded: <ph>");

}


}

;

}
);
break ;

case "triangles":
pPolygons.p = new Array((3 * iCount) * iStride);
eachByTag(pXML, "p", function(pXMLData) {
n += string2IntArray(stringData(pXMLData), pPolygons.p, n);

}
);
break ;

case "trifans":
pPolygons.p = trifanToTriangles(pXML, iStride);
break ;

case "tristrips":
pPolygons.p = tristripToTriangles(pXML, iStride);
break ;

default:
if (!0) {
var err=((((((("Error:: " + (("unsupported polygon[" + sType) + "] type founded")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("unsupported polygon[" + sType) + "] type founded"));

}


}

;
}
if ((pPolygons.eType) === undefined) {
pPolygons.eType = 4;

}

return pPolygons;

}

function COLLADAVertexWeights(pXML) {
var pVertexWeights= {iCount: parseInt(attr(pXML, "count")), pInput: [], pWeightInput: null, pVcount: null, pV: null};
var iOffset=0;
var pInput;
eachByTag(pXML, "input", function(pXMLData) {
pInput = COLLADAInput(pXMLData, iOffset);
if ((pInput.sSemantic) === "WEIGHT") {
pVertexWeights.pWeightInput = pInput;

}

pVertexWeights.pInput.push(pInput);
iOffset++;

}
);
var pVcountData, pVData;
pVcountData = new Array(pVertexWeights.iCount);
string2IntArray(stringData(firstChild(pXML, "vcount")), pVcountData);
pVertexWeights.pVcount = pVcountData;
var n=0;
for (var i=0; i < (pVcountData.length); ++i) {
n += pVcountData[i];

}

n *= pVertexWeights.pInput.length;
if (!((pVertexWeights.pInput.length) === 2)) {
var err=((((((("Error:: " + "more than 2 inputs in <vertex_weights/> not supported currently") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("more than 2 inputs in <vertex_weights/> not supported currently");

}


}

;
pVData = new Array(n);
string2IntArray(stringData(firstChild(pXML, "v")), pVData);
pVertexWeights.pV = pVData;
return pVertexWeights;

}

function prepareInput(pInput) {
var pSupportedFormat=getSupportedFormat(pInput.sSemantic);
if (!pSupportedFormat) {
var err=((((((("Error:: " + (("unsupported semantic used <" + (pInput.sSemantic)) + ">")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("unsupported semantic used <" + (pInput.sSemantic)) + ">"));

}


}

;
pInput.sArrayId = COLLADAGetSourceData(pInput.sSource, pSupportedFormat);
pInput.pArray = source(pInput.sArrayId);
pInput.pAccessor = source(pInput.sSource).pTechniqueCommon.pAccessor;
return pInput;

}

function COLLADAGetSourceData(sSourceId, pFormat) {
var nStride=calcFormatStride(pFormat);
var pSource=source(sSourceId);
if (!pSource) {
var err=((((((("Error:: " + (("<source /> with id <" + sSourceId) + "> not founded")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("<source /> with id <" + sSourceId) + "> not founded"));

}


}

;
var pTech=pSource.pTechniqueCommon;
if (!pTech) {
var err=((((((("Error:: " + (("<source /> with id <" + sSourceId) + "> has no <technique_common />")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("<source /> with id <" + sSourceId) + "> has no <technique_common />"));

}


}

;
var pAccess=pTech.pAccessor;
var isFormatSupported;
if (!((pAccess.iStride) <= nStride)) {
trace(pAccess.iStride, "/", nStride);

}

if (!((pAccess.iStride) <= nStride)) {
var err=((((((("Error:: " + ((("<source /> width id" + sSourceId) + " has unsupported stride: ") + (pAccess.iStride))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(((("<source /> width id" + sSourceId) + " has unsupported stride: ") + (pAccess.iStride)));

}


}

;
var fnUnsupportedFormatError=function() {
trace("expected format: ", pFormat);
trace("given format: ", pAccess.pParam);
if (!0) {
var err=((((((("Error:: " + (("accessor of <" + sSourceId) + "> has unsupported format")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("accessor of <" + sSourceId) + "> has unsupported format"));

}


}

;

};
for (var i in pAccess.pParam) {
if ((typeof (pFormat[i].sName)) === "string") {
if ((pAccess.pParam[i].sName.toLowerCase()) != (pFormat[i].sName.toLowerCase())) {
fnUnsupportedFormatError();

}


}
else  {
isFormatSupported = false;
for (var f=0; f < (pFormat[i].sName.length); ++f) {
if ((((pAccess.pParam[i].sName) || "").toLowerCase()) == (((pFormat[i].sName[f]) || "").toLowerCase())) {
isFormatSupported = true;

}


}

if (!isFormatSupported) {
fnUnsupportedFormatError();

}


}

if ((typeof (pFormat[i].sType)) === "string") {
if ((pAccess.pParam[i].sType.toLowerCase()) != (pFormat[i].sType.toLowerCase())) {
fnUnsupportedFormatError();

}


}
else  {
isFormatSupported = false;
for (var f=0; f < (pFormat[i].sType.length); ++f) {
if ((pAccess.pParam[i].sType.toLowerCase()) == (pFormat[i].sType[f].toLowerCase())) {
isFormatSupported = true;

}


}

if (!isFormatSupported) {
fnUnsupportedFormatError();

}


}


}

return pAccess.sSource;

}

function COLLADAMesh(pXML) {
"use strict";
var pMesh= {pSource: [], pPolygons: []};
var id, tmp, pVertices, pPos;
eachChild(pXML, function(pXMLData, sName) {
switch(sName) {
case "source":
pMesh.pSource.push(COLLADASource(pXMLData));
break ;

case "vertices":
pVertices = COLLADAVertices(pXMLData);
break ;

case "lines":
;

case "linestrips":
;

case "tristrips":
;

case "trifans":
;

case "triangles":
;

case "polygons":
;

case "polylist":
tmp = COLLADAPolygons(pXMLData, sName);
for (var i=0; i < (tmp.pInput.length); ++i) {
pPos = null;
if ((tmp.pInput[i].sSemantic) == "VERTEX") {
if ((tmp.pInput[i].sSource) == ("#" + (pVertices.id))) {
pPos = pVertices.pInput["POSITION"];
tmp.pInput[i].sSource = pPos.sSource;
tmp.pInput[i].sSemantic = pPos.sSemantic;

}
else  {
if (!0) {
var err=((((((("Error:: " + "<input /> with semantic VERTEX must refer to <vertices /> tag in same mesh.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("<input /> with semantic VERTEX must refer to <vertices /> tag in same mesh.");

}


}

;

}


}

prepareInput(tmp.pInput[i]);

}

pMesh.pPolygons.push(tmp);
break ;
}

}
);
return pMesh;

}

function COLLADAGeometrie(pXML) {
var pGeometrie= {pMesh: null, pConvexMesh: null, pSpline: null, id: attr(pXML, "id"), sName: attr(pXML, "name")};
link(pGeometrie);
var pXMLData=firstChild(pXML);
var sName=pXMLData.nodeName;
if (sName == "mesh") {
pGeometrie.pMesh = COLLADAMesh(pXMLData);

}

return pGeometrie;

}

function COLLADASkin(pXML) {
var pSkin= {m4fShapeMatrix: COLLADAData(firstChild(pXML, "bind_shape_matrix")), pSource: [], pGeometry: source(attr(pXML, "source")), pJoints: null, pVertexWeights: null};
var tmp, pInput;
eachChild(pXML, function(pXMLData, sName) {
switch(sName) {
case "source":
pSkin.pSource.push(COLLADASource(pXMLData));
break ;

case "joints":
pSkin.pJoints = COLLADAJoints(pXMLData);
break ;

case "vertex_weights":
tmp = COLLADAVertexWeights(pXMLData);
for (var i=0; i < (tmp.pInput.length); ++i) {
pInput = tmp.pInput[i];
prepareInput(pInput);

}

pSkin.pVertexWeights = tmp;
break ;
}

}
);
return pSkin;

}

function COLLADAController(pXML) {
var pController= {pSkin: null, pMorph: null, sName: attr(pXML, "name"), id: attr(pXML, "id")};
link(pController);
var pXMLData=firstChild(pXML, "skin");
if (pXMLData) {
pController.pSkin = COLLADASkin(pXMLData);

}
else  {
return null;

}

return pController;

}

function COLLADAInstanceEffect(pXML) {
var pInstance= {pParameters:  {}, pTechniqueHint:  {}, sUrl: attr(pXML, "url")};
eachByTag(pXML, "technique_hint", function(pXMLData) {
pInstance.pTechniqueHint[attr(pXMLData, "platform")] = attr(pXMLData, "ref");
console.log("technique_hint used!!!!");

}
);
eachByTag(pXML, "setparam", function(pXMLData) {
pParameters[attr(pXMLData, "ref")] = COLLADAData(pXMLData);
console.log("setparam used!!!!");

}
);
return pInstance;

}

function COLLADAMaterial(pXML) {
var pMaterial= {id: attr(pXML, "id"), sName: attr(pXML, "name"), pInstanceEffect: COLLADAInstanceEffect(firstChild(pXML, "instance_effect"))};
link(pMaterial);
return pMaterial;

}

function COLLADANewParam(pXML) {
var pParam= {sid: attr(pXML, "sid"), pAnnotate: null, sSemantic: null, sModifier: null, pValue: null, sType: null};
link(pParam.sid, pParam);
eachChild(pXML, function(pXMLData, sName) {
switch(sName) {
case "semantic":
pParam.sSemantic = stringData(pXMLData);
break ;

case "modifier":
pParam.sModifier = stringData(pXMLData);

case "annotate":
pParam.pAnnotate =  {sName: attr(pXMLData, "name"), sValue: stringData(pXMLData)};

case "float":
;

case "float2":
;

case "float3":
;

case "float4":
;

case "surface":
;

case "sampler2D":
pParam.sType = sName;
pParam.pValue = COLLADAData(pXMLData);
break ;

default:
pParam.pValue = COLLADAData(pXMLData);
}

}
);
return pParam;

}

function COLLADATexture(pXML) {
var pTexture= {sSampler: attr(pXML, "texture"), sTexcoord: attr(pXML, "texcoord"), pSampler: null, pSurface: null, pImage: null};
pTexture.pSampler = source(pTexture.sSampler);
if ((pTexture.pSampler) && (pTexture.pSampler.pValue)) {
pTexture.pSurface = source(pTexture.pSampler.pValue.sSource);

}

if (pTexture.pSurface) {
pTexture.pImage = source(pTexture.pSurface.pValue.sInitFrom);

}

return pTexture;

}

function COLLADAPhong(pXML) {
var pMat=new a.Material();
var pXMLData;
var pList=["emission", "ambient", "diffuse", "shininess", "reflective", "reflectivity", "transparent", "transparency", "specular"];
pMat.pTextures =  {};
for (var i=0; i < (pList.length); i++) {
pXMLData = firstChild(pXML, pList[i]);
if (pXMLData) {
eachChild(pXMLData, function(pXMLData, sName) {
switch(sName) {
case "float":
;

case "color":
pMat[pList[i]] = COLLADAData(pXMLData);
break ;

case "texture":
var pTexture=COLLADATexture(pXMLData);
pMat.pTextures[pList[i]] =  {sParam: pTexture.sTexcoord, pTexture: pTexture};
}

}
);

}


}

pMat.shininess *= 10;
return pMat;

}

function COLLADAEffectTechnique(pXML) {
var pTech= {sid: attr(pXML, "sid"), sType: null, pValue: null};
link(pTech.sid, pTech);
var pValue=firstChild(pXML);
pTech.sType = pValue.nodeName;
switch(pTech.sType) {
case "blinn":
;

case "phong":
;

case "lambert":
pTech.pValue = COLLADAPhong(pValue);
break ;

default:
if (!0) {
var err=((((((("Error:: " + (("unsupported technique <" + (pTech.sType)) + " /> founded")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("unsupported technique <" + (pTech.sType)) + " /> founded"));

}


}

;
}
return pTech;

}

function COLLADAProfileCommon(pXML) {
var pProfile= {pTechnique: null, pNewParam:  {}};
eachByTag(pXML, "newparam", function(pXMLData) {
pProfile.pNewParam[attr(pXMLData, "sid")] = COLLADANewParam(pXMLData);

}
);
pProfile.pTechnique = COLLADAEffectTechnique(firstChild(pXML, "technique"));
return pProfile;

}

function COLLADAEffect(pXML) {
var pEffect= {id: attr(pXML, "id"), pProfileCommon: null};
eachChild(pXML, function(pXMLData, sName) {
switch(sName) {
case "profile_COMMON":
pEffect.pProfileCommon = COLLADAProfileCommon(pXMLData);
pEffect.pProfileCommon.pTechnique.pValue.name = pEffect.id;
break ;

case "extra":
break ;

default:
if (!0) {
var err=((((((("Error:: " + (("<" + sName) + " /> unsupported in effect section")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("<" + sName) + " /> unsupported in effect section"));

}


}

;
}

}
);
link(pEffect);
return pEffect;

}

function COLLADABindMaterial(pXML) {
if (!pXML) {
return null;

}

var pMaterials= {};
var pMat=null;
var pSourceMat=null;
var pTech=firstChild(pXML, "technique_common");
eachByTag(pTech, "instance_material", function(pInstMat) {
pSourceMat = source(attr(pInstMat, "target"));
pMat =  {sUrl: pSourceMat.pInstanceEffect.sUrl, pVertexInput:  {}};
eachByTag(pInstMat, "bind_vertex_input", function(pXMLVertexInput) {
var sInputSemantic=attr(pXMLVertexInput, "input_semantic");
if (sInputSemantic !== "TEXCOORD") {
if (!0) {
var err=((((((("Error:: " + ("unsupported vertex input semantics founded: " + sSemantic)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("unsupported vertex input semantics founded: " + sSemantic));

}


}

;

}

var sSemantic=attr(pXMLVertexInput, "semantic");
var sInputSet=parseInt(attr(pXMLVertexInput, "input_set"));
pMat.pVertexInput[sSemantic] =  {"sSemantic": sSemantic, "sInputSet": sInputSet, "sInputSemantic": sInputSemantic};

}
);
pMaterials[attr(pInstMat, "symbol")] = pMat;

}
);
return pMaterials;

}

function COLLADAInstanceController(pXML) {
var pInst= {sUrl: attr(pXML, "url"), pController: source(attr(pXML, "url")), pMaterials: COLLADABindMaterial(firstChild(pXML, "bind_material")), pSkeleton: []};
eachByTag(pXML, "skeleton", function(pXMLData) {
pInst.pSkeleton.push(stringData(pXMLData).substr(1));

}
);
return pInst;

}

function COLLADAInstanceGeometry(pXML) {
var pInst= {pGeometry: source(attr(pXML, "url")), pMaterials: COLLADABindMaterial(firstChild(pXML, "bind_material"))};
return pInst;

}

function COLLADANode(pXML, iDepth) {
iDepth = iDepth || 0;
var pNode= {id: attr(pXML, "id"), sid: attr(pXML, "sid"), sName: (attr(pXML, "name")) || "unknown", sType: attr(pXML, "type"), sLayer: attr(pXML, "layer"), m4fTransform: new Mat4(1), pGeometry: [], pController: [], pChildNodes: [], iDepth: iDepth, pTransforms: [], pConstructedNode: null};
var m4fMatrix;
var sType, id, sid;
link(pNode);
eachChild(pXML, function(pXMLData, sName) {
switch(sName) {
case "rotate":
;

case "matrix":
;

case "translate":
;

case "scale":
pNode.pTransforms.push(COLLADATransform(pXMLData, pNode.id));
m4fMatrix = COLLADAData(pXMLData);
pNode.m4fTransform.mult(m4fMatrix);
break ;

case "instance_geometry":
pNode.pGeometry.push(COLLADAInstanceGeometry(pXMLData));
break ;

case "instance_controller":
pNode.pController.push(COLLADAInstanceController(pXMLData));
break ;

case "node":
pNode.pChildNodes.push(COLLADANode(pXMLData, iDepth + 1));
break ;
}

}
);
return pNode;

}

function COLLADAVisualScene(pXML) {
var pNode;
var pScene= {id: attr(pXML, "id"), name: attr(pXML, "name"), pNodes: []};
link(pScene);
eachChild(pXML, function(pXMLData, sName) {
switch(sName) {
case "node":
pNode = COLLADANode(pXMLData);
if (pNode) {
pScene.pNodes.push(pNode);

}

break ;
}

}
);
return pScene;

}

function COLLADAImage(pXML) {
var pImage= {id: attr(pXML, "id"), sName: attr(pXML, "name"), iDepth: 1, pData: null, sImagePath: null};
var sPath=null;
link(pImage);
var pXMLInitData, pXMLData;
if (pXMLInitData = firstChild(pXML, "init_from")) {
sPath = stringData(pXMLInitData);
if (sFilename) {
if (!(a.pathinfo(sPath).isAbsolute())) {
sPath = ((a.pathinfo(sFilename).dirname) + "/") + sPath;

}


}

pImage.sImagePath = sPath;

}
else if (pXMLData = firstChild(pXML, "data")) {
if (!0) {
var err=((((((("Error:: " + "image loading from <data /> tag unsupported yet.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("image loading from <data /> tag unsupported yet.");

}


}

;

}
else  {
if (!0) {
var err=((((((("Error:: " + (("image with id: " + (pImage.id)) + " has no data.")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("image with id: " + (pImage.id)) + " has no data."));

}


}

;

}


return pImage;

}

function COLLADAAsset(pXML) {
var pAsset= {pUnit:  {fMeter: 1, sName: "meter"}, sUPaxis: "Y_UP", sTitle: null, sCreated: null, sModified: null, pContributor: null};
eachChild(pXML, function(pXMLNode, sName) {
var sValue=stringData(pXMLNode);
switch(sName) {
case "up_axis":
pAsset.sUPaxis = sValue;
break ;

case "created":
pAsset.sCreated = sValue;
break ;

case "modified":
pAsset.sModified = sValue;
break ;

case "title":
pAsset.sTitle = sValue;
break ;

case "contributor":
break ;

case "unit":
pAsset.pUnit.fMeter = parseFloat(attr(pXMLNode, "meter"));
pAsset.pUnit.sName = attr(pXMLNode, "name");
break ;
}

}
);
return pAsset;

}

function COLLADALibrary(pXML, sTag, fnLoader) {
if (!pXML) {
return null;

}

var pLib= {};
var pData;
pLib[sTag] =  {};
eachChild(pXML, function(pXMLData, sName) {
if (sTag !== sName) {
return ;

}

pData = fnLoader(pXMLData);
if (!pData) {
return ;

}

pLib[sTag][attr(pXMLData, "id")] = pData;

}
);
return pLib;

}

function COLLADAScene(pXML) {
var pXMLData=firstChild(pXML, "instance_visual_scene");
var pScene=source(attr(pXMLData, "url"));
if ((!pXMLData) || (!pScene)) {
debug_warning(("collada model: " + sFilename) + " has no visual scenes.");

}

return pScene;

}

function COLLADAAnimationSampler(pXML) {
"use strict";
var pSampler= {pInput:  {}, id: attr(pXML, "id")};
link(pSampler);
var pInput;
eachByTag(pXML, "input", function(pXMLData) {
var sSemantic=attr(pXMLData, "semantic");
switch(sSemantic) {
case "INPUT":
;

case "OUTPUT":
;

case "INTERPOLATION":
;

case "IN_TANGENT":
;

case "OUT_TANGENT":
pInput = COLLADAInput(pXMLData);
pSampler.pInput[sSemantic] = pInput;
prepareInput(pInput);
break ;

default:
if (!0) {
var err=((((((("Error:: " + "semantics are different from OUTPUT/INTERPOLATION/IN_TANGENT/OUT_TANGENT is not supported in the <sampler /> tag") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("semantics are different from OUTPUT/INTERPOLATION/IN_TANGENT/OUT_TANGENT is not supported in the <sampler /> tag");

}


}

;
}

}
);
return pSampler;

}

function COLLADAAnimationChannel(pXML) {
"use strict";
var pChannel= {pSource: source(attr(pXML, "source")), pTarget: null};
pChannel.pTarget = target(attr(pXML, "target"));
if ((!(pChannel.pTarget)) || (!(pChannel.pTarget.pObject))) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "][") + "") + "]") + (("cound not setup animation channel for <" + (attr(pXML, "target"))) + ">"));
return null;

}

return pChannel;

}

function COLLADAAnimation(pXML) {
"use strict";
var pAnimation= {pSource: [], pSampler: [], pChannel: [], id: attr(pXML, "id"), name: attr(pXML, "name"), pAnimations: []};
var pChannel;
var pSubAnimation;
link(pAnimation);
eachChild(pXML, function(pXMLData, sName) {
switch(sName) {
case "source":
pAnimation.pSource.push(COLLADASource(pXMLData));
break ;

case "sampler":
pAnimation.pSampler.push(COLLADAAnimationSampler(pXMLData));
break ;

case "channel":
pChannel = COLLADAAnimationChannel(pXMLData);
if (pChannel) {
pAnimation.pChannel.push(pChannel);

}

break ;

case "animation":
pSubAnimation = COLLADAAnimation(pXMLData);
if (pSubAnimation) {
pAnimation.pAnimations.push(pSubAnimation);

}

;
}

}
);
if (((pAnimation.pChannel.length) == 0) && ((pAnimation.pAnimations.length) == 0)) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "][") + "") + "]") + (("animation with id \"" + (pAnimation.id)) + "\" skipped, because channels/sub animation are empty"));
return null;

}

return pAnimation;

}

function buildAnimationTrack(pChannel) {
"use strict";
var sNodeId=pChannel.pTarget.pSource.id;
var sJoint=source(sNodeId).sid;
var pTrack=null;
var pSampler=pChannel.pSource;
if (!pSampler) {
var err=((((((("Error:: " + "could not find sampler for animation channel") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("could not find sampler for animation channel");

}


}

;
var pInput=pSampler.pInput["INPUT"];
var pOutput=pSampler.pInput["OUTPUT"];
var pInterpolation=pSampler.pInput["INTERPOLATION"];
var pTimeMarks=pInput.pArray;
var pOutputValues=pOutput.pArray;
var pTransform=pChannel.pTarget.pObject;
var sTransform=pTransform.sName;
var v4f;
var pValue;
var nMatrices;
switch(sTransform) {
case "translate":
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "][") + "") + "]") + ("TODO:: " + "implement animation translation"));
throw new Error("TODO::\n" + "implement animation translation");
break ;

case "rotate":
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "][") + "") + "]") + ("TODO:: " + "implement animation rotation"));
throw new Error("TODO::\n" + "implement animation rotation");
break ;

case "matrix":
pValue = pChannel.pTarget.pValue;
if (pValue === null) {
pTrack = new a.AnimationTransformation(sJoint);
nMatrices = (pOutputValues.length) / 16;
pOutputValues = new Float32Array(pOutputValues);
if (!((nMatrices % 1) === 0)) {
var err=((((((("Error:: " + (("incorrect output length of transformation data (" + (pOutputValues.length)) + ")")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("incorrect output length of transformation data (" + (pOutputValues.length)) + ")"));

}


}

;
for (var i=0; i < nMatrices; i++) {
pTrack.keyFrame(pTimeMarks[i], new Mat4(pOutputValues.subarray(i * 16, (i * 16) + 16), true).transpose());

}

;

}
else  {
pTrack = new a.AnimationMatrixModification(sJoint, pValue);
for (var i=0; i < (pTimeMarks.length); ++i) {
pTrack.keyFrame(pTimeMarks[i], pOutputValues[i]);

}


}

break ;

default:
if (!0) {
var err=((((((("Error:: " + ("unsupported animation typed founeed: " + sTransform)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("unsupported animation typed founeed: " + sTransform));

}


}

;
}
if (pTrack) {
pTrack.nodeName = sNodeId;

}

return pTrack;

}

function buildAnimationTrackList(pAnimationData) {
"use strict";
var pSubAnimations=pAnimationData.pAnimations;
var pSubTracks;
var pTrackList=[];
var pTrack;
var pChannels=pAnimationData.pChannel;
for (var i=0; i < (pChannels.length); ++i) {
pTrack = buildAnimationTrack(pChannels[i]);
pTrackList.push(pTrack);

}

if (pSubAnimations) {
for (var i=0; i < (pSubAnimations.length); ++i) {
pSubTracks = buildAnimationTrackList(pSubAnimations[i]);
pTrackList = pTrackList.concat(pSubTracks);

}


}

return pTrackList;

}

function buildAnimation(pAnimationData) {
"use strict";
var pTracks=buildAnimationTrackList(pAnimationData);
var sAnimation=(pAnimationData.length? pAnimationData[0].name : null);
var pAnimation=new a.Animation(sAnimation || sBasename);
for (var i=0; i < (pTracks.length); i++) {
pAnimation.push(pTracks[i]);

}

;
return pAnimation;

}

function buildAnimations(pAnimations, pAnimationsList) {
"use strict";
if (!pAnimations) {
return null;

}

pAnimationsList = pAnimationsList || ([]);
for (var i in pAnimations) {
var pAnimation=buildAnimation(pAnimations[i]);
pAnimationsList.push(pAnimation);
if (pModelResource && useAnimation) {
pModelResource.addAnimation(pAnimation);

}


}

;
return pAnimationsList;

}

function buildAssetTransform(pNode, pAsset) {
"use strict";
if (pAsset) {
var fUnit=pAsset.pUnit.fMeter;
var sUPaxis=pAsset.sUPaxis;
pNode.setScale(fUnit);
if ((sUPaxis.toUpperCase()) == "Z_UP") {
pNode.addRelRotation(0, (-0.5) * (Math.PI), 0);

}


}

return pNode;

}

function buildMaterials(pMesh, pMeshNode) {
"use strict";
var pMaterials=pMeshNode.pMaterials;
var pEffects=pLib["library_effects"];
for (var sMaterial in pMaterials) {
var pInputs=pMaterials[sMaterial].pVertexInput;
var pEffect=pEffects.effect[pMaterials[sMaterial].sUrl.substr(1)];
var pMaterial=pEffect.pProfileCommon.pTechnique.pValue;
for (var j=0; j < (pMesh.length); ++j) {
var pSubMesh=pMesh[j];
if ((pSubMesh.material.name) === sMaterial) {
pSubMesh.material.value = pMaterial;
pSubMesh.applyFlexMaterial(sMaterial, pMaterial);
if ((pSubMesh.renderMethod.effect.isResourceLoaded()) === false) {
pSubMesh.renderMethod.effect.create();

}

pSubMesh.renderMethod.effect.use("akra.system.mesh_texture");
for (var c in pMaterial.pTextures) {
var pTextureObject=pMaterial.pTextures[c];
var pInput=pInputs[pTextureObject.sParam];
if (!pInput) {
continue ;

}

var sInputSemantics=pInputs[pTextureObject.sParam].sInputSemantic;
var pColladaImage=pTextureObject.pTexture;
var pSurfaceMaterial=pSubMesh.surfaceMaterial;
var pTexture=pEngine.displayManager().texturePool().loadResource(pColladaImage.pImage.sImagePath);
var pMatches=sInputSemantics.match(/^(.*?\w)(\d+)$/i);
var iTexCoord=(pMatches? pMatches[2] : 0);
var iTexture=$$enum_SURFACEMATERIAL_TEXTURES$_obj[c.toUpperCase()];
if (iTexture === undefined) {
continue ;

}

pSurfaceMaterial.setTexture(iTexture, pTexture, iTexCoord);

}


}


}


}

return pMesh;

}

function buildMesh(pMeshNode) {
"use strict";
var pMeshList=pCache["@mesh"];
var pGeometry=pMeshNode.pGeometry;
var pNodeData=pGeometry.pMesh;
var sMeshName=pGeometry.id;
if (!pNodeData) {
return null;

}

if (pMeshList && (pMeshList[sMeshName])) {
return buildMaterials(pMeshList[sMeshName].clone((0) | (1)), pMeshNode);

}

var iBegin=a.now();
var pMesh=new a.Mesh(pEngine, 8, sMeshName, sharedBuffer());
var pPolyGroup=pNodeData.pPolygons;
var pMeshData=pMesh.data;
for (var i=0; i < (pPolyGroup.length); ++i) {
pMesh.createSubset("submesh-" + i, (useWireframe? 1 : pPolyGroup[i].eType));

}

for (var i=0, pUsedSemantics= {}; i < (pPolyGroup.length); ++i) {
var pPolygons=pPolyGroup[i];
for (var j=0; j < (pPolygons.pInput.length); ++j) {
var pInput=pPolygons.pInput[j];
var sSemantic=pInput.sSemantic;
var pData=pInput.pArray;
var pDecl, pDataExt;
if (!(pUsedSemantics[sSemantic])) {
pUsedSemantics[sSemantic] = true;
switch(sSemantic) {
case "POSITION":
;

case "NORMAL":
pDataExt = new Float32Array(((pData.length) / 3) * 4);
for (var y=0, n=m = 0, l=(pData.length) / 3; y < l; y++, n++) {
pDataExt[n++] = pData[m++];
pDataExt[n++] = pData[m++];
pDataExt[n++] = pData[m++];

}

;
pData = pDataExt;
pDecl = [new Object( {nCount: 3, eType: 5126, eUsage: sSemantic, iOffset: undefined}), new Object( {nCount: 0, eType: 5121, eUsage: "\u000D", iOffset: 16})];
break ;

case "TEXCOORD":
;

case "TEXCOORD1":
;

case "TEXCOORD2":
;

case "TEXCOORD3":
;

case "TEXCOORD4":
;

case "TEXCOORD5":
if (sSemantic === "TEXCOORD") {
sSemantic = "TEXCOORD0";

}

pDecl = [new Object( {nCount: pInput.pAccessor.iStride, eType: 5126, eUsage: sSemantic, iOffset: undefined})];
break ;

default:
if (!0) {
var err=((((((("Error:: " + ("unsupported semantics used: " + sSemantic)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("unsupported semantics used: " + sSemantic));

}


}

;
}
pMeshData.allocateData(pDecl, pData);

}


}


}

for (var i=0; i < (pPolyGroup.length); ++i) {
var pPolygons=pPolyGroup[i];
var pSubMesh=pMesh.getSubset(i);
var pSubMeshData=pSubMesh.data;
var pDecl=new Array(pPolygons.pInput.length);
var iIndex=0;
var pSurfaceMaterial=null;
var pSurfacePool=null;
for (var j=0; j < (pPolygons.pInput.length); ++j) {
pDecl[j] = new Object( {nCount: 1, eType: 5126, eUsage: (("INDEX") + (iIndex++)), iOffset: undefined});

}

pSubMeshData.allocateIndex(pDecl, new Float32Array(pPolygons.p));
for (var j=0; j < (pDecl.length); ++j) {
var sSemantic=pPolygons.pInput[j].sSemantic;
pSubMeshData.index(sSemantic, pDecl[j].eUsage);

}

pSubMesh.material.name = pPolygons.sMaterial;

}

pMesh.addFlexMaterial("default");
pMesh.setFlexMaterial("default");
pMeshList[sMeshName] = pMesh;
sharedBuffer(pMesh.buffer);
return buildMaterials(pMesh, pMeshNode);

}

;
function buildSkeleton(pSkeletonsList) {
var pSkeleton=null;
pSkeleton = new a.Skeleton(pEngine, pSkeletonsList[0]);
for (var i=0; i < (pSkeletonsList.length); ++i) {
pSkeleton.addRootJoint(source(pSkeletonsList[i]).pConstructedNode);

}

if (pModelResource && useScene) {
pModelResource.addSkeleton(pSkeleton);

}

return pSkeleton;

}

function buildSkinMesh(pSkinMeshNode) {
"use strict";
var pController=pSkinMeshNode.pController;
var pMaterials=pSkinMeshNode.pMaterials;
var pSkinData=pController.pSkin;
var pBoneList=pSkinData.pJoints.pInput["JOINT"].pArray;
var pBoneOffsetMatrices=pSkinData.pJoints.pInput["INV_BIND_MATRIX"].pArray;
var pGeometry=pSkinData.pGeometry;
var m4fBindMatrix=pSkinData.m4fShapeMatrix;
var pVertexWeights=pSkinData.pVertexWeights;
var pMesh;
var pSkeleton;
var pSkin;
pSkeleton = buildSkeleton(pSkinMeshNode.pSkeleton);
pMesh = buildMesh( {pGeometry: pGeometry, pMaterials: pMaterials});
pSkin = new a.Skin(pMesh);
pSkin.setBindMatrix(m4fBindMatrix);
pSkin.setBoneNames(pBoneList);
pSkin.setBoneOffsetMatrices(pBoneOffsetMatrices);
pSkin.setSkeleton(pSkeleton);
if (!(pSkin.setVertexWeights(new Float32Array(pVertexWeights.pVcount), new Float32Array(pVertexWeights.pV), new Float32Array(pVertexWeights.pWeightInput.pArray)))) {
if (!0) {
var err=((((((("Error:: " + "cannot set vertex weight info to skin") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("cannot set vertex weight info to skin");

}


}

;

}

pMesh.setSkin(pSkin);
pMesh.setSkeleton(pSkeleton);
pSkeleton.attachMesh(pMesh);
return pMesh;

}

function buildInstance(pInstances, fnBuilder, pSceneNode, bAttach) {
bAttach = bAttach || false;
var pInstance=null;
var pInstanceList=[];
for (var m=0; m < (pInstances.length); ++m) {
pInstance = fnBuilder(pInstances[m]);
pInstanceList.push(pInstance);
if (!pInstance) {
var err=((((((("Error:: " + (("cannot find instance <" + (pInstances[m].sUrl)) + ">\'s data")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/collada/Collada.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("cannot find instance <" + (pInstances[m].sUrl)) + ">\'s data"));

}


}

;
if (pModelResource && useScene) {
pModelResource.addMesh(pInstance);

}

if (bAttach) {
pSceneNode.addMesh(pInstance);

}


}

return pInstanceList;

}

function buildMeshes(pSceneRoot) {
var pMeshes=[];
findNode(pSceneRoot.pNodes, null, function(pNode) {
var pModelNode=pNode.pConstructedNode;
if (!(pModelNode instanceof (a.SceneModel))) {
pModelNode = new a.SceneModel(pEngine);
pModelNode.create();
pModelNode.attachToParent(pNode.pConstructedNode);

}

pMeshes.insert(buildInstance(pNode.pController, buildSkinMesh, pModelNode, false));
pMeshes.insert(buildInstance(pNode.pGeometry, buildMesh, pModelNode, true));

}
);
return pMeshes;

}

function findNode(pNodes, sNode, fnNodeCallback) {
sNode = sNode || null;
fnNodeCallback = fnNodeCallback || null;
var pNode=null;
var pRootJoint=null;
for (var i=(pNodes.length) - 1; i >= 0; i--) {
pNode = pNodes[i];
if (pNode === null) {
continue ;

}

if (sNode && (("#" + (pNode.id)) === sNode)) {
return pNode;

}

if (fnNodeCallback) {
fnNodeCallback(pNode);

}

if (pNode.pChildNodes) {
pRootJoint = findNode(pNode.pChildNodes, sNode, fnNodeCallback);
if (pRootJoint) {
return pRootJoint;

}


}


}

return null;

}

function buildSceneNode(pNode) {
var pSceneNode=pNode.pConstructedNode;
var pController, pGeometry;
if (!pSceneNode) {
if (pNode.pGeometry.length) {
pSceneNode = new a.SceneModel(pEngine);

}
else  {
pSceneNode = new a.SceneNode(pEngine);

}

pSceneNode.create();

}

return pSceneNode;

}

function buildJointNode(pNode) {
var pJointNode=pNode.pConstructedNode;
var sJointSid=pNode.sid;
var sJointName=pNode.id;
var pSkeleton;
if (!pJointNode) {
pJointNode = new a.Joint(pEngine);
pJointNode.create();
pJointNode.boneName = sJointSid;
if (bDrawJoints) {
var pSceneNode=pEngine.appendMesh(pEngine.pCubeMesh.clone((0) | (1)), pJointNode);
pSceneNode.name = sJointName + "[joint]";
pSceneNode.setScale(0.02);

}

;

}

return pJointNode;

}

function buildNodes(pNodes, pParentNode) {
pParentNode = pParentNode || null;
if (!pNodes) {
return null;

}

var pNode=null;
var pHierarchyNode=null;
var pMesh=null;
var pGeometry=null;
var m4fLocalMatrix=null;
for (var i=(pNodes.length) - 1; i >= 0; i--) {
pNode = pNodes[i];
if (!pNode) {
continue ;

}

if ((pNode.sType) === "JOINT") {
pHierarchyNode = buildJointNode(pNode);

}
else  {
pHierarchyNode = buildSceneNode(pNode);

}

pHierarchyNode.setName((pNode.id) || (pNode.sName));
pHierarchyNode.setInheritance(2);
pHierarchyNode.attachToParent(pParentNode);
pNode.pConstructedNode = pHierarchyNode;
m4fLocalMatrix = pHierarchyNode.accessLocalMatrix();
m4fLocalMatrix.set(pNode.m4fTransform);
buildNodes(pNode.pChildNodes, pHierarchyNode);

}

return pHierarchyNode;

}

function buildInititalPose(pNodes, pSkeleton) {
var sPose=(("Pose-" + sBasename) + "-") + (pSkeleton.name);
var pPose=new a.Animation(sPose);
var pNodeList=pSkeleton.getNodeList();
var pNodeMap= {};
var pTrack;
for (var i=0; i < (pNodeList.length); ++i) {
pNodeMap[pNodeList[i].name] = pNodeList[i];

}

findNode(pNodes, null, function(pNode) {
var sJoint=pNode.sid;
var sNodeId=pNode.id;
if (!(pNodeMap[sNodeId])) {
return ;

}

pTrack = new a.AnimationTrack(sJoint);
pTrack.nodeName = sNodeId;
pTrack.keyFrame(0, pNode.m4fTransform);
pPose.push(pTrack);

}
);
if (pModelResource && bExtractInitialPoses) {
pModelResource.addAnimation(pPose);

}

return pPose;

}

function buildInitialPoses(pSceneRoot, pPoseSkeletons) {
var pSkeleton;
var pPoses=[];
for (var i=0; i < (pPoseSkeletons.length); ++i) {
pSkeleton = pPoseSkeletons[i];
pPoses.push(buildInititalPose(pSceneRoot.pNodes, pSkeleton));

}

return pPoses;

}

function buildScene(pSceneRoot, pAsset) {
var pNodes=[];
var pNode=null;
for (var i=0; i < (pSceneRoot.pNodes.length); i++) {
pNode = pSceneRoot.pNodes[i];
pNodes.push(buildNodes([pNode], null));

}

for (var i=0; i < (pNodes.length); i++) {
pNodes[i] = buildAssetTransform(pNodes[i], pAsset);
if (pModelResource && useScene) {
pModelResource.addNode(pNodes[i]);

}


}

;
return pNodes;

}

;
function readLibraries(pXMLCollada, pTemplate, ppLibraries) {
ppLibraries = ppLibraries || pLib;
for (var i=0; i < (pTemplate.length); i++) {
ppLibraries[pTemplate[i].sLib] = COLLADALibrary(firstChild(pXMLCollada, pTemplate[i].sLib), pTemplate[i].sElement, pTemplate[i].fn);

}


}

function readCollada(sXMLData) {
"use strict";
var pParser=new DOMParser();
var pXMLRootNode=pParser.parseFromString(sXMLData, "application/xml");
var pXMLCollada=pXMLRootNode.getElementsByTagName("COLLADA")[0];
var pAsset;
var m4fRootTransform;
var pSceneRoot;
var pSkeletons, pSkeleton;
var pPoses;
var pSceneOutput=null;
var pAnimationOutput=null;
var pMeshOutput=null;
var pInitialPosesOutput=null;
readLibraries(pXMLCollada, pSceneTemplate);
pAsset = COLLADAAsset(firstChild(pXMLCollada, "asset"));
pSceneRoot = COLLADAScene(firstChild(pXMLCollada, "scene"));
if (pSceneRoot && useScene) {
pSceneOutput = buildScene(pSceneRoot, pAsset);
pMeshOutput = buildMeshes(pSceneRoot);

}

if (useAnimation) {
readLibraries(pXMLCollada, pAnimationTemplate);
if (pLib["library_animations"]) {
pAnimationOutput = buildAnimations(pLib["library_animations"].animation);

}


}

if (bExtractInitialPoses) {
pInitialPosesOutput = buildInitialPoses(pSceneRoot, pPoseSkeletons);

}

if (useAnimation && bAnimationWithPose) {
pSkeletons = pPoseSkeletons || ([]);
if (pMeshOutput) {
for (var i=0; i < (pMeshOutput.length); ++i) {
pSkeleton = pMeshOutput[i].skeleton;
pSkeletons.push(pSkeleton);

}


}
else  {
if (!pSceneOutput) {
buildScene(pSceneRoot, pAsset);

}

eachByTag(pXMLCollada, "skeleton", function(pXML) {
pSkeleton = buildSkeleton([stringData(pXML)]);
pSkeletons.push(pSkeleton);

}
);

}

pPoses = buildInitialPoses(pSceneRoot, pSkeletons);
for (var i=0; i < (pAnimationOutput.length); ++i) {
for (var j=0; j < (pPoses.length); ++j) {
pAnimationOutput[i].extend(pPoses[j]);

}


}


}

if (fnCallback) {
fnCallback.call(pEngine, pSceneOutput, pMeshOutput, pAnimationOutput, pInitialPosesOutput);

}


}

if (sFilename) {
a.fopen(sFilename).read(readCollada);
return true;

}
else if (sContent) {
readCollada(sContent);
return true;

}


return false;

}

a.COLLADA = COLLADA;
function Item(pRule, iPos, pExpected) {
this.pRule = pRule;
this.iPos = iPos;
this.pExpected =  {};
this.iIndex = 0;
this.isNewExpected = true;
this.pState = null;
this.iLength = 0;
if (pExpected) {
for (var i in pExpected) {
this.addExpected(i);

}


}


}

Item.prototype.isEqual_LR0 = function(pItem) {
return ((this.pRule) === (pItem.pRule)) && ((this.iPos) === (pItem.iPos));

};
Item.prototype.isEqual_LR = function(pItem) {
if (!((((this.pRule) === (pItem.pRule)) && ((this.iPos) === (pItem.iPos))) && ((this.iLength) === (pItem.iLength)))) {
return false;

}

for (var i in this.pExpected) {
if (!(pItem.isExpected(i))) {
return false;

}


}

return true;

};
Item.prototype.isParentItem = function(pItem) {
return ((this.pRule) === (pItem.pRule)) && ((this.iPos) === ((pItem.iPos) + 1));

};
Item.prototype.isChildItem = function(pItem) {
return ((this.pRule) === (pItem.pRule)) && ((this.iPos) === ((pItem.iPos) - 1));

};
Item.prototype.toString = function() {
var sMsg=(this.pRule.sLeft) + " -> ";
var sExpected="";
var pRight=this.pRule.pRight;
for (var k=0; k < (pRight.length); k++) {
if (k === (this.iPos)) {
sMsg += ". ";

}

sMsg += (pRight[k]) + " ";

}

if ((this.iPos) === (pRight.length)) {
sMsg += ". ";

}

if (this.pExpected) {
sExpected = ", ";
for (var l in this.pExpected) {
sExpected += l + "/";

}

if (sExpected !== ", ") {
sMsg += sExpected;

}


}

sMsg = sMsg.slice(0, (sMsg.length) - 1);
return sMsg;

};
Item.prototype.isExpected = function(sSymbol) {
return !(!(this.pExpected[sSymbol]));

};
Item.prototype.addExpected = function(sSymbol) {
if (this.pExpected[sSymbol]) {
return false;

}

this.pExpected[sSymbol] = 1;
this.isNewExpected = true;
this.iLength++;
return true;

};
Item.prototype.mark = function() {
if ((this.iPos) === (this.pRule.pRight.length)) {
return "END";

}

return this.pRule.pRight[this.iPos];

};
Item.prototype.end = function() {
return (this.pRule.pRight[(this.pRule.pRight.length) - 1]) || "EMPTY";

};
Item.prototype.nextMarked = function() {
return (this.pRule.pRight[(this.iPos) + 1]) || "END";

};
function State() {
this.pItems = [];
this.pNextStates =  {};
this.iIndex = 0;
this.nBaseItems = 0;

}

State.prototype.push = function(pItem) {
if (((this.pItems.length) === 0) || ((pItem.iPos) > 0)) {
this.nBaseItems += 1;

}

pItem.pState = this;
this.pItems.push(pItem);

};
State.prototype.hasItem = function(pItem) {
var i;
for (i = 0; i < (this.pItems.length); i++) {
if (this.pItems[i].isEqual_LR0(pItem)) {
return this.pItems[i];

}


}

return false;

};
State.prototype.toString = function(isBase) {
var len;
var sMsg;
sMsg = ("State " + (this.iIndex)) + ":\n";
var pItems=this.pItems;
len = (isBase? this.nBaseItems : pItems.length);
for (var j=0; j < len; j++) {
sMsg += "\t\t";
sMsg += pItems[j].toString();
sMsg += "\n";

}

return sMsg;

};
State.prototype.hasParentItem = function(pItem) {
var i;
for (i = 0; i < (this.pItems.length); i++) {
if (this.pItems[i].isParentItem(pItem)) {
return this.pItems[i];

}


}

return false;

};
State.prototype.hasChildItem = function(pItem) {
var i;
for (i = 0; i < (this.pItems.length); i++) {
if (this.pItems[i].isChildItem(pItem)) {
return this.pItems[i];

}


}

return false;

};
State.prototype.tryPush_LR0 = function(pRule, iPos) {
var i;
var pItems=this.pItems;
for (i = 0; i < (pItems.length); i++) {
if (((pItems[i].pRule) === pRule) && ((pItems[i].iPos) === iPos)) {
return false;

}


}

var pItem=new Item(pRule, iPos);
this.push(pItem);
return true;

};
State.prototype.tryPush = function(pRule, iPos, pExpectedSymbol) {
var i;
var pItems=this.pItems;
for (i = 0; i < (pItems.length); i++) {
if (((pItems[i].pRule) === pRule) && ((pItems[i].iPos) === iPos)) {
return pItems[i].addExpected(pExpectedSymbol);

}


}

var pExpected= {};
pExpected[pExpectedSymbol] = 1;
var pItem=new Item(pRule, iPos, pExpected, 1);
this.push(pItem);
return true;

};
State.prototype.deleteNotBase = function() {
this.pItems.length = this.nBaseItems;

};
State.prototype.isEqual_LR0 = function(pState) {
var pItemsA=this.pItems;
var pItemsB=pState.pItems;
if ((this.nBaseItems) !== (pState.nBaseItems)) {
return false;

}

var nItems=this.nBaseItems;
var i, j;
var isEqual;
for (i = 0; i < nItems; i++) {
isEqual = false;
for (j = 0; j < nItems; j++) {
if (pItemsA[i].isEqual_LR0(pItemsB[j])) {
isEqual = true;
break ;

}


}

if (!isEqual) {
return false;

}


}

return true;

};
State.prototype.isEqual_LR = function(pState) {
var pItemsA=this.pItems;
var pItemsB=pState.pItems;
if ((this.nBaseItems) !== (pState.nBaseItems)) {
return false;

}

var nItems=this.nBaseItems;
var i, j;
var isEqual;
for (i = 0; i < nItems; i++) {
isEqual = false;
for (j = 0; j < nItems; j++) {
if (pItemsA[i].isEqual_LR(pItemsB[j])) {
isEqual = true;
break ;

}


}

if (!isEqual) {
return false;

}


}

return true;

};
State.prototype.isEmpty = function() {
return !(this.pItems.length);

};
function Rule() {
this.sLeft = "";
this.pRight = [];
this.iIndex = 0;

}

function Operation(eType, pParam) {
this.eType = eType || 100;
this.iIndex = (eType === 101? pParam : -1);
this.pRule = (eType === 102? pParam : null);

}

function Tree() {
this.pRoot = null;
this._pNodes = [];
this._pNodesCountStack = [];

}

Tree.prototype._addLink = function(pParent, pNode) {
if (!(pParent.pChildren)) {
pParent.pChildren = [];

}

pParent.pChildren.push(pNode);
pNode.pParent = pParent;

};
Tree.prototype.setRoot = function() {
this.pRoot = this._pNodes.pop();

};
Tree.prototype.addNode = function(pNode) {
this._pNodes.push(pNode);
this._pNodesCountStack.push(1);

};
Tree.prototype.reduceByRule = function(pRule, isCreate, isOptimize) {
isCreate = isCreate || 10;
var iReduceCount=0;
var pNodesCountStack=this._pNodesCountStack;
var pNode;
var iRuleLength=pRule.pRight.length;
var pNodes=this._pNodes;
var nOptimize=(isOptimize? 1 : 0);
while (iRuleLength) {
iReduceCount += pNodesCountStack.pop();
iRuleLength--;

}
if (((isCreate === 10) && (iReduceCount > nOptimize)) || (isCreate === 9)) {
pNode =  {sName: pRule.sLeft};
while (iReduceCount) {
this._addLink(pNode, pNodes.pop());
iReduceCount -= 1;

}
pNodes.push(pNode);
pNodesCountStack.push(1);

}
else  {
pNodesCountStack.push(iReduceCount);

}


};
Tree.prototype.toString = function(pNode, sPadding) {
sPadding = sPadding || "";
var sRes=sPadding + "{\n";
var sOldPadding=sPadding;
var sDefaultPadding="  ";
sPadding += sDefaultPadding;
if (pNode.sValue) {
sRes += (((sPadding + "name : \"") + (pNode.sName)) + "\"") + ",\n";
sRes += (((sPadding + "value : \"") + (pNode.sValue)) + "\"") + "\n";

}
else  {
var i;
sRes += (((sPadding + "name : \"") + (pNode.sName)) + "\"") + "\n";
sRes += sPadding + "children : [";
if (pNode.pChildren) {
sRes += "\n";
sPadding += sDefaultPadding;
for (i = (pNode.pChildren.length) - 1; i >= 0; i--) {
sRes += this.toString(pNode.pChildren[i], sPadding);
sRes += ",\n";

}

sRes = sRes.slice(0, (sRes.length) - 2);
sRes += "\n";
sRes += (sOldPadding + sDefaultPadding) + "]\n";

}
else  {
sRes += " ]\n";

}


}

sRes += sOldPadding + "}";
return sRes;

};
Tree.prototype.toHTMLString = function(pNode, sPadding) {
sPadding = sPadding || "";
var sRes=sPadding + "{\n";
var sOldPadding=sPadding;
var sDefaultPadding="  ";
sPadding += sDefaultPadding;
if (pNode.sValue) {
sRes += (((sPadding + "<b style=\"color: #458383;\">name</b>: \"") + (pNode.sName)) + "\"") + ",\n";
sRes += (((sPadding + "<b style=\"color: #458383;\">value</b>: \"") + (pNode.sValue)) + "\"") + ",\n";
sRes += (((sPadding + "<b style=\"color: #458383;\">line</b>: \"") + (pNode.iLine)) + "\"") + ",\n";
sRes += (((sPadding + "<b style=\"color: #458383;\">column</b>: \"") + (pNode.iStart)) + "\"") + "\n";

}
else  {
var i;
sRes += (((sPadding + "<i style=\"color: #8A2BE2;\">name</i>: \"") + (pNode.sName)) + "\"") + "\n";
sRes += sPadding + "<i style=\"color: #8A2BE2;\">children</i>: [";
if (pNode.pChildren) {
sRes += "\n";
sPadding += sDefaultPadding;
for (i = (pNode.pChildren.length) - 1; i >= 0; i--) {
sRes += this.toHTMLString(pNode.pChildren[i], sPadding);
sRes += ",\n";

}

sRes = sRes.slice(0, (sRes.length) - 2);
sRes += "\n";
sRes += (sOldPadding + sDefaultPadding) + "]\n";

}
else  {
sRes += " ]\n";

}


}

sRes += sOldPadding + "}";
return sRes;

};
Tree.prototype.toTreeView = function(pNode) {
var pRes= {};
if (pNode.sValue) {
pRes.label = ((pNode.sName) + ": ") + (pNode.sValue);

}
else  {
pRes.label = pNode.sName;
if (pNode.pChildren) {
pRes.children = [];
pRes.expanded = true;
for (var i=(pNode.pChildren.length) - 1; i >= 0; i--) {
pRes.children.push(this.toTreeView(pNode.pChildren[i]));

}


}


}

return pRes;

};
Tree.prototype.cloneMe = function() {
function fnCloneNode(pNode, me) {
var pNewNode;
pNewNode =  {sName: pNode.sName, sValue: pNode.sValue};
for (var i=0; (pNode.pChildren) && (i < (pNode.pChildren.length)); i++) {
me._addLink(pNewNode, fnCloneNode(pNode.pChildren[i], me));

}

return pNewNode;

}

var pTree=new Tree();
pTree.pRoot = fnCloneNode(this.pRoot, this);
return pTree;

};
function ParserBase() {
this.sSource = "";
this.iIndex = 0;
this._pLex = null;
this._pStack = null;
this._pToken = null;
this._pFinishCallback = null;
this._pCaller = null;
this._pSymbols =  {"$": 1};
this._ppSynatxTable = null;
this._ppReduceOperations = null;
this._pSuccessOperation = null;
this._ppShiftOperations = null;
this._ppFirstTerminal = null;
this._ppFollowTerminal = null;
this._ppRules = null;
this._pStates = null;
this._nRules = 0;
this._pRuleFunction = null;
this._pAdditionalFunctions = null;
this.eType = 0;
this._pStatesTemp = null;
this._pBaseItemsIndex = null;
this._pExpectedExtensionTable = null;
this.pSyntaxTree = null;
this.pSymbolTable = null;
this._pSymbolsWithNodes = null;
this._isAllNodeMode = false;
this._isNegateMode = true;
this._isAddMode = true;
this._isOptimizeMode = true;
this._isSync = false;

}

ParserBase.prototype._error = function() {
var pErr=new Error();
pErr.arguments = arguments;
throw pErr;

};
ParserBase.prototype._clearMem = function() {
delete (this._ppFirstTerminal);
delete (this._ppFollowTerminal);
delete (this._ppRules);
delete (this._pStates);
delete (this._ppReduceOperations);
delete (this._ppShiftOperations);
delete (this._pSuccessOperation);
delete (this._pStatesTemp);
delete (this._pBaseItemsIndex);
delete (this._pExpectedExtensionTable);

};
ParserBase.prototype._hasState_LR0 = function(pState) {
var pStates=this._pStates;
var i;
for (i = 0; i < (pStates.length); i++) {
if (pStates[i].isEqual_LR0(pState)) {
return pStates[i];

}


}

return false;

};
ParserBase.prototype._hasState_LR = function(pState) {
var pStates=this._pStates;
var i;
for (i = 0; i < (pStates.length); i++) {
if (pStates[i].isEqual_LR(pState)) {
return pStates[i];

}


}

return false;

};
ParserBase.prototype._isTerminal = function(sSymbol) {
return !(this._ppRules[sSymbol]);

};
ParserBase.prototype._pushState = function(pState) {
pState.iIndex = this._pStates.length;
this._pStates.push(pState);

};
ParserBase.prototype._pushBaseItem = function(pItem) {
pItem.iIndex = this._pBaseItemsIndex.length;
this._pBaseItemsIndex.push(pItem);

};
ParserBase.prototype._tryAddState_LR = function(pState) {
var pRes=this._hasState_LR(pState);
if (!pRes) {
this._pushState(pState);
this._closure(pState);
return pState;

}

return pRes;

};
ParserBase.prototype._tryAddState_LR0 = function(pState) {
var pRes=this._hasState_LR0(pState);
if (!pRes) {
var i;
for (i = 0; i < (pState.pItems.length); i++) {
this._pushBaseItem(pState.pItems[i]);

}

this._pushState(pState);
this._closure_LR0(pState);
return pState;

}

return pRes;

};
ParserBase.prototype._hasEmptyRule = function(sSymbol) {
if (this._isTerminal(sSymbol)) {
return false;

}

var i;
for (i in this._ppRules[sSymbol]) {
if ((this._ppRules[sSymbol][i].pRight.length) === 0) {
return true;

}


}

return false;

};
ParserBase.prototype._pushInSyntaxTable = function(iIndex, sSymbol, pOperation) {
if (!(this._ppSynatxTable[iIndex])) {
this._ppSynatxTable[iIndex] =  {};

}

if (this._ppSynatxTable[iIndex][sSymbol]) {
this._error("Grammar is not LALR(1)!", "State:", this._pStates[iIndex], "Symbol:", sSymbol, ":", "Old value:", this._ppSynatxTable[iIndex][sSymbol], "New Value: ", pOperation);

}

this._ppSynatxTable[iIndex][sSymbol] = pOperation;

};
ParserBase.prototype._addStateLink = function(pState, pNextState, sSymbol) {
if (pState.pNextStates[sSymbol]) {
this._error("AddlinkState: Grammar is not LALR(1)! Rewrite link!", "State", pState, "Link to", pNextState, "Symbol", sSymbol);

}

pState.pNextStates[sSymbol] = pNextState;

};
ParserBase.prototype._firstTerminal = function(sSymbol) {
if (this._isTerminal(sSymbol)) {
return sSymbol;

}

if (this._ppFirstTerminal[sSymbol]) {
return this._ppFirstTerminal[sSymbol];

}

var i, j, k;
var pRules=this._ppRules[sSymbol];
var pTempRes= {};
var pRight;
var pRes;
var isFinish;
pRes = this._ppFirstTerminal[sSymbol] =  {};
if (this._hasEmptyRule(sSymbol)) {
pRes["EMPTY"] = 1;

}

for (i in pRules) {
isFinish = false;
pRight = pRules[i].pRight;
for (j = 0; j < (pRight.length); j++) {
if ((pRight[j]) === sSymbol) {
if (pRes["EMPTY"]) {
continue ;

}

isFinish = true;
break ;

}

pTempRes = this._firstTerminal(pRight[j]);
if ((typeof pTempRes) === "string") {
pRes[pTempRes] = 1;

}
else  {
for (k in pTempRes) {
pRes[k] = 1;

}


}

if (!(this._hasEmptyRule(pRight[j]))) {
isFinish = true;
break ;

}


}

if (!isFinish) {
pRes["EMPTY"] = 1;

}


}

return pRes;

};
ParserBase.prototype._followTerminal = function(sSymbol) {
if (this._ppFollowTerminal[sSymbol]) {
return this._ppFollowTerminal[sSymbol];

}

var pRes;
var pTempRes;
var pRules=this._ppRules;
var i, j, k, l, m;
var pRight;
var isFinish;
pRes = this._ppFollowTerminal[sSymbol] =  {};
for (i in pRules) {
for (j in pRules[i]) {
pRight = pRules[i][j].pRight;
for (k = 0; k < (pRight.length); k++) {
if ((pRight[k]) === sSymbol) {
if (k === ((pRight.length) - 1)) {
pTempRes = this._followTerminal(pRules[i][j].sLeft);
for (m in pTempRes) {
pRes[m] = 1;

}


}
else  {
isFinish = false;
for (l = k + 1; l < (pRight.length); l++) {
pTempRes = this._firstTerminal(pRight[l]);
if ((typeof pTempRes) === "string") {
pRes[pTempRes] = 1;
isFinish = true;
break ;

}
else  {
for (m in pTempRes) {
pRes[m] = 1;

}


}

if (!(pTempRes["EMPTY"])) {
isFinish = true;
break ;

}


}

if (!isFinish) {
pTempRes = this._followTerminal(pRules[i][j].sLeft);
for (m in pTempRes) {
pRes[m] = 1;

}


}


}


}


}


}


}

return pRes;

};
ParserBase.prototype._firstTerminalForSet = function(pSet, pExpected) {
var pRes= {};
var pTempRes;
var i, j;
var isEmpty;
for (i in pSet) {
pTempRes = this._firstTerminal(pSet[i]);
if ((typeof pTempRes) === "string") {
pRes[pTempRes] = 1;
return pRes;

}

isEmpty = false;
for (j in pTempRes) {
if (j === "EMPTY") {
isEmpty = true;
continue ;

}

pRes[j] = 1;

}

if (!isEmpty) {
return pRes;

}


}

for (i in pExpected) {
pRes[i] = 1;

}

return pRes;

};
ParserBase.prototype._generateRules = function(sSource) {
var pRuleArray=sSource.split(/\r?\n/);
var pTempArr;
var pRule;
var isLexer=false;
this._ppRules =  {};
this._pPunctuators =  {};
this._pKeywords =  {};
this._pRuleFunction =  {};
this._pSymbolsWithNodes =  {};
var i, j, k;
for (i = 0; i < (pRuleArray.length); i++) {
if (((pRuleArray[i]) === "") || ((pRuleArray[i]) === "\r")) {
continue ;

}

pTempArr = pRuleArray[i].split(/\s* \s*/);
if (isLexer) {
if ((((pTempArr.length) === 3) || (((pTempArr.length) === 4) && ((pTempArr[3]) === ""))) && ((((pTempArr[2][0]) === "\"") || ((pTempArr[2][0]) === "'")) && ((pTempArr[2].length) > 3))) {
if ((pTempArr[2][0]) !== (pTempArr[2][(pTempArr[2].length) - 1])) {
this._error("Can`t generate rules from grammar! Unexpected symbol! Must be");

}

pTempArr[2] = pTempArr[2].slice(1, (pTempArr[2].length) - 1);
var ch=pTempArr[2][0];
if (((ch === "_") || ((ch >= "a") && (ch <= "z"))) || ((ch >= "A") && (ch <= "Z"))) {
this._pLex.addKeyword(pTempArr[2], pTempArr[0]);

}
else  {
this._pLex.addPunctuator(pTempArr[2], pTempArr[0]);

}


}

continue ;

}

if ((pTempArr[0]) === "--LEXER--") {
isLexer = true;
continue ;

}
else  {
if (!(this._ppRules[pTempArr[0]])) {
this._ppRules[pTempArr[0]] =  {};

}

pRule = new Rule();
pRule.sLeft = pTempArr[0];
this._pSymbols[pTempArr[0]] = 1;
if (this._isAllNodeMode) {
console.log(111);
this._pSymbolsWithNodes[pTempArr[0]] = 10;

}
else  {
if (this._isNegateMode) {
if ((this._pSymbolsWithNodes[pTempArr[0]]) === undefined) {
this._pSymbolsWithNodes[pTempArr[0]] = 10;

}


}
else if (this._isAddMode) {
if ((this._pSymbolsWithNodes[pTempArr[0]]) === undefined) {
this._pSymbolsWithNodes[pTempArr[0]] = 11;

}


}



}

for (var j=2; j < (pTempArr.length); j++) {
if ((pTempArr[j]) === "") {
continue ;

}

if ((pTempArr[j]) === "--AN") {
if (this._isAddMode) {
this._pSymbolsWithNodes[pTempArr[0]] = 9;

}

continue ;

}

if ((pTempArr[j]) === "--NN") {
if ((this._isNegateMode) && (!(this._isAllNodeMode))) {
this._pSymbolsWithNodes[pTempArr[0]] = 11;

}

continue ;

}

if ((pTempArr[j]) === "--F") {
if ((!(pTempArr[j + 1])) || ((pTempArr[j + 1].length) === 0)) {
this._error("Can`t generate rule for grammar! Addititional functionhas has bad name");

}

this._pRuleFunction[this._nRules] = pTempArr[j + 1];
j++;
continue ;

}

if (((pTempArr[j][0]) === "'") || ((pTempArr[j][0]) === "\"")) {
if ((pTempArr[j].length) !== 3) {
this._error("Can`t generate rules from grammar! Keywords must be rules");

}

if ((pTempArr[j][0]) !== (pTempArr[j][2])) {
this._error("Can`t generate rules from grammar! Unexpected symbol! Must be");

}

var sName=this._pLex.addPunctuator(pTempArr[j][1]);
pRule.pRight.push(sName);
this._pSymbols[sName] = 1;

}
else  {
pRule.pRight.push(pTempArr[j]);
this._pSymbols[pTempArr[j]] = 1;

}


}

pRule.iIndex = this._nRules;
this._ppRules[pTempArr[0]][pRule.iIndex] = pRule;
this._nRules += 1;

}


}


};
ParserBase.prototype._generateFirstState_LR0 = function() {
var pState=new State();
var pItem=new Item(this._ppRules["S"][0], 0);
this._pushBaseItem(pItem);
pState.push(pItem);
this._closure_LR0(pState);
this._pushState(pState);

};
ParserBase.prototype._generateFirstState_LR = function() {
var pState=new State();
var pExpected= {};
pExpected["$"] = 1;
pState.push(new Item(this._ppRules["S"][0], 0, pExpected));
this._closure(pState);
this._pushState(pState);

};
ParserBase.prototype._closure_LR0 = function(pState) {
var pItems=pState.pItems;
var i, j;
var sSymbol;
for (i = 0; i < (pItems.length); i++) {
sSymbol = pItems[i].mark();
if ((sSymbol !== "END") && (!(this._isTerminal(sSymbol)))) {
for (j in this._ppRules[sSymbol]) {
pState.tryPush_LR0(this._ppRules[sSymbol][j], 0);

}


}


}

return pState;

};
ParserBase.prototype._closure = function(pState) {
var pItems=pState.pItems;
var i=0, j, k;
var sSymbol;
var pSymbols;
var pTempSet;
var isNewExpected=false;
while (1) {
if (i === (pItems.length)) {
if (!isNewExpected) {
break ;

}

i = 0;
isNewExpected = false;

}

sSymbol = pItems[i].mark();
if ((sSymbol !== "END") && (!(this._isTerminal(sSymbol)))) {
pTempSet = pItems[i].pRule.pRight.slice((pItems[i].iPos) + 1);
pSymbols = this._firstTerminalForSet(pTempSet, pItems[i].pExpected);
for (j in this._ppRules[sSymbol]) {
for (k in pSymbols) {
if (pState.tryPush(this._ppRules[sSymbol][j], 0, k)) {
isNewExpected = true;

}


}


}


}

i++;

}
return pState;

};
ParserBase.prototype._nextState_LR0 = function(pState, sSymbol) {
var pItems=pState.pItems;
var i;
var pNewState=new State();
for (i = 0; i < (pItems.length); i++) {
if (sSymbol === (pItems[i].mark())) {
pNewState.push(new Item(pItems[i].pRule, (pItems[i].iPos) + 1));

}


}

return pNewState;

};
ParserBase.prototype._nextState_LR = function(pState, sSymbol) {
var pItems=pState.pItems;
var i, j;
var pNewState=new State();
for (i = 0; i < (pItems.length); i++) {
if (sSymbol === (pItems[i].mark())) {
pNewState.push(new Item(pItems[i].pRule, (pItems[i].iPos) + 1, pItems[i].pExpected));

}


}

return pNewState;

};
ParserBase.prototype._deleteNotBaseItems = function() {
var i;
for (i in this._pStates) {
this._pStates[i].deleteNotBase();

}


};
ParserBase.prototype._closureForItem = function(pRule, iPos) {
var sIndex="";
sIndex += ((pRule.iIndex) + "_") + iPos;
var pState=this._pStatesTemp[sIndex];
if (pState) {
return pState;

}
else  {
pState = new State();
pState.push(new Item(pRule, iPos,  {"##": 1}));
this._closure(pState);
this._pStatesTemp[sIndex] = pState;
return pState;

}


};
ParserBase.prototype._addLinkExpected = function(pItem, pItemX) {
var pTable=this._pExpectedExtensionTable;
var iIndex=pItem.iIndex;
if (!(pTable[iIndex])) {
pTable[iIndex] =  {};

}

pTable[iIndex][pItemX.iIndex] = 1;

};
ParserBase.prototype._determineExpected = function(pTestState, sSymbol) {
var pStateX=pTestState.pNextStates[sSymbol];
if (pStateX) {
var pItemsX=pStateX.pItems;
var pState;
var pItem;
var i, j, k;
var pItems=pTestState.pItems;
for (i = 0; i < (pTestState.nBaseItems); i++) {
pState = this._closureForItem(pItems[i].pRule, pItems[i].iPos);
for (j = 0; j < (pStateX.nBaseItems); j++) {
pItem = pState.hasChildItem(pItemsX[j]);
if (pItem) {
for (k in pItem.pExpected) {
if (k === "##") {
this._addLinkExpected(pItems[i], pItemsX[j]);

}
else  {
pItemsX[j].addExpected(k);

}


}


}


}


}


}


};
ParserBase.prototype._generateLinksExpected = function() {
var i, j;
var pStates=this._pStates;
for (i = 0; i < (pStates.length); i++) {
for (j in this._pSymbols) {
this._determineExpected(pStates[i], j);

}


}


};
ParserBase.prototype._expandExpected = function() {
var pItems=this._pBaseItemsIndex;
var pTable=this._pExpectedExtensionTable;
var i=0, j;
var sSymbol;
var isNewExpected=false;
pItems[0].pExpected["$"] = 1;
pItems[0].isNewExpected = true;
while (1) {
if (i === (pItems.length)) {
if (!isNewExpected) {
break ;

}

isNewExpected = false;
i = 0;

}

if (pItems[i].isNewExpected) {
for (sSymbol in pItems[i].pExpected) {
for (j in pTable[i]) {
if (pItems[j].addExpected(sSymbol)) {
isNewExpected = true;

}


}


}


}

pItems[i].isNewExpected = false;
i++;

}

};
ParserBase.prototype._generateStates_LR0 = function() {
this._generateFirstState_LR0();
var i;
var pStates=this._pStates;
var sSymbol;
var pState;
for (i = 0; i < (pStates.length); i++) {
for (sSymbol in this._pSymbols) {
pState = this._nextState_LR0(pStates[i], sSymbol);
if (!(pState.isEmpty())) {
pState = this._tryAddState_LR0(pState);
this._addStateLink(pStates[i], pState, sSymbol);

}


}


}


};
ParserBase.prototype._generateStates_LR = function() {
this._ppFirstTerminal =  {};
this._generateFirstState_LR();
var i;
var pStates=this._pStates;
var sSymbol;
var pState;
for (i = 0; i < (pStates.length); i++) {
for (sSymbol in this._pSymbols) {
pState = this._nextState_LR(pStates[i], sSymbol);
if (!(pState.isEmpty())) {
pState = this._tryAddState_LR(pState);
this._addStateLink(pStates[i], pState, sSymbol);

}


}


}


};
ParserBase.prototype._generateStates_LALR = function() {
this._pStatesTemp =  {};
this._pBaseItemsIndex = [];
this._pExpectedExtensionTable =  {};
this._ppFirstTerminal =  {};
this._generateStates_LR0();
this._deleteNotBaseItems();
this._generateLinksExpected();
this._expandExpected();
var i;
var pStates=this._pStates;
for (i = 0; i < (pStates.length); i++) {
this._closure(pStates[i]);

}


};
ParserBase.prototype._calcBaseItem = function() {
var num=0;
for (var i in this._pStates) {
num += this._pStates[i].nBaseItems;

}

console.log("Num of base items : ", num);
return num;

};
ParserBase.prototype._printStates = function(isBase) {
var sMsg="";
var i;
for (i = 0; i < (this._pStates.length); i++) {
sMsg += (this._printState(this._pStates[i], isBase)) + " ";

}


};
ParserBase.prototype._printState = function(pState, isBase) {
var sMsg=pState.toString(isBase);
console.log(sMsg);
return sMsg;

};
ParserBase.prototype._printExpectedTable = function() {
var i, j;
var sMsg="";
for (i in this._pExpectedExtensionTable) {
sMsg += ("State " + (this._pBaseItemsIndex[i].pState.iIndex)) + ":   ";
sMsg += (this._pBaseItemsIndex[i].toString()) + "  |----->\n";
for (j in this._pExpectedExtensionTable[i]) {
sMsg += (("\t\t\t\t\t" + "State ") + (this._pBaseItemsIndex[j].pState.iIndex)) + ":   ";
sMsg += (this._pBaseItemsIndex[j].toString()) + "\n";

}

sMsg += "\n";

}

console.log(sMsg);

};
ParserBase.prototype._addReducing = function(pState) {
var i, j;
var pItems=pState.pItems;
for (i = 0; i < (pItems.length); i++) {
if ((pItems[i].mark()) === "END") {
if ((pItems[i].pRule.sLeft) === "S") {
this._pushInSyntaxTable(pState.iIndex, "$", this._pSuccessOperation);

}
else  {
for (j in pItems[i].pExpected) {
this._pushInSyntaxTable(pState.iIndex, j, this._ppReduceOperations[pItems[i].pRule.iIndex]);

}


}


}


}


};
ParserBase.prototype._addShift = function(pState) {
var i;
var pStates=pState.pNextStates;
for (i in pStates) {
this._pushInSyntaxTable(pState.iIndex, i, this._ppShiftOperations[pStates[i].iIndex]);

}


};
ParserBase.prototype._buildSyntaxTable = function() {
var i, j;
this._pStates = [];
var pStates=this._pStates;
var pState;
if ((this.eType) === 10) {
this._generateStates_LALR();

}
else if ((this.eType) === 11) {
this._generateStates_LR();

}


this._ppSynatxTable =  {};
this._ppReduceOperations =  {};
this._pSuccessOperation = new Operation(103);
this._ppShiftOperations =  {};
for (i = 0; i < (pStates.length); i++) {
this._ppShiftOperations[pStates[i].iIndex] = new Operation(101, pStates[i].iIndex);

}

for (i in this._ppRules) {
for (j in this._ppRules[i]) {
this._ppReduceOperations[j] = new Operation(102, this._ppRules[i][j]);

}


}

for (i = 0; i < (pStates.length); i++) {
pState = pStates[i];
this._addReducing(pState);
this._addShift(pState);

}


};
ParserBase.prototype._readToken = function() {
return this._pLex.getNextToken();

};
ParserBase.prototype._ruleAction = function(pRule) {
this.pSyntaxTree.reduceByRule(pRule, this._pSymbolsWithNodes[pRule.sLeft], this._isOptimizeMode);
var pActionName=this._pRuleFunction[pRule.iIndex];
if (pActionName) {
return this._pAdditionalFunctions[pActionName].call(this, pRule);

}

return true;

};
ParserBase.prototype._defaultInit = function() {
this.iIndex = 0;
this._pStack = [0];
this.pSyntaxTree = new Tree();
this.pSymbolTable =  {};

};
ParserBase.prototype._resumeParse = function() {
try {
var pTree=this.pSyntaxTree;
var pStack=this._pStack;
var ppSyntaxTable=this._ppSynatxTable;
var isStop=false;
var isError=false;
var isPause=false;
var pToken=this._pToken;
var pOperation;
var iRuleLength;
while (!isStop) {
pOperation = ppSyntaxTable[pStack[(pStack.length) - 1]][pToken.sName];
if (pOperation) {
switch(pOperation.eType) {
case 103:
isStop = true;
break ;

case 101:
pStack.push(pOperation.iIndex);
pTree.addNode(pToken);
pToken = this._readToken();
break ;

case 102:
iRuleLength = pOperation.pRule.pRight.length;
pStack.length -= iRuleLength;
pStack.push(ppSyntaxTable[pStack[(pStack.length) - 1]][pOperation.pRule.sLeft].iIndex);
if ((this._ruleAction(pOperation.pRule)) === 104) {
this._pToken = pToken;
isStop = true;
isPause = true;

}

break ;
}

}
else  {
isError = true;
isStop = true;

}


}
if (isPause) {
trace("Pause syntax parse of file");
return 104;

}

if (!isError) {
pTree.setRoot();
trace("Syntax analyze of source file is good");
return (this._pFinishCallback? this._pFinishCallback.call(this._pCaller, 200) : true);

}
else  {
trace("Error!!!", pToken);
return (this._pFinishCallback? this._pFinishCallback.call(this._pCaller, 401) : 401);

}


}
catch(e) {
console.error(e.stack);

}

};
ParserBase.prototype.isTypeId = function(sValue) {
return !(!((this.pSymbolTable[sValue]) && (this.pSymbolTable[sValue].isType)));

};
ParserBase.prototype.returnCode = function(pNode) {
if (pNode) {
if (pNode.sValue) {
return (pNode.sValue) + " ";

}
else if (pNode.pChildren) {
var sCode="";
var i;
for (i = (pNode.pChildren.length) - 1; i >= 0; i--) {
sCode += this.returnCode(pNode.pChildren[i]);

}

return sCode;

}



}

return "";

};
ParserBase.prototype.init = function(sGrammar, eType, pFlags) {
try {
this.eType = eType || 10;
this._pLex = new Lexer(this);
if (pFlags) {
this._isAddMode = (pFlags.addMode) || false;
this._isNegateMode = (pFlags.negateMode) || false;
this._isAllNodeMode = (pFlags.allMode) || false;
this._isOptimizeMode = (pFlags.optimizeMode) || false;

}

this._generateRules(sGrammar);
this._buildSyntaxTable();
this._clearMem();
return true;

}
catch(e) {
console.error(e.stack, e.arguments);
return false;

}

};
ParserBase.prototype.parse = function(sSource, isSync, fnFinish, pCaller) {
try {
this._defaultInit();
this.sSource = sSource;
this._pLex.init(sSource);
this._isSync = isSync;
this._pFinishCallback = fnFinish || null;
this._pCaller = pCaller || null;
var pTree=this.pSyntaxTree;
var pStack=this._pStack;
var ppSyntaxTable=this._ppSynatxTable;
var isStop=false;
var isError=false;
var isPause=false;
var pToken=this._readToken();
var pOperation;
var iRuleLength;
while (!isStop) {
pOperation = ppSyntaxTable[pStack[(pStack.length) - 1]][pToken.sName];
if (pOperation) {
switch(pOperation.eType) {
case 103:
isStop = true;
break ;

case 101:
pStack.push(pOperation.iIndex);
pTree.addNode(pToken);
pToken = this._readToken();
break ;

case 102:
iRuleLength = pOperation.pRule.pRight.length;
pStack.length -= iRuleLength;
pStack.push(ppSyntaxTable[pStack[(pStack.length) - 1]][pOperation.pRule.sLeft].iIndex);
if ((this._ruleAction(pOperation.pRule)) === 104) {
this._pToken = pToken;
isStop = true;
isPause = true;

}

break ;
}

}
else  {
isError = true;
isStop = true;

}


}
if (isPause) {
trace("Pause syntax parse of file");
return 104;

}

if (!isError) {
pTree.setRoot();
trace("Syntax analyze of source file is good");
return (this._pFinishCallback? this._pFinishCallback.call(this._pCaller, 200) : 200);

}
else  {
trace("Error!!!", pToken);
return (this._pFinishCallback? this._pFinishCallback.call(this._pCaller, 401) : 401);

}


}
catch(e) {
console.error(e.stack);

}

};
ParserBase.prototype.pause = function() {
return 104;

};
ParserBase.prototype.resume = function() {
this._resumeParse();

};
ParserBase.prototype.error = function(eCode) {
return (this._pFinishCallback? this._pFinishCallback.call(this._pCaller, eCode) : eCode);

};
function Lexer(pParser) {
this.iLineNumber = 0;
this.iColumnNumber = 0;
this.sSource = "";
this.iIndex = 0;
this.pParser = pParser || null;
this._pPunctuators =  {};
this._pKeywords =  {};
this._pPunctuatorsFirstSymbols =  {};
if (!(this.constructor.errorMessages)) {
this.constructor.errorMessages =  {11: "Bad token! Information:", 12: "Unknown token! Information:"};

}

;

}

Lexer.prototype.addPunctuator = function(sValue, sName) {
if ((!sName) && ((sValue.length) === 1)) {
sName = "T_PUNCTUATOR_" + (sValue.charCodeAt(0));

}

this._pPunctuators[sValue] = sName;
this._pPunctuatorsFirstSymbols[sValue[0]] = 1;
return sName;

};
Lexer.prototype.addKeyword = function(sValue, sName) {
this._pKeywords[sValue] = sName;

};
Lexer.prototype.init = function(sSource) {
this.sSource = sSource;
this.iLineNumber = 0;
this.iColumnNumber = 0;
this.iIndex = 0;

};
Lexer.prototype.getNextToken = function() {
var ch=this._currentChar();
if (!ch) {
return  {sName: "$", sValue: "$", iStart: this.iColumnNumber, iEnd: this.iColumnNumber, iLine: this.iLineNumber};

}

var eType=this._identifyTokenType(ch);
var pToken;
switch(eType) {
case 1:
pToken = this._scanNumber();
break ;

case 2:
this._scanComment();
pToken = this.getNextToken();
break ;

case 3:
pToken = this._scanString();
break ;

case 4:
pToken = this._scanPunctuator();
break ;

case 7:
pToken = this._scanKeyWord();
break ;

case 6:
pToken = this._scanIdentifier();
break ;

case 5:
this._scanWhiteSpace();
pToken = this.getNextToken();
break ;

default:
this._error(12,  {sValue: ch + (this.sSource[(this.iIndex) + 1]), iStart: this.iColumnNumber, iLine: this.iLineNumber});
}
return pToken;

};
Lexer.prototype._error = function(sMsg, pInfo) {
trace(this.constructor.sMsg, pInfo);
if (!0) {
var err=((((((("Error:: " + this.constructor.sMsg) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/utils/Parser.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(this.constructor.sMsg);

}


}

;

};
Lexer.prototype._identifyTokenType = function() {
if (this._isIdentifierStart()) {
return 6;

}

if (this._isWhiteSpaceStart()) {
return 5;

}

if (this._isStringStart()) {
return 3;

}

if (this._isCommentStart()) {
return 2;

}

if (this._isNumberStart()) {
return 1;

}

if (this._isPunctuatorStart()) {
return 4;

}

return 8;

};
Lexer.prototype._isNumberStart = function() {
var ch=this._currentChar();
if ((ch >= "0") && (ch <= "9")) {
return true;

}

var ch1=this.sSource[(this.iIndex) + 1];
if (((ch === ".") && (ch1 >= "0")) && (ch1 <= "9")) {
return true;

}

return false;

};
Lexer.prototype._isCommentStart = function() {
var ch=this._currentChar();
var ch1=this.sSource[(this.iIndex) + 1];
if ((ch === "/") && ((ch1 === "/") || (ch1 === "*"))) {
return true;

}

return false;

};
Lexer.prototype._isStringStart = function() {
var ch=this._currentChar();
if ((ch === "\"") || (ch === "'")) {
return true;

}

return false;

};
Lexer.prototype._isPunctuatorStart = function() {
var ch=this._currentChar();
if (this._pPunctuatorsFirstSymbols[ch]) {
return true;

}

return false;

};
Lexer.prototype._isIdentifierStart = function() {
var ch=this._currentChar();
if (((ch === "_") || ((ch >= "a") && (ch <= "z"))) || ((ch >= "A") && (ch <= "Z"))) {
return true;

}

return false;

};
Lexer.prototype._isWhiteSpaceStart = function() {
var ch=this._currentChar();
if ((((ch === " ") || (ch === "\n")) || (ch === "\r")) || (ch === "\t")) {
return true;

}

return false;

};
Lexer.prototype._isLineTerminator = function(ch) {
return (((ch === "\n") || (ch === "\r")) || (ch === "\u2028")) || (ch === "\u2029");

};
Lexer.prototype._isWhiteSpace = function(ch) {
return (ch === " ") || (ch === "\t");

};
Lexer.prototype._isKeyword = function(sValue) {
return !(!(this._pKeywords[sValue]));

};
Lexer.prototype._isPunctuator = function(sValue) {
return !(!(this._pPunctuators[sValue]));

};
Lexer.prototype._nextChar = function() {
this.iIndex++;
this.iColumnNumber++;
return this.sSource[this.iIndex];

};
Lexer.prototype._currentChar = function() {
return this.sSource[this.iIndex];

};
Lexer.prototype._scanString = function() {
var chFirst=this._currentChar();
var sValue=chFirst;
var ch;
var chPrevious=chFirst;
var isGoodFinish=false;
var iStart=this.iColumnNumber;
while (1) {
ch = this._nextChar();
if (!ch) {
break ;

}

sValue += ch;
if ((ch === chFirst) && (chPrevious !== "\\")) {
isGoodFinish = true;
this._nextChar();
break ;

}

chPrevious = ch;

}
if (isGoodFinish) {
return  {sName: "T_STRING", sValue: sValue, iStart: iStart, iEnd: (this.iColumnNumber) - 1, iLine: this.iLineNumber};

}
else  {
if (!ch) {
ch = "EOF";

}

sValue += ch;
this._error(11,  {eType: 3, sValue: sValue, iStart: iStart, iEnd: this.iColumnNumber, iLine: this.iLineNumber});

}


};
Lexer.prototype._scanPunctuator = function() {
var sValue=this._currentChar();
var ch;
var iStart=this.iColumnNumber;
while (1) {
ch = this._nextChar();
if (ch) {
sValue += ch;
this.iColumnNumber++;
if (!(this._isPunctuator(sValue))) {
sValue = sValue.slice(0, (sValue.length) - 1);
break ;

}


}
else  {
break ;

}


}
return  {sName: this._pPunctuators[sValue], sValue: sValue, iStart: iStart, iEnd: (this.iColumnNumber) - 1, iLine: this.iLineNumber};

};
Lexer.prototype._scanWhiteSpace = function() {
var ch=this._currentChar();
while (1) {
if (!ch) {
break ;

}

if (this._isLineTerminator(ch)) {
this.iLineNumber++;
ch = this._nextChar();
this.iColumnNumber = 0;
continue ;

}
else if (ch === "\t") {
this.iColumnNumber += 3;

}
else if (ch !== " ") {
break ;

}



ch = this._nextChar();

}
return true;

};
Lexer.prototype._scanComment = function() {
var sValue=this._currentChar();
var ch=this._nextChar();
sValue += ch;
if (ch === "/") {
while (1) {
ch = this._nextChar();
if (!ch) {
break ;

}

if (this._isLineTerminator(ch)) {
this.iLineNumber++;
this._nextChar();
this.iColumnNumber = 0;
break ;

}

sValue += ch;

}
return true;

}
else  {
var chPrevious=ch;
var isGoodFinish=false;
var iStart=this.iColumnNumber;
while (1) {
ch = this._nextChar();
if (!ch) {
break ;

}

sValue += ch;
if ((ch === "/") && (chPrevious === "*")) {
isGoodFinish = true;
this._nextChar();
break ;

}

if (this._isLineTerminator(ch)) {
this.iLineNumber++;
this.iColumnNumber = -1;

}

chPrevious = ch;

}
if (isGoodFinish) {
return true;

}
else  {
if (!ch) {
ch = "EOF";

}

sValue += ch;
this._error(11,  {eType: 2, sValue: sValue, iStart: iStart, iEnd: this.iColumnNumber, iLine: this.iLineNumber});

}


}


};
Lexer.prototype._scanNumber = function() {
var ch=this._currentChar();
var sValue="";
var isFloat=false;
var chPrevious=ch;
var isGoodFinish=false;
var iStart=this.iColumnNumber;
var isE=false;
if (ch === ".") {
sValue += 0;
isFloat = true;

}

sValue += ch;
while (1) {
ch = this._nextChar();
if (ch === ".") {
if (isFloat) {
break ;

}
else  {
isFloat = true;

}


}
else if (ch === "e") {
if (isE) {
break ;

}
else  {
isE = true;

}


}
else if (((ch === "+") || (ch === "-")) && (chPrevious === "e")) {
sValue += ch;
chPrevious = ch;
continue ;

}
else if ((ch === "f") && isFloat) {
ch = this._nextChar();
if (((ch >= "a") && (ch <= "z")) || ((ch >= "A") && (ch <= "Z"))) {
break ;

}

isGoodFinish = true;
break ;

}
else if (((ch >= "a") && (ch <= "z")) || ((ch >= "A") && (ch <= "Z"))) {
break ;

}
else if ((!((ch >= "0") && (ch <= "9"))) || (!ch)) {
if ((((isE && (chPrevious !== "+")) && (chPrevious !== "-")) && (chPrevious !== "e")) || (!isE)) {
isGoodFinish = true;

}

break ;

}






sValue += ch;
chPrevious = ch;

}
if (isGoodFinish) {
var sName=(isFloat? "T_FLOAT" : "T_UINT");
return  {sName: sName, sValue: sValue, iStart: iStart, iEnd: (this.iColumnNumber) - 1, iLine: this.iLineNumber};

}
else  {
if (!ch) {
ch = "EOF";

}

sValue += ch;
this._error(11,  {eType: 1, sValue: sValue, iStart: iStart, iEnd: this.iColumnNumber, iLine: this.iLineNumber});

}


};
Lexer.prototype._scanIdentifier = function() {
var ch=this._currentChar();
var sValue=ch;
var iStart=this.iColumnNumber;
var isGoodFinish=false;
while (1) {
ch = this._nextChar();
if (!ch) {
isGoodFinish = true;
break ;

}

if (!((((ch === "_") || ((ch >= "a") && (ch <= "z"))) || ((ch >= "A") && (ch <= "Z"))) || ((ch >= "0") && (ch <= "9")))) {
isGoodFinish = true;
break ;

}

sValue += ch;

}
if (isGoodFinish) {
if (this._isKeyword(sValue)) {
return  {sName: this._pKeywords[sValue], sValue: sValue, iStart: iStart, iEnd: (this.iColumnNumber) - 1, iLine: this.iLineNumber};

}
else  {
var sName=(this.pParser.isTypeId(sValue)? "T_TYPE_ID" : "T_NON_TYPE_ID");
return  {sName: sName, sValue: sValue, iStart: iStart, iEnd: (this.iColumnNumber) - 1, iLine: this.iLineNumber};

}


}
else  {
if (!ch) {
ch = "EOF";

}

sValue += ch;
this._error(11,  {eType: 6, sValue: sValue, iStart: iStart, iEnd: this.iColumnNumber, iLine: this.iLineNumber});

}


};
function EffectParser() {
var _pCtorValue=EffectParser.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pAdditionalFunctions =  {addType: this._addType, includeCode: this._includeCode};
this._pIncludeTable =  {};

}

a.extend(EffectParser, ParserBase);
EffectParser.prototype._addType = function(pRule) {
var pTree=this.pSyntaxTree;
var pNode=pTree._pNodes[(pTree._pNodes.length) - 1];
pNode = pNode.pChildren[(pNode.pChildren.length) - 1];
var sName=pNode.pChildren[(pNode.pChildren.length) - 2].sValue;
this.pSymbolTable[sName] =  {isType: 1};
return true;

};
EffectParser.prototype._includeCode = function(pRule) {
var pTree=this.pSyntaxTree;
var pNode=pTree._pNodes[(pTree._pNodes.length) - 1];
var sFile=pNode.pChildren[0].sValue;
sFile = sFile.substr(1, (sFile.length) - 2);
if (this._pIncludeTable[sFile]) {
return this._pIncludeTable[sFile];

}

if (this._isSync) {
var pRequest=a.ajax( {url: sFile, async: false});
if ((pRequest.xhr.status) === (200)) {
var sSource=pRequest.data;
var index=this._pLex.iIndex;
this.sSource = ((this.sSource.substr(0, index)) + sSource) + (this.sSource.substr(index));
this._pIncludeTable[sFile] = sSource;
return true;

}
else  {
error("Could not load file in 'inlude'", sFile);
return false;

}


}
else  {
var me=this;
a.fopen(sFile, "r").read(function(pData) {
var sSource=pData;
var index=me._pLex.iIndex;
sSource = ((me.sSource.substr(0, index)) + pData) + (me.sSource.substr(index));
me.sSource = sSource;
me._pLex.sSource = sSource;
me._pIncludeTable[sFile] = pData;
me.resume();

}
, function() {
me.error(400);

}
);
return this.pause();

}


};
EffectParser.prototype._defaultInit = function() {
this.iIndex = 0;
this._pStack = [0];
this.pSyntaxTree = new Tree();
this.pSymbolTable =  {float2:  {isType: 1}, float3:  {isType: 1}, float4:  {isType: 1}, float2x2:  {isType: 1}, float3x3:  {isType: 1}, float4x4:  {isType: 1}, int2:  {isType: 1}, int3:  {isType: 1}, int4:  {isType: 1}, bool2:  {isType: 1}, bool3:  {isType: 1}, bool4:  {isType: 1}};

};
a.util.parser = new EffectParser();
a.util.parser.init(a.ajax( {url: "http://akra/akra-engine-general/media/grammars/HLSL_grammar.gr", async: false}).data);
function PoolGroup(pEngine, fnTemplate, iMaxCount) {
if (!pEngine) {
var err=((((((("Error:: " + "Engine не передан в PoolGroup") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Engine не передан в PoolGroup");

}


}

;
if (!(fnTemplate != undefined)) {
var err=((((((("Error:: " + "Type data not defined") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Type data not defined");

}


}

;
this._pEngine = pEngine;
this._fnTemplate = fnTemplate;
this._iTotalOpen = 0;
this._iFirstOpen = 0;
this._iMaxCount = iMaxCount;
this._pNextOpenList = null;
this._pMemberList = null;

}

PoolGroup.prototype.create = function() {
var i;
if (!(((this._pMemberList) == null) && ((this._pNextOpenList) == null))) {
var err=((((((("Error:: " + "Group has already been created") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Group has already been created");

}


}

;
this._pNextOpenList = new Array(this._iMaxCount);
if (!((this._pNextOpenList) != null)) {
var err=((((((("Error:: " + "tragic memory allocation failure!") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("tragic memory allocation failure!");

}


}

;
this._pMemberList = new Array(this._iMaxCount);
for (i = 0; i < (this._iMaxCount); i++) {
this._pMemberList[i] = new this._fnTemplate(this._pEngine);

}

if (!((this._pNextOpenList) != null)) {
var err=((((((("Error:: " + "tragic memory allocation failure!") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("tragic memory allocation failure!");

}


}

;
for (i = 0; i < ((this._iMaxCount) - 1); i++) {
this._pNextOpenList[i] = i + 1;

}

this._pNextOpenList[i] = i;
this._iTotalOpen = this._iMaxCount;
this._iFirstOpen = 0;

};
PoolGroup.prototype.destroy = function() {
if (!(((this._pMemberList) != null) && ((this._pNextOpenList) != null))) {
var err=((((((("Error:: " + "Group has not been created") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Group has not been created");

}


}

;
if (!((this._iTotalOpen) == (this._iMaxCount))) {
var err=((((((("Error:: " + "Group is not empty") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Group is not empty");

}


}

;
delete (this._pMemberList);
this._pMemberList = null;
delete (this._pNextOpenList);
this._pNextOpenList = null;
this._iTotalOpen = 0;
this._iMaxCount = 0;

};
PoolGroup.prototype.nextMember = function() {
if (!(((this._pMemberList) != null) && ((this._pNextOpenList) != null))) {
var err=((((((("Error:: " + "Group has not been created") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Group has not been created");

}


}

;
if (!((this._iTotalOpen) != null)) {
var err=((((((("Error:: " + "no open slots") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("no open slots");

}


}

;
var iSlot=this._iFirstOpen;
this._iFirstOpen = this._pNextOpenList[iSlot];
this._iTotalOpen--;
if (!((this._iFirstOpen) != 65535)) {
var err=((((((("Error:: " + "Invalid Open Index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Invalid Open Index");

}


}

;
if (!this.isOpen(iSlot)) {
var err=((((((("Error:: " + "invalid index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid index");

}


}

;
this._pNextOpenList[iSlot] = 65535;
return iSlot;

};
PoolGroup.prototype.addMember = function(pMember) {
var iSlot=this.nextMember();
this._pMemberList[iSlot] = pMember;
return iSlot;

};
PoolGroup.prototype.release = function(iIndex) {
if (!(((this._pMemberList) != null) && ((this._pNextOpenList) != null))) {
var err=((((((("Error:: " + "Group has not been created") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Group has not been created");

}


}

;
if (!(iIndex < (this._iMaxCount))) {
var err=((((((("Error:: " + "invalid index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid index");

}


}

;
if (!((this.isOpen(iIndex)) == false)) {
var err=((((((("Error:: " + "invalid index to release") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid index to release");

}


}

;
this._pNextOpenList[iIndex] = ((this._iTotalOpen) > 0? this._iFirstOpen : iIndex);
this._iTotalOpen++;
this._iFirstOpen = iIndex;

};
PoolGroup.prototype.totalOpen = function(pMember) {
return this._iTotalOpen;

};
PoolGroup.prototype.totalUsed = function(pMember) {
return (this._iMaxCount) - (this._iTotalOpen);

};
PoolGroup.prototype.firstOpen = function(pMember) {
return this._iFirstOpen;

};
PoolGroup.prototype.isOpen = function(iIndex) {
if (!(((this._pMemberList) != null) && ((this._pNextOpenList) != null))) {
var err=((((((("Error:: " + "Group has not been created") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Group has not been created");

}


}

;
if (!(iIndex < (this._iMaxCount))) {
var err=((((((("Error:: " + "invalid index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid index");

}


}

;
return (this._pNextOpenList[iIndex]) != 65535;

};
PoolGroup.prototype.member = function(iIndex) {
if (!(((this._pMemberList) != null) && ((this._pNextOpenList) != null))) {
var err=((((((("Error:: " + "Group has not been created") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Group has not been created");

}


}

;
if (!(iIndex < (this._iMaxCount))) {
var err=((((((("Error:: " + "invalid index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid index");

}


}

;
return this._pMemberList[iIndex];

};
PoolGroup.prototype.memberPtr = function(iIndex) {
if (!(((this._pMemberList) != null) && ((this._pNextOpenList) != null))) {
var err=((((((("Error:: " + "Group has not been created") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Group has not been created");

}


}

;
if (!(iIndex < (this._iMaxCount))) {
var err=((((((("Error:: " + "invalid index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid index");

}


}

;
return this._pMemberList[iIndex];

};
function DataPoolInterface(pEngine, fnTemplate) {
if (!(fnTemplate != undefined)) {
var err=((((((("Error:: " + "Type data not defined") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Type data not defined");

}


}

;
this._pEngine = pEngine;
this._fnTemplate = fnTemplate;
this._iInitialized = false;

}

DataPoolInterface.prototype.initialize = function(iGrowSize) {

};
DataPoolInterface.prototype.initialize = null;
DataPoolInterface.prototype.destroy = function() {

};
DataPoolInterface.prototype.destroy = null;
DataPoolInterface.prototype.clear = function() {

};
DataPoolInterface.prototype.clear = null;
DataPoolInterface.prototype.nextHandle = function() {

};
DataPoolInterface.prototype.nextHandle = null;
DataPoolInterface.prototype.release = function(iHandle) {

};
DataPoolInterface.prototype.release = null;
DataPoolInterface.prototype.forEach = function(fFunction) {

};
DataPoolInterface.prototype.forEach = null;
DataPoolInterface.prototype.getGenericPtr = function(iHandle) {

};
DataPoolInterface.prototype.getGenericPtr = null;
DataPoolInterface.prototype.isInitialized = function() {
return this._iInitialized;

};
a.DataPoolInterface = DataPoolInterface;
function DataPool(pEngine, fnTemplate) {
this._pGroupList = new Array();
this._iTotalMembers = 0;
this._iTotalOpen = 0;
this._iGroupCount = 0;
this._iIndexMask = 0;
this._iIndexShift = 0;
DataPool.superclass.constructor.apply(this, arguments);

}

a.extend(DataPool, a.DataPoolInterface);
DataPool.prototype.initialize = function(iGrowSize) {
if (!((this.isInitialized()) == false)) {
var err=((((((("Error:: " + "the cDataPool is already initialized") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("the cDataPool is already initialized");

}


}

;
this._iInitialized = true;
this._iGroupCount = Math.nearestPowerOfTwo(iGrowSize);
this._iIndexShift = Math.lowestBitSet(this._iGroupCount);
this._iIndexShift = Math.max(1, Math.min(this._iIndexShift, 15));
this._iGroupCount = 1 << (this._iIndexShift);
this._iIndexMask = (this._iGroupCount) - 1;

};
DataPool.prototype.destroy = function() {
this.clear();
this._iInitialized = false;

};
DataPool.prototype._getGroupNumber = function(iHandle) {
return iHandle >> (this._iIndexShift);

};
DataPool.prototype._getItemIndex = function(iHandle) {
return iHandle & (this._iIndexMask);

};
DataPool.prototype._buildHandle = function(iGroup, iIndex) {
return (iGroup << (this._iIndexShift)) + iIndex;

};
DataPool.prototype.forEach = function(fFunction) {
if (!((this.isInitialized()) == true)) {
var err=((((((("Error:: " + "the cDataPool is not initialized") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("the cDataPool is not initialized");

}


}

;
var iGroupNumber=0;
for (GroupIter = 0; GroupIter < (this._pGroupList.length); GroupIter++) {
var nCallbackCount=this._pGroupList[GroupIter].totalUsed();
var iItemIndex=0;
while ((nCallbackCount != 0) && (iItemIndex < (this._iGroupCount))) {
if ((this._pGroupList[GroupIter].isOpen(iItemIndex)) == false) {
fFunction(this, this._buildHandle(iGroupNumber, iItemIndex), this._pGroupList[GroupIter].member(iItemIndex));
nCallbackCount--;

}

++iItemIndex;

}
++iGroupNumber;

}


};
DataPool.prototype.clear = function() {
for (var GroupIter in this._pGroupList) {
this._pGroupList[GroupIter].destroy();

}

this._pGroupList.splice(0);

};
DataPool.prototype._addGroup = function() {
var pNewGroup=new PoolGroup(this._pEngine, this._fnTemplate, this._iGroupCount);
this._pGroupList.push(pNewGroup);
pNewGroup.create();
this._iTotalMembers += this._iGroupCount;
this._iTotalOpen += this._iGroupCount;
return pNewGroup;

};
DataPool.prototype._findOpenGroup = function(pGroupNumber) {
pGroupNumber.value = 0;
for (GroupIter = 0; GroupIter < (this._pGroupList.length); GroupIter++) {
if ((this._pGroupList[GroupIter].totalOpen()) > 0) {
return this._pGroupList[GroupIter];

}

pGroupNumber.value++;

}

if (!(((this._pGroupList.length) + 1) < 65535)) {
var err=((((((("Error:: " + "the cDataPool is full!!!!") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("the cDataPool is full!!!!");

}


}

;
return this._addGroup();

};
DataPool.prototype._getGroup = function(iIndex) {
if (!(iIndex < (this._pGroupList.length))) {
var err=((((((("Error:: " + "Invalid group index requested") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Invalid group index requested");

}


}

;
return this._pGroupList[iIndex];

};
DataPool.prototype.add = function(pMembers) {
if (!((this.isInitialized()) == true)) {
var err=((((((("Error:: " + "the cDataPool is not initialized") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("the cDataPool is not initialized");

}


}

;
var iGroupNumber= {};
iGroupNumber.value = 0;
var pOpenGroup=this._findOpenGroup(iGroupNumber);
var iIndex=pOpenGroup.addMember(pMembers);
this._iTotalOpen--;
return this._buildHandle(iGroupNumber.value, iIndex);

};
DataPool.prototype.nextHandle = function() {
if (!((this.isInitialized()) == true)) {
var err=((((((("Error:: " + "the cDataPool is not initialized") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("the cDataPool is not initialized");

}


}

;
var iGroupNumber= {};
iGroupNumber.value = 0;
var pOpenGroup=this._findOpenGroup(iGroupNumber);
var iIndex=pOpenGroup.nextMember();
this._iTotalOpen--;
return this._buildHandle(iGroupNumber.value, iIndex);

};
DataPool.prototype.release = function(iHandle) {
if (!((this.isInitialized()) == true)) {
var err=((((((("Error:: " + "the cDataPool is not initialized") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("the cDataPool is not initialized");

}


}

;
if ((this.isHandleValid(iHandle)) == true) {
if (!((this._pGroupList.length) != 0)) {
var err=((((((("Error:: " + "The cDataPool has not been properly created") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The cDataPool has not been properly created");

}


}

;
var iGroupIndex=this._getGroupNumber(iHandle);
var iItemIndex=this._getItemIndex(iHandle);
pGroup = this._getGroup(iGroupIndex);
pGroup.release(iItemIndex);
pGroupBack = this._pGroupList[(this._pGroupList.length) - 1];
if ((pGroupBack.totalOpen()) == (this._iGroupCount)) {
pGroupBack.destroy();
this._pGroupList.splice((this._pGroupList.length) - 1, 1);

}

this._iTotalOpen++;

}


};
DataPool.prototype.isHandleValid = function(iHandle) {
if (!((this.isInitialized()) == true)) {
var err=((((((("Error:: " + "the cDataPool is not initialized") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("the cDataPool is not initialized");

}


}

;
if ((iHandle != 65535) == true) {
if (!((this._pGroupList.length) != 0)) {
var err=((((((("Error:: " + "The cDataPool has not been properly created") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The cDataPool has not been properly created");

}


}

;
var pGroup=this._getGroup(this._getGroupNumber(iHandle));
return !(pGroup.isOpen(this._getItemIndex(iHandle)));

}

return false;

};
DataPool.prototype.get = function(iHandle) {
if (!((this.isInitialized()) == true)) {
var err=((((((("Error:: " + "the cDataPool is not initialized") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("the cDataPool is not initialized");

}


}

;
if (!((this._pGroupList.length) != 0)) {
var err=((((((("Error:: " + "The cDataPool has not been properly created") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The cDataPool has not been properly created");

}


}

;
var pGroup=this._getGroup(this._getGroupNumber(iHandle));
var iItemIndex=this._getItemIndex(iHandle);
return pGroup.member(iItemIndex);

};
DataPool.prototype.getPtr = function(iHandle) {
if (!((this.isInitialized()) == true)) {
var err=((((((("Error:: " + "the cDataPool is not initialized") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("the cDataPool is not initialized");

}


}

;
if (!((this._pGroupList.length) != 0)) {
var err=((((((("Error:: " + "The cDataPool has not been properly created") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The cDataPool has not been properly created");

}


}

;
var pGroup=this._getGroup(this._getGroupNumber(iHandle));
var iItemIndex=this._getItemIndex(iHandle);
return pGroup.memberPtr(iItemIndex);

};
DataPool.prototype.getGenericPtr = function(iHandle) {
if (!((this.isInitialized()) == true)) {
var err=((((((("Error:: " + "the cDataPool is not initialized") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/DataPool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("the cDataPool is not initialized");

}


}

;
return this.getPtr(iHandle);

};
a.DataPool = DataPool;
function ResourceCode() {
switch(arguments.length) {
case 0:
this.iValue = 4294967295;
break ;

case 1:
if ((arguments[0]) instanceof ResourceCode) {
this.iValue = arguments[0].iValue;

}
else  {
this.iValue = arguments[0];

}

break ;

case 2:
this.iFamily = arguments[0];
this.iType = arguments[1];
break ;
}

}

a.defineProperty(ResourceCode, "iFamily", function() {
return (this.iValue) >> 16;

}
, function(iNewFamily) {
this.iValue &= 65535;
this.iValue |= iNewFamily << 16;

}
);
a.defineProperty(ResourceCode, "iType", function() {
return (this.iValue) & 65535;

}
, function(iNewType) {
this.iValue &= 4294901760;
this.iValue |= iNewType & 65535;

}
);
ResourceCode.prototype.setInvalid = function() {
this.iValue = 4294967295;

};
ResourceCode.prototype.less = function(pSrc) {
return (this.iValue) < (pSrc.iValue);

};
ResourceCode.prototype.eq = function(pSrc) {
this.iValue = pSrc.iValue;
return this;

};
ResourceCode.prototype.valueOf = function() {
return this.iValue;

};
a.ResourceCode = ResourceCode;
function ResourcePoolItem(pEngine) {
;
if (!pEngine) {
var err=((((((("Error:: " + "Engine не передан") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolItem.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Engine не передан");

}


}

;
this._pResourceCode = new a.ResourceCode(0);
this._pResourcePool = null;
this._iResourceHandle = 0;
this._iResourceFlags = 0;
this._pEngine = pEngine;
this._iSystemId = a.sid();
this._pCallbackFunctions = [];
this._fnStateWatcher = [];
this._pCallbackSlots = null;
this._pCallbackSlots = [];
for (var _i=0; _i < 4; ++_i) {
this._pCallbackSlots[_i] = (null? new null() : null);

}

;
ResourcePoolItem.superclass.constructor.apply(this, arguments);

}

a.extend(ResourcePoolItem, a.ReferenceCounter);
ResourcePoolItem.prototype.getDevice = function() {
return this._pEngine.pDevice;

};
ResourcePoolItem.prototype.toNumber = function() {
return this._iSystemId;

};
ResourcePoolItem.prototype.getEngine = function() {
return this._pEngine;

};
ResourcePoolItem.prototype.createResource = function() {

};
ResourcePoolItem.prototype.destroyResource = function() {

};
ResourcePoolItem.prototype.disableResource = function() {

};
ResourcePoolItem.prototype.restoreResource = function() {

};
ResourcePoolItem.prototype.loadResource = function(sFileName) {
sFileName = sFileName || "";

};
ResourcePoolItem.prototype.saveResource = function(sFileName) {
sFileName = sFileName || "";

};
ResourcePoolItem.prototype._setResourceCode = function(pCode) {
this._pResourceCode.eq(pCode);

};
ResourcePoolItem.prototype._setResourcePool = function(pPool) {
this._pResourcePool = pPool;

};
ResourcePoolItem.prototype._setResourceHandle = function(iHandle) {
this._iResourceHandle = iHandle;

};
ResourcePoolItem.prototype.setChangesNotifyRoutine = function(fn) {
if (!((typeof fn) == "function")) {
var err=((((((("Error:: " + "Передана не функция") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolItem.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Передана не функция");

}


}

;
for (var i=0; i < (this._pCallbackFunctions.length); i++) {
if ((this._pCallbackFunctions[i]) == fn) {
return ;

}


}

this._pCallbackFunctions.push(fn);

};
ResourcePoolItem.prototype.delChangesNotifyRoutine = function(fn) {
if (!((typeof fn) == "function")) {
var err=((((((("Error:: " + "Передана не функция") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolItem.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Передана не функция");

}


}

;
for (var i=0; i < (this._pCallbackFunctions.length); i++) {
if ((this._pCallbackFunctions[i]) == fn) {
this._pCallbackFunctions[i] = null;

}


}


};
ResourcePoolItem.parseEvent = function(pEvent) {
if ((typeof pEvent) == "number") {
return pEvent;

}

switch(pEvent.toLowerCase()) {
case "loaded":
return 1;

case "created":
return 0;

case "disabled":
return 2;

case "altered":
return 3;

default:
if (!0) {
var err=((((((("Error:: " + "Использовано неизвестное событие для ресурса.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolItem.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Использовано неизвестное событие для ресурса.");

}


}

;
}
return 0;

};
ResourcePoolItem.prototype.setStateWatcher = function(eState, fnWatcher) {
this._fnStateWatcher[eState] = fnWatcher;

};
ResourcePoolItem.prototype._notifyStateChange = function(eSlot, pTarget) {
if (!(this._fnStateWatcher[eSlot])) {
return ;

}

var pSignSlots=this._pCallbackSlots[eSlot];
var nTotal=pSignSlots.length, nLoaded=0;
for (var i=0; i < nTotal; ++i) {
if (pSignSlots[i].bState) {
++nLoaded;

}


}

this._fnStateWatcher[eSlot](nLoaded, nTotal, pTarget);

};
ResourcePoolItem.prototype.disconnect = function(pResourceItem, eSignal, eSlot) {
eSlot = (eSlot === undefined? eSignal : eSlot);
eSlot = ResourcePoolItem.parseEvent(eSlot);
eSignal = ResourcePoolItem.parseEvent(eSignal);
if (!((0 <= eSlot) && (eSlot < (4)))) {
var err=((((((("Error:: " + (("Invalid slot used(" + eSlot) + ").")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolItem.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("Invalid slot used(" + eSlot) + ")."));

}


}

;
var pSlots=this._pCallbackSlots, pSignSlots;
var me=this;
var isRem=false;
pSignSlots = pSlots[eSlot];
for (var i=0, n=pSignSlots.length; i < n; ++i) {
if ((pSignSlots[i].pResourceItem) === pResourceItem) {
pSignSlots[i].pResourceItem.delChangesNotifyRoutine(pSignSlots[i].fn);
pSignSlots.splice(i, 1);
--n;
--i;
isRem = true;

}


}

return isRem;

};
ResourcePoolItem.prototype.connect = function(pResourceItem, eSignal, eSlot) {
eSlot = (eSlot === undefined? eSignal : eSlot);
eSlot = ResourcePoolItem.parseEvent(eSlot);
eSignal = ResourcePoolItem.parseEvent(eSignal);
if (!((0 <= eSlot) && (eSlot < (4)))) {
var err=((((((("Error:: " + (("Invalid slot used(" + eSlot) + ").")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolItem.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("Invalid slot used(" + eSlot) + ")."));

}


}

;
var pSlots=this._pCallbackSlots, pSignSlots;
var me=this, n, fn, bState;
if ((pSlots[eSlot]) === null) {
pSlots[eSlot] = [];

}

pSignSlots = pSlots[eSlot];
n = pSignSlots.length;
bState = (pResourceItem._iResourceFlags & (1 << eSignal)) != 0;
fn = function(eFlag, iResourceFlags, isSet) {
if (eFlag == eSignal) {
pSignSlots[n].bState = isSet;
me._notifyStateChange(eSlot, this);
for (var i=0; i < (pSignSlots.length); ++i) {
if ((pSignSlots[i].bState) === false) {
if ((me._iResourceFlags & (1 << eFlag)) != 0) {
me._setResourceFlag(eFlag, false);

}

return ;

}


}

me._setResourceFlag(eFlag, true);

}


};
pSignSlots.push( {bState: bState, fn: fn, pResourceItem: pResourceItem});
fn.call(pResourceItem, eSignal, pResourceItem._iResourceFlags, bState);
pResourceItem.setChangesNotifyRoutine(fn);
return true;

};
ResourcePoolItem.prototype._setResourceFlag = function(iFlagBit, isSetting) {
var iTempFlags=this._iResourceFlags;
(isSetting? this._iResourceFlags |= 1 << iFlagBit : this._iResourceFlags &= ~(1 << iFlagBit));
if (iTempFlags != (this._iResourceFlags)) {
for (var i=0; i < (this._pCallbackFunctions.length); i++) {
if (this._pCallbackFunctions[i]) {
this._pCallbackFunctions[i].call(this, iFlagBit, this._iResourceFlags, isSetting);

}


}


}


};
ResourcePoolItem.prototype.notifyCreated = function() {
this._setResourceFlag(0, true);

};
ResourcePoolItem.prototype.notifyDestroyed = function() {
this._setResourceFlag(0, false);

};
ResourcePoolItem.prototype.notifyLoaded = function() {
this.setAlteredFlag(false);
this._setResourceFlag(1, true);

};
ResourcePoolItem.prototype.notifyUnloaded = function() {
this._setResourceFlag(1, false);

};
ResourcePoolItem.prototype.notifyRestored = function() {
this._setResourceFlag(2, false);

};
ResourcePoolItem.prototype.notifyDisabled = function() {
this._setResourceFlag(2, true);

};
ResourcePoolItem.prototype.notifyAltered = function() {
this._setResourceFlag(3, true);

};
ResourcePoolItem.prototype.notifySaved = function() {
this.setAlteredFlag(false);

};
ResourcePoolItem.prototype.resourceCode = function() {
return this._pResourceCode;

};
ResourcePoolItem.prototype.resourcePool = function() {
return this._pResourcePool;

};
ResourcePoolItem.prototype.resourceHandle = function() {
return this._iResourceHandle;

};
ResourcePoolItem.prototype.resourceFlags = function() {
return this._iResourceFlags;

};
ResourcePoolItem.prototype.isResourceCreated = function() {
return (this._iResourceFlags & (1 << 0)) != 0;

};
ResourcePoolItem.prototype.isResourceLoaded = function() {
return (this._iResourceFlags & (1 << 1)) != 0;

};
ResourcePoolItem.prototype.isResourceDisabled = function() {
return (this._iResourceFlags & (1 << 2)) != 0;

};
ResourcePoolItem.prototype.isResourceAltered = function() {
return (this._iResourceFlags & (1 << 3)) != 0;

};
ResourcePoolItem.prototype.setAlteredFlag = function(isOn) {
isOn = (isOn === undefined? true : isOn);
this._setResourceFlag(3, isOn);

};
ResourcePoolItem.prototype.alteredFlag = function() {
return (this._iResourceFlags & (1 << 3)) != 0;

};
ResourcePoolItem.prototype.setResourceName = function(sName) {
if ((this._pResourcePool) != null) {
this._pResourcePool.setResourceName(this._iResourceHandle, sName);

}


};
ResourcePoolItem.prototype.findResourceName = function() {
if ((this._pResourcePool) != null) {
return this._pResourcePool.findResourceName(this._iResourceHandle);

}

return null;

};
ResourcePoolItem.prototype.release = function() {
var iRefCount=ResourcePoolItem.superclass.release.apply(this, arguments);
if (iRefCount == 0) {
if ((this._pResourcePool) != null) {
this._pResourcePool.destroyResource(this);

}


}

return iRefCount;

};
a.ResourcePoolItem = ResourcePoolItem;
function ResourcePoolManager() {
this._pResourceFamilyList = new Array(3);
for (var i=0; i < (3); i++) {
this._pResourceFamilyList[i] = new Array();
this._pResourceFamilyList[i].splice(0);

}

this._pResourceTypeMap = new Array();
this._pResourceTypeMap.splice(0);
this.pTypedResourseTotal = [12, 0, 0];
this._pWaiterResource = new ResourcePoolItem( {});
if (!((ResourcePoolManager.prototype._isSingleton) == true)) {
var err=((((((("Error:: " + "This class is singleton") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("This class is singleton");

}


}

;
ResourcePoolManager.prototype._isSingleton = false;

}

ResourcePoolManager.prototype._isSingleton = true;
ResourcePoolManager.prototype.registerResourcePool = function(pCode, pInterface) {
if (!(pInterface != null)) {
var err=((((((("Error:: " + "invalid cResourcePoolInterface pointer") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid cResourcePoolInterface pointer");

}


}

;
if (!((pCode.iFamily) >= 0)) {
var err=((((((("Error:: " + "invalid family index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid family index");

}


}

;
if (!((pCode.iFamily) < (3))) {
var err=((((((("Error:: " + "invalid family index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid family index");

}


}

;
if (!((this._pResourceTypeMap[pCode.valueOf()]) == undefined)) {
var err=((((((("Error:: " + "Resource type code already registered") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Resource type code already registered");

}


}

;
this._pResourceTypeMap[pCode.valueOf()] = pInterface;
this._pResourceFamilyList[pCode.iFamily].push(pInterface);

};
ResourcePoolManager.prototype.unregisterResourcePool = function(pCode) {
if (!((pCode.iFamily) >= 0)) {
var err=((((((("Error:: " + "invalid family index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid family index");

}


}

;
if (!((pCode.iFamily) < (3))) {
var err=((((((("Error:: " + "invalid family index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid family index");

}


}

;
var pInterface=null;
if ((this._pResourceTypeMap[pCode.valueOf()]) != undefined) {
pInterface = this._pResourceTypeMap[pCode.valueOf()];
delete (this._pResourceTypeMap[pCode.valueOf()]);

}

if (pInterface != null) {
for (var pIter in this._pResourceFamilyList[pCode.iFamily]) {
if ((this._pResourceFamilyList[pCode.iFamily][pIter]) == pInterface) {
delete (this._pResourceFamilyList[pCode.iFamily][pIter]);
return pInterface;

}


}


}

return pInterface;

};
ResourcePoolManager.prototype.destroyAll = function() {
for (var i=0; i < (3); i++) {
this.destroyResourceFamily(i);

}


};
ResourcePoolManager.prototype.restoreAll = function() {
for (var i=0; i < (3); i++) {
this.restoreResourceFamily(i);

}


};
ResourcePoolManager.prototype.disableAll = function() {
for (var i=0; i < (3); i++) {
this.disableResourceFamily(i);

}


};
ResourcePoolManager.prototype.clean = function() {
for (var i=0; i < (3); i++) {
this.cleanResourceFamily(i);

}


};
ResourcePoolManager.prototype.destroyResourceFamily = function(iFamily) {
if (!(iFamily >= 0)) {
var err=((((((("Error:: " + "invalid family index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid family index");

}


}

;
if (!(iFamily < (3))) {
var err=((((((("Error:: " + "invalid family index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid family index");

}


}

;
for (var iIter in this._pResourceFamilyList[iFamily]) {
this._pResourceFamilyList[iFamily][iIter].destroyAll();

}


};
ResourcePoolManager.prototype.restoreResourceFamily = function(iFamily) {
if (!(iFamily >= 0)) {
var err=((((((("Error:: " + "invalid family index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid family index");

}


}

;
if (!(iFamily < (3))) {
var err=((((((("Error:: " + "invalid family index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid family index");

}


}

;
for (var iIter in this._pResourceFamilyList[iFamily]) {
this._pResourceFamilyList[iFamily][iIter].restoreAll();

}


};
ResourcePoolManager.prototype.disableResourceFamily = function(iFamily) {
if (!(iFamily >= 0)) {
var err=((((((("Error:: " + "invalid family index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid family index");

}


}

;
if (!(iFamily < (3))) {
var err=((((((("Error:: " + "invalid family index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid family index");

}


}

;
for (var iIter in this._pResourceFamilyList[iFamily]) {
this._pResourceFamilyList[iFamily][iIter].disableAll();

}


};
ResourcePoolManager.prototype.cleanResourceFamily = function(iFamily) {
if (!(iFamily >= 0)) {
var err=((((((("Error:: " + "invalid family index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid family index");

}


}

;
if (!(iFamily < (3))) {
var err=((((((("Error:: " + "invalid family index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid family index");

}


}

;
for (var iIter in this._pResourceFamilyList[iFamily]) {
this._pResourceFamilyList[iFamily][iIter].clean();

}


};
ResourcePoolManager.prototype.destroyResourceType = function(pCode) {
if ((this._pResourceTypeMap[pCode.valueOf()]) != undefined) {
this._pResourceTypeMap[pCode.valueOf()].destroyAll();

}


};
ResourcePoolManager.prototype.destroyResourceType = function(pCode) {
if ((this._pResourceTypeMap[pCode.valueOf()]) != undefined) {
this._pResourceTypeMap[pCode.valueOf()].restoreAll();

}


};
ResourcePoolManager.prototype.disableResourceType = function(pCode) {
if ((this._pResourceTypeMap[pCode.valueOf()]) != undefined) {
this._pResourceTypeMap[pCode.valueOf()].disableAll();

}


};
ResourcePoolManager.prototype.cleanResourceType = function(pCode) {
if ((this._pResourceTypeMap[pCode.valueOf()]) != undefined) {
this._pResourceTypeMap[pCode.valueOf()].clean();

}


};
ResourcePoolManager.prototype.findResourcePool = function(pCode) {
if ((this._pResourceTypeMap[pCode.valueOf()]) != undefined) {
return this._pResourceTypeMap[pCode.valueOf()];

}
else  {
return null;

}


};
ResourcePoolManager.prototype.findResourceHandle = function(pCode, sName) {
var pPool=this.findResourcePool(pCode);
var iHandle;
iHandle = 65535;
if (pPool != null) {
iHandle = pPool.findResourceHandle(sName);

}

return iHandle;

};
ResourcePoolManager.prototype.findResource = function(pCode, sName) {
if ((typeof (arguments[1])) == "string") {
var pPool=this.findResourcePool(pCode);
var pResult=null;
var iHandle;
if (pPool != null) {
iHandle = pPool.findResourceHandle(sName);
if (iHandle != 65535) {
pResult = pPool.getResource(iHandle);

}


}

return pResult;

}
else if ((typeof (arguments[1])) == "number") {
var pPool=this.findResourcePool(pCode);
var pResult=null;
if (pPool != null) {
if (sName != 65535) {
pResult = pPool.getResource(sName);

}


}


}
else  {
if (!(1 == 0)) {
var err=((((((("Error:: " + "invalid type 2 parameter") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePoolManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid type 2 parameter");

}


}

;
return null;

}



};
ResourcePoolManager.prototype.monitorInitResources = function(fnMonitor) {
var me=this;
this._pWaiterResource.setStateWatcher(1, function() {
fnMonitor.apply(me, arguments);

}
);

};
ResourcePoolManager.prototype.setLoadedAllRoutine = function(fnCallback) {
var pPool;
var pResource;
var iHandleResource;
var pWaiterResouse=this._pWaiterResource;
var fnResCallback=function(iFlagBit, iResourceFlags, isSetting) {
if ((iFlagBit == (1)) && (isSetting == true)) {
fnCallback();

}


};
pWaiterResouse.notifyLoaded();
for (var n=0; n < (3); n++) {
for (var i=0; i < (this.pTypedResourseTotal[n]); i++) {
pPool = this.findResourcePool(new a.ResourceCode(n, i));
if (pPool) {
for (var iHandleResource in pPool._pNameMap) {
pResource = pPool.getResource(iHandleResource);
pWaiterResouse.connect(pResource, 1);

}


}


}


}

(pWaiterResouse.isResourceLoaded()? fnCallback() : pWaiterResouse.setChangesNotifyRoutine(fnResCallback));

};
a.ResourcePoolManager = ResourcePoolManager;
function ResourcePoolInterface(pEngine, fnTemplate) {
if (!(fnTemplate != undefined)) {
var err=((((((("Error:: " + "Type data not defined") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Type data not defined");

}


}

;
this._pEngine = pEngine;
this._fnTemplate = fnTemplate;
this.sExt = null;
this._pRegistrationCode = new a.ResourceCode(4294967295);
this._pNameMap = new Array();
this._pNameMap.splice(0);

}

;
ResourcePoolInterface.prototype.initialize = function(iGrowSize) {

};
ResourcePoolInterface.prototype.destroy = function() {

};
ResourcePoolInterface.prototype.isInitialized = function() {

};
ResourcePoolInterface.prototype.destroyAll = function() {

};
ResourcePoolInterface.prototype.disableAll = function() {

};
ResourcePoolInterface.prototype.restoreAll = function() {

};
ResourcePoolInterface.prototype.clean = function() {

};
ResourcePoolInterface.prototype._internalCreateResource = function(sResourceName) {

};
ResourcePoolInterface.prototype._internalDestroyResource = function(iHandle) {

};
ResourcePoolInterface.prototype._internalGetResource = function(iHandle) {

};
Object.defineProperty(ResourcePoolInterface.prototype, "iFourcc",  {set: function(iNewFourcc) {
this.sExt = String.fromCharCode(iNewFourcc & 255, (iNewFourcc & 65280) >>> 8, (iNewFourcc & 16711680) >>> 16, (iNewFourcc & 4278190080) >>> 24);

}
, get: function() {
return ((((this.sExt.charCodeAt(3)) << 24) | ((this.sExt.charCodeAt(2)) << 16)) | ((this.sExt.charCodeAt(1)) << 8)) | (this.sExt.charCodeAt(0));

}
});
ResourcePoolInterface.prototype.registerResourcePool = function(pCode) {
this._pRegistrationCode.eq(pCode);
this._pEngine.pResourceManager.registerResourcePool(this._pRegistrationCode, this);

};
ResourcePoolInterface.prototype.unregisterResourcePool = function(pCode) {
this._pEngine.pResourceManager.unregisterResourcePool(this._pRegistrationCode);
this._pRegistrationCode.setInvalid();

};
ResourcePoolInterface.prototype.findResourceHandle = function(sName) {
var iNewHandle=0;
iNewHandle = 65535;
for (var iHandle in this._pNameMap) {
if ((this._pNameMap[iHandle]) == sName) {
return iHandle;

}


}

return iNewHandle;

};
ResourcePoolInterface.prototype.findResourceName = function(iHandle) {
return this._pNameMap[iHandle];

};
ResourcePoolInterface.prototype.setResourceName = function(iHandle, sName) {
this._pNameMap[iHandle] = sName;

};
ResourcePoolInterface.prototype.createResource = function(sResourceName) {
var iHandle=this._internalCreateResource(sResourceName);
if (iHandle != 65535) {
var pResource=this.getResource(iHandle);
pResource._setResourcePool(this);
pResource._setResourceHandle(iHandle);
pResource._setResourceCode(this._pRegistrationCode);
return pResource;

}

return null;

};
ResourcePoolInterface.prototype.loadResource = function(sResourceName) {
var pResource=this.findResource(sResourceName);
if (pResource == null) {
pResource = this.createResource(sResourceName);
if (pResource != null) {
if (pResource.loadResource(sResourceName)) {
return pResource;

}

pResource.release();
pResource = null;

}


}

return pResource;

};
ResourcePoolInterface.prototype.saveResource = function(pResource) {
if (pResource != null) {
return pResource.saveResource(0);

}

return false;

};
ResourcePoolInterface.prototype.findResource = function(sName) {
for (var iHandle in this._pNameMap) {
if ((this._pNameMap[iHandle]) == sName) {
if (iHandle != 65535) {
var pResource=this.getResource(iHandle);
return pResource;

}


}


}

return null;

};
ResourcePoolInterface.prototype.getResource = function(iHandle) {
var pResource=this._internalGetResource(iHandle);
if (pResource != null) {
pResource.addRef();

}

return pResource;

};
ResourcePoolInterface.prototype.destroyResource = function(pResource) {
if (pResource != null) {
var iReferenceCount=pResource.referenceCount();
if (!(iReferenceCount == 0)) {
var err=((((((("Error:: " + "destruction of non-zero reference count!") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("destruction of non-zero reference count!");

}


}

;
if (iReferenceCount <= 0) {
var iHandle=pResource.resourceHandle();
this._internalDestroyResource(iHandle);

}


}


};
a.ResourcePoolInterface = ResourcePoolInterface;
function ResourcePool(pEngine, fnTemplate) {
ResourcePool.superclass.constructor.apply(this, arguments);
this._pEngine = pEngine;
this._fnTemplate = fnTemplate;
this._pDataPool = new a.DataPool(this._pEngine, this._fnTemplate);

}

a.extend(ResourcePool, a.ResourcePoolInterface);
ResourcePool.prototype.initialize = function(iGrowSize) {
this._pDataPool.initialize(iGrowSize);

};
ResourcePool.prototype.destroy = function() {
this._pDataPool.destroy();

};
ResourcePool.prototype.isInitialized = function() {
return this._pDataPool.isInitialized();

};
ResourcePool.prototype._internalCreateResource = function(sResourceName) {
var iHandle=this._pDataPool.nextHandle();
for (var iter in this._pNameMap) {
if (!((this._pNameMap[iter]) != sResourceName)) {
var err=((((((("Error:: " + ("A resource with this name already exists: " + sResourceName)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/pool/ResourcePool.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("A resource with this name already exists: " + sResourceName));

}


}

;

}

this._pNameMap[iHandle] = sResourceName;
var pResource=this._pDataPool.getPtr(iHandle);
pResource.createResource();
return iHandle;

};
ResourcePool.prototype._internalDestroyResource = function(iHandle) {
var pResource=this._pDataPool.getPtr(iHandle);
pResource.destroyResource();
delete (this._pNameMap[iHandle]);
this._pDataPool.release(iHandle);

};
ResourcePool.callbackDestroy = function(pPool, iHandle, pResource) {
pResource.destroyResource();

};
ResourcePool.callbackDisable = function(pPool, iHandle, pResource) {
pResource.disableResource();

};
ResourcePool.callbackRestore = function(pPool, iHandle, pResource) {
pResource.restoreResource();

};
ResourcePool.callbackClean = function(pPool, iHandle, pResource) {
if ((pResource.referenceCount()) == 0) {
pPool.release(iHandle);

}


};
ResourcePool.prototype.destroyAll = function() {
this._pDataPool.forEach(ResourcePool.callbackDestroy);

};
ResourcePool.prototype.restoreAll = function() {
this._pDataPool.forEach(ResourcePool.callbackRestore);

};
ResourcePool.prototype.disableAll = function() {
this._pDataPool.forEach(ResourcePool.callbackDisable);

};
ResourcePool.prototype.clean = function() {
this._pDataPool.forEach(ResourcePool.callbackClean);

};
ResourcePool.prototype._internalGetResource = function(iHandle) {
return this._pDataPool.getPtr(iHandle);

};
ResourcePool.prototype.createResource = function(sResourceName) {
return ResourcePool.superclass.createResource.apply(this, arguments);

};
ResourcePool.prototype.loadResource = function(sResourceName) {
return ResourcePool.superclass.loadResource.apply(this, arguments);

};
ResourcePool.prototype.findResource = function(sName) {
return ResourcePool.superclass.findResource.apply(this, arguments);

};
ResourcePool.prototype.getResource = function(iHandle) {
return ResourcePool.superclass.getResource.apply(this, arguments);

};
a.ResourcePool = ResourcePool;
var TEMPSCENEVECTOR3FORCALC0=Vec3();
var TEMPSCENEMATRIX4FORCALC0=Mat4();
var TEMPSCENEVECTOR4FORCALC0=Vec4();
var TEMPSCENEMATRIX3FORCALC0=Mat3();
var TEMPSCENEQUAT4FORCALC0=Quat4();
function Node(pEngine) {
var _pCtorValue=Node.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._m4fLocalMatrix = null;
this._m4fWorldMatrix = null;
this._m4fInverseWorldMatrix = null;
this._m3fNormalMatrix = null;
this._iUpdateFlags = 0;
this._pParent = null;
this._pSibling = null;
this._pChild = null;
this._iInheritance = 0;
this._qRotation = null;
this._v3fTranslation = null;
this._v3fScale = null;
this._v3fWorldPosition = null;
this._sName = null;

}

a.extend(Node, a.ReferenceCounter);
a.defineProperty(Node, "name", function() {
return this._sName;

}
, function(sName) {
this._sName = sName;

}
);
a.defineProperty(Node, "depth", function() {
var iDepth=-1;
for (var pNode=this; pNode; pNode = pNode.parent(), ++iDepth) {

}

;
return iDepth;

}
);
Node.prototype.findNode = function(sNodeName) {
"use strict";
var pNode=null;
if ((this._sName) === sNodeName) {
return this;

}

if (this._pSibling) {
pNode = this._pSibling.findNode(sNodeName);

}

if ((pNode == null) && (this._pChild)) {
pNode = this._pChild.findNode(sNodeName);

}

return pNode;

};
Node.prototype.explore = function(fn) {
"use strict";
if ((fn.call(this)) === false) {
return ;

}

if (this._pSibling) {
this._pSibling.explore(fn);

}

if (this._pChild) {
this._pChild.explore(fn);

}


};
Node.prototype.childOf = function(pParent) {
"use strict";
for (var pNode=this; pNode; pNode = pNode.parent()) {
if ((pNode.parent()) === pParent) {
return true;

}


}

return false;

};
a.defineProperty(Node, "root", function() {
var iDepth=-1;
for (var pNode=this; pNode.parent(); pNode = pNode.parent(), ++iDepth) {

}

;
return pNode;

}
);
Node.prototype.setName = function(sName) {
"use strict";
this._sName = sName;

};
Node.prototype.getName = function() {
"use strict";
return this._sName;

};
Node.prototype.parent = function() {
;
return this._pParent;

};
Node.prototype.sibling = function() {
;
return this._pSibling;

};
Node.prototype.child = function() {
;
return this._pChild;

};
Node.prototype.worldMatrix = function() {
;
return this._m4fWorldMatrix;

};
Node.prototype.normalMatrix = function() {
if ((this._iUpdateFlags & (1 << 5)) != 0) {
this._m4fWorldMatrix.toInverseMat3(this._m3fNormalMatrix).transpose();
this._iUpdateFlags &= ~(1 << 5);

}

return this._m3fNormalMatrix;

};
Node.prototype.worldPosition = function() {
return this._v3fWorldPosition;

};
Node.prototype.localMatrix = function() {
;
return this._m4fLocalMatrix;

};
Node.prototype.inverseWorldMatrix = function() {
;
if ((this._iUpdateFlags & (1 << 4)) != 0) {
this._m4fWorldMatrix.inverse(this._m4fInverseWorldMatrix);
this._iUpdateFlags &= ~(1 << 4);

}

return this._m4fInverseWorldMatrix;

};
Node.prototype.updateFlags = function() {
;
return this._iUpdateFlags;

};
Node.prototype.hasParent = function() {
;
if (this._pParent) {
return true;

}

return false;

};
Node.prototype.hasChild = function() {
;
if (this._pChild) {
return true;

}

return false;

};
Node.prototype.hasSibling = function() {
;
if (this._pSibling) {
return true;

}

return false;

};
Node.prototype.setUpdatedLocalMatrixFlag = function() {
;
this._iUpdateFlags |= 1 << 3;

};
Node.prototype.accessLocalMatrix = function() {
;
this.setUpdatedLocalMatrixFlag();
return this._m4fLocalMatrix;

};
Node.prototype.isWorldMatrixNew = function() {
;
return (this._iUpdateFlags & (1 << 2)) != 0;

};
Node.prototype.isLocalMatrixNew = function() {
"use strict";
return (this._iUpdateFlags & (1 << 3)) != 0;

};
Node.prototype.create = function() {
return true;

};
Node.prototype.destroy = function() {
this.promoteChildren();
this.detachFromParent();
if (!((this.referenceCount()) == 0)) {
var err=((((((("Error:: " + "Attempting to delete a scene node which is still in use") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/scene/Node.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Attempting to delete a scene node which is still in use");

}


}

;
if (!((this._pSibling) == null)) {
var err=((((((("Error:: " + "Failure Destroying Node") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/scene/Node.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Failure Destroying Node");

}


}

;
if (!((this._pChild) == null)) {
var err=((((((("Error:: " + "Failure Destroying Node") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/scene/Node.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Failure Destroying Node");

}


}

;

};
Node.prototype.setSibling = function(pNode) {
"use strict";
this._pSibling = pNode;

};
Node.prototype.setChild = function(pNode) {
"use strict";
this._pChild = pNode;

};
Node.prototype.addSibling = function(pSibling) {
if (pSibling) {
pSibling.setSibling(this._pSibling);
this.setSibling(pSibling);

}


};
Node.prototype.addChild = function(pChild) {
if (pChild) {
pChild.setSibling(this._pChild);
this._pChild = pChild;

}


};
Node.prototype.removeChild = function(pChild) {
if ((this._pChild) && pChild) {
if ((this._pChild) == pChild) {
this._pChild = pChild.sibling();
pChild.setSibling(null);

}
else  {
var pTempNode=this._pChild;
while (pTempNode && ((pTempNode.sibling()) != pChild)) {
pTempNode = pTempNode.sibling();

}
if (pTempNode) {
pTempNode.setSibling(pChild.sibling());
pChild.setSibling(null);

}


}


}


};
Node.prototype.removeAllChildren = function() {
while ((this._pChild) != 0) {
var NextSibling=this._pChild.sibling();
this._pChild.detachFromParent();
this._pChild = NextSibling;

}

};
Node.prototype.attachToParent = function(pParent) {
if (pParent != (this._pParent)) {
this.detachFromParent();
if (pParent) {
this._pParent = pParent;
this._pParent.addChild(this);
var invertedParentMatrix=Mat4();
this._pParent._m4fWorldMatrix.inverse(invertedParentMatrix);
this._m4fLocalMatrix.multiply(invertedParentMatrix);

}


}


};
Node.prototype.setInheritance = function(iSetting) {
this._iInheritance = iSetting;

};
Node.prototype.detachFromParent = function() {
if (this._pParent) {
this._pParent.removeChild(this);
if (this._pParent) {
this._pParent.release();

}

this._pParent = null;
this._m4fLocalMatrix = this._m4fWorldMatrix;
this._m4fWorldMatrix = new Mat4(1);

}


};
Node.prototype.promoteChildren = function() {
while ((this._pChild) != null) {
var NextSibling=this._pChild.sibling();
this._pChild.attachToParent(this._pParent);
this._pChild = NextSibling;

}

};
Node.prototype.relocateChildren = function(pParent) {
if (pParent != (this)) {
while ((this._pChild) != 0) {
var NextSibling=this._pChild.sibling();
this._pChild.attachToParent(pParent);
this._pChild = NextSibling;

}

}


};
Node.prototype.isASibling = function(pSibling) {
if (!pSibling) {
return false;

}

if (((this) == pSibling) || ((this._pSibling) == pSibling)) {
return true;

}

if (this._pSibling) {
return this._pSibling.isASibling(pSibling);

}

return false;

};
Node.prototype.isAChild = function(pChild) {
if (!pChild) {
return false;

}

if ((this._pChild) == pChild) {
return true;

}

if (this._pChild) {
return this._pChild.isASibling(pChild);

}

return false;

};
Node.prototype.isInFamily = function(pNode, SearchEntireTree) {
if (!pNode) {
return false;

}

if ((((this) == pNode) || ((this._pChild) == pNode)) || ((this._pSibling) == pNode)) {
return true;

}

if (!SearchEntireTree) {
if (this.isASibling(pNode)) {
return true;

}

if ((this._pChild) && (this._pChild.isASibling(pNode))) {
return true;

}


}
else  {
if ((this._pSibling) && (this._pSibling.isInFamily(pNode, SearchEntireTree))) {
return true;

}

if ((this._pChild) && (this._pChild.isInFamily(pNode, SearchEntireTree))) {
return true;

}


}

return false;

};
Node.prototype.siblingCount = function() {
var count=0;
if (this._pParent) {
var pNextSibling=this._pParent.child();
if (pNextSibling) {
while (pNextSibling) {
pNextSibling = pNextSibling.sibling();
++count;

}

}


}

return count;

};
Node.prototype.childCount = function() {
var count=0;
pNextChild = this.child();
if (pNextChild) {
++count;
while (pNextChild) {
pNextChild = pNextChild.sibling();
++count;

}

}

return count;

};
Node.prototype.update = function() {
this.recalcWorldMatrix();

};
Node.prototype.prepareForUpdate = function() {
this._iUpdateFlags &= ~(((1 << 3) | (1 << 1)) | (1 << 2));

};
Node.prototype.recursiveUpdate = function() {
this.update();
if (this._pSibling) {
this._pSibling.recursiveUpdate();

}

if (this._pChild) {
this._pChild.recursiveUpdate();

}


};
Node.prototype.recursivePreUpdate = function() {
"use strict";
this.prepareForUpdate();
if (this._pSibling) {
this._pSibling.recursivePreUpdate();

}

if (this._pChild) {
this._pChild.recursivePreUpdate();

}


};
Node.prototype.recalcWorldMatrix = function() {
"use strict";
var isParentMoved=(this._pParent) && (this._pParent.isWorldMatrixNew());
var isOrientModified=(this._iUpdateFlags & (1 << 1)) != 0;
var isLocalModified=(this._iUpdateFlags & (1 << 3)) != 0;
if ((isOrientModified || isParentMoved) || isLocalModified) {
var m4fLocal=this._m4fLocalMatrix;
var m4fWorld=this._m4fWorldMatrix;
var m4fParent=(this._pParent? this._pParent.worldMatrix() : Mat4(1));
var m4fOrient=TEMPSCENEMATRIX4FORCALC0;
var v3fTemp=TEMPSCENEVECTOR3FORCALC0;
var pWorldData=m4fWorld.pData;
var pParentData=m4fParent.pData;
var pOrientData=m4fOrient.pData;
this._qRotation.toMat4(m4fOrient);
m4fOrient.setTranslation(this._v3fTranslation);
m4fOrient.scale(this._v3fScale);
m4fOrient.multiply(m4fLocal);
if (this._pParent) {
if ((this._iInheritance) === (2)) {
m4fParent.multiply(m4fOrient, m4fWorld);

}
else if ((this._iInheritance) === (0)) {
m4fWorld.set(m4fOrient);
pWorldData[12] = (pParentData[12]) + (pOrientData[12]);
pWorldData[13] = (pParentData[13]) + (pOrientData[13]);
pWorldData[14] = (pParentData[14]) + (pOrientData[14]);

}
else if ((this._iInheritance) === (1)) {
var p11=pParentData[0], p12=pParentData[4], p13=pParentData[8];
var p21=pParentData[1], p22=pParentData[5], p23=pParentData[9];
var p31=pParentData[2], p32=pParentData[6], p33=pParentData[10];
var l11=pOrientData[0], l12=pOrientData[4], l13=pOrientData[8];
var l21=pOrientData[1], l22=pOrientData[5], l23=pOrientData[9];
var l31=pOrientData[2], l32=pOrientData[6], l33=pOrientData[10];
pWorldData[0] = ((p11 * l11) + (p12 * l21)) + (p13 * l31);
pWorldData[4] = ((p11 * l12) + (p12 * l22)) + (p13 * l32);
pWorldData[8] = ((p11 * l13) + (p12 * l23)) + (p13 * l33);
pWorldData[12] = pOrientData[12];
pWorldData[1] = ((p21 * l11) + (p22 * l21)) + (p23 * l31);
pWorldData[5] = ((p21 * l12) + (p22 * l22)) + (p23 * l32);
pWorldData[9] = ((p21 * l13) + (p22 * l23)) + (p23 * l33);
pWorldData[13] = pOrientData[13];
pWorldData[2] = ((p31 * l11) + (p32 * l21)) + (p33 * l31);
pWorldData[6] = ((p31 * l12) + (p32 * l22)) + (p33 * l32);
pWorldData[10] = ((p31 * l13) + (p32 * l23)) + (p33 * l33);
pWorldData[14] = pOrientData[14];
pWorldData[3] = pOrientData[3];
pWorldData[7] = pOrientData[7];
pWorldData[11] = pOrientData[11];
pWorldData[15] = pOrientData[15];

}




}
else  {
m4fWorld.set(m4fOrient);

}

this._v3fWorldPosition.pData[0] = pWorldData[12];
this._v3fWorldPosition.pData[1] = pWorldData[13];
this._v3fWorldPosition.pData[2] = pWorldData[14];
if (true) {
this._iUpdateFlags |= 1 << 2;

}
else  {
this._iUpdateFlags &= ~(1 << 2);

}

;
if (true) {
this._iUpdateFlags |= 1 << 4;

}
else  {
this._iUpdateFlags &= ~(1 << 4);

}

;
if (true) {
this._iUpdateFlags |= 1 << 5;

}
else  {
this._iUpdateFlags &= ~(1 << 5);

}

;
return true;

}

return false;

};
Node.prototype.setPosition = function() {
"use strict";
var pPos=((arguments.length) === 1? arguments[0] : arguments);
var v3fTranslation=this._v3fTranslation;
v3fTranslation.set(pPos);
if (true) {
this._iUpdateFlags |= 1 << 1;

}
else  {
this._iUpdateFlags &= ~(1 << 1);

}

;

};
Node.prototype.setRelPosition = function() {
"use strict";
var pPos=((arguments.length) === 1? arguments[0] : arguments);
var v3fTranslation=this._v3fTranslation;
this._qRotation.multiplyVec3(pPos);
v3fTranslation.set(pPos);
if (true) {
this._iUpdateFlags |= 1 << 1;

}
else  {
this._iUpdateFlags &= ~(1 << 1);

}

;

};
Node.prototype.addPosition = function() {
"use strict";
var pPos=((arguments.length) === 1? arguments[0] : Vec3(arguments));
var v3fTranslation=this._v3fTranslation;
v3fTranslation.add(pPos);
if (true) {
this._iUpdateFlags |= 1 << 1;

}
else  {
this._iUpdateFlags &= ~(1 << 1);

}

;

};
Node.prototype.addRelPosition = function() {
"use strict";
var pPos=((arguments.length) === 1? arguments[0] : Vec3(arguments));
var v3fTranslation=this._v3fTranslation;
this._qRotation.multiplyVec3(pPos);
v3fTranslation.add(pPos);
if (true) {
this._iUpdateFlags |= 1 << 1;

}
else  {
this._iUpdateFlags &= ~(1 << 1);

}

;

};
Node.prototype.setRotation = function() {
"use strict";
var qTemp=TEMPSCENEQUAT4FORCALC0;
switch(arguments.length) {
case 1:
if (arguments[0].toQuat4) {
arguments[0].toQuat4(this._qRotation);

}
else  {
this._qRotation.set(arguments[0]);

}

break ;

case 2:
if ((typeof (arguments[1])) == "number") {
Quat4.fromAxisAngle(arguments[0], arguments[1], this._qRotation);

}
else if ((typeof (arguments[0])) == "number") {
Quat4.fromAxisAngle(arguments[1], arguments[0], this._qRotation);

}
else  {
Quat4.fromForwardUp(arguments[0], arguments[1], this._qRotation);

}


break ;

case 3:
Quat4.fromYawPitchRoll(arguments[1], arguments[0], arguments[2], this._qRotation);
break ;

case 4:
Quat4.fromAxisAngle(arguments, arguments[3], qTemp);
}
if (true) {
this._iUpdateFlags |= 1 << 1;

}
else  {
this._iUpdateFlags &= ~(1 << 1);

}

;

};
Node.prototype.addRelRotation = function() {
"use strict";
var qTemp=TEMPSCENEQUAT4FORCALC0;
switch(arguments.length) {
case 1:
arguments[0].toQuat4(qTemp);
break ;

case 2:
if ((typeof (arguments[1])) == "number") {
Quat4.fromAxisAngle(arguments[0], arguments[1], qTemp);

}
else if ((typeof (arguments[0])) == "number") {
Quat4.fromAxisAngle(arguments[1], arguments[0], qTemp);

}
else  {
Quat4.fromForwardUp(arguments[0], arguments[1], qTemp);

}


;

case 3:
Quat4.fromYPR(arguments[0], arguments[1], arguments[2], qTemp);
break ;

case 4:
Quat4.fromAxisAngle(arguments, arguments[3], qTemp);
}
this._qRotation.multiply(qTemp);
if (true) {
this._iUpdateFlags |= 1 << 1;

}
else  {
this._iUpdateFlags &= ~(1 << 1);

}

;

};
Node.prototype.setScale = function(scale) {
"use strict";
var pScale=((arguments.length) === 1? arguments[0] : arguments);
var v3fScale=this._v3fScale;
if ((typeof pScale) === "number") {
v3fScale.set(pScale, pScale, pScale);

}
else  {
v3fScale.set(pScale);

}

if (true) {
this._iUpdateFlags |= 1 << 1;

}
else  {
this._iUpdateFlags &= ~(1 << 1);

}

;

};
Node.prototype.multScale = function(scale) {
"use strict";
var pScale=((arguments.length) === 1? arguments[0] : arguments);
var v3fScale=this._v3fScale;
v3fScale.scale(pScale);
if (true) {
this._iUpdateFlags |= 1 << 1;

}
else  {
this._iUpdateFlags &= ~(1 << 1);

}

;

};
Node.prototype.scale = Node.prototype.multScale;
Node.prototype.toString = function(isRecursive, iDepth) {
"use strict";
iDepth = iDepth || 0;
isRecursive = isRecursive || false;
if (!isRecursive) {
return ("<node" + ((this._sName? " " + (this._sName) : ""))) + ">";

}

var pSibling=this.sibling();
var pChild=this.child();
var s="";
for (var i=0; i < iDepth; ++i) {
s += ":  ";

}

s += ((("+----[depth: " + (this.depth)) + "]") + (this.toString())) + "\n";
if (pChild) {
s += pChild.toString(true, iDepth + 1);

}

if (pSibling) {
s += pSibling.toString(true, iDepth);

}

return s;

};
a["Node"] = Node;
function SceneNode(pEngine) {
var _pCtorValue=SceneNode.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
if (!pEngine) {
var err=((((((("Error:: " + "SceneNode. Engine не передан") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/scene/SceneNode.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("SceneNode. Engine не передан");

}


}

;
this._pEngine = pEngine;
this._pSubNodeGroupData = null;
this._pSubNodeGroupOwner = null;

}

a.extend(SceneNode, Node);
SceneNode.prototype.create = function() {
this._m4fLocalMatrix = new Mat4(1);
this._m4fWorldMatrix = new Mat4(1);
this._m4fInverseWorldMatrix = new Mat4(1);
this._m3fNormalMatrix = new Mat3();
this._v3fWorldPosition = new Vec3();
this._v3fTranslation = new Vec3(0);
this._v3fScale = new Vec3(1);
this._qRotation = new Quat4(0, 1);
return true;

};
SceneNode.prototype.subNodeGroupData = function() {
;
return this._pSubNodeGroupData;

};
SceneNode.prototype.subNodeGroupOwner = function() {
;
return this._pSubNodeGroupOwner;

};
SceneNode.prototype.setSubNodeGroupOwner = function(pOwner) {
;
this._pSubNodeGroupOwner = pOwner;

};
SceneNode.prototype.createFromResource = function(iModelResource) {
this.releaseGroupData();
this._pSubNodeGroupData = new SubNodeGroup();
if (this._pSubNodeGroupData.create(this, iModelResource)) {
return true;

}
else  {
delete (this._pSubNodeGroupData);

}

return false;

};
SceneNode.prototype.releaseGroupData = function() {
if (this._pSubNodeGroupData) {
this._pSubNodeGroupData.destroy();
delete (this._pSubNodeGroupData);

}


};
SceneNode.prototype.destroy = function() {
this.constructor.superclass.destroy.call(this, undefined);
this.releaseGroupData();
this._pSubNodeGroupOwner = null;

};
SceneNode.prototype.update = function() {
Node.prototype.update.call(this);
if (this._pSubNodeGroupData) {
this._pSubNodeGroupData.update();

}

;

};
SceneNode.prototype.prepareForRender = function() {

};
SceneNode.prototype.render = function() {

};
SceneNode.prototype.renderCallback = function(pEntry, iActivationFlags) {

};
SceneNode.prototype.recursiveRender = function() {
this.prepareForRender();
this.render();
if (this.sibling()) {
this.sibling().recursiveRender();

}

if (this.child()) {
this.child().recursiveRender();

}


};
SceneNode.prototype.createSubNode = function() {
switch(arguments.length) {
case 2:
var node=new a.SceneModel();
node.create();
node.setModelResource(pModelResource, frameIndex);
node._pSubNodeGroupOwner = this;
return node;

default:
var node=new a.SceneNode();
node.create();
node._pSubNodeGroupOwner = this;
return node;
}

};
SceneNode.prototype.destroySubNode = function(pSubNode) {
pSubNode.destroy();
pSubNode._pSubNodeGroupOwner = null;
pSubNode = null;

};
SceneNode.prototype.toString = function(isRecursive, iDepth) {
"use strict";
isRecursive = isRecursive || false;
if (!isRecursive) {
return ("<scene_node" + ((this._sName? " " + (this._sName) : ""))) + ">";

}

return Node.prototype.toString.call(this, isRecursive, iDepth);

};
a["SceneNode"] = SceneNode;
function SubNodeGroup() {
this._pParentNode = null;
this._pModelResource = null;
this._totalSubNodes = 0;
this._ppSubNodePtrList = null;
this._totalNamedSubNodes = 0;
this._ppNamedSubNodePtrList = null;
this._animController = null;

}

;
SubNodeGroup.prototype.modelResource = function() {
;
return this._pModelResource;

};
SubNodeGroup.prototype.totalSubNodes = function() {
;
return this._totalSubNodes;

};
SubNodeGroup.prototype.subNodePtr = function(index) {
;
if (!(index < (this._totalSubNodes))) {
var err=((((((("Error:: " + "invalid subnode index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/scene/SubNodeGroup.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid subnode index");

}


}

;
return this._ppSubNodePtrList[index];

};
SubNodeGroup.prototype.totalNamedSubNodes = function() {
;
return this._totalNamedSubNodes;

};
SubNodeGroup.prototype.namedSubNodePtr = function(index) {
;
if (!(index < (this._totalNamedSubNodes))) {
var err=((((((("Error:: " + "invalid subnode index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/scene/SubNodeGroup.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid subnode index");

}


}

;
return this._ppNamedSubNodePtrList[index];

};
SubNodeGroup.prototype.animController = function() {
;
return this._animController;

};
SubNodeGroup.prototype.create = function(pRootNode, iModelResource) {
this.destroy();
this._pParentNode = pRootNode;
this._pModelResource = a.displayManager().modelPool().getResource(ModelResource);
if (this._pModelResource) {
this._totalSubNodes = this._pModelResource.totalFrames();
this._totalNamedSubNodes = 0;
this._ppSubNodePtrList = new Array();
this._ppNamedSubNodePtrList = new Array();
for (var i=0; i < (this._totalSubNodes); ++i) {
var pMeshContainer=this._pModelResource.frame(i).pMeshContainer;
if (pMeshContainer) {
this._ppSubNodePtrList[i] = pRootNode.createSubNode(this._pModelResource, i);

}
else  {
this._ppSubNodePtrList[i] = pRootNode.createSubNode();

}

var parentIndex=this._pModelResource.frame(i).parentIndex;
debug_assert(parentIndex == (a.define.MAXUINT16), parentIndex < (this._pModelResource.frame(i).frameIndex), "invalid model resource");
if (parentIndex == (a.define.MAXUINT16)) {
this._ppSubNodePtrList[i].attachToParent(pRootNode);

}
else  {
this._ppSubNodePtrList[i].attachToParent(this._ppSubNodePtrList[parentIndex]);

}

var pLocalMatrix=this._pSubNodePtrList[i].accessLocalMatrix();
pLocalMatrix.set(this._pModelResource.frame(i).TransformationMatrix);
if (this._pModelResource.frame(i).Name) {
this._ppNamedSubNodePtrList[this._totalNamedSubNodes] = this._ppSubNodePtrList[i];
++this._totalNamedSubNodes;

}


}

this._animController.create(this, iModelResource);
return true;

}

return false;

};
SubNodeGroup.prototype.destroy = function() {
this._animController.destroy();
if (this._ppSubNodePtrList) {
for (var i=0; i < (this._totalSubNodes); ++i) {
this._pParentNode.destroySubNode(this._ppSubNodePtrList[i]);

}


}

;
delete (this._ppSubNodePtrList);
delete (this._ppNamedSubNodePtrList);
this._totalSubNodes = 0;
this._totalNamedSubNodes = 0;
this._pModelResource.release();
this._pModelResource = null;

};
SubNodeGroup.prototype.update = function() {
this._animController.update();

};
SubNodeGroup.prototype.adjustForAnimationStep = function() {
for (var i=0; i < (this._totalNamedSubNodes); ++i) {
this._ppNamedSubNodePtrList[i].setUpdatedLocalMatrixFlag();

}


};
a["SubNodeGroup"] = SubNodeGroup;
function SceneObject(pEngine) {
var _pCtorValue=SceneObject.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._iObjectFlags = 0;
this._pLocalBounds = new a.Rect3d();
this._pWorldBounds = new a.Rect3d();
this._pOcTree = null;
this._pOcTreeNode = null;
this._pForwardTreeLink = null;
this._pRearTreeLink = null;
this._pForwardSearchLink = null;
this._pRearSearchLink = null;
this._hasShadow = false;

}

;
a.extend(SceneObject, SceneNode);
SceneObject.prototype.setWorldBounds = function(pBox) {
;
this._pWorldBounds = pBox;

};
SceneObject.prototype.setForwardSearchLink = function(pForwardLink) {
;
this._pForwardSearchLink = pForwardLink;

};
SceneObject.prototype.setRearSearchLink = function(pRearLink) {
;
this._pRearSearchLink = pRearLink;

};
SceneObject.prototype.objectFlags = function() {
;
return this._iObjectFlags;

};
SceneObject.prototype.accessLocalBounds = function() {
;
if (true) {
this._iObjectFlags |= 1 << 0;

}
else  {
this._iObjectFlags &= ~(1 << 0);

}

;
return this._pLocalBounds;

};
SceneObject.prototype.treeNode = function() {
;
return this._pOcTreeNode;

};
SceneObject.prototype.forwardTreeLink = function() {
;
return this._pForwardTreeLink;

};
SceneObject.prototype.rearTreeLink = function() {
;
return this._pRearTreeLink;

};
SceneObject.prototype.setOcTreeData = function(pParentNode) {
;
this._pOcTreeNode = pParentNode;

};
SceneObject.prototype.setForwardTreeLink = function(pLink) {
;
this._pForwardTreeLink = pLink;

};
SceneObject.prototype.setRearTreeLink = function(pLink) {
;
this._pRearTreeLink = pLink;

};
SceneObject.prototype.localBounds = function() {
;
return this._pLocalBounds;

};
SceneObject.prototype.worldBounds = function() {
;
return this._pWorldBounds;

};
SceneObject.prototype.isWorldBoundsNew = function() {
;
return (this._iObjectFlags & (1 << 1)) != 0;

};
SceneObject.prototype.nextSearchLink = function() {
;
return this._pForwardSearchLink;

};
SceneObject.prototype.create = function() {
var result=SceneNode.prototype.create.call(this);
if (result) {
this.attachToOcTree(this._pEngine.getSceneTree());

}

return result;

};
SceneObject.prototype.destroy = function() {
this.detachFromOcTree();
SceneObject.superclass.destroy.apply(this, arguments);

};
SceneObject.prototype.prepareForUpdate = function() {
SceneObject.superclass.prepareForUpdate.apply(this, arguments);
this._iObjectFlags &= ~((1 << 0) | (1 << 1));

};
SceneObject.prototype.update = function() {
SceneNode.prototype.update.call(this);
this.recalcWorldBounds();
this.refreshOcTreeMembership();

};
SceneObject.prototype.recalcWorldBounds = function() {
if (((this._iObjectFlags & (1 << 0)) != 0) || (this.isWorldMatrixNew())) {
this._pWorldBounds.set(this._pLocalBounds);
if (this._pOcTree) {
this._pWorldBounds.fX1 = Math.max(this._pWorldBounds.fX1, (this._pWorldBounds.fX0) + 0.01);
this._pWorldBounds.fY1 = Math.max(this._pWorldBounds.fY1, (this._pWorldBounds.fY0) + 0.01);
this._pWorldBounds.fZ1 = Math.max(this._pWorldBounds.fZ1, (this._pWorldBounds.fZ0) + 0.01);

}

this._pWorldBounds.transform(this.worldMatrix());
if (true) {
this._iObjectFlags |= 1 << 1;

}
else  {
this._iObjectFlags &= ~(1 << 1);

}

;

}


};
SceneObject.prototype.refreshOcTreeMembership = function() {
if ((this._pOcTree) && ((this._iObjectFlags & (1 << 1)) != 0)) {
this._pOcTree.addOrUpdateSceneObject(this);

}


};
SceneObject.prototype.attachToOcTree = function(pParentTree) {
this.detachFromOcTree();
this._pOcTree = pParentTree;
this._pOcTree.addOrUpdateSceneObject(this);

};
SceneObject.prototype.detachFromOcTree = function() {
if (this._pOcTreeNode) {
this._pOcTreeNode.removeMember(this);
this._pOcTreeNode = null;

}

this._pOcTree = null;
this._pForwardTreeLink = null;
this._pRearTreeLink = null;

};
SceneObject.prototype.attachToSearchResult = function(pRearLink, pForwardLink) {
this._pForwardSearchLink = pForwardLink;
this._pRearSearchLink = pRearLink;
if (this._pForwardSearchLink) {
this._pForwardSearchLink.setRearSearchLink(this);

}

if (this._pRearSearchLink) {
this._pRearSearchLink.setForwardSearchLink(this);

}


};
SceneObject.prototype.detachFromSearchResult = function() {
if (this._pForwardSearchLink) {
this._pForwardSearchLink.setRearSearchLink(this._pRearSearchLink);

}

if (this._pRearSearchLink) {
this._pRearSearchLink.setForwardSearchLink(this._pForwardSearchLink);

}

this._pForwardSearchLink = null;
this._pRearSearchLink = null;

};
SceneObject.prototype.clearSearchResults = function() {
this._pRearSearchLink = null;
this._pForwardSearchLink = null;

};
SceneObject.prototype.prepareForRender = function() {

};
SceneObject.prototype.render = function() {
SceneObject.superclass.render.apply(this, arguments);

};
SceneObject.prototype.renderCallback = function(entry, activationFlags) {

};
SceneObject.prototype.renderShadow = function() {

};
SceneObject.prototype.hasShadow = function(hasShadow) {
if (hasShadow !== undefined) {
this._hasShadow = hasShadow;

}

return this._hasShadow;

};
SceneObject.prototype.toString = function(isRecursive, iDepth) {
"use strict";
isRecursive = isRecursive || false;
if (!isRecursive) {
return ("<scene_object" + ((this._sName? " " + (this._sName) : ""))) + ">";

}

return SceneNode.prototype.toString.call(this, isRecursive, iDepth);

};
a["SceneObject"] = SceneObject;
function Joint(pEngine) {
var _pCtorValue=Joint.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
if (!pEngine) {
var err=((((((("Error:: " + "engine must be") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/scene/Joint.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("engine must be");

}


}

;
this._sBone = null;
this._iUpdated = 0;
this._pEngine = pEngine;

}

a.extend(Joint, a.Node);
a.defineProperty(Joint, "boneName", function() {
return this._sBone;

}
, function(sBone) {
this._sBone = sBone;

}
);
Joint.prototype.getEngine = function() {
"use strict";
return this._pEngine;

};
Joint.prototype.create = function() {
"use strict";
this._m4fLocalMatrix = new Mat4(1);
this._m4fWorldMatrix = new Mat4(1);
this._v3fWorldPosition = new Vec3();
this._v3fTranslation = new Vec3(0, 0, 0);
this._v3fScale = new Vec3(1);
this._qRotation = new Quat4(0, 1);
this.setInheritance(2);
return true;

};
Joint.prototype.toString = function(isRecursive, iDepth) {
"use strict";
isRecursive = isRecursive || false;
if (!isRecursive) {
return ("<joint" + ((this._sName? " " + (this._sName) : ""))) + ">";

}

return Node.prototype.toString.call(this, isRecursive, iDepth);

};
a["Joint"] = Joint;
function Camera() {
Camera.superclass.constructor.apply(this, arguments);
this.iType = 0;
this.m4fView = new Mat4();
this.m4fProj = new Mat4();
this.m4fUnitProj = new Mat4();
this.m4fViewProj = new Mat4();
this.m4fBillboard = new Mat4();
this.m4fSkyBox = new Mat4();
this.m4fRenderStageProj = new Mat4();
this.m4fRenderStageViewProj = new Mat4();
this.pSearchRect = new a.Rect3d();
this.v3fTargetPos = new Vec3();
this.fFOV = (Math.PI) / 5;
this.fAspect = 640 / 480;
this.fNearPlane = 0.1;
this.fFarPlane = 500;
this.fWidth = 0;
this.fHeight = 0;
this.fMinX = 0;
this.fMaxX = 0;
this.fMinY = 0;
this.fMaxY = 0;
this.pv3fFarPlanePoints = new Array(8);
for (var i=0; i < 8; ++i) {
this.pv3fFarPlanePoints[i] = new Vec3();

}

this.pFrustum = new a.Frustum();

}

;
a.extend(Camera, a.SceneNode);
Camera.prototype.create = function() {
var result=Camera.superclass.create.apply(this, arguments);
if (result) {
this.v3fTargetPos.set(this._m4fLocalMatrix[8], this._m4fLocalMatrix[9], this._m4fLocalMatrix[10]);
this.v3fTargetPos.negate();
this.setProjParams(this.fFOV, this.fAspect, this.fNearPlane, this.fFarPlane);
this.recalcMatrices();

}

return result;

};
Camera.prototype.setProjParams = function(fFOV, fAspect, fNearPlane, fFarPlane) {
this.fFOV = fFOV;
this.fAspect = fAspect;
this.fNearPlane = fNearPlane;
this.fFarPlane = fFarPlane;
this.iType = 0;
Mat4.matrixPerspectiveFovRH(fFOV, fAspect, fNearPlane, fFarPlane, this.m4fProj);
Mat4.matrixPerspectiveFovRH(fFOV, fAspect, 0.01, 2, this.m4fUnitProj);

};
Camera.prototype.setOrthoParams = function(fWidth, fHeight, fNearPlane, fFarPlane) {
this.fWidth = fWidth;
this.fHeight = fHeight;
this.fNearPlane = fNearPlane;
this.fFarPlane = fFarPlane;
this.iType = 1;
Mat4.matrixOrthoRH(fWidth, fHeight, fNearPlane, fFarPlane, this.m4fProj);
Mat4.matrixOrthoRH(fWidth, fHeight, 0.01, 2, this.m4fUnitProj);

};
Camera.prototype.setOffsetOrthoParams = function(fMinX, fMaxX, fMinY, fMaxY, fNearPlane, fFarPlane) {
this.fMinX = fMinX;
this.fMaxX = fMaxX;
this.fMinY = fMinY;
this.fMaxY = fMaxY;
this.fNearPlane = fNearPlane;
this.fFarPlane = fFarPlane;
this.iType = 2;
Mat4.orthogonalProjection(fMinX, fMaxX, fMinY, fMaxY, fNearPlane, fFarPlane, this.m4fProj);
Mat4.orthogonalProjection(fMinX, fMaxX, fMinY, fMaxY, 0.01, 2, this.m4fUnitProj);

};
Camera.prototype.recalcMatrices = function() {
this.v3fTargetPos.set(this._m4fLocalMatrix.pData[8], this._m4fLocalMatrix.pData[9], this._m4fLocalMatrix.pData[10]);
this.v3fTargetPos.negate();
this.m4fView.set(this.inverseWorldMatrix());
this.m4fSkyBox.set(this.m4fView);
this.m4fSkyBox.pData[12] = 0;
this.m4fSkyBox.pData[13] = 0;
this.m4fSkyBox.pData[14] = 0;
this.m4fUnitProj.multiply(this.m4fSkyBox, this.m4fSkyBox);
this.m4fBillboard.set(this.worldMatrix());
this.m4fBillboard.pData[12] = 0;
this.m4fBillboard.pData[13] = 0;
this.m4fBillboard.pData[14] = 0;
this.m4fProj.multiply(this.m4fView, this.m4fViewProj);
var m4fInvProj=Mat4();
var m4fInvCamera=Mat4();
this.m4fProj.inverse(m4fInvProj);
this.worldMatrix().multiply(m4fInvProj, m4fInvCamera);
var v3fWorldPos=Vec3(this.worldPosition());
var p0=Vec3(-1, 1, 1);
var p1=Vec3(-1, -1, 1);
var p2=Vec3(1, -1, 1);
var p3=Vec3(1, 1, 1);
var p4=Vec3(-1, 1, 0);
var p5=Vec3(-1, -1, 0);
var p6=Vec3(1, -1, 0);
var p7=Vec3(1, 1, 0);
p0.vec3TransformCoord(m4fInvCamera, this.pv3fFarPlanePoints[0]);
p1.vec3TransformCoord(m4fInvCamera, this.pv3fFarPlanePoints[1]);
p2.vec3TransformCoord(m4fInvCamera, this.pv3fFarPlanePoints[2]);
p3.vec3TransformCoord(m4fInvCamera, this.pv3fFarPlanePoints[3]);
p4.vec3TransformCoord(m4fInvCamera, this.pv3fFarPlanePoints[4]);
p5.vec3TransformCoord(m4fInvCamera, this.pv3fFarPlanePoints[5]);
p6.vec3TransformCoord(m4fInvCamera, this.pv3fFarPlanePoints[6]);
p7.vec3TransformCoord(m4fInvCamera, this.pv3fFarPlanePoints[7]);
this.pSearchRect.set(v3fWorldPos.pData[0], v3fWorldPos.pData[0], v3fWorldPos.pData[1], v3fWorldPos.pData[1], v3fWorldPos.pData[2], v3fWorldPos.pData[2]);
this.pSearchRect.unionPoint(this.pv3fFarPlanePoints[0]);
this.pSearchRect.unionPoint(this.pv3fFarPlanePoints[1]);
this.pSearchRect.unionPoint(this.pv3fFarPlanePoints[2]);
this.pSearchRect.unionPoint(this.pv3fFarPlanePoints[3]);
this.pSearchRect.unionPoint(this.pv3fFarPlanePoints[4]);
this.pSearchRect.unionPoint(this.pv3fFarPlanePoints[5]);
this.pSearchRect.unionPoint(this.pv3fFarPlanePoints[6]);
this.pSearchRect.unionPoint(this.pv3fFarPlanePoints[7]);
this._extractFrustumVertices();
this._calculateFrustumPlanes();
this.m4fRenderStageProj.set(this.m4fProj);
this.m4fRenderStageViewProj.set(this.m4fViewProj);

};
Camera.prototype.update = function() {
Camera.superclass.update.apply(this, arguments);
if (this.isWorldMatrixNew()) {
this.recalcMatrices();

}


};
Camera.prototype.applyRenderStageBias = function(iStage) {
var fZ_bias=(iStage > 1? 0.001 : 0);
this.m4fRenderStageProj.set(this.m4fProj);
this.m4fRenderStageViewProj.set(this.m4fViewProj);
this.m4fRenderStageProj[14] -= fZ_bias;
this.m4fRenderStageViewProj[14] -= fZ_bias;

};
Camera.prototype.viewMatrix = function() {
;
return this.m4fView;

};
Camera.prototype.projectionMatrix = function() {
;
return this.m4fRenderStageProj;

};
Camera.prototype.viewProjMatrix = function() {
;
return this.m4fRenderStageViewProj;

};
Camera.prototype.billboardMatrix = function() {
;
return this.m4fBillboard;

};
Camera.prototype.skyBoxMatrix = function() {
;
return this.m4fSkyBox;

};
Camera.prototype.internalProjectionMatrix = function() {
;
return this.m4fProj;

};
Camera.prototype.internalViewProjMatrix = function() {
;
return this.m4fViewProj;

};
Camera.prototype.targetPos = function() {
;
return this.v3fTargetPos;

};
Camera.prototype.fov = function() {
;
return this.fFOV;

};
Camera.prototype.aspect = function() {
;
return this.fAspect;

};
Camera.prototype.nearPlane = function() {
;
return this.fNearPlane;

};
Camera.prototype.farPlane = function() {
;
return this.fFarPlane;

};
Camera.prototype.viewDistance = function() {
;
return (this.fFarPlane) - (this.fNearPlane);

};
Camera.prototype.searchRect = function() {
;
return this.pSearchRect;

};
Camera.prototype.farPlanePoints = function() {
;
return this.pv3fFarPlanePoints;

};
Camera.prototype.frustum = function() {
;
return this.pFrustum;

};
Camera.prototype.toString = function(isRecursive, iDepth) {
"use strict";
isRecursive = isRecursive || false;
if (!isRecursive) {
return ("<camera" + ((this._sName? " " + (this._sName) : ""))) + ">";

}

return SceneNode.prototype.toString.call(this, isRecursive, iDepth);

};
Camera.prototype.lookAt = function() {
var v3fFrom, v3fCenter, v3fUp;
if ((arguments.length) < 3) {
v3fFrom = this.worldPosition();
v3fCenter = arguments[0];
v3fUp = arguments[1];

}
else  {
v3fFrom = arguments[0];
v3fCenter = arguments[1];
v3fUp = arguments[2];

}

v3fUp = v3fUp || (Vec3(0, 1, 0));
var v3fParentPos=this.parent().worldPosition().pData;
var m4fTemp=Mat4.lookAt(v3fFrom, v3fCenter, v3fUp, Mat4()).inverse();
var pData=m4fTemp.pData;
switch(this._iInheritance) {
case 2:
this._pParent.inverseWorldMatrix().mult(m4fTemp, m4fTemp);
m4fTemp.toQuat4(this._qRotation);
this.setPosition(pData[12], pData[13], pData[14]);
break ;

case 1:
var m3fTemp=m4fTemp.toMat3();
m3fTemp = this._pParent.inverseWorldMatrix().toMat3().mult(m3fTemp, Mat3());
m3fTemp.toQuat4(this._qRotation);
this.setPosition(pData[12], pData[13], pData[14]);
break ;

default:
m4fTemp.toQuat4(this._qRotation);
this.setPosition((pData[12]) - (v3fParentPos[0]), (pData[13]) - (v3fParentPos[1]), (pData[14]) - (v3fParentPos[2]));
}

};
function unproj(m4fProj, v4fScreen, v4fDestination) {
if (!v4fDestination) {
v4fDestination = new Vec4();

}

var pData1=m4fProj.pData;
var pData2=v4fScreen.pData;
var pDataDestination=v4fDestination.pData;
var z=(-(pData1[14])) / ((pData1[10]) + (pData2[2]));
var y=(((-(pData2[1])) * z) - ((pData1[9]) * z)) / (pData1[5]);
var x=(((-(pData2[0])) * z) - ((pData1[8]) * z)) / (pData1[0]);
pDataDestination[0] = x;
pDataDestination[1] = y;
pDataDestination[2] = z;
pDataDestination[3] = 1;
return v4fDestination;

}

;
Camera.prototype._extractFrustumVertices = function() {
"use strict";
var m4fProj=this.m4fProj;
this._v4fLeftBottomNear = new Vec4();
unproj(m4fProj, Vec4(-1, -1, -1, 1), this._v4fLeftBottomNear);
this._v4fRightBottomNear = new Vec4();
unproj(m4fProj, Vec4(1, -1, -1, 1), this._v4fRightBottomNear);
this._v4fLeftTopNear = new Vec4();
unproj(m4fProj, Vec4(-1, 1, -1, 1), this._v4fLeftTopNear);
this._v4fRightTopNear = new Vec4();
unproj(m4fProj, Vec4(1, 1, -1, 1), this._v4fRightTopNear);
this._v4fLeftBottomFar = new Vec4();
unproj(m4fProj, Vec4(-1, -1, 1, 1), this._v4fLeftBottomFar);
this._v4fRightBottomFar = new Vec4();
unproj(m4fProj, Vec4(1, -1, 1, 1), this._v4fRightBottomFar);
this._v4fLeftTopFar = new Vec4();
unproj(m4fProj, Vec4(-1, 1, 1, 1), this._v4fLeftTopFar);
this._v4fRightTopFar = new Vec4();
unproj(m4fProj, Vec4(1, 1, 1, 1), this._v4fRightTopFar);

};
Camera.prototype._calculateFrustumPlanes = function() {
"use strict";
var m4fCameraWorld=this._m4fWorldMatrix;
var pFrustum=this.pFrustum;
var v4fLeftBottomNearData=m4fCameraWorld.multiply(this._v4fLeftBottomNear, Vec4()).pData;
var v4fRightBottomNearData=m4fCameraWorld.multiply(this._v4fRightBottomNear, Vec4()).pData;
var v4fLeftTopNearData=m4fCameraWorld.multiply(this._v4fLeftTopNear, Vec4()).pData;
var v4fRightTopNearData=m4fCameraWorld.multiply(this._v4fRightTopNear, Vec4()).pData;
var v4fLeftBottomFarData=m4fCameraWorld.multiply(this._v4fLeftBottomFar, Vec4()).pData;
var v4fRightBottomFarData=m4fCameraWorld.multiply(this._v4fRightBottomFar, Vec4()).pData;
var v4fLeftTopFarData=m4fCameraWorld.multiply(this._v4fLeftTopFar, Vec4()).pData;
var v4fRightTopFarData=m4fCameraWorld.multiply(this._v4fRightTopFar, Vec4()).pData;
var x1, y1, z1;
var x2, y2, z2;
var x3, y3, z3;
var fLength, fInvLength;
var pDirectionLTNLBN=Vec3().pData;
var pDirectionLTNRTN=Vec3().pData;
var pDirectionLTNLTF=Vec3().pData;
var pDirectionRBFRTF=Vec3().pData;
var pDirectionRBFRBN=Vec3().pData;
var pDirectionRBFLBF=Vec3().pData;
pDirectionLTNLBN[0] = (v4fLeftBottomNearData[0]) - (v4fLeftTopNearData[0]);
pDirectionLTNLBN[1] = (v4fLeftBottomNearData[1]) - (v4fLeftTopNearData[1]);
pDirectionLTNLBN[2] = (v4fLeftBottomNearData[2]) - (v4fLeftTopNearData[2]);
pDirectionLTNRTN[0] = (v4fRightTopNearData[0]) - (v4fLeftTopNearData[0]);
pDirectionLTNRTN[1] = (v4fRightTopNearData[1]) - (v4fLeftTopNearData[1]);
pDirectionLTNRTN[2] = (v4fRightTopNearData[2]) - (v4fLeftTopNearData[2]);
pDirectionLTNLTF[0] = (v4fLeftTopFarData[0]) - (v4fLeftTopNearData[0]);
pDirectionLTNLTF[1] = (v4fLeftTopFarData[1]) - (v4fLeftTopNearData[1]);
pDirectionLTNLTF[2] = (v4fLeftTopFarData[2]) - (v4fLeftTopNearData[2]);
pDirectionRBFRTF[0] = (v4fRightTopFarData[0]) - (v4fRightBottomFarData[0]);
pDirectionRBFRTF[1] = (v4fRightTopFarData[1]) - (v4fRightBottomFarData[1]);
pDirectionRBFRTF[2] = (v4fRightTopFarData[2]) - (v4fRightBottomFarData[2]);
pDirectionRBFRBN[0] = (v4fRightBottomNearData[0]) - (v4fRightBottomFarData[0]);
pDirectionRBFRBN[1] = (v4fRightBottomNearData[1]) - (v4fRightBottomFarData[1]);
pDirectionRBFRBN[2] = (v4fRightBottomNearData[2]) - (v4fRightBottomFarData[2]);
pDirectionRBFLBF[0] = (v4fLeftBottomFarData[0]) - (v4fRightBottomFarData[0]);
pDirectionRBFLBF[1] = (v4fLeftBottomFarData[1]) - (v4fRightBottomFarData[1]);
pDirectionRBFLBF[2] = (v4fLeftBottomFarData[2]) - (v4fRightBottomFarData[2]);
var testPoint1=v4fLeftTopNearData;
var testPoint2=v4fRightBottomFarData;
x1 = pDirectionLTNLBN[0];
y1 = pDirectionLTNLBN[1];
z1 = pDirectionLTNLBN[2];
x2 = pDirectionLTNRTN[0];
y2 = pDirectionLTNRTN[1];
z2 = pDirectionLTNRTN[2];
x3 = (y1 * z2) - (z1 * y2);
y3 = (z1 * x2) - (x1 * z2);
z3 = (x1 * y2) - (y1 * x2);
fLength = Math.sqrt(((x3 * x3) + (y3 * y3)) + (z3 * z3));
fInvLength = 1 / fLength;
x3 *= fInvLength;
y3 *= fInvLength;
z3 *= fInvLength;
var v3fNormalNearData=pFrustum.nearPlane.v3fNormal.pData;
v3fNormalNearData[0] = x3;
v3fNormalNearData[1] = y3;
v3fNormalNearData[2] = z3;
pFrustum.nearPlane.fDistance = -((((testPoint1[0]) * x3) + ((testPoint1[1]) * y3)) + ((testPoint1[2]) * z3));
x1 = pDirectionLTNLTF[0];
y1 = pDirectionLTNLTF[1];
z1 = pDirectionLTNLTF[2];
x2 = pDirectionLTNLBN[0];
y2 = pDirectionLTNLBN[1];
z2 = pDirectionLTNLBN[2];
x3 = (y1 * z2) - (z1 * y2);
y3 = (z1 * x2) - (x1 * z2);
z3 = (x1 * y2) - (y1 * x2);
fLength = Math.sqrt(((x3 * x3) + (y3 * y3)) + (z3 * z3));
fInvLength = 1 / fLength;
x3 *= fInvLength;
y3 *= fInvLength;
z3 *= fInvLength;
var v3fNormalLeftData=pFrustum.leftPlane.v3fNormal.pData;
v3fNormalLeftData[0] = x3;
v3fNormalLeftData[1] = y3;
v3fNormalLeftData[2] = z3;
pFrustum.leftPlane.fDistance = -((((testPoint1[0]) * x3) + ((testPoint1[1]) * y3)) + ((testPoint1[2]) * z3));
x1 = pDirectionLTNRTN[0];
y1 = pDirectionLTNRTN[1];
z1 = pDirectionLTNRTN[2];
x2 = pDirectionLTNLTF[0];
y2 = pDirectionLTNLTF[1];
z2 = pDirectionLTNLTF[2];
x3 = (y1 * z2) - (z1 * y2);
y3 = (z1 * x2) - (x1 * z2);
z3 = (x1 * y2) - (y1 * x2);
fLength = Math.sqrt(((x3 * x3) + (y3 * y3)) + (z3 * z3));
fInvLength = 1 / fLength;
x3 *= fInvLength;
y3 *= fInvLength;
z3 *= fInvLength;
var v3fNormalTopData=pFrustum.topPlane.v3fNormal.pData;
v3fNormalTopData[0] = x3;
v3fNormalTopData[1] = y3;
v3fNormalTopData[2] = z3;
pFrustum.topPlane.fDistance = -((((testPoint1[0]) * x3) + ((testPoint1[1]) * y3)) + ((testPoint1[2]) * z3));
x1 = pDirectionRBFRTF[0];
y1 = pDirectionRBFRTF[1];
z1 = pDirectionRBFRTF[2];
x2 = pDirectionRBFRBN[0];
y2 = pDirectionRBFRBN[1];
z2 = pDirectionRBFRBN[2];
x3 = (y1 * z2) - (z1 * y2);
y3 = (z1 * x2) - (x1 * z2);
z3 = (x1 * y2) - (y1 * x2);
fLength = Math.sqrt(((x3 * x3) + (y3 * y3)) + (z3 * z3));
fInvLength = 1 / fLength;
x3 *= fInvLength;
y3 *= fInvLength;
z3 *= fInvLength;
var v3fNormalRightData=pFrustum.rightPlane.v3fNormal.pData;
v3fNormalRightData[0] = x3;
v3fNormalRightData[1] = y3;
v3fNormalRightData[2] = z3;
pFrustum.rightPlane.fDistance = -((((testPoint2[0]) * x3) + ((testPoint2[1]) * y3)) + ((testPoint2[2]) * z3));
x1 = pDirectionRBFRBN[0];
y1 = pDirectionRBFRBN[1];
z1 = pDirectionRBFRBN[2];
x2 = pDirectionRBFLBF[0];
y2 = pDirectionRBFLBF[1];
z2 = pDirectionRBFLBF[2];
x3 = (y1 * z2) - (z1 * y2);
y3 = (z1 * x2) - (x1 * z2);
z3 = (x1 * y2) - (y1 * x2);
fLength = Math.sqrt(((x3 * x3) + (y3 * y3)) + (z3 * z3));
fInvLength = 1 / fLength;
x3 *= fInvLength;
y3 *= fInvLength;
z3 *= fInvLength;
var v3fNormalBottomData=pFrustum.bottomPlane.v3fNormal.pData;
v3fNormalBottomData[0] = x3;
v3fNormalBottomData[1] = y3;
v3fNormalBottomData[2] = z3;
pFrustum.bottomPlane.fDistance = -((((testPoint2[0]) * x3) + ((testPoint2[1]) * y3)) + ((testPoint2[2]) * z3));
x1 = pDirectionRBFLBF[0];
y1 = pDirectionRBFLBF[1];
z1 = pDirectionRBFLBF[2];
x2 = pDirectionRBFRTF[0];
y2 = pDirectionRBFRTF[1];
z2 = pDirectionRBFRTF[2];
x3 = (y1 * z2) - (z1 * y2);
y3 = (z1 * x2) - (x1 * z2);
z3 = (x1 * y2) - (y1 * x2);
fLength = Math.sqrt(((x3 * x3) + (y3 * y3)) + (z3 * z3));
fInvLength = 1 / fLength;
x3 *= fInvLength;
y3 *= fInvLength;
z3 *= fInvLength;
var v3fNormalFarData=pFrustum.farPlane.v3fNormal.pData;
v3fNormalFarData[0] = x3;
v3fNormalFarData[1] = y3;
v3fNormalFarData[2] = z3;
pFrustum.farPlane.fDistance = -((((testPoint2[0]) * x3) + ((testPoint2[1]) * y3)) + ((testPoint2[2]) * z3));

};
a.Camera = Camera;
function OcTree() {
;
this._ppLevelNodes = null;
this.pFirstNode = null;
this._v3fWorldExtents = new Vec3();
this._v3fWorldScale = new Vec3();
this._v3fWorldOffset = new Vec3();
this._iDepth = 0;
this._pFreeNodePool = null;
this.pTestLocalRect = null;

}

;
OcTree.prototype.getAndSetFreeNode = function(iLevel, iX, iY, iZ, iIndex) {
var pNode=this._pFreeNodePool.pop();
if (!pNode) {
pNode = new a.OcTreeNode(this);

}

pNode.iLevel = iLevel;
pNode.iX = iX;
pNode.iY = iY;
pNode.iZ = iZ;
pNode.iIndex = iIndex;
pNode.pNodeTrueRect.clear();
this._ppLevelNodes[iLevel][iIndex] = pNode;
if (this.pFirstNode) {
this.pFirstNode.pRearNodeLink = pNode;

}

pNode.pForwardNodeLink = this.pFirstNode;
pNode.pRearNodeLink = null;
this.pFirstNode = pNode;
return pNode;

};
OcTree.prototype.isReady = function() {
return (this._iDepth) && (this._ppLevelNodes);

};
OcTree.prototype.getNodeFromLevelXYZ = function(iLevel, iIndex) {
if (!this.isReady()) {
var err=((((((("Error:: " + "the Oc tree has not been created") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Tree.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("the Oc tree has not been created");

}


}

;
if ((iLevel >= 0) && (iLevel < (this._iDepth))) {
return this._ppLevelNodes[iLevel][iIndex];

}

return -1;

};
OcTree.prototype.create = function(pWorldBoundingBox, iDepth, nNode) {
if (!(!(this.isReady()))) {
var err=((((((("Error:: " + "the Oc tree has already been created") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Tree.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("the Oc tree has already been created");

}


}

;
if (!(iDepth >= (1))) {
var err=((((((("Error:: " + "invalid tree iDepth") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Tree.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid tree iDepth");

}


}

;
if (!(iDepth <= (11))) {
var err=((((((("Error:: " + "invalid tree iDepth") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Tree.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid tree iDepth");

}


}

;
this._iDepth = iDepth;
var v3fTemp;
v3fTemp = pWorldBoundingBox.size();
this._v3fWorldExtents.set(v3fTemp);
v3fTemp = pWorldBoundingBox.minPoint().negate();
this._v3fWorldOffset.set(v3fTemp);
this._v3fWorldScale.x = 1024 / (this._v3fWorldExtents.x);
this._v3fWorldScale.y = 1024 / (this._v3fWorldExtents.y);
this._v3fWorldScale.z = 1024 / (this._v3fWorldExtents.z);
this._ppLevelNodes = new Array(iDepth);
var i=0;
for (i = 0; i < iDepth; ++i) {
this._ppLevelNodes[i] = new Array();

}

this.pTestLocalRect = new Array(iDepth);
for (i = 0; i < iDepth; ++i) {
this.pTestLocalRect[i] = new OcTreeRect();

}

this._pFreeNodePool = new Array();
var nodes=((arguments.length) == 3? nNode : 10);
for (i = 0; i < nodes; ++i) {
this._pFreeNodePool.push(new a.OcTreeNode(this));

}


};
OcTree.prototype.destroy = function() {
var i;
for (i = 0; i < (this._iDepth); ++i) {
delete (this._ppLevelNodes[i]);

}

delete (this._ppLevelNodes);
for (i = 0; i < (this._pFreeNodePool.length); ++i) {
delete (this._pFreeNodePool[i]);

}

delete (this._pFreeNodePool);
this._iDepth = 0;

};
OcTree.prototype.findTreeNode = function(iX0, iX1, iY0, iY1, iZ0, iZ1) {
var level, levelX, levelY, levelZ;
var xPattern=iX0 ^ iX1;
var yPattern=iY0 ^ iY1;
var zPattern=iZ0 ^ iZ1;
var bitPattern=Math.max(zPattern, Math.max(xPattern, yPattern));
var highBit=(bitPattern? ((bitPattern == 0? null : (bitPattern < 0? 31 : ((Math.log(bitPattern)) / (Math.LN2)) << 0))) + 1 : 0);
level = ((11) - highBit) - 1;
level = Math.min(level, (this._iDepth) - 1);
var shift=((11) - level) - 1;
levelX = iX1 >> shift;
levelY = iY1 >> shift;
levelZ = iZ1 >> shift;
var iIndex=(((levelZ << level) << level) + (levelY << level)) + levelX;
var pNode=this.getNodeFromLevelXYZ(level, iIndex);
if (!pNode) {
return this.getAndSetFreeNode(level, levelX, levelY, levelZ, iIndex);

}

return pNode;

};
OcTree.prototype.buildByteRect = function(pWorldRect, pWorldByteRect) {
pWorldByteRect.convert(pWorldRect, this._v3fWorldOffset, this._v3fWorldScale);

};
OcTree.prototype.addOrUpdateSceneObject = function(pNewNode) {
var pRect=pNewNode._pWorldBounds;
var iX0=pRect.fX0, iX1=pRect.fX1, iY0=pRect.fY0, iY1=pRect.fY1, iZ0=pRect.fZ0, iZ1=pRect.fZ1;
var pWorldOffsetData=this._v3fWorldOffset.pData;
var pWorldScaleData=this._v3fWorldScale.pData;
iX0 += pWorldOffsetData[0];
iX1 += pWorldOffsetData[0];
iY0 += pWorldOffsetData[1];
iY1 += pWorldOffsetData[1];
iZ0 += pWorldOffsetData[2];
iZ1 += pWorldOffsetData[2];
iX0 *= pWorldScaleData[0];
iX1 *= pWorldScaleData[0];
iY0 *= pWorldScaleData[1];
iY1 *= pWorldScaleData[1];
iZ0 *= pWorldScaleData[2];
iZ1 *= pWorldScaleData[2];
iX0 = iX0 << 0;
iX1 = iX1 << 0;
iY0 = iY0 << 0;
iY1 = iY1 << 0;
iZ0 = iZ0 << 0;
iZ1 = iZ1 << 0;
iX0 = Math.max(0, Math.min(iX0, 1022));
iY0 = Math.max(0, Math.min(iY0, 1022));
iZ0 = Math.max(0, Math.min(iZ0, 1022));
iX1 = Math.max((iX0 + 1), Math.min(iX1, 1023));
iY1 = Math.max((iY0 + 1), Math.min(iY1, 1023));
iZ1 = Math.max((iZ0 + 1), Math.min(iZ1, 1023));
var pNode=this.findTreeNode(iX0, iX1, iY0, iY1, iZ0, iZ1);
return pNode.addOrUpdateMember(pNewNode);

};
OcTree.prototype.deleteNodeFromTree = function(pNode) {
if (pNode.pRearNodeLink) {
pNode.pRearNodeLink.pForwardNodeLink = pNode.pForwardNodeLink;

}

if (pNode.pForwardNodeLink) {
pNode.pForwardNodeLink.pRearNodeLink = pNode.pRearNodeLink;

}

if ((this.pFirstNode) == pNode) {
this.pFirstNode = pNode.pForwardNodeLink;

}

var iLevel=pNode.iLevel;
this._ppLevelNodes[iLevel][pNode.iIndex] = null;
pNode.pForwardNodeLink = null;
pNode.pRearNodeLink = null;
this._pFreeNodePool.push(pNode);

};
OcTree.prototype.buildSearchResults = function(pWorldRect, pOptionalFrustum) {
var pResultListStart=null;
var pResultListEnd=null;
var pByteRect=OcTreeRect();
this.buildByteRect(pWorldRect, pByteRect);
var iLevel=0;
var iX, iY, iZ;
var pLocalRect;
var pObject=null;
var pResult=a.Rect3d();
var pNode=null;
var i;
for (i = 0; i < (this._iDepth); ++i) {
var shift_count=10 - i;
this.pTestLocalRect[i].set((pByteRect.iX0) >> shift_count, (pByteRect.iX1) >> shift_count, (pByteRect.iY0) >> shift_count, (pByteRect.iY1) >> shift_count, (pByteRect.iZ0) >> shift_count, (pByteRect.iZ1) >> shift_count);

}

for (pNode = this.pFirstNode; pNode; pNode = pNode.pForwardNodeLink) {
iLevel = pNode.iLevel;
iX = pNode.iX;
iY = pNode.iY;
iZ = pNode.iZ;
pLocalRect = this.pTestLocalRect[iLevel];
if ((((((iY < (pLocalRect.iY0)) || (iY > (pLocalRect.iY1))) || (iX < (pLocalRect.iX0))) || (iX > (pLocalRect.iX1))) || (iZ < (pLocalRect.iZ0))) || (iZ > (pLocalRect.iZ1))) {
continue ;

}

if ((((((iY == (pLocalRect.iY0)) || (iY == (pLocalRect.iY1))) || (iX == (pLocalRect.iX0))) || (iX == (pLocalRect.iX1))) || (iZ == (pLocalRect.iZ0))) || (iZ == (pLocalRect.iZ1))) {
pObject = null;
if (!pOptionalFrustum) {
for (pObject = pNode.pFirstMember; pObject; pObject = pObject._pForwardTreeLink) {
if (a.intersectRect3d(pWorldRect, pObject.worldBounds(), pResult)) {
if (pResultListEnd) {
pObject.attachToSearchResult(pResultListEnd, null);
pResultListEnd = pObject;

}
else  {
pObject.clearSearchResults();
pResultListEnd = pObject;
pResultListStart = pObject;

}


}


}

continue ;

}

if (pNode.pNodeTrueRect.isClear()) {
pNode.nodeCoords();

}

if (!(pOptionalFrustum.testRect(pNode.pNodeTrueRect))) {
continue ;

}

for (pObject = pNode.pFirstMember; pObject; pObject = pObject._pForwardTreeLink) {
if (a.intersectRect3d(pWorldRect, pObject.worldBounds(), pResult)) {
if (pOptionalFrustum.testRect(pObject.worldBounds())) {
if (pResultListEnd) {
pObject.attachToSearchResult(pResultListEnd, null);
pResultListEnd = pObject;

}
else  {
pObject.clearSearchResults();
pResultListEnd = pObject;
pResultListStart = pObject;

}


}


}


}

continue ;

}
else  {
pObject = null;
if (!pOptionalFrustum) {
for (pObject = pNode.pFirstMember; pObject; pObject = pObject._pForwardTreeLink) {
if (pResultListEnd) {
pObject.attachToSearchResult(pResultListEnd, null);
pResultListEnd = pObject;

}
else  {
pObject.clearSearchResults();
pResultListEnd = pObject;
pResultListStart = pObject;

}


}

continue ;

}

if (pNode.pNodeTrueRect.isClear()) {
pNode.nodeCoords();

}

if (!(pOptionalFrustum.testRect(pNode.pNodeTrueRect))) {
continue ;

}

for (pObject = pNode.pFirstMember; pObject; pObject = pObject._pForwardTreeLink) {
if (pOptionalFrustum.testRect(pObject.worldBounds())) {
if (pResultListEnd) {
pObject.attachToSearchResult(pResultListEnd, null);
pResultListEnd = pObject;

}
else  {
pObject.clearSearchResults();
pResultListEnd = pObject;
pResultListStart = pObject;

}


}


}

continue ;

}


}

return pResultListStart;

};
function OcTreeRect() {
if ((((this) === window) || (!(this))) || ((this) === (window.AKRA))) {
OcTreeRect._iIndex = ((OcTreeRect._iIndex) === ((OcTreeRect._nStorageSize) - 1)? 0 : OcTreeRect._iIndex);
return OcTreeRect._pStorage[OcTreeRect._iIndex++];

}

;
this.iX0 = 0;
this.iX1 = 0;
this.iY0 = 0;
this.iY1 = 0;
this.iZ0 = 0;
this.iZ1 = 0;
switch(arguments.length) {
case 1:
this.iX0 = arguments[0].iX0;
this.iX1 = arguments[0].iX1;
this.iY0 = arguments[0].iY0;
this.iY1 = arguments[0].iY1;
this.iZ0 = arguments[0].iZ0;
this.iZ1 = arguments[0].iZ1;
break ;

case 6:
this.iX0 = arguments[0];
this.iX1 = arguments[1];
this.iY0 = arguments[2];
this.iY1 = arguments[3];
this.iZ0 = arguments[4];
this.iZ1 = arguments[5];
break ;
}

}

a.allocateStorage(OcTreeRect, 8);
OcTreeRect.prototype.convert = function(pWorldRect, v3fOffset, v3fScale) {
var convertedRect=new a.Rect3d(pWorldRect);
convertedRect.addSelf(v3fOffset);
convertedRect.multSelf(v3fScale);
convertedRect.fX1 = Math.max((convertedRect.fX1) - 0.01, convertedRect.fX0);
convertedRect.fY1 = Math.max((convertedRect.fY1) - 0.01, convertedRect.fY0);
convertedRect.fZ1 = Math.max((convertedRect.fZ1) - 0.01, convertedRect.fZ0);
this.iX0 = (convertedRect.fX0) << 0;
this.iX1 = (convertedRect.fX1) << 0;
this.iY0 = (convertedRect.fY0) << 0;
this.iY1 = (convertedRect.fY1) << 0;
this.iZ0 = (convertedRect.fZ0) << 0;
this.iZ1 = (convertedRect.fZ1) << 0;
this.iX0 = Math.max(0, Math.min(this.iX0, 1022));
this.iY0 = Math.max(0, Math.min(this.iY0, 1022));
this.iZ0 = Math.max(0, Math.min(this.iZ0, 1022));
this.iX1 = Math.max(((this.iX0) + 1), Math.min(this.iX1, 1023));
this.iY1 = Math.max(((this.iY0) + 1), Math.min(this.iY1, 1023));
this.iZ1 = Math.max(((this.iZ0) + 1), Math.min(this.iZ1, 1023));

};
OcTreeRect.prototype.set = function(iX0, iX1, iY0, iY1, iZ0, iZ1) {
this.iX0 = iX0;
this.iX1 = iX1;
this.iY0 = iY0;
this.iY1 = iY1;
this.iZ0 = iZ0;
this.iZ1 = iZ1;

};
function OcTreeNode(pTree) {
this.pTree = pTree;
this.iLevel = 0;
this.iX = 0;
this.iY = 0;
this.iZ = 0;
this.iIndex = 0;
this.pFirstMember = null;
this.pNodeTrueRect = new Rect3d();
this.pForwardNodeLink = null;
this.pRearNodeLink = null;
if ((arguments.length) == 4) {
this.iLevel = arguments[0];
this.iX = arguments[1];
this.iY = arguments[2];
this.iZ = arguments[3];

}


}

;
OcTreeNode.prototype.addOrUpdateMember = function(pMember) {
if ((pMember._pOcTreeNode) != (this)) {
if (pMember._pOcTreeNode) {
pMember._pOcTreeNode.removeMember(pMember);

}

if (!(this.pFirstMember)) {
this.pFirstMember = pMember;

}
else  {
pMember._pRearTreeLink = null;
pMember._pForwardTreeLink = this.pFirstMember;
this.pFirstMember._pRearTreeLink = pMember;
this.pFirstMember = pMember;

}

pMember._pOcTreeNode = this;

}

this.nodeCoords();

};
OcTreeNode.prototype.removeMember = function(pMember) {
if (!((pMember._pOcTreeNode) == (this))) {
var err=((((((("Error:: " + "error removing Oc tree pMember") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Tree.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("error removing Oc tree pMember");

}


}

;
if (pMember._pForwardTreeLink) {
pMember._pForwardTreeLink._pRearTreeLink = pMember._pRearTreeLink;

}

if (pMember._pRearTreeLink) {
pMember._pRearTreeLink._pForwardTreeLink = pMember._pForwardTreeLink;

}

if ((this.pFirstMember) == pMember) {
this.pFirstMember = pMember._pForwardTreeLink;

}

pMember._pRearTreeLink = null;
pMember._pForwardTreeLink = null;
pMember._pOcTreeNode = null;
if (!(this.pFirstMember)) {
pMember._pOcTree.deleteNodeFromTree(this);

}
else  {
this.nodeCoords();

}


};
OcTreeNode.prototype.nodeCoords = function() {
var w=1 << (10 - (this.iLevel));
var pNodeTrueRect=this.pNodeTrueRect;
pNodeTrueRect.fX0 = (this.iX) * w;
pNodeTrueRect.fX1 = ((this.iX) + 1) * w;
pNodeTrueRect.fY0 = (this.iY) * w;
pNodeTrueRect.fY1 = ((this.iY) + 1) * w;
pNodeTrueRect.fZ0 = (this.iZ) * w;
pNodeTrueRect.fZ1 = ((this.iZ) + 1) * w;
pNodeTrueRect.divSelf(this.pTree._v3fWorldScale);
pNodeTrueRect.subSelf(this.pTree._v3fWorldOffset);
var iLimit=(1 << (this.iLevel)) - 1;
var iX=this.iX;
var iY=this.iY;
var iZ=this.iZ;
if ((((((iX == 0) || (iX == iLimit)) || (iY == 0)) || (iY == iLimit)) || (iZ == 0)) || (iZ == iLimit)) {
var pObject=null;
for (pObject = this.pFirstMember; pObject; pObject = pObject._pForwardTreeLink) {
var pWorldRect=pObject.worldBounds();
if (iX == 0) {
pNodeTrueRect.fX0 = Math.min(pNodeTrueRect.fX0, pWorldRect.fX0);

}

if (iX == iLimit) {
pNodeTrueRect.fX1 = Math.max(pNodeTrueRect.fX1, pWorldRect.fX1);

}

if (iY == 0) {
pNodeTrueRect.fY0 = Math.min(pNodeTrueRect.fY0, pWorldRect.fY0);

}

if (iY == iLimit) {
pNodeTrueRect.fY1 = Math.max(pNodeTrueRect.fY1, pWorldRect.fY1);

}

if (iZ == 0) {
pNodeTrueRect.fZ0 = Math.min(pNodeTrueRect.fZ0, pWorldRect.fZ0);

}

if (iZ == iLimit) {
pNodeTrueRect.fZ1 = Math.max(pNodeTrueRect.fZ1, pWorldRect.fZ1);

}


}


}


};
a.OcTree = OcTree;
a.OcTreeNode = OcTreeNode;
a.OcTreeRect = OcTreeRect;
function ShaderProgram(pEngine) {
var _pCtorValue=ShaderProgram.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pEngine = pEngine;
this._sHash = null;
this._pDevice = pEngine.pDevice;
this._pRenderer = pEngine.shaderManager();
this._sFragmentCode = " void main(void){}";
this._sVertexCode = "void main(void){gl_Position = vec4(0., 0., 0., 1.);}";
this._pAttrToReal = null;
this._pATRKeys = null;
this._pAttrToBuffer = null;
this._pATBKeys = null;
this._pSamplersToReal = null;
this._pBuffersToReal = null;
this._pRealAttr = null;
this._pRealSamplers = null;
this._pRealUniformList =  {};
this._pUniformKeys = null;
this._pHardwareProgram = null;
this._pUniformVars = null;
this._pOffsets = null;
this._pBuffers = null;
this._pStreams = null;
this._pTextureSlots = null;
this._nActiveTimes = 0;
this._pPassBlend = null;
this._pTextures = null;
this._isZeroSampler = false;
this._eActiveStream = true;
this._pActiveStreams = null;
this._pUniformApplyFunctions =  {};
this._pUniformPreparedData =  {};
this._pStreamToBufferHandle = null;

}

a.extend(ShaderProgram, a.ResourcePoolItem);
ShaderProgram.prototype.createResource = function() {
if (!(!(this.isResourceCreated()))) {
var err=((((((("Error:: " + "The resource has already been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/ShaderProgram.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has already been created.");

}


}

;
this.notifyCreated();
this.notifyDisabled();
return true;

};
ShaderProgram.prototype.destroyResource = function() {
if (this.isResourceCreated()) {
this._pRenderer._disableShaderProgram(this);
this.disableResource();
this.notifyUnloaded();
this.notifyDestroyed();
return true;

}

return false;

};
ShaderProgram.prototype.disableResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/ShaderProgram.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyDisabled();
return true;

};
ShaderProgram.prototype.restoreResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/ShaderProgram.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyRestored();
return true;

};
ShaderProgram.prototype.loadResource = function() {
return true;

};
ShaderProgram.prototype.saveResource = function() {
return true;

};
ShaderProgram.prototype.create = function(sHash, sVertexCode, sFragmentCode) {
var pHardwareProgram, pDevice=this._pDevice;
this._sHash = sHash;
this._sVertexCode = sVertexCode = sVertexCode || (this._sVertexCode);
this._sFragmentCode = sFragmentCode = sFragmentCode || (this._sFragmentCode);
pHardwareProgram = this._pHardwareProgram = pDevice.createProgram();
var pVertexShader=this._buildShader(35633, sVertexCode);
var pPixelShader=this._buildShader(35632, sFragmentCode);
pDevice.attachShader(pHardwareProgram, pVertexShader);
pDevice.attachShader(pHardwareProgram, pPixelShader);
pDevice.linkProgram(pHardwareProgram);
if (!(pDevice.getProgramParameter(pHardwareProgram, pDevice.VALIDATE_STATUS))) {

}

if (!pDevice.getProgramParameter(pHardwareProgram, pDevice.LINK_STATUS)) {
var err=((((((("Error:: " + "cannot link program") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/ShaderProgram.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
new a.DebugWindow("cannot link program").print(this._programInfoLog(pHardwareProgram, pVertexShader, pPixelShader));

}


}

;
this._isValid = true;
this._pEngine.shaderManager()._registerProgram(this._sHash, this);
return true;

};
ShaderProgram.prototype.setup = function(pAttrData, pUniformData, pTextures) {
var pDevice=this._pDevice;
var pProgram=this._pHardwareProgram;
var pUniforms=this._pRealUniformList;
var pOffsets= {}, pBuffers= {};
var pUniformsKeys=[];
var pSamplers=this._pPassBlend.pSamplers, pGlobalBuffers=this._pPassBlend.pGlobalBuffers;
var i=0, n;
var pKeys;
var sKey1, sOffset, sSampler, sTexture;
var pData, pTexture, pUniformInfo;
var pRealAttr=this._pRealAttr, pAttrReal=this._pAttrToReal, pRealSamplers=this._pRealSamplers, pBufReal=this._pAttrToBuffer;
var pFunctions=this._pUniformApplyFunctions, pPreparedData=this._pUniformPreparedData;
for (i = 0; i < (pRealAttr.length); i++) {
pRealAttr[i] = pDevice.getAttribLocation(pProgram, (a.fx.SHADER_PREFIX.ATTRIBUTE) + i);

}

for (i = 0, n = pDevice.getProgramParameter(pProgram, pDevice.ACTIVE_UNIFORMS); i < n; i++) {
pUniformInfo = pDevice.getActiveUniform(pProgram, i);
pUniformsKeys.push(pUniformInfo.name);

}

for (i = 0; i < (pUniformsKeys.length); i++) {
pUniforms[pUniformsKeys[i]] = pDevice.getUniformLocation(pProgram, pUniformsKeys[i]);

}

for (i = 0; i < (pRealSamplers.length); i++) {
sSampler = (a.fx.SHADER_PREFIX.SAMPLER) + i;
pRealSamplers[i] = pUniforms[sSampler];
pPreparedData[sSampler] = null;
if (this._pPassBlend.pSamplers[sSampler]) {
pFunctions[sSampler] = this.applySampler2D;

}
else  {
pFunctions[sSampler] = this.applyVideoBuffer;

}


}

pKeys = this._pATRKeys;
for (i = 0; i < (pKeys.length); i++) {
sKey1 = pKeys[i];
pData = pAttrData[sKey1];
if ((pAttrReal[sKey1]) !== undefined) {
pAttrReal[sKey1] = pRealAttr[pAttrReal[sKey1]];
if ((pData.eType) === (1)) {
sOffset = (a.fx.SHADER_PREFIX.OFFSET) + sKey1;
if (pUniforms[sOffset]) {
pOffsets[sOffset] = null;
pBuffers[(a.fx.SHADER_PREFIX.SAMPLER) + (this._pAttrToBuffer[sKey1])] = null;
pFunctions[sOffset] = this.applyFloat;
pPreparedData[sOffset] = null;

}


}


}


}

this._pUniformKeys = pUniformsKeys;
this._pStreams = new Array(pRealAttr.length);
this._pStreamToBufferHandle = new Array(pRealAttr.length);
this._pActiveStreams = new Array(pRealAttr.length);
for (i = 0; i < (this._pActiveStreams.length); i++) {
this._pActiveStreams[i] = this._eActiveStream;

}

this._pOffsets = pOffsets;
this._pBuffers = pBuffers;
this._pTextureSlots = new Array(a.info.graphics.maxTextureImageUnits(this._pDevice));
this._pTextureParams = new Array(a.info.graphics.maxTextureImageUnits(this._pDevice));
function fnDefaultTexParametr() {
var obj= {};
obj[10240] = null;
obj[10241] = null;
obj[10242] = null;
obj[10243] = null;
return obj;

}

for (i = 0; i < (this._pTextureParams.length); i++) {
this._pTextureParams[i] = fnDefaultTexParametr();

}

return true;

};
ShaderProgram.prototype.generateInputData = function(pAttrData, pUniformData) {
var pAttrs=new Array(this._pRealAttr.length);
var i;
var pKeys=this._pATRKeys, pAttrReal=this._pAttrToReal;
var sKey, sType, sOffset, sBuf;
var pData, pType;
for (i = 0; i < (pKeys.length); i++) {
sKey = pKeys[i];
pData = pAttrData[sKey];
if (pData !== null) {
if ((pData.eType) !== (1)) {
pAttrs[pAttrReal[sKey]] = pData;
continue ;

}

pAttrs[pAttrReal[sKey]] = pData.pMapper;
sOffset = (a.fx.SHADER_PREFIX.OFFSET) + sKey;
if ((pUniformData[sOffset]) !== undefined) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/ShaderProgram.js") + "][") + "") + "]") + "Something bad with offsets");
continue ;

}

if ((this._pOffsets[sOffset]) === null) {
pUniformData[sOffset] = pData.pData.getVertexDeclaration().element(sKey).iOffset;
sBuf = (a.fx.SHADER_PREFIX.SAMPLER) + (this._pAttrToBuffer[sKey]);
pUniformData[sBuf] = pData.pData.buffer;
this._pBuffersToReal[sBuf] = sBuf;

}


}


}

return pAttrs;

};
ShaderProgram.prototype._buildShader = function(eType, sCode) {
var pDevice=this._pDevice;
var pShader=pDevice.createShader(eType);
pDevice.shaderSource(pShader, sCode);
pDevice.compileShader(pShader);
if (!pDevice.getShaderParameter(pShader, pDevice.COMPILE_STATUS)) {
var err=((((((("Error:: " + "cannot compile shader") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/ShaderProgram.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
new a.DebugWindow("cannot compile shader").print(this._shaderInfoLog(pShader, eType));

}


}

;
return pShader;

};
ShaderProgram.prototype.applyUniform = function(sName, pData) {
if (pData === null) {
return false;

}

if (this._pUniformApplyFunctions[sName]) {
return this._pUniformApplyFunctions[sName].call(this, sName, pData);

}

trace("Something going wrong:", sName, pData);
return false;

};
ShaderProgram.prototype.applyFloat = function(sName, pData) {
if (!(this._pRealUniformList[sName])) {
return false;

}

var pDevice=this._pDevice;
pDevice.uniform1f(this._pRealUniformList[sName], pData);

};
ShaderProgram.prototype.applyInt = function(sName, pData) {
if (!(this._pRealUniformList[sName])) {
return false;

}

var pDevice=this._pDevice;
pDevice.uniform1i(this._pRealUniformList[sName], pData);

};
ShaderProgram.prototype.applyVec2I = function(sName, pData) {
if (!(this._pRealUniformList[sName])) {
return false;

}

pData = ((pData.pData) !== undefined? pData.pData : pData);
var pDevice=this._pDevice;
pDevice.uniform2iv(this._pRealUniformList[sName], pData);

};
ShaderProgram.prototype.applyVec3I = function(sName, pData) {
if (!(this._pRealUniformList[sName])) {
return false;

}

pData = ((pData.pData) !== undefined? pData.pData : pData);
var pDevice=this._pDevice;
pDevice.uniform3iv(this._pRealUniformList[sName], pData);

};
ShaderProgram.prototype.applyVec4I = function(sName, pData) {
if (!(this._pRealUniformList[sName])) {
return false;

}

pData = ((pData.pData) !== undefined? pData.pData : pData);
var pDevice=this._pDevice;
pDevice.uniform4iv(this._pRealUniformList[sName], pData);

};
ShaderProgram.prototype.applyVec2F = function(sName, pData) {
if (!(this._pRealUniformList[sName])) {
return false;

}

pData = ((pData.pData) !== undefined? pData.pData : pData);
var pDevice=this._pDevice;
pDevice.uniform2fv(this._pRealUniformList[sName], pData);

};
ShaderProgram.prototype.applyVec3F = function(sName, pData) {
var time=new Date();
if (!(this._pRealUniformList[sName])) {
return false;

}

pData = ((pData.pData) !== undefined? pData.pData : pData);
var pDevice=this._pDevice;
for (var i=0; i < 2000; i++)pDevice.uniform3fv(this._pRealUniformList[sName], pData);

alert((new Date()) - time);

};
ShaderProgram.prototype.applyVec4F = function(sName, pData) {
if (!(this._pRealUniformList[sName])) {
return false;

}

pData = ((pData.pData) !== undefined? pData.pData : pData);
var pDevice=this._pDevice;
pDevice.uniform4fv(this._pRealUniformList[sName], pData);

};
ShaderProgram.prototype.applyMat2 = function(sName, pData) {
if (!(this._pRealUniformList[sName])) {
return false;

}

pData = ((pData.pData) !== undefined? pData.pData : pData);
var pDevice=this._pDevice;
pDevice.uniformMatrix2fv(this._pRealUniformList[sName], false, pData);

};
ShaderProgram.prototype.applyMat3 = function(sName, pData) {
if (!(this._pRealUniformList[sName])) {
return false;

}

pData = ((pData.pData) !== undefined? pData.pData : pData);
var pDevice=this._pDevice;
pDevice.uniformMatrix3fv(this._pRealUniformList[sName], false, pData);

};
ShaderProgram.prototype.applyMat4 = function(sName, pData) {
if (!(this._pRealUniformList[sName])) {
return false;

}

pData = ((pData.pData) !== undefined? pData.pData : pData);
var pDevice=this._pDevice;
pDevice.uniformMatrix4fv(this._pRealUniformList[sName], false, pData);

};
ShaderProgram.prototype.applyFloatArray = function(sName, pData) {
sName += "[0]";
if (!(this._pRealUniformList[sName])) {
return false;

}

var pDevice=this._pDevice;
pDevice.uniform1iv(this._pRealUniformList[sName], pData);

};
ShaderProgram.prototype.applyIntArray = function(sName, pData) {
sName += "[0]";
if (!(this._pRealUniformList[sName])) {
return false;

}

var pDevice=this._pDevice;
pDevice.uniform1iv(this._pRealUniformList[sName], pData);

};
ShaderProgram.prototype.applyVec2IArray = function(sName, pData) {
var pPreparedData=this._pUniformPreparedData[sName];
sName += "[0]";
if (!(this._pRealUniformList[sName])) {
return false;

}

if ((pData.length) !== (pPreparedData.length)) {
var iSize=2;
var iLength=(pPreparedData.length) / iSize;
if ((((pData.length) !== iLength) || (!(pData[0].pData))) || ((pData[0].pData.length) !== iSize)) {
return false;

}

for (var i=0; i < iLength; i++) {
for (var j=0; j < iSize; j++) {
pPreparedData[(i * iSize) + j] = pData[i].pData[j];

}


}


}
else  {
pPreparedData = pData;

}

var pDevice=this._pDevice;
pDevice.uniform2iv(this._pRealUniformList[sName], pPreparedData);

};
ShaderProgram.prototype.applyVec3IArray = function(sName, pData) {
var pPreparedData=this._pUniformPreparedData[sName];
sName += "[0]";
if (!(this._pRealUniformList[sName])) {
return false;

}

if ((pData.length) !== (pPreparedData.length)) {
var iSize=3;
var iLength=(pPreparedData.length) / iSize;
if ((((pData.length) !== iLength) || (!(pData[0].pData))) || ((pData[0].pData.length) !== iSize)) {
return false;

}

for (var i=0; i < iLength; i++) {
for (var j=0; j < iSize; j++) {
pPreparedData[(i * iSize) + j] = pData[i].pData[j];

}


}


}
else  {
pPreparedData = pData;

}

var pDevice=this._pDevice;
pDevice.uniform3iv(this._pRealUniformList[sName], pPreparedData);

};
ShaderProgram.prototype.applyVec4IArray = function(sName, pData) {
var pPreparedData=this._pUniformPreparedData[sName];
sName += "[0]";
if (!(this._pRealUniformList[sName])) {
return false;

}

if ((pData.length) !== (pPreparedData.length)) {
var iSize=4;
var iLength=(pPreparedData.length) / iSize;
if ((((pData.length) !== iLength) || (!(pData[0].pData))) || ((pData[0].pData.length) !== iSize)) {
return false;

}

for (var i=0; i < iLength; i++) {
for (var j=0; j < iSize; j++) {
pPreparedData[(i * iSize) + j] = pData[i].pData[j];

}


}


}
else  {
pPreparedData = pData;

}

var pDevice=this._pDevice;
pDevice.uniform4iv(this._pRealUniformList[sName], pPreparedData);

};
ShaderProgram.prototype.applyVec2FArray = function(sName, pData) {
var pPreparedData=this._pUniformPreparedData[sName];
sName += "[0]";
if (!(this._pRealUniformList[sName])) {
return false;

}

if ((pData.length) !== (pPreparedData.length)) {
var iSize=2;
var iLength=(pPreparedData.length) / iSize;
if ((((pData.length) !== iLength) || (!(pData[0].pData))) || ((pData[0].pData.length) !== iSize)) {
return false;

}

for (var i=0; i < iLength; i++) {
for (var j=0; j < iSize; j++) {
pPreparedData[(i * iSize) + j] = pData[i].pData[j];

}


}


}
else  {
pPreparedData = pData;

}

var pDevice=this._pDevice;
pDevice.uniform2fv(this._pRealUniformList[sName], pPreparedData);

};
ShaderProgram.prototype.applyVec3FArray = function(sName, pData) {
var pPreparedData=this._pUniformPreparedData[sName];
sName += "[0]";
if (!(this._pRealUniformList[sName])) {
return false;

}

if ((pData.length) !== (pPreparedData.length)) {
var iSize=3;
var iLength=(pPreparedData.length) / iSize;
if ((((pData.length) !== iLength) || (!(pData[0].pData))) || ((pData[0].pData.length) !== iSize)) {
return false;

}

for (var i=0; i < iLength; i++) {
for (var j=0; j < iSize; j++) {
pPreparedData[(i * iSize) + j] = pData[i].pData[j];

}


}


}
else  {
pPreparedData = pData;

}

var pDevice=this._pDevice;
pDevice.uniform3fv(this._pRealUniformList[sName], pPreparedData);

};
ShaderProgram.prototype.applyVec4FArray = function(sName, pData) {
var pPreparedData=this._pUniformPreparedData[sName];
sName += "[0]";
if (!(this._pRealUniformList[sName])) {
return false;

}

if ((pData.length) !== (pPreparedData.length)) {
var iSize=4;
var iLength=(pPreparedData.length) / iSize;
if ((((pData.length) !== iLength) || (!(pData[0].pData))) || ((pData[0].pData.length) !== iSize)) {
return false;

}

for (var i=0; i < iLength; i++) {
for (var j=0; j < iSize; j++) {
pPreparedData[(i * iSize) + j] = pData[i].pData[j];

}


}


}
else  {
pPreparedData = pData;

}

var pDevice=this._pDevice;
pDevice.uniform4fv(this._pRealUniformList[sName], pPreparedData);

};
ShaderProgram.prototype.applyMat2Array = function(sName, pData) {
var pPreparedData=this._pUniformPreparedData[sName];
sName += "[0]";
if (!(this._pRealUniformList[sName])) {
return false;

}

if ((pData.length) !== (pPreparedData.length)) {
var iSize=4;
var iLength=(pPreparedData.length) / iSize;
if ((((pData.length) !== iLength) || (!(pData[0].pData))) || ((pData[0].pData.length) !== iSize)) {
return false;

}

for (var i=0; i < iLength; i++) {
for (var j=0; j < iSize; j++) {
pPreparedData[(i * iSize) + j] = pData[i].pData[j];

}


}


}
else  {
pPreparedData = pData;

}

var pDevice=this._pDevice;
pDevice.uniformMatrix2fv(this._pRealUniformList[sName], false, pPreparedData);

};
ShaderProgram.prototype.applyMat3Array = function(sName, pData) {
var pPreparedData=this._pUniformPreparedData[sName];
sName += "[0]";
if (!(this._pRealUniformList[sName])) {
return false;

}

if ((pData.length) !== (pPreparedData.length)) {
var iSize=9;
var iLength=(pPreparedData.length) / iSize;
if ((((pData.length) !== iLength) || (!(pData[0].pData))) || ((pData[0].pData.length) !== iSize)) {
return false;

}

for (var i=0; i < iLength; i++) {
for (var j=0; j < iSize; j++) {
pPreparedData[(i * iSize) + j] = pData[i].pData[j];

}


}


}
else  {
pPreparedData = pData;

}

var pDevice=this._pDevice;
pDevice.uniformMatrix3fv(this._pRealUniformList[sName], false, pPreparedData);

};
ShaderProgram.prototype.applyMat4Array = function(sName, pData) {
var pPreparedData=this._pUniformPreparedData[sName];
sName += "[0]";
if (!(this._pRealUniformList[sName])) {
return false;

}

if ((pData.length) !== (pPreparedData.length)) {
var iSize=16;
var iLength=(pPreparedData.length) / iSize;
if ((((pData.length) !== iLength) || (!(pData[0].pData))) || ((pData[0].pData.length) !== iSize)) {
return false;

}

for (var i=0; i < iLength; i++) {
for (var j=0; j < iSize; j++) {
pPreparedData[(i * iSize) + j] = pData[i].pData[j];

}


}


}
else  {
pPreparedData = pData;

}

var pDevice=this._pDevice;
pDevice.uniformMatrix4fv(this._pRealUniformList[sName], false, pPreparedData);

};
ShaderProgram.prototype.applySampler2D = function(sName, pData) {
var sTexture, pTexture;
if (!pData) {
return true;

}

var sRealName=this._pSamplersToReal[sName];
var pSlots;
var i;
var pTextureParam;
if (sRealName === null) {
return true;

}

if ((typeof sRealName) === "object") {
pSlots = sRealName;
sRealName = sName;
for (i = 0; i < (pSlots.length); i++) {
sTexture = pData[i][a.fx.GLOBAL_VARS.TEXTURE];
pTexture = (this._pTextures? this._pTextures[sTexture] : null);
if (!pTexture) {
pSlots[i] = a.fx.ZEROSAMPLER;

}
else  {
pSlots[i] = this._pRenderer.activateTexture(pTexture);
pTextureParam = this._pTextureParams[pSlots[i]];
trace("Slot #" + (pSlots[i]));
pTextureParam[10240] = ((pData[i][10240]) || (pTexture._getParameter(10240))) || (9729);
pTextureParam[10241] = ((pData[i][10241]) || (pTexture._getParameter(10241))) || (9729);
pTextureParam[10242] = ((pData[i][10242]) || (pTexture._getParameter(10242))) || (10497);
pTextureParam[10243] = ((pData[i][10243]) || (pTexture._getParameter(10243))) || (10497);

}


}

return this.applyIntArray(sRealName, pSlots);

}

if ((pData.length) >= 0) {
sTexture = pData[0][a.fx.GLOBAL_VARS.TEXTURE];

}
else  {
sTexture = pData[a.fx.GLOBAL_VARS.TEXTURE];

}

pTexture = (this._pTextures? this._pTextures[sTexture] : null);
if (!pTexture) {
return true;

}

var iSlot=this._pRenderer.activateTexture(pTexture);
pTextureParam = this._pTextureParams[iSlot];
trace("Slot #" + iSlot);
pTextureParam[10240] = ((pData[10240]) || (pTexture._getParameter(10240))) || (9729);
pTextureParam[10241] = ((pData[10241]) || (pTexture._getParameter(10241))) || (9729);
pTextureParam[10242] = ((pData[10242]) || (pTexture._getParameter(10242))) || (10497);
pTextureParam[10243] = ((pData[10243]) || (pTexture._getParameter(10243))) || (10497);
return this.applyInt(sRealName, iSlot);

};
ShaderProgram.prototype.applyVideoBuffer = function(sName, pData) {
var sRealName=this._pBuffersToReal[sName];
if (sRealName === null) {
return true;

}

var iSlot=this._pRenderer.activateTexture(pData);
var pTextureParam=this._pTextureParams[iSlot];
pTextureParam[10240] = (pData._getParameter(10240)) || (9729);
pTextureParam[10241] = (pData._getParameter(10241)) || (9729);
pTextureParam[10242] = (pData._getParameter(10242)) || (10497);
pTextureParam[10243] = (pData._getParameter(10243)) || (10497);
return this.applyInt(sRealName, iSlot);

};
ShaderProgram.prototype.applyData = function(pData, iSlot) {
if (!pData) {
return false;

}

if ((this._eActiveStream[iSlot]) === (this._eActiveStream)) {
return true;

}

var pVertexData;
var isMapper=false;
if (pData.pData) {
pVertexData = pData.pData;
isMapper = true;

}
else  {
pVertexData = pData;

}

var pDevice=this._pDevice;
var iStride=pVertexData.getStride();
var pManager=this._pRenderer;
var pAttrs=this._pAttrToReal, iStream, pDecl;
var pVertexElement;
var pVertexBuffer=pVertexData.buffer;
var iState=pManager.getRenderResourceState(pVertexBuffer);
var iBufferHandle=this._pStreamToBufferHandle[iSlot];
var iStreamState=this.toNumber();
var isActivate=false;
var isChange=false;
pDecl = pVertexData.getVertexDeclaration();
if (isMapper) {
if (iBufferHandle !== (pVertexBuffer.toNumber())) {
isChange = true;

}
else if (iStreamState !== (pManager._getStreamState(iSlot))) {
isChange = true;

}
else if ((this._pStreams[iSlot]) !== iState) {
isChange = true;

}



if (!isChange) {
return true;

}

this._pStreams[iSlot] = iState;
this._pStreamToBufferHandle[iSlot] = pVertexBuffer.toNumber();
pManager._occupyStream(iSlot, this);
pManager.activateVertexBuffer(pVertexBuffer, true);
pVertexElement = pDecl.element(pData.eSemantics);
pDevice.vertexAttribPointer(iSlot, pVertexElement.nCount, pVertexElement.eType, false, iStride, pVertexElement.iOffset);
this._pActiveStreams[iSlot] = this._eActiveStream;
return true;

}

for (var i=0; i < (pDecl.length); i++) {
pVertexElement = pDecl[i];
iStream = pAttrs[pVertexElement.eUsage];
if (iStreamState !== (pManager._getStreamState(iSlot))) {
isChange = true;

}
else if ((this._pStreams[iStream]) !== iState) {
isChange = true;

}


if (!isChange) {
return true;

}

this._pStreams[iStream] = iState;
pManager._occupyStream(iStream, this);
if (!isActivate) {
pManager.activateVertexBuffer(pVertexBuffer, true);
isActivate = true;

}

pDevice.vertexAttribPointer(iStream, pVertexElement.nCount, pVertexElement.eType, false, iStride, pVertexElement.iOffset);
this._pActiveStreams[iStream] = this._eActiveStream;

}

return true;

};
ShaderProgram.prototype.setCurrentTextureSet = function(pTextures) {
this._pTextures = pTextures;

};
ShaderProgram.prototype.setAttrParams = function(pAttrToReal, pAttrToBuffer, pSamplersToReal, pBuffersToReal, nAttr, nRealSamplers) {
this._pAttrToReal = pAttrToReal;
this._pAttrToBuffer = pAttrToBuffer;
this._pBuffersToReal = pBuffersToReal;
this._pSamplersToReal = pSamplersToReal;
this._pATRKeys = Object.keys(pAttrToReal);
this._pATBKeys = Object.keys(pAttrToBuffer);
this._pRealAttr = new Array(nAttr);
this._pRealSamplers = new Array(nRealSamplers);

};
ShaderProgram.prototype.setUniformVars = function(pUniforms, isZeroSampler) {
this._pUniformVars = pUniforms;
this._isZeroSampler = isZeroSampler || false;
var i;
var sType;
var isArray;
var pVar;
var pPreparedData=this._pUniformPreparedData;
var pFunctions=this._pUniformApplyFunctions;
for (i in pUniforms) {
pVar = pUniforms[i];
if (!pVar) {
continue ;

}

sType = pVar.pType.pEffectType.toCode();
isArray = pVar.isArray;
pPreparedData[i] = this._preparedUniformData(pVar);
switch(sType) {
case "float":
if (isArray) {
pFunctions[i] = this.applyFloatArray;

}
else  {
pFunctions[i] = this.applyFloat;

}

break ;

case "int":
if (isArray) {
pFunctions[i] = this.applyIntArray;

}
else  {
pFunctions[i] = this.applyInt;

}

break ;

case "vec2":
if (isArray) {
pFunctions[i] = this.applyVec2FArray;

}
else  {
pFunctions[i] = this.applyVec2F;

}

break ;

case "vec3":
if (isArray) {
pFunctions[i] = this.applyVec3FArray;

}
else  {
pFunctions[i] = this.applyVec3F;

}

break ;

case "vec4":
if (isArray) {
pFunctions[i] = this.applyVec4FArray;

}
else  {
pFunctions[i] = this.applyVec4F;

}

break ;

case "ivec2":
if (isArray) {
pFunctions[i] = this.applyVec2IArray;

}
else  {
pFunctions[i] = this.applyVec2I;

}

break ;

case "ivec3":
if (isArray) {
pFunctions[i] = this.applyVec3IArray;

}
else  {
pFunctions[i] = this.applyVec3I;

}

break ;

case "ivec4":
if (isArray) {
pFunctions[i] = this.applyVec4IArray;

}
else  {
pFunctions[i] = this.applyVec4I;

}

break ;

case "mat2":
if (isArray) {
pFunctions[i] = this.applyMat2Array;

}
else  {
pFunctions[i] = this.applyMat2;

}

break ;

case "mat3":
if (isArray) {
pFunctions[i] = this.applyMat3Array;

}
else  {
pFunctions[i] = this.applyMat3;

}

break ;

case "mat4":
if (isArray) {
pFunctions[i] = this.applyMat4Array;

}
else  {
pFunctions[i] = this.applyMat4;

}

break ;

case "sampler2D":
;

case "samplerCube":
if (this._pPassBlend.pSamplers[i]) {
pFunctions[i] = this.applySampler2D;

}
else  {
pFunctions[i] = this.applyVideoBuffer;

}

break ;

default:
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/ShaderProgram.js") + "][") + "") + "]") + "Another base types are not support yet");
}

}


};
ShaderProgram.prototype.setTextureSlot = function(iSlot, pTexture) {
this._pTextureSlots[iSlot] = this._nActiveTimes;

};
ShaderProgram.prototype._preparedUniformData = function(pVar) {
var pData;
var sType;
if ((!(pVar.isArray)) && ((pVar.iSize) === 1)) {
return null;

}

sType = pVar.pType.pEffectType.toCode();
var isFloat=true;
if (((((((sType === "float") || (sType === "vec2")) || (sType === "vec3")) || (sType === "vec4")) || (sType === "mat2")) || (sType === "mat3")) || (sType === "mat4")) {
isFloat = true;

}
else  {
isFloat = false;

}

if (isFloat) {
pData = new Float32Array(pVar.iSize);

}
else  {
pData = new Int32Array(pVar.iSize);

}

return pData;

};
ShaderProgram.prototype.getSourceCode = function(eType) {
return (eType === (35633)? this._sVertexCode : this._sFragmentCode);

};
ShaderProgram.prototype.getEmptyTextureSlot = function() {
var i;
var pSlots=this._pTextureSlots;
for (i = 0; i < (pSlots.length); i++) {
if ((pSlots[i]) !== (this._nActiveTimes)) {
return i;

}


}


};
ShaderProgram.prototype.getStreamData = function(iStream) {
return this._pStreams[iStream];

};
ShaderProgram.prototype.getStreamNumber = function() {
return this._pRealAttr.length;

};
ShaderProgram.prototype.activate = function() {
this._nActiveTimes++;
this._pDevice.useProgram(this._pHardwareProgram);
if (this._isZeroSampler) {
this.applyInt(PassBlend.sZeroSampler, a.fx.ZEROSAMPLER);

}


};
ShaderProgram.prototype.deactivate = function() {
this._pDevice.useProgram(null);

};
ShaderProgram.prototype.isActive = function() {
return (this._pDevice.getParameter(this._pDevice.CURRENT_PROGRAM)) === (this._pHardwareProgram);

};
ShaderProgram.prototype.activateTextures = function() {
var i=0;
var iCheck=this._nActiveTimes;
for (i = 0; i < (this._pTextureSlots.length); i++) {
if ((this._pTextureSlots[i]) === iCheck) {
trace("Activate texture slot #" + i);
this._pRenderer._activateTextureSlot(i, this._pTextureParams[i]);

}


}


};
ShaderProgram.prototype.resetActivationStreams = function() {
this._eActiveStream = !(this._eActiveStream);

};
ShaderProgram.prototype._programInfoLog = function(pHardwareProgram, pVertexShader, pPixelShader) {
var pShaderDebugger=this._pEngine.getDevice().getExtension("WEBGL_debug_shaders");
if (pShaderDebugger) {
trace("translated vertex shader =========>");
trace(pShaderDebugger.getTranslatedShaderSource(pVertexShader));
trace("translated pixel shader =========>");
trace(pShaderDebugger.getTranslatedShaderSource(pPixelShader));

}

return (((((((("<pre style=\"background-color: #FFCACA;\">" + (this._pDevice.getProgramInfoLog(this._pHardwareProgram))) + "</pre>") + "<hr />") + "<pre>") + (this.getSourceCode(35633))) + "</pre><hr />") + "<pre>") + (this.getSourceCode(35632))) + "</pre>";

};
ShaderProgram.prototype._shaderInfoLog = function(pShader, eType) {
var sCode=this.getSourceCode(eType), sLog;
var tmp=sCode.split("\n");
sCode = "";
for (var i=0; i < (tmp.length); i++) {
sCode += (((i + 1) + "| ") + (tmp[i])) + "\n";

}

sLog = this._pDevice.getShaderInfoLog(pShader);
return (((((("<div style=\"background: #FCC\">" + "<pre>") + sLog) + "</pre>") + "</div>") + "<pre style=\"background-color: #EEE;\">") + sCode) + "</pre>";

};
a["ShaderProgram"] = ShaderProgram;
var GLOBAL_VARS= {VARIABLEDECL: "VariableDecl", TYPEDECL: "TypeDecl", VARSTRUCTDECL: "VarStructDecl", FUNCTIONDECL: "FunctionDecl", TECHIQUEDECL: "TechniqueDecl", USAGES: "Usages", SEMANTIC: "Semantic", ANNOTATION: "Annotation", INITIALIZER: "Initializer", CONST: "const", ROW_MAJOR: "row_major", COLUMN_MAJOR: "column_major", UNIFORM: "uniform", STATIC: "static", SHARED: "shared", EXTERN: "extern", INLINE: "inline", TYPE: "Type", VARIABLE: "Variable", T_KW_STATIC: "static", T_KW_UNIFORM: "uniform", T_KW_EXTERN: "extern", T_KW_VOLATILE: "volatile", T_KW_FOREIGN: "foreign", T_KW_INLINE: "inline", T_KW_SHARED: "shared", T_KW_CONST: "const", T_KW_ROW_MAJOR: "row_major", T_KW_COLUMN_MAJOR: "column_major", T_KW_TYPEDEF: "typedef", T_KW_STRUCT: "struct", T_KW_VOID: "void", T_KW_BOOL: "bool", T_KW_INT: "int", T_KW_HALF: "half", T_KW_FLOAT: "float", T_KW_DOUBLE: "double", T_KW_VECTOR: "vector", T_KW_MATRIX: "matrix", T_KW_STRING: "string", T_KW_TEXTURE: "texture", T_KW_TEXTURE1D: "texture1D", T_KW_TEXTURE2D: "texture2D", T_KW_TEXTURE3D: "texture3D", T_KW_TEXTURECUBE: "texturecube", T_KW_SAMPLER: "sampler", T_KW_SAMPLER1D: "sampler1D", T_KW_SAMPLER2D: "sampler2D", T_KW_SAMPLER3D: "sampler3D", T_KW_SAMPLERCUBE: "samplercube", T_KW_PIXELSHADER: "pixelshader", T_KW_VERTEXSHADER: "vertexshader", T_KW_PIXELFRAGMENT: "pixelfragment", T_KW_VERTEXFRAGMENT: "vertexfragment", T_KW_STATEBLOCK: "stateblock", T_KW_STATEBLOCK_STATE: "stateblock_state", T_KW_COMPILE_FRAGMENT: "compile_fragment", T_KW_REGISTER: "register", T_KW_COMPILE: "compile", T_KW_SAMPLER_STATE: "sampler_state", T_NON_TYPE_ID: "T_NON_TYPE_ID", T_TYPE_ID: "T_TYPE_ID", T_STRING: "T_STRING", T_FLOAT: "T_FLOAT", T_UINT: "T_UINT", T_KW_TRUE: "T_KW_TRUE", T_KW_FALSE: "T_KW_FALSE", PROGRAM: "Program", DECLS: "Decls", DECL: "Decl", USEDECL: "UseDecl", USAGE: "Usage", CONSTUSAGES: "ConstUsages", CONSTUSAGE: "ConstUsage", USAGETYPE: "UsageType", USAGESTRUCTDECL: "UsageStructDecl", TYPEDEFS: "TypeDefs", CONSTTYPE: "ConstType", CONSTTYPEDIM: "ConstTypeDim", BASETYPE: "BaseType", SCALARTYPE: "ScalarType", VECTORTYPE: "VectorType", MATRIXTYPE: "MatrixType", OBJECTTYPE: "ObjectType", STRUCT: "Struct", STRUCTDECL: "StructDecl", CONSTSTRUCTDECL: "ConstStructDecl", STRUCTBEGIN: "StructBegin", STRUCTDECLS: "StructDecls", STRUCTEND: "StructEnd", SEMANTICS: "Semantics", SEMANTICSOPT: "SemanticsOpt", REGISTER: "Register", ANNOTATIONOPT: "AnnotationOpt", ANNOTATIONBEGIN: "AnnotationBegin", ANNOTATIONDECLS: "AnnotationDecls", ANNOTATIONEND: "AnnotationEnd", INITIALIZEROPT: "InitializerOpt", VARIABLES: "Variables", VARIABLEDIM: "VariableDim", FUNCTIONDEF: "FunctionDef", PARAMLIST: "ParamList", PARAMLISTBEGIN: "ParamListBegin", PARAMLISTEND: "ParamListEnd", PARAMETERDECLS: "ParameterDecls", PARAMETERDECL: "ParameterDecl", PARAMUSAGETYPE: "ParamUsageType", PARAMUSAGES: "ParamUsages", PARAMUSAGE: "ParamUsage", TECHNIQUEDECL: "TechniqueDecl", TECHNIQUEBODY: "TechniqueBody", TECHNIQUEBEGIN: "TechniqueBegin", TECHNIQUEEND: "TechniqueEnd", PASSDECLS: "PassDecls", PASSDECL: "PassDecl", STATEBLOCK: "StateBlock", STATEBLOCKBEGIN: "StateBlockBegin", STATEBLOCKEND: "StateBlockEnd", STATES: "States", STATE: "State", STATEINDEX: "StateIndex", STATEEXPRBEGIN: "StateExprBegin", STATEEXPREND: "StateExprEnd", STMTBLOCK: "StmtBlock", STMTBLOCKBEGIN: "StmtBlockBegin", STMTBLOCKEND: "StmtBlockEnd", STMTS: "Stmts", SIMPLESTMT: "SimpleStmt", NONIFSTMT: "NonIfStmt", STMT: "Stmt", FOR: "For", FORINIT: "ForInit", FORCOND: "ForCond", FORSTEP: "ForStep", DWORDEXPR: "DwordExpr", STATEEXPR: "StateExpr", SIMPLEEXPR: "SimpleExpr", COMPLEXEXPR: "ComplexExpr", OBJECTEXPR: "ObjectExpr", PRIMARYEXPR: "PrimaryExpr", POSTFIXEXPR: "PostfixExpr", UNARYEXPR: "UnaryExpr", CASTEXPR: "CastExpr", MULEXPR: "MulExpr", ADDEXPR: "AddExpr", RELATIONALEXPR: "RelationalExpr", EQUALITYEXPR: "EqualityExpr", ANDEXPR: "AndExpr", OREXPR: "OrExpr", CONDITIONALEXPR: "ConditionalExpr", ASSIGNMENTEXPR: "AssignmentExpr", ARGUMENTS: "Arguments", ARGUMENTSOPT: "ArgumentsOpt", INITEXPR: "InitExpr", INITEXPRS: "InitExprs", CONSTANTEXPR: "ConstantExpr", EXPR: "Expr", DWORD: "Dword", DWORDID: "DwordId", ID: "Id", IDOPT: "IdOpt", TARGET: "Target", UINT: "Uint", FLOAT: "Float", STRINGS: "Strings", STRING: "String", TYPEID: "TypeId", NONTYPEID: "NonTypeId", T_KW_FOR: "for", T_KW_RETURN: "return", T_KW_DO: "do", T_KW_DISCARD: "discard", T_KW_WHILE: "while", T_KW_IF: "if", T_KW_ELSE: "else", T_KW_BREAK: "break", FROMEXPR: "FromExpr", MEMEXPR: "MemExpr", T_KW_USE: "use", T_KW_STRICT: "strict", IMPORTDECL: "ImportDecl", PROVIDEDECL: "ProvideDecl", STATEIF: "StateIf", STATESWITCH: "StateSwitch", CASESTATE: "CaseState", DEFAULTSTATE: "DefaultState", PASSSTATE: "PassState", SYSTEMVAR: "engine", UNDEFINEDTYPE: 7, GLOBAL: 0, VERTEXUSAGE: 1, FRAGMENTUSAGE: 2, STRUCTUSAGE: 3, LOCALUSAGE: 4, PARAMETRUSAGE: 5, VERTEXUSAGEPARAM: 6, GLOBALUSAGE: 7, NOTUSAGE: -1, ERRORBADFUNCTION: 147, SHADEROUT: "Out", SHADERPREFIX: "shader_main_", VERTEXPREFIX: "vertex_main_", FRAGMENTPREFIX: "fragment_main_", TEXTURE: "TEXTURE", PREFIX: 10, INARRAY: 1, INOBJECT: 2, EXTERNAL_V: 1, EXTERNAL_F: 2};
a["fx"]["GLOBAL_VARS"] = GLOBAL_VARS;
var SEMANTIC_BLACKLIST= {"A_b_0": null, "A_b_1": null, "A_b_2": null, "A_b_3": null, "A_b_4": null, "A_b_5": null, "A_b_6": null, "A_b_7": null, "A_b_8": null, "A_b_9": null, "A_b_10": null, "A_b_11": null, "A_b_12": null, "A_b_13": null, "A_b_14": null, "A_b_15": null, "A_b_16": null, "A_h_0": null, "A_h_1": null, "A_h_2": null, "A_h_3": null, "A_h_4": null, "A_h_5": null, "A_h_6": null, "A_h_7": null, "A_h_8": null, "A_h_9": null, "A_h_10": null, "A_h_11": null, "A_h_12": null, "A_h_13": null, "A_h_14": null, "A_h_15": null, "A_h_16": null};
a["fx"]["SEMANTIC_BLACKLIST"] = SEMANTIC_BLACKLIST;
var NAME_BLACKLIST= {"A_b_": null, "A_h_": null};
a["fx"]["NAME_BLACKLIST"] = NAME_BLACKLIST;
function fnSimpleExtractCode(pCode, sCode, eMode) {
var i;
var pSubCode;
for (i = 0; i < (pCode.length); i++) {
if ((typeof (pCode[i])) === "string") {
sCode += pCode[i];

}
else  {
pSubCode = pCode[i].toCode(eMode);
if ((typeof pSubCode) === "string") {
sCode += pSubCode;

}
else  {
sCode += a.fx.fnSimpleExtractCode(pSubCode, sCode, eMode);

}


}


}

return sCode;

}

a["fx"]["fnSimpleExtractCode"] = fnSimpleExtractCode;
function GLSLExpr(sTemplate) {
this.pArgs =  {};
this.pExpr = [];
var pObj=sTemplate.split(/(\$\d+)/);
for (var i=0; i < (pObj.length); i++) {
if (pObj[i]) {
if ((pObj[i][0]) !== "$") {
this.pExpr.push(pObj[i]);

}
else  {
this.pExpr.push(null);
this.pArgs[(this.pExpr.length) - 1] = (pObj[i].substr(1)) - 1;

}


}


}


}

GLSLExpr.prototype.toGLSL = function(pArguments) {
var i=0, j;
var pExpr=this.pExpr;
var pArgs=this.pArgs;
var pRes=[];
for (i = 0; i < (pExpr.length); i++) {
if ((pExpr[i]) === null) {
if ((pArgs[i]) === undefined) {
if (!0) {
var err=((((((("Error:: " + "Bad translate expr") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Bad translate expr");

}


}

;
return ;

}

if (!(pArguments[pArgs[i]])) {
console.log(this, pArguments, pArguments[pArgs[i]], pArguments[1], pArgs[i], i);
if (!0) {
var err=((((((("Error:: " + "bad translation pArguments") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad translation pArguments");

}


}

;
return ;

}

pRes.push("(");
for (j = 0; j < (pArguments[pArgs[i]].length); j++) {
pRes.push(pArguments[pArgs[i]][j]);

}

pRes.push(")");

}
else  {
pRes.push(pExpr[i]);

}


}

return pRes;

};
function VariableType() {
this.pEffectType = null;
this._isBase = false;
this.sSemantic = null;
this.pUsages = null;
this.pUsagesName = null;
this.isMixible = false;
this.isVSInput = false;
this.isFSInput = false;
this._sCode = null;

}

VariableType.prototype.setUsage = function(sValue) {
if (!(this.pUsages)) {
this.pUsages = [];

}

if (!(this.pUsagesName)) {
this.pUsagesName =  {};

}

this.pUsages.push(sValue);
if ((this.pUsagesName[sValue]) === null) {
if (!0) {
var err=((((((("Error:: " + "same usage 2 times") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("same usage 2 times");

}


}

;
return ;

}

this.pUsagesName[sValue] = null;

};
VariableType.prototype.setType = function(pType) {
if (pType instanceof VariableType) {
this.pEffectType = pType.pEffectType;
this._isBase = pType._isBase;
this.sSemantic = pType.sSemantic;
this.pUsages = pType.pUsages;

}
else  {
this.pEffectType = pType;
if (pType.isBase()) {
this._isBase = true;

}


}


};
VariableType.prototype.toCode = function() {
if (this._sCode) {
return this._sCode;

}

var i;
this._sCode = "";
if (this.pUsages) {
for (i = 0; i < (this.pUsages.length); i++) {
if ((this.pUsages[i]) !== "global") {
this._sCode += (this.pUsages[i]) + " ";

}


}


}

this._sCode += this.pEffectType.toCodeString();
return this._sCode;

};
VariableType.prototype.isStruct = function() {
if ((this.pEffectType) && (this.pEffectType.isStruct)) {
return true;

}

return false;

};
VariableType.prototype.isBase = function() {
return this._isBase;

};
VariableType.prototype.isVoid = function() {
if ((this.pEffectType.sName) === "void") {
return true;

}

return false;

};
VariableType.prototype.checkMe = function() {
var i;
for (i = 0; i < (arguments.length); i++) {
switch(arguments[i]) {
case a.fx.GLOBAL_VARS.NOTUSAGE:
break ;

case a.fx.GLOBAL_VARS.VERTEXUSAGE:
if ((this.isStruct()) && (this.pEffectType.checkMe(a.fx.GLOBAL_VARS.VERTEXUSAGE))) {
continue ;

}

if ((this.isBase()) && ((this.sSemantic) === "POSITION")) {
continue ;

}

if (this.isVoid()) {
continue ;

}

return false;

case a.fx.GLOBAL_VARS.FRAGMENTUSAGE:
if ((this.isStruct()) && (this.pEffectType.checkMe(a.fx.GLOBAL_VARS.FRAGMENTUSAGE))) {
continue ;

}

if ((this.isBase()) && ((this.sSemantic) === "COLOR")) {
continue ;

}

if (this.isVoid()) {
continue ;

}

return false;

case a.fx.GLOBAL_VARS.STRUCTUSAGE:
if (this.pUsages) {
return false;

}

break ;

case a.fx.GLOBAL_VARS.VERTEXUSAGEPARAM:
if (!(this.pEffectType.checkMe(a.fx.GLOBAL_VARS.VERTEXUSAGEPARAM))) {
return false;

}

break ;

case a.fx.GLOBAL_VARS.PARAMETRUSAGE:
break ;

case a.fx.GLOBAL_VARS.LOCALUSAGE:
if (((this.pUsagesName["uniform"]) === null) || ((this.pUsagesName["global"]) === null)) {
return false;

}

break ;

case a.fx.GLOBAL_VARS.GLOBALUSAGE:
break ;

default:
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "][") + "") + "]") + "Unknown usage for check");
break ;
}

}

return true;

};
VariableType.prototype.isStrictEqual = function(pType) {
if (pType instanceof VariableType) {
return this.pEffectType.isStrictEqual(pType.pEffectType);

}

return this.pEffectType.isStrictEqual(pType);

};
VariableType.prototype.isEqual = function(pType) {
if (pType instanceof VariableType) {
return this.pEffectType.isEqual(pType.pEffectType);

}

return this.pEffectType.isEqual(pType);

};
VariableType.prototype.isType = function(pEffectType) {
if ((this.pEffectType) === pEffectType) {
return true;

}

return false;

};
VariableType.prototype.cloneMe = function() {
var pType=new VariableType();
pType.pEffectType = this.pEffectType;
pType._isBase = this._isBase;
pType.sSemantic = this.sSemantic;
pType.pUsages = this.pUsages;
pType.isVSInput = this.isVSInput;
return pType;

};
VariableType.prototype.toStr = function() {
var sRes="";
var i;
for (i = 0; (this.pUsages) && (i < (this.pUsages.length)); i++) {
sRes += (this.pUsages[i]) + ":";

}

sRes += this.pEffectType.sName;
return sRes;

};
VariableType.prototype.isSampler = function() {
return this.pEffectType.isSampler();

};
VariableType.prototype.isConst = function() {
if ((this.pUsagesName) && ((this.pUsagesName["const"]) === null)) {
return true;

}

return false;

};
VariableType.prototype.setMixible = function() {
if ((!(this.pEffectType)) || (this.isMixible)) {
return ;

}

this.isMixible = true;
this.pEffectType.setMixible();

};
VariableType.prototype.setVSInput = function() {
this.isVSInput = true;
this.pEffectType.setVSInput();

};
VariableType.prototype.setFSInput = function() {
this.isFSInput = true;
this.pEffectType.setFSInput();

};
VariableType.prototype.hasIndexData = function() {
if (!(this.isBase())) {
return this.pEffectType.hasIndexData();

}

return false;

};
VariableType.prototype.canMixible = function() {
return this.pEffectType.canMixible();

};
VariableType.prototype.canBlend = function(pType, isStrict) {
if ((!(this.canMixible())) || (!(pType.canMixible()))) {
return 0;

}

if ((this.isBase()) !== (pType.isBase())) {
return 0;

}

if ((this.isBase()) && (this.isEqual(pType))) {
return 1;

}

return this.pEffectType.canBlend(pType.pEffectType, isStrict);

};
function EffectType(sName, sRealName, isBase, iSize) {
this.sName = sName || null;
this.sRealName = sRealName || null;
this.pDesc = null;
this.isStruct = false;
this.isAnalyzed = isBase || false;
this._isBase = isBase || false;
this.iSize = iSize || 0;
this.isMixible = false;
this.isVSInput = false;
this.isFSInput = false;
this._sCode = null;
this._sHash = (isBase? sName : null);
this._sStrongHash = (isBase? sName : null);
this._canMixible = (isBase? true : false);
this.iScope = -1;
this.nOrder = 0;

}

EffectType.prototype.hash = function() {
if (!(this._sHash)) {
this.calcHash();

}

return this._sHash;

};
EffectType.prototype.strongHash = function() {
if (!(this._sStrongHash)) {
this.calcHash();

}

return this._sStrongHash;

};
EffectType.prototype.calcHash = function() {
if (this._isBase) {
this._sHash = this.sRealName;
this._sStrongHash = this.sRealName;
return ;

}

var sHash="{";
var sStrongHash="{";
var i, j;
var pField;
var pType;
for (i = 0; i < (this.pDesc.pOrders.length); i++) {
pField = this.pDesc.pOrders[i];
pType = pField.pType;
for (j = 0; (pType.pUsages) && (j < (pType.pUsages.length)); j++) {
sHash += (pType.pUsages[j]) + "|";
sStrongHash += (pType.pUsages[j]) + "|";

}

sHash += pType.pEffectType.hash();
sStrongHash += pType.pEffectType.strongHash();
if (pField.isArray) {
sHash += ":" + (pField.iLength);
sStrongHash += ":" + (pField.iLength);

}

if (pField.isPointer) {
sStrongHash += "@" + (pField.nDim);

}

sHash += ";";
sStrongHash += ";";

}

sHash += "}";
sStrongHash += "}";
this._sHash = sHash;
this._sStrongHash = sStrongHash;

};
EffectType.prototype.isEqual = function(pType) {
if (pType instanceof VariableType) {
return (this.hash()) === (pType.pEffectType.hash());

}

return (this.hash()) === (pType.hash());

};
EffectType.prototype.isStrictEqual = function(pType) {
if (pType instanceof VariableType) {
return (this.strongHash()) === (pType.pEffectType.strongHash());

}

return (this.strongHash()) === (pType.strongHash());

};
EffectType.prototype.isConst = function() {
return true;

};
EffectType.prototype.isSampler = function() {
if ((((((this.sName) === "sampler") || ((this.sName) === "sampler1D")) || ((this.sName) === "sampler2D")) || ((this.sName) === "sampler3D")) || ((this.sName) === "samplercube")) {
return true;

}

return false;

};
EffectType.prototype.fromStruct = function(pStruct) {
this.sName = pStruct.sName;
this.pDesc = pStruct;
this.isStruct = true;
this._canMixible = pStruct.canMixible();
pStruct.setPadding();
this.iSize = pStruct.iSize;

};
EffectType.prototype.toStr = function() {
return this.sName;

};
EffectType.prototype.isBase = function() {
return this._isBase;

};
EffectType.prototype.toCode = function() {
if (this._sCode) {
return this._sCode;

}

if (this._isBase) {
this._sCode = this.sRealName;

}
else  {
this._sCode = "struct " + (this.sRealName);
this._sCode += this.pDesc.toCode();

}

return this._sCode;

};
EffectType.prototype.toCodeString = function() {
if (this.sRealName) {
return this.sRealName;

}
else  {
if (!0) {
var err=((((((("Error:: " + "I should not be here. Something bad have happened.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("I should not be here. Something bad have happened.");

}


}

;
return ;

}


};
EffectType.prototype.hasSemantic = function(sSemantic) {
return (this.pDesc.hasSemantic(sSemantic)) || false;

};
EffectType.prototype.hasEmptySemantic = function() {
return this.pDesc.hasEmptySemantic();

};
EffectType.prototype.hasMultipleSemantic = function() {
return this.pDesc.hasMultipleSemantic();

};
EffectType.prototype.hasComplexType = function() {
return this.pDesc.hasComplexType();

};
EffectType.prototype.checkMe = function() {
if (this._isBase) {
return true;

}

var i, j;
if (!(this.isAnalyzed)) {
this.pDesc.analyzeSemantics();
this.isAnalyzed = true;

}

for (i = 0; i < (arguments.length); i++) {
switch(arguments[i]) {
case a.fx.GLOBAL_VARS.VERTEXUSAGE:
if (((this.hasEmptySemantic()) || (this.hasMultipleSemantic())) || (this.hasComplexType())) {
return false;

}

break ;

case a.fx.GLOBAL_VARS.FRAGMENTUSAGE:
if (((this.pDesc.pOrders.length) !== 1) || (!(this.hasSemantic("COLOR")))) {
return false;

}

break ;

case a.fx.GLOBAL_VARS.VERTEXUSAGEPARAM:
if ((this.hasEmptySemantic()) || (this.hasMultipleSemantic())) {
return false;

}

if (this.hasComplexType()) {
for (j = 0; j < (this.pDesc.pOrders.length); j++) {
if (!(this.pDesc.pOrders[j].pType.checkMe(a.fx.GLOBAL_VARS.VERTEXUSAGEPARAM))) {
return false;

}


}


}

break ;

default:
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "][") + "") + "]") + "Unknown usage for check");
break ;
}

}

return true;

};
EffectType.prototype.setMixible = function() {
if ((!(this.pDesc)) || (this.isMixible)) {
return ;

}

this.isMixible = true;
this.pDesc.setMixible();

};
EffectType.prototype.setVSInput = function() {
this.isVSInput = true;

};
EffectType.prototype.setFSInput = function() {
this.isFSInput = true;

};
EffectType.prototype.hasIndexData = function() {
if (this.pDesc) {
return this.pDesc.hasIndexData();

}

return false;

};
EffectType.prototype.globalUsedTypes = function() {
if (this._isBase) {
return null;

}

return this.pDesc.globalUsedTypes();

};
EffectType.prototype.canMixible = function() {
return this._canMixible;

};
EffectType.prototype.canBlend = function(pType, isStrict) {
return this.pDesc.canBlend(pType.pDesc, isStrict);

};
function EffectStruct() {
this.pOrders = null;
this.pFields = null;
this.sName = null;
this._pSemantics = null;
this._hasMultipleSemantic = false;
this._hasEmptySemantic = false;
this._hasComplexType = false;
this.isAnalyzed = false;
this.isMixible = false;
this._canMixible = false;
this._hasIndexData = null;
this._sCode = null;
this.pGlobalUsedTypes = null;
this.iSize = 0;
this._pPointers = null;

}

EffectStruct.prototype.toCode = function() {
if (this._sCode) {
return this._sCode;

}

this._sCode = "{";
var i;
for (i = 0; i < (this.pOrders.length); i++) {
this._sCode += (((this.pOrders[i].pType.toCode()) + " ") + (this.pOrders[i].toCode())) + ";";

}

this._sCode += "}";
return this._sCode;

};
EffectStruct.prototype.checkMe = function() {
return true;

};
EffectStruct.prototype.hasField = function(sName) {
return (this.pFields[sName]) || false;

};
EffectStruct.prototype.analyzeSemantics = function() {
if (this.isAnalyzed) {
return ;

}

var i;
var pSemantics= {};
var pOrders=this.pOrders;
for (i = 0; i < (pOrders.length); i++) {
if (!(pOrders[i].sSemantic)) {
this._hasEmptySemantic = true;

}

if (!(pOrders[i].pType.isBase())) {
this._hasComplexType = true;

}

if (pSemantics[pOrders[i].sSemantic]) {
this._hasMultipleSemantic = true;

}

pSemantics[pOrders[i].sSemantic] = pOrders[i];

}

this._pSemantics = pSemantics;
this.isAnalyzed = true;

};
EffectStruct.prototype.hasSemantic = function(sSemantic) {
if (this._pSemantics) {
return this._pSemantics[sSemantic];

}

var pOrders=this.pOrders;
var i;
for (i = 0; i < (pOrders.length); i++) {
if ((pOrders[i].sSemantic) === sSemantic) {
return pOrders[i];

}


}

return false;

};
EffectStruct.prototype.hasEmptySemantic = function() {
if (this._pSemantics) {
return this._hasEmptySemantic;

}

var pOrders=this.pOrders;
var i;
for (i = 0; i < (pOrders.length); i++) {
if (!(pOrders[i].sSemantic)) {
this._hasEmptySemantic = true;
return true;

}


}

this._hasEmptySemantic = false;
return false;

};
EffectStruct.prototype.hasMultipleSemantic = function() {
if (this._pSemantics) {
return this._hasMultipleSemantic;

}

var i, j;
var pOrders=this.pOrders;
for (i = 0; i < (pOrders.length); i++) {
for (j = i + 1; j < (pOrders.length); j++) {
if (pOrders[j].sSemantic = pOrders[i].sSemantic) {
this._hasMultipleSemantic = true;
return true;

}


}


}

this._hasMultipleSemantic = false;
return false;

};
EffectStruct.prototype.hasComplexType = function() {
if (this._pSemantics) {
return this._hasComplexType;

}

var pOrders=this.pOrders;
var i;
for (i = 0; i < (pOrders.length); i++) {
if (!(pOrders[i].pType.isBase())) {
this._hasComplexType = true;
return true;

}


}

this._hasComplexType = false;
return false;

};
EffectStruct.prototype.setMixible = function() {
if (this.isMixible) {
return ;

}

var pOrders=this.pOrders;
var i;
for (i = 0; i < (pOrders.length); i++) {
pOrders[i].setMixible();

}

this.isMixible = true;

};
EffectStruct.prototype.hasIndexData = function() {
if ((this._hasIndexData) !== null) {
return this._hasIndexData;

}

var pOrders=this.pOrders;
var i;
for (i = 0; i < (pOrders.length); i++) {
if (pOrders[i].isPointer) {
this._hasIndexData = true;
return true;

}

if ((!(pOrders[i].pType.isBase())) && (pOrders[i].pType.pEffectType.pDesc.hasIndexData())) {
this._hasIndexData = true;
return true;

}


}

this._hasIndexData = false;
return this._hasIndexData;

};
EffectStruct.prototype.globalUsedTypes = function() {
if (this.pGlobalUsedTypes) {
return this.pGlobalUsedTypes;

}

var pTypes= {};
var pType;
var i, j;
var isOk=false;
var pTypes1;
for (i = 0; i < (this.pOrders.length); i++) {
pType = this.pOrders[i].pType.pEffectType;
if ((pType.iScope) === (a.fx.GLOBAL_VARS.GLOBAL)) {
pTypes[pType.sName] = pType;
isOk = true;
pTypes1 = pType.pDesc.globalUsedTypes();
for (j in pTypes1) {
pTypes[pTypes1[j].sName] = pTypes1[j];

}


}


}

if (isOk) {
this.pGlobalUsedTypes = pTypes;

}

return this.pGlobalUsedTypes;

};
EffectStruct.prototype.canMixible = function() {
return this._canMixible;

};
EffectStruct.prototype.canBlend = function(pStruct, isStrict) {
this.analyzeSemantics();
pStruct.analyzeSemantics();
var pSemantics1=this._pSemantics;
var pSemantics2=pStruct._pSemantics;
var i;
var pVar1, pVar2;
var iStatus=1, iBlend;
for (i in pSemantics1) {
pVar1 = pSemantics1[i];
pVar2 = pSemantics2[i];
if (pVar2) {
iBlend = pVar1.canBlend(pVar2, isStrict);
if (iBlend === 0) {
return 0;

}

if (iBlend === 2) {
iStatus = iBlend;
continue ;

}

if (isStrict && ((pVar2.iPadding) !== (pVar1.iPadding))) {
iStatus = 2;

}


}
else  {
iStatus = 2;

}


}

if ((this.pOrders.length) !== (pStruct.pOrders.length)) {
iStatus = 2;

}

return iStatus;

};
EffectStruct.prototype.setPadding = function() {
var i;
var iPadding=0;
var pVar;
for (i = 0; i < (this.pOrders.length); i++) {
pVar = this.pOrders[i];
pVar.iPadding = iPadding;
iPadding += pVar.iSize;

}

this.iSize = iPadding;

};
EffectStruct.prototype.getPointers = function() {
if (!(this.hasIndexData())) {
return null;

}

if (this._pPointers) {
return this._pPointers;

}

var i;
var pPointers=[];
var pOrders=this.pOrders;
for (i = 0; i < (pOrders.length); i++) {
if (pOrders[i].isPointer) {
pPointers.push(pOrders[i].pPointers[(pOrders[i].pPointers.length) - 1]);

}

if ((!(pOrders[i].pType.isBase())) && (pOrders[i].pType.pEffectType.pDesc.hasIndexData())) {
pPointers = pPointers.concat(pOrders[i].pType.pEffectType);

}


}


};
function EffectPointer(pVar, nDim, pFirst, sPrev, isAttr) {
this.pVar = pVar || null;
this.sRealName = null;
this.nDim = nDim || 0;
this.isAttr = isAttr;
this.sPrevReal = sPrev;
this.pFirst = pFirst;

}

EffectPointer.prototype.toCode = function() {
var i;
if (this.sRealName) {
return this.sRealName;

}

if ((!(this.pFirst)) || ((this.isAttr) && (this.pFirst.isVSInput))) {
this.sRealName = "";

}
else  {
this.sRealName = (this.pFirst.sRealName) + "_";

}

this.sRealName += ((this.sPrevReal) !== ""? (this.sPrevReal) + "_" : "");
this.sRealName += this.pVar.toCode(a.fx.GLOBAL_VARS.PREFIX);
for (i = 0; i <= (this.nDim); i++) {
this.sRealName += "_index";

}

return this.sRealName;

};
function EffectBuffer(pVar) {
if (!(this.constructor.fnToCode)) {
this.constructor.fnToCode = function() {
return this.pData;

};

}

;
this.pRealBuffer = null;
this.pSampler =  {pData: null, toDataCode: EffectBuffer.fnToCode};
this.pHeader =  {pData: null, toDataCode: EffectBuffer.fnToCode};
this.isUniform = false;
this.id = EffectBuffer.nCount++;
this.pVar = pVar || null;

}

EffectBuffer.nCount = 0;
function EffectVariable() {
this.pType = null;
this.sName = null;
this.sRealName = null;
this.sFullName = null;
this.sSemantic = null;
this.pAnnotation = null;
this.pInitializer = null;
this.pDefaultValue = null;
this.isArray = false;
this.iLength = 1;
this.isPointer = false;
this.nDim = 0;
this.pBuffer = null;
this.pPointers = null;
this.iScope = 0;
this._isConstInit = null;
this.pTextures = null;
this.pStates = null;
this._pCurrentState = null;
this._pCurrentTexture = null;
this._isSampler = false;
this._pSamplerData = null;
this.isParametr = false;
this.isUniform = false;
this.isGlobal = false;
this.isMixible = false;
this.isVSInput = false;
this.isFSInput = false;
this.isVertexOnly = false;
this.isFragmentOnly = false;
this.iPadding = -1;
this.iSize = 0;
this.isUsed = false;
this._pAllPointers = null;
this._pIndexFields = null;
this.isValid = false;

}

EffectVariable.prototype.isInput = function() {
if ((this.pType.pUsagesName) && (((this.pType.pUsagesName["in"]) === null) || ((this.pType.pUsagesName["inout"]) === null))) {
return true;

}

return false;

};
EffectVariable.prototype.isOutput = function() {
if ((this.pType.pUsagesName) && (((this.pType.pUsagesName["out"]) === null) || ((this.pType.pUsagesName["inout"]) === null))) {
return true;

}

return false;

};
EffectVariable.prototype.isConst = function() {
return this.pType.isConst();

};
EffectVariable.prototype.isConstInit = function() {
if (!(this.pInitializer)) {
this._isConstInit = null;
return null;

}

if ((this._isConstInit) !== null) {
return this._isConstInit;

}

var i;
for (i = 0; i < (this.pInitializer.length); i++) {
if (((typeof (this.pInitializer[i])) === "object") && (!(this.pInitializer[i].isConst()))) {
this._isConstInit = false;
return false;

}


}

this._isConstInit = true;
return true;

};
EffectVariable.prototype.setType = function(pType) {
this.pType = pType;
if (pType.pUsagesName) {
this.isUniform = ((pType.pUsagesName["uniform"]) === null? true : false);
this.isGlobal = ((pType.pUsagesName["global"]) === null? true : false);
this.isUniform = (this.isUniform) || (this.isSampler());

}

if (this.isPointer) {
this.iSize = 1;

}
else  {
this.iSize = (this.pType.pEffectType.iSize) * (this.iLength);

}


};
EffectVariable.prototype.addAnnotation = function(pAnnotation) {
this.pAnnotation = pAnnotation;

};
EffectVariable.prototype.addSemantic = function(sSemantic) {
this.sSemantic = sSemantic;

};
EffectVariable.prototype.addInitializer = function(pInit) {
this.pInitializer = pInit;

};
EffectVariable.prototype.toCode = function() {
return this.sRealName;

};
EffectVariable.prototype.checkMe = function() {
return true;

};
EffectVariable.prototype.cloneMe = function() {
var pVar=new EffectVariable();
pVar.pType = this.pType.cloneMe();
pVar.sName = this.sName;
pVar.sRealName = this.sRealName;
pVar.sSemantic = this.sSemantic;
pVar.isArray = this.isArray;
pVar.iLength = this.iLength;
pVar.isPointer = this.isPointer;
pVar.pPointers = this.pPointers;
pVar.pBuffer = this.pBuffer;
pVar.nDim = this.nDim;
pVar.iSize = this.iSize;
pVar.iPadding = this.iPadding;
pVar._pAllPointers = this._pAllPointers;
pVar._pIndexFields = this._pIndexFields;
pVar.sFullName = this.pFullName;
return pVar;

};
EffectVariable.prototype.setTexture = function(pTex) {
this._pCurrentTexture = pTex;
this._isSampler = true;
if (!(this._pCurrentState)) {
this._pCurrentState =  {};

}

this._pCurrentState[a.fx.GLOBAL_VARS.TEXTURE] = pTex.sRealName;

};
EffectVariable.prototype.setState = function(eState, eValue) {
if (!(this._pCurrentState)) {
this._pCurrentState =  {};
this._isSampler = true;

}

if (this._pCurrentState[eState]) {
if (!0) {
var err=((((((("Error:: " + "Bad 197") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Bad 197");

}


}

;
return ;

}

this._pCurrentState[eState] = eValue;

};
EffectVariable.prototype.setMixible = function() {
if ((this.isUniform) || (this.isMixible)) {
return ;

}

if (!(this.pType.canMixible())) {
if (!0) {
var err=((((((("Error:: " + "For mixible variables semantics are necessary") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("For mixible variables semantics are necessary");

}


}

;
return ;

}

this.isMixible = true;
this.sRealName = (this.sSemantic) || (this.sName);
this.pType.setMixible();

};
EffectVariable.prototype.setVSInput = function() {
this.isVSInput = true;
this.pType.setVSInput();

};
EffectVariable.prototype.setFSInput = function() {
this.isFSInput = true;
this.pType.setFSInput();

};
EffectVariable.prototype.toCodeDecl = function(isInit) {
var sCode;
sCode = ((this.pType.toCode()) + " ") + (this.sRealName);
if (this.isArray) {
sCode += ("[" + (this.iLength)) + "]";

}

if (isInit && (this.pInitializer)) {
sCode += "=";
var i;
sCode += (this.pType.pEffectType.toCode()) + "(";
for (i = 0; i < (this.pInitializer.length); i++) {
if ((typeof (this.pInitializer[i])) !== "string") {
if (!0) {
var err=((((((("Error:: " + "May be yo use in init expr of varibale some bad constructions") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("May be yo use in init expr of varibale some bad constructions");

}


}

;
return ;

}

sCode += this.pInitializer[i];
if (i < ((this.pInitializer.length) - 1)) {
sCode += ",";

}


}

sCode += ")";

}

sCode += ";";
return sCode;

};
EffectVariable.prototype.toOffsetStr = function() {
return (a.fx.SHADER_PREFIX.OFFSET) + (this.sRealName);

};
EffectVariable.prototype.toDataCode = function() {
if (!(this.isSampler)) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "][") + "") + "]") + "Only for samplers");

}

return this._pSamplerData;

};
EffectVariable.prototype.isSampler = function() {
return this._isSampler;

};
EffectVariable.prototype.isBuffer = function() {
return (this.pBuffer) && ((this.iScope) === (a.fx.GLOBAL_VARS.GLOBAL));

};
EffectVariable.prototype.canBlend = function(pVar, isStrict) {
if (((isStrict && (((pVar.isPointer) !== (this.isPointer)) || ((pVar.nDim) !== (this.nDim)))) || ((pVar.iLength) !== (this.iLength))) || ((pVar.isArray) !== (this.isArray))) {
return 0;

}

return this.pType.canBlend(pVar.pType, isStrict);

};
EffectVariable.prototype.addSamplerState = function() {
if (!(this.pStates)) {
this.pStates = this._pCurrentState;
this.pTextures = this._pCurrentTexture;

}
else if ((this.pStates) instanceof Array) {
this.pStates.push(this._pCurrentState);
this.pTextures.push(this._pCurrentTexture);

}
else  {
this.pStates = [this.pStates, this._pCurrentState];
this.pTextures = [this.pTextures, this._pCurrentTexture];

}


this._pCurrentState = null;
this._pCurrentTexture = null;

};
function SamplerIndex(pCode, pSampler) {
this.pData = pCode;
this.pSampler = pSampler;

}

SamplerIndex.prototype.toDataCode = function() {
return (this.pSampler.isValid? this.pData : "");

};
SamplerIndex.prototype.extract = function(eMode) {
this.pData = a.fx.fnSimpleExtractCode(this.pData, "", eMode);

};
function EffectVariableBase(pVar, pFirst, sRealPrevName, iScope, sFullName, iPadding) {
this.pVar = pVar;
this.pFirst = pFirst;
this.sRealPrevName = sRealPrevName;
this.iScope = iScope;
this.iPadding = (pVar.iPadding) + iPadding;
this.isPointer = false;
this.pPointers = null;
this._pAllPointers = null;
this.pBuffer = null;
this.pType = pVar.pType;
this.isArray = pVar.isArray;
this.iSize = pVar.iSize;
this.iLength = pVar.iLength;
this.sName = pVar.sRealName;
this.sFullName = sFullName;
this.sRealNameShader = null;
this.sRealName = null;
this.isUsed = false;
this._pIndexFields = null;

}

EffectVariableBase.prototype.toCode = function(isShader) {
if (isShader === (a.fx.GLOBAL_VARS.PREFIX)) {
return this.sName;

}

var sName;
if (isShader && (this.sRealNameShader)) {
return this.sRealNameShader;

}

if ((!isShader) && (this.sRealName)) {
return this.sRealName;

}

sName = "";
if (!(isShader && (this.pFirst.isVSInput))) {
sName = (this.pFirst.toCode()) + ".";

}

sName += (this.sRealPrevName? (this.sRealPrevName) + "." : "");
sName += this.sName;
if (isShader) {
this.sRealNameShader = sName;

}
else  {
this.sRealName = sName;

}

return sName;

};
EffectVariableBase.prototype.cloneMe = function() {
var pVar=this.pVar.cloneMe();
pVar.sName = this.pVar.sName;
pVar.sFullName = this.sFullName;
pVar.sRealName = this.pVar.sRealName;
pVar.sSemantic = this.pVar.sSemantic;
pVar.isArray = this.isArray;
pVar.iLength = this.iLength;
pVar.isPointer = this.isPointer;
pVar.pPointers = this.pPointers;
pVar.pBuffer = this.pBuffer;
pVar.nDim = this.pVar.nDim;
pVar.iSize = this.iSize;
pVar.iPadding = this.iPadding;
pVar._pAllPointers = this._pAllPointers;
pVar._pIndexFields = this._pIndexFields;
return pVar;

};
function EffectBaseFunction() {
var pFunction;
if ((arguments.length) === 1) {
pFunction = arguments[0];

}

this.sName = null;
this.sRealName = null;
this.pFunction = pFunction || null;
this.sSemantic = (pFunction? pFunction.sSemantic : null);
this.pReturnType = (pFunction? pFunction.pReturnType : null);
this.pMainInputVar = (pFunction? pFunction.pMainInputVar : null);
this.pGlobalUsedTypes = (pFunction && (pFunction.pImplement)? pFunction.pGlobalUsedTypes :  {});
this._isGlobalTypesAnalyzed = (pFunction && (pFunction.pImplement)? pFunction._isGlobalTypesAnalyzed : false);
this.pGlobalVariables = (pFunction && (pFunction.pImplement)? pFunction.pGlobalVariables : null);
this.pUniforms = (pFunction && (pFunction.pImplement)? pFunction.pUniforms : null);
this.pExternals = (pFunction && (pFunction.pImplement)? pFunction.pExternals : null);
this.pImplement = null;
this.iScope = 0;
this.pScopeStack = null;
this.pFunctions = null;
this._pBaseMemBlocks =  {};
this.pMemBlocks =  {};
this._pExtractFunctions = null;
this._sDefinition = null;
this._pCodeAll = null;
this._sCodeAll = null;
this._pLocalPointers =  {};

}

EffectBaseFunction.prototype.addGlobalVariable = function(pVar) {
if (pVar.isGlobal) {
return false;

}

if (!(this.pGlobalVariables)) {
this.pGlobalVariables =  {};

}

if ((this.pUniforms) && (this.pUniforms[pVar.sName])) {
delete (this.pUniforms[pVar.sName]);

}

if (this.pGlobalVariables[pVar.sName]) {
return false;

}

this.pGlobalVariables[pVar.sName] = pVar;
return true;

};
EffectBaseFunction.prototype.addUniform = function(pVar) {
if (pVar.isGlobal) {
return false;

}

if (!(this.pUniforms)) {
this.pUniforms =  {};

}

if ((this.pGlobalVariables) && (this.pGlobalVariables[pVar.sName])) {
return ;

}

if (this.pUniforms[pVar.sName]) {
return false;

}

this.pUniforms[pVar.sName] = pVar;
return true;

};
EffectBaseFunction.prototype.addFunction = function(pFunc) {
if (pFunc === (this)) {
if (!0) {
var err=((((((("Error:: " + "Recursion don`t support") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Recursion don`t support");

}


}

;
return ;

}

if (!(this.pFunctions)) {
this.pFunctions =  {};

}

this.pFunctions[pFunc.sHash] = pFunc;

};
EffectBaseFunction.prototype.addType = function(pType) {
if (!pType) {
return false;

}

var isNewType=false;
var pTypes;
if (pType instanceof EffectType) {
if (this.pGlobalUsedTypes[pType.sName]) {
return false;

}

this.pGlobalUsedTypes[pType.sName] = pType;
isNewType = true;
pTypes = pType.globalUsedTypes();
for (var i in pTypes) {
if (!(this.pGlobalUsedTypes[pTypes[i].sName])) {
this.pGlobalUsedTypes[pTypes[i].sName] = pTypes[i];
isNewType = true;

}


}

return isNewType;

}

for (var i in pType) {
if (this.addType(pType[i])) {
isNewType = true;

}


}

return isNewType;

};
EffectBaseFunction.prototype.addExternal = function(pVar) {
if (!(this.pExternals)) {
this.pExternals =  {};

}

if (!(this.pExternals[pVar.sName])) {
this.pExternals[pVar.sName] = pVar;
return true;

}

return false;

};
EffectBaseFunction.prototype.globalUsedTypes = function() {
if (this._isGlobalTypesAnalyzed) {
return this.pGlobalUsedTypes;

}

var isNewType=false;
var pTypes;
var i, j;
while (isNewType) {
isNewType = false;
for (i = 0; i < (this.pScopeStack.length); i++) {
pTypes = this._ppScopes[this.pScopeStack[i]].pTypeTable;
for (j in pTypes) {
if (this.addType(pTypes[j].globalUsedTypes())) {
isNewType = true;

}


}


}


}
return this.pGlobalUsedTypes;

};
EffectBaseFunction.prototype.hasImplementation = function() {
return (this.pImplement? true : false);

};
EffectBaseFunction.prototype.setName = function(sName) {
this.sName = sName;

};
EffectBaseFunction.prototype.addSemantic = function(sSemantic) {
this.sSemantic = sSemantic;
this.pReturnType.sSemantic = sSemantic;

};
EffectBaseFunction.prototype.setImplement = function(pImplement) {
this.pImplement = pImplement;

};
EffectBaseFunction.prototype.memBlock = function(pVar, iPointer) {
var sName=(pVar.sName) + "?";
sName += (pVar.iScope) + "@";
var pBase;
var pBlock;
if (!(this._pBaseMemBlocks[sName])) {
this._pBaseMemBlocks[sName] = new MemBlock(pVar);

}

pBase = this._pBaseMemBlocks[sName];
if (iPointer === undefined) {
pBlock = pBase;

}
else  {
sName += (iPointer !== undefined? iPointer : "");
if (!(this.pMemBlocks[sName])) {
this.pMemBlocks[sName] = new MemBlock(pBase, iPointer);
pBlock = this.pMemBlocks[sName];

}


}

return pBlock;

};
EffectBaseFunction.prototype.generateDefinitionCode = function() {
this._sDefinition = (((this.pReturnType.toCode()) + " ") + (this.sRealName)) + "()";

};
EffectBaseFunction.prototype.toCode = function(isAllCode) {
if (!isAllCode) {
if (!(this.sRealName)) {
if (!0) {
var err=((((((("Error:: " + "Cannot be traslated") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Cannot be traslated");

}


}

;
return ;

}

return this.sRealName;

}
else  {
return this.toCodeAll();

}


};
EffectBaseFunction.prototype.toCodeAll = function() {
return "";

};
EffectBaseFunction.prototype.generateExtractedCode = function() {
return "";

};
EffectBaseFunction.prototype.addGlobalBuffer = function(pBuf) {
if (!(pBuf.isUniform)) {
trace(pBuf);
if (!0) {
var err=((((((("Error:: " + "something going wrong with add global buffer") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("something going wrong with add global buffer");

}


}

;
return ;

}

this.addUniform(pBuf.pVar);
if (!(this.pGlobalBuffers)) {
this.pGlobalBuffers =  {};

}

if (!(this.pGlobalBuffers[pBuf.pVar.sRealName])) {
this.pGlobalBuffers[pBuf.pVar.sRealName] = pBuf;
return true;

}

return false;

};
EffectBaseFunction.prototype.addPointers = function(pVar) {
if (((pVar.iScope) !== (this.iScope)) && ((pVar.iScope) !== (a.fx.GLOBAL_VARS.GLOBAL))) {
var i;
for (i = 0; i < (pVar._pAllPointers.length); i++) {
this._pLocalPointers[pVar._pAllPointers[i].toCode()] = pVar._pAllPointers[i];

}


}


};
function EffectFunction(sName, pGLSLExpr, pTypes) {
var _pCtorValue=EffectFunction.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this.sName = sName || null;
this.pGLSLExpr = pGLSLExpr || null;
this.pParameters = null;
this.nParamsNeeded = 0;
this.pParamOrders = null;
this.sHash = null;
this.isConstant = true;
this.isFragmentOnly = false;
this.isVertexOnly = false;
this.isBufferNeed = false;
this.isFragmentShader = false;
this.isVertexShader = false;
this.pShader = null;
this.pStructTable = null;
this.isSystem = (pGLSLExpr? true : false);
this.pTypes = pTypes || null;

}

a.extend(EffectFunction, EffectBaseFunction);
EffectFunction.prototype.isConst = function() {
return this.isConstant;

};
EffectFunction.prototype.calcHash = function() {
var sHash="";
sHash += this.sName;
var i;
if (!(this.pTypes)) {
for (i = 0; (this.pParamOrders? i < (this.pParamOrders.length) : false); i++) {
sHash += "!" + (this.pParamOrders[i].pType.toStr());

}


}
else  {
for (i = 0; i < (this.pTypes.length); i++) {
sHash += "!" + (this.pTypes[i].sName);

}


}

sHash += "-->" + (this.pReturnType.toStr());
return sHash;

};
EffectFunction.prototype.hash = function() {
if (!(this.sHash)) {
this.sHash = this.calcHash();

}

return this.sHash;

};
EffectFunction.prototype.addParameter = function(pVar) {
if (!(this.pParameters)) {
this.pParameters =  {};

}

if (!(this.pParamOrders)) {
this.pParamOrders = [];

}

if (this.pParameters[pVar.sName]) {
if (!0) {
var err=((((((("Error:: " + "So so bad. try to this parametr") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("So so bad. try to this parametr");

}


}

;
return ;

}

this.pParamOrders.push(pVar);
this.pParameters[pVar.sName] = pVar;
pVar.isParametr = true;
if (pVar.isUniform) {
pVar.isUniform = true;
this.addUniform(pVar);

}

if (!(pVar.pInitializer)) {
this.nParamsNeeded = this.pParamOrders.length;

}


};
EffectFunction.prototype.checkMe = function() {
var i, j, k;
var pType;
var pVar;
var pSemantics;
var isOne=false;
for (i = 0; i < (arguments.length); i++) {
switch(arguments[i]) {
case a.fx.GLOBAL_VARS.VERTEXUSAGE:
if (!(this.pReturnType.checkMe(a.fx.GLOBAL_VARS.VERTEXUSAGE))) {
return false;

}

pSemantics =  {};
for (j = 0; j < (this.pParamOrders.length); j++) {
pVar = this.pParamOrders[j];
pType = pVar.pType;
if ((pType.pUsagesName) && ((pType.pUsagesName["uniform"]) === null)) {
continue ;

}

if (isOne === true) {
return false;

}

if (isOne === undefined) {
if ((pVar.sSemantic) === null) {
isOne = true;

}
else  {
isOne = false;

}


}

if (pType.isBase()) {
isOne = false;
if ((pVar.sSemantic) === null) {
return false;

}

if ((pSemantics[pVar.sSemantic]) === null) {
return false;

}

pSemantics[pVar.sSemantic] = null;
continue ;

}

if (!(pType.checkMe(a.fx.GLOBAL_VARS.VERTEXUSAGEPARAM))) {
return false;

}

for (k = 0; k < (pType.pEffectType.pDesc.pOrders.length); k++) {
pVar = pType.pEffectType.pDesc.pOrders[k];
if ((pSemantics[pVar.sSemantic]) === null) {
return false;

}

pSemantics[pVar.sSemantic] = null;

}


}

break ;

case a.fx.GLOBAL_VARS.FRAGMENTUSAGE:
if (this.pReturnType.checkMe(a.fx.GLOBAL_VARS.FRAGMENTUSAGE)) {
return true;

}

break ;

default:
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "][") + "") + "]") + "Unknown usage for check");
return true;
}

}

return true;

};
EffectFunction.prototype.generateDefinitionCode = function() {
this._sDefinition = (((this.pReturnType.toCode()) + " ") + (this.sRealName)) + "(";
var i, j;
var pType;
for (i = 0; (this.pParamOrders) && (i < (this.pParamOrders.length)); i++) {
pType = this.pParamOrders[i].pType;
if (!((pType.pUsagesName) && ((pType.pUsagesName["uniform"]) === null))) {
this._sDefinition += pType.toCode();
if (i !== ((this.pParamOrders.length) - 1)) {
this._sDefinition += ",";

}


}


}

this._sDefinition += ")";

};
EffectFunction.prototype.generateExtractedCode = function() {
var i, j;
var sCode;
var pCode=null;
sCode = (((this.pReturnType.toCode()) + " ") + (this.sRealName)) + "(";
var pType, pVar;
for (i = 0; i < (this.pParamOrders.length); i++) {
pVar = this.pParamOrders[i];
pType = pVar.pType;
if (!((pType.pUsagesName) && ((pType.pUsagesName["uniform"]) === null))) {
sCode += ((pType.toCode()) + " ") + (pVar.toCode());
if (i !== ((this.pParamOrders.length) - 1)) {
sCode += ",";

}


}


}

sCode += "){";
for (i in this._pLocalPointers) {
if (this._pLocalPointers[i].pVar.isUsed) {
sCode += ("float " + i) + "=0.0;";

}


}

function fnExtractCode(pElement) {
var pToCode;
if ((typeof pElement) === "string") {
sCode += pElement;

}
else if (((pElement.pData) === undefined) || ((((pElement.pData) !== undefined) && ((pElement.isParametr) === true)) && ((pElement.isUniform) === false))) {
pToCode = pElement.toCode(false);
if ((typeof pToCode) === "string") {
if (!pCode) {
pCode = [];

}

if (sCode !== "") {
pCode.push(sCode);

}

pCode.push(pElement);
sCode = "";

}
else  {
for (j = 0; j < (pToCode.length); j++) {
fnExtractCode(pToCode[j]);

}


}


}
else  {
if (!pCode) {
pCode = [];

}

if (sCode !== "") {
pCode.push(sCode);

}

if (pElement instanceof SamplerIndex) {
pElement.extract(false);

}

pCode.push(pElement);
sCode = "";

}



}

for (i = 0; i < (this.pImplement.length); i++) {
fnExtractCode(this.pImplement[i]);

}

sCode += "}";
if (pCode) {
pCode.push(sCode);
this._pCodeAll = pCode;
return ;

}
else  {
this._sCodeAll = sCode;
return ;

}


};
EffectFunction.prototype.toCodeAll = function() {
if ((!(this._pCodeAll)) && (!(this._sCodeAll))) {
this.generateExtractedCode();

}

if (this._sCodeAll) {
return this._sCodeAll;

}

var i, j;
var sCode="";
var pCode=null;
var pElement;
var pToCode;
for (i = 0; i < (this._pCodeAll.length); i++) {
pElement = this._pCodeAll[i];
if ((typeof pElement) === "string") {
sCode += pElement;

}
else  {
if ((!((pElement.isSampler) && ((pElement.iScope) === (a.fx.GLOBAL_VARS.GLOBAL)))) && ((pElement.pData) === undefined)) {
pToCode = pElement.toCode(false);
if ((typeof pToCode) === "string") {
sCode += pToCode;

}
else  {
if (!0) {
var err=((((((("Error:: " + "extrct function don`t work as expected") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("extrct function don`t work as expected");

}


}

;
return ;

}


}
else  {
if (!pCode) {
pCode = [];

}

if (sCode !== "") {
pCode.push(sCode);

}

pCode.push(pElement);
sCode = "";

}


}


}

if (pCode) {
if (sCode !== "") {
pCode.push(sCode);

}

return pCode;

}
else  {
return sCode;

}


};
function EffectShader(pFunction) {
var _pCtorValue=EffectShader.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this.pReturnVariable = null;
this.pTwin = null;
this.isLocalOut = false;
this.pGlobalVarBlock = null;
this.pGlobalsByRealName = null;
this.pUniformsBlock = null;
this.pUniformsByName = null;
this.pUniformsByRealName = null;
this.pUniformsDefault = null;
this.pBuffersBlock = null;
this.pBuffersByName = null;
this.pBuffersByRealName = null;
this.pAttrBuffers = null;
this.pMixibleTypes = null;
this.pTypesBlock = null;
this.pTypesByName = null;
this.pFuncByDef = null;
this.pFuncBlock = null;
this.pTexturesByName = null;
this.pTexturesByRealName = null;
this.pGlobalPointers = [];
this._isReady = false;

}

a.extend(EffectShader, EffectBaseFunction);
EffectShader.prototype.createTwinIn = function() {
if (!(this.pMainInputVar)) {
if (!0) {
var err=((((((("Error:: " + "Twin available only for Vertex Shader with Struct Attrib") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Twin available only for Vertex Shader with Struct Attrib");

}


}

;
return ;

}

this.pTwin = this.pMainInputVar.cloneMe();
this.pTwin.sName = (this.pTwin.sName) + "_clone";

};
EffectShader.prototype.generateDefinitionCode = function(id, iEffectId) {
this.sRealName = (((a.fx.GLOBAL_VARS.SHADERPREFIX) + id) + "_") + iEffectId;
this._sDefinition = ("void " + (this.sRealName)) + "()";

};
EffectShader.prototype.generateExtractedCode = function() {
var i, j;
var sCode;
var pCode=null;
if (!(this._sDefinition)) {
if (!0) {
var err=((((((("Error:: " + "Before generate code for shader, you should definite this function") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Before generate code for shader, you should definite this function");

}


}

;
return ;

}

sCode = this._sDefinition;
sCode += "{";
for (i in this._pLocalPointers) {
if (this._pLocalPointers[i].pVar.isUsed) {
sCode += ("float " + i) + "=0.0;";

}


}

if (this.pTwin) {
if (!pCode) {
pCode = [];

}

var pTwin=this.pTwin;
var pVar;
pCode.push(sCode);
sCode = "";
pCode.push(pTwin.pType, " ", pTwin, ";");
if ((this) instanceof EffectVertex) {
for (i = 0; i < (pTwin.pType.pEffectType.pDesc.pOrders.length); i++) {
pVar = pTwin.pType.pEffectType.pDesc.pOrders[i];
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "][") + "") + "]") + "Not full support of types have been implemented yet");
pCode.push(pTwin, ".", pVar, " = ", this._pAttrSemantics[pVar.sSemantic], ";");

}


}
else  {
for (i = 0; i < (pTwin.pType.pEffectType.pDesc.pOrders.length); i++) {
pVar = pTwin.pType.pEffectType.pDesc.pOrders[i];
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "][") + "") + "]") + "Not full support of types have been implemented yet");
pCode.push(pTwin, ".", pVar, " = ", this._pVaryingsSemantics[pVar.sSemantic], ";");

}


}


}

function fnExtractCode(pElement) {
var pToCode;
if ((typeof pElement) === "string") {
sCode += pElement;

}
else if (((pElement.pData) === undefined) || ((((pElement.pData) !== undefined) && ((pElement.isParametr) === true)) && ((pElement.isUniform) === false))) {
pToCode = (pElement instanceof EffectBaseFunction? pElement.toCode() : pElement.toCode(true));
if ((typeof pToCode) === "string") {
if (!pCode) {
pCode = [];

}

if (sCode !== "") {
pCode.push(sCode);

}

pCode.push(pElement);
sCode = "";

}
else  {
for (j = 0; j < (pToCode.length); j++) {
fnExtractCode(pToCode[j]);

}


}


}
else  {
if (!pCode) {
pCode = [];

}

if (sCode !== "") {
pCode.push(sCode);

}

if (pElement instanceof SamplerIndex) {
pElement.extract(true);

}

pCode.push(pElement);
sCode = "";

}



}

for (i = 0; i < (this.pImplement.length); i++) {
fnExtractCode(this.pImplement[i]);

}

if (this._pAttributes) {
var pData;
for (i in this._pAttrDataInit) {
pData = this._pAttrDataInit[i];
if ((pData.isComplex) !== true) {
for (j = 0; j < (pData.length); j++) {
if ((((typeof (pData[j])) === "string") || ((pData[j].pData) !== undefined)) || ((typeof (pData[j])) === "number")) {
continue ;

}

pData[j] = pData[j].toCode(true);

}


}

pData = this._pAttrIndexInit[i];
if (pData) {
for (j = 0; j < (pData.length); j++) {
if ((((typeof (pData[j])) === "string") || ((pData[j].pData) !== undefined)) || ((typeof (pData[j])) === "number")) {
continue ;

}

pData[j] = pData[j].toCode(true);

}


}


}

for (i = 0; i < (this._pAttributes.length); i++) {
pData = this._pAttrDataInit[this._pAttributes[i].sSemantic];
if (pData && ((pData.isComplex) === true)) {
this._extractAttrSubData(pData);

}


}


}

sCode += "}";
if (pCode) {
pCode.push(sCode);
this._pCodeAll = pCode;
return ;

}
else  {
this._sCodeAll = sCode;
return ;

}


};
EffectShader.prototype.toCodeAll = function(id) {
if (this._isReady) {
return ;

}

var i, j;
var pVar;
if (this.pReturnVariable) {
this.pReturnVariable.sRealName = a.fx.GLOBAL_VARS.SHADEROUT;

}

if (this.pTwin) {
this.pTwin.sRealName += "_twin";

}

this.pGlobalsByRealName =  {};
this.pGlobalVarBlock =  {};
for (i in this.pGlobalVariables) {
pVar = this.pGlobalVariables[i];
pVar.sRealName = ((pVar.sName) + "_g_") + id;
this.pGlobalsByRealName[pVar.sRealName] = pVar;
this.pGlobalVarBlock[pVar.sRealName] = pVar.toCodeDecl(true);

}

this.pUniformsByName =  {};
this.pUniformsByRealName =  {};
this.pUniformsDefault =  {};
this.pUniformsBlock =  {};
this.pTexturesByName =  {};
this.pTexturesByRealName =  {};
for (i in this.pUniforms) {
pVar = this.pUniforms[i];
pVar.sRealName = (pVar.sSemantic) || (pVar.sRealName);
this.pUniformsByName[i] = pVar.sRealName;
if (pVar.isSampler()) {
if ((pVar.pStates) instanceof Array) {
this.pUniformsDefault[pVar.sRealName] = pVar.pStates;
for (j = 0; j < (pVar.pTextures.length); j++) {
if (pVar.pTextures[j]) {
this.pTexturesByName[pVar.pTextures[j].sName] = pVar.pTextures[j].sRealName;
this.pTexturesByRealName[pVar.pTextures[j].sRealName] = null;

}


}


}
else  {
this.pUniformsDefault[pVar.sRealName] = pVar.pStates;
if (pVar.pTextures) {
this.pTexturesByName[pVar.pTextures.sName] = pVar.pTextures.sRealName;
this.pTexturesByRealName[pVar.pTextures.sRealName] = null;

}


}


}
else  {
this.pUniformsDefault[pVar.sRealName] = pVar.pDefaultValue;

}

this.pUniformsByRealName[pVar.sRealName] = pVar;
this.pUniformsBlock[pVar.sRealName] = (pVar.isUniform? pVar.toCodeDecl() : "uniform " + (pVar.toCodeDecl()));

}

this.pTypesBlock =  {};
this.pTypesByName =  {};
var pType;
for (i in this.pGlobalUsedTypes) {
pType = this.pGlobalUsedTypes[i];
this.pTypesByName[pType.sRealName] = pType;
this.pTypesBlock[pType.sRealName] = pType.toCode();

}

this.pFuncBlock =  {};
this.pFuncByDef =  {};
var pFunc;
for (i in this.pFunctions) {
pFunc = this.pFunctions[i];
this.pFuncByDef[pFunc._sDefinition] = pFunc;
this.pFuncBlock[pFunc._sDefinition] = pFunc.toCode(true);

}

this.pBuffersBlock =  {};
this.pBuffersByRealName =  {};
this.pBuffersByName =  {};
var pBuf;
for (i in this.pGlobalBuffers) {
pBuf = this.pGlobalBuffers[i];
pVar = pBuf.pVar;
pVar.sRealName = (pVar.sSemantic) || (pVar.sRealName);
this.pBuffersByName[pVar.sName] = pVar.sRealName;
this.pBuffersByRealName[pVar.sRealName] = pBuf;

}

if ((this) instanceof EffectVertex) {
this.pAttrBuffers =  {};
for (i in this._pAttrSemantics) {
pVar = this._pAttrSemantics[i];
if ((pVar.isPointer) !== false) {
this.pAttrBuffers[i] = pVar.pBuffer;

}


}


}

if ((!(this._sCodeAll)) && (!(this._pCodeAll))) {
this.generateExtractedCode();

}

if (this._sCodeAll) {
return this._sCodeAll;

}

var sCode="";
var pCode=null;
var pElement;
var pToCode;
for (i = 0; i < (this._pCodeAll.length); i++) {
pElement = this._pCodeAll[i];
if ((typeof pElement) === "string") {
sCode += pElement;

}
else  {
if ((!((pElement._isSampler) && ((pElement.iScope) === (a.fx.GLOBAL_VARS.GLOBAL)))) && ((pElement.pData) === undefined)) {
pToCode = (pElement instanceof EffectBaseFunction? pElement.toCode() : pElement.toCode(true));
if ((typeof pToCode) === "string") {
sCode += pToCode;

}
else  {
if (!0) {
var err=((((((("Error:: " + "extrct function don`t work as expected") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("extrct function don`t work as expected");

}


}

;
return ;

}


}
else  {
if (!pCode) {
pCode = [];

}

if (sCode !== "") {
pCode.push(sCode);

}

pCode.push(pElement);
sCode = "";

}


}


}

if (sCode !== "") {
if (!pCode) {
this._sCodeAll = sCode;

}
else  {
pCode.push(sCode);

}


}

if (pCode) {
this._pCodeAll = pCode;

}
else  {
this._sCodeAll = sCode;

}

this._isReady = true;

};
EffectShader.prototype.generateGlobalPointers = function() {
var i, j;
var pPointers;
for (i in this.pGlobalsByRealName) {
pPointers = this.pGlobalsByRealName[i].pPointers;
for (j = 0; j < (pPointers.length); j++) {
pPointers[j].sRealName = null;
this.pGlobalPointers[pPointers[j].toCode()] = pPointers[j];

}


}


};
EffectShader.prototype.toFinal = function() {
if (!(this._isReady)) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "][") + "") + "]") + "You must use postAnalyzeEffect before");
return false;

}

if (this._sCodeAll) {
return this._sCodeAll;

}
else  {
var sCode="";
var pCode=this._pCodeAll;
var i;
for (i = 0; i < (pCode.length); i++) {
if ((typeof (pCode[i])) === "string") {
sCode += pCode[i];

}
else  {
sCode += pCode[i].toDataCode();

}


}

return sCode;

}


};
EffectShader.prototype._extractAttrSubData = function(pData) {
var i, j;
var nLength=pData.length;
var pSubData;
for (i = 0; i < nLength; i++) {
pSubData = this._pAttrDataInit[pData[i]];
if (pSubData.isComplex) {
this._extractAttrSubData(pSubData);
pData = pData.concat(pSubData);
pData.isComplex = true;

}


}


};
function EffectVertex(pFunction) {
var _pCtorValue=EffectVertex.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pVaryings = [];
this._pVaryingsSemantics =  {};
this._pAttributes = [];
this._pAttrSemantics =  {};
this._pAttrDataDecl =  {};
this._pAttrIndexDecl =  {};
this._pAttrDataInit =  {};
this._pAttrIndexInit =  {};

}

a.extend(EffectVertex, EffectShader);
EffectVertex.prototype.addVarying = function(pVar) {
if (this._pVaryingsSemantics[pVar.sSemantic]) {
if (!0) {
var err=((((((("Error:: " + "don`t do so bad things") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("don`t do so bad things");

}


}

;

}

var pNewVar=pVar.cloneMe();
pNewVar.sRealName = (pNewVar.sSemantic) + "_VAR";
this._pVaryingsSemantics[pNewVar.sSemantic] = pNewVar;
this._pVaryings.push(pNewVar);

};
EffectVertex.prototype.createReturnVar = function(pType) {
this.pReturnVariable = new EffectVariable();
this.pReturnVariable.sName = a.fx.GLOBAL_VARS.SHADEROUT;
this.pReturnVariable.pType = pType.cloneMe();

};
EffectVertex.prototype.addAttribute = function(pVar, pEffect) {
var pAttr;
if (!(pVar.isVSInput)) {
pAttr = pVar.cloneMe();
pVar.sRealName = pVar.sSemantic;
pAttr.isUsed = pVar.isUsed;
pAttr.iScope = pVar.iScope;
pAttr.sRealName = pAttr.sSemantic;
this._pAttributes.push(pAttr);
this._pAttrSemantics[pAttr.sSemantic] = pAttr;
return ;

}

var i;
var pVars=pVar.pType.pEffectType.pDesc.pOrders;
var pScope=pEffect._ppScopes[pVar.iScope].pStructTable;
var sName;
for (i = 0; i < (pVars.length); i++) {
sName = ((pVar.sName) + ".") + (pVars[i].sName);
this.addAttribute(pScope[sName], pEffect);

}


};
EffectVertex.prototype.addAttributeDecl = function(pAttr, pEffect) {
var sRealName=pAttr.toCode();
if (!(pAttr.isUsed)) {
return false;

}

this._pAttrDataDecl[sRealName] = pAttr.toCodeDecl();
if ((pAttr.isPointer) === false) {
return true;

}

var i;
var pPointer;
this._pAttrIndexDecl[sRealName] = "";
for (i = 0; i < (pAttr.pPointers.length); i++) {
pPointer = pAttr.pPointers[i];
pPointer.sRealName = null;
this._pAttrIndexDecl[sRealName] += ("float " + (pPointer.toCode())) + ";";

}

if (pAttr._pAllPointers) {
for (i = pAttr.pPointers.length; i < (pAttr._pAllPointers.length); i++) {
pPointer = pAttr._pAllPointers[i];
sRealName = pPointer.pVar.toCode(true);
if ((this._pAttrIndexDecl[sRealName]) === undefined) {
this._pAttrIndexDecl[sRealName] = "";

}

pPointer.sRealName = null;
this._pAttrIndexDecl[sRealName] += ("float " + (pPointer.toCode())) + ";";

}


}

if ((this._pExtractFunctions) === null) {
this._pExtractFunctions =  {};

}

pEffect._extractVariableData(pAttr, this._pAttrDataInit, pAttr.pBuffer, this, a.fx.GLOBAL_VARS.INOBJECT);
pEffect._extractVariableIndex(pAttr, this._pAttrIndexInit, pAttr.pBuffer, a.fx.GLOBAL_VARS.INOBJECT, true);

};
EffectVertex.prototype.generateDefinitionCode = function(id, iEffectId) {
this.sRealName = (((a.fx.GLOBAL_VARS.VERTEXPREFIX) + id) + "_") + iEffectId;
this._sDefinition = ("void " + (this.sRealName)) + "()";

};
EffectVertex.prototype.setAttributeUsed = function(pVar, pEffect) {
var pAttr;
var sSemantic;
if (!(pVar.isVSInput)) {
sSemantic = (pVar.pVar? pVar.pVar.sSemantic : pVar.sSemantic);
pAttr = this._pAttrSemantics[sSemantic];
pAttr.isUsed = pVar.isUsed;
pAttr.iScope = pVar.iScope;
pEffect._getAllPointers(pAttr);
this.addAttributeDecl(pAttr, pEffect);
return ;

}

var i;
var pVars=pVar.pType.pEffectType.pDesc.pOrders;
var pScope=pEffect._ppScopes[pVar.iScope].pStructTable;
var sName;
for (i = 0; i < (pVars.length); i++) {
sName = ((pVar.sName) + ".") + (pVars[i].sName);
this.setAttributeUsed(pScope[sName], pEffect);

}


};
function EffectFragment(pFunction) {
var _pCtorValue=EffectFragment.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pCode = [];
this._pVaryings = [];
this._pVaryingsSemantics =  {};

}

a.extend(EffectFragment, EffectShader);
EffectFragment.prototype.createTwinIn = function() {
if (!(this.pMainInputVar)) {
if (!0) {
var err=((((((("Error:: " + "Twin available only for Vertex Shader with Struct Attrib") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Twin available only for Vertex Shader with Struct Attrib");

}


}

;
return ;

}

this.pTwin = this.pMainInputVar.cloneMe();
this.pTwin.sName = (this.pTwin.sName) + "_clone";

};
EffectFragment.prototype.addVarying = function(pVar) {
var pVary;
if (!(pVar.isFSInput)) {
pVary = pVar.cloneMe();
pVar.sRealName = pVar.sSemantic;
pVary.sName = pVary.sSemantic;
pVary.sRealName = (pVary.sSemantic) + "_VAR";
this._pVaryings.push(pVary);
this._pVaryingsSemantics[pVary.sSemantic] = pVary;
return ;

}

var i;
var pVars=pVar.pType.pEffectType.pDesc.pOrders;
for (i = 0; i < (pVars.length); i++) {
pVary = pVars[i].cloneMe();
pVary.sName = pVary.sSemantic;
pVary.sRealName = (pVary.sSemantic) + "_VAR";
this._pVaryings.push(pVary);
this._pVaryingsSemantics[pVary.sSemantic] = pVary;

}


};
EffectFragment.prototype.generateDefinitionCode = function(id, iEffectId) {
this.sRealName = (((a.fx.GLOBAL_VARS.FRAGMENTPREFIX) + id) + "_") + iEffectId;
this._sDefinition = ("void " + (this.sRealName)) + "()";

};
function EffectTechnique(pEffect) {
this.pPasses = [];
this.pPassesNames =  {};
this.isPostEffect = false;
this.pAnnotation = null;
this.sName = "";
this._isComplexName = false;
this.sComponents = null;
this.pComponents = null;
this.pComponentsShift = null;
this.pExteranalsFragment = null;
this.pExteranalsVertex = null;
this.pEffect = pEffect;

}

EffectTechnique.prototype.addPass = function(pPass) {
this.pPasses.push(pPass);
if (this.pPassesNames[pPass.sName]) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "][") + "") + "]") + "You tru add pass with the same name. It sounds not good(");

}

this.pPassesNames[pPass.sName] = pPass;

};
EffectTechnique.prototype.setName = function(sName) {
this.sName = sName;

};
EffectTechnique.prototype.addSemantic = function(sSemantic) {
sSemantic = sSemantic.toUpperCase();
if (sSemantic === "POSTEFFECT") {
this.isPostEffect = true;

}
else if (sSemantic === "EFFECT") {
this.isPostEffect = false;

}
else  {
if (!0) {
var err=((((((("Error:: " + "bad 301") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 301");

}


}

;
return ;

}



};
EffectTechnique.prototype.addAnnotation = function(pAnnotation) {
this.pAnnotation = pAnnotation;

};
EffectTechnique.prototype.hasComplexName = function(isComplex) {
if (isComplex) {
this._isComplexName = isComplex;

}

return this._isComplexName;

};
EffectTechnique.prototype.generateListOfExternals = function() {
var i, j;
var pExV, pExF;
this.pExteranalsFragment =  {};
this.pExteranalsVertex =  {};
for (i = 0; i < (this.pPasses.length); i++) {
pExV = this.pPasses[i].pExteranalsVertex;
pExF = this.pPasses[i].pExteranalsFragment;
for (j in pExV) {
this.pExteranalsVertex[j] = pExV[j];

}

for (j in pExF) {
this.pExteranalsFragment[j] = pExF[j];

}


}


};
EffectTechnique.prototype.addComponent = function(pComponent, nShift) {
nShift = nShift || 0;
if ((!(this.sComponents)) || (!(this.pComponents))) {
this.sComponents = "";
this.pComponents = [];
this.pComponentsShift = [];

}

this.sComponents += (((pComponent.findResourceName()) + ">>") + nShift) + "&";
this.pComponents.push(pComponent);
this.pComponentsShift.push(nShift);
var i;
for (i in pComponent.pExteranalsVertex) {
this.pEffect.addExternalVar(pComponent.pExteranalsVertex[i], a.fx.GLOBAL_VARS.EXTERNAL_V);

}

for (i in pComponent.pExteranalsFragment) {
this.pEffect.addExternalVar(pComponent.pExteranalsVertex[i], a.fx.GLOBAL_VARS.EXTERNAL_F);

}


};
EffectTechnique.prototype.finalize = function() {
if ((!(this._isComplexName)) && (this.pEffect._sProvideNameSpace)) {
this.sName = ((this.pEffect._sProvideNameSpace) + ".") + (this.sName);

}

if ((this.pEffect.sComponents) || (this.pEffect.pComponents)) {
this.sComponents = (this.pEffect.sComponents) + (((this.sComponents) !== null? this.sComponents : ""));
if (this.pComponents) {
this.pComponents = this.pEffect.pComponents.concat(this.pComponents);

}
else  {
this.pComponents = this.pEffect.pComponents.concat();

}


}


};
function EffectPass() {
this.sVertex = "";
this.sFragment = "";
this.pStates =  {};
this.pVertexShader = null;
this.pFragmentShader = null;
this.sName = "";
this.sRealName = "";
this.pAnnotation = null;
this.sJSCode = "";
this.pJSStates = null;
this.pGlobalVariables = null;
this.pGlobalsByName = null;
this.pGlobalsByRealName = null;
this.pGlobalsDefault = null;
this.pTexturesByName = null;
this.pTexturesByRealName = null;
this.pGlobalsStrict = null;
this.isComplex = false;
this.pGlobalValues = null;
this.pFuncHash = null;
this.pCode = [];
this.pFragments =  {};
this.pVertexes =  {};
this.pExteranalsFragment = null;
this.pExteranalsVertex = null;
this._fnEval = null;
this.isEval = false;

}

EffectPass.prototype.setVertexShader = function(pParam) {
if ((typeof pParam) === "string") {
this.sVertexName = pParam;

}
else  {
this.pVertexShader = pParam;

}


};
EffectPass.prototype.setFragmentShader = function(pParam) {
if ((typeof pParam) === "string") {
this.sFragmentName = pParam;

}
else  {
this.pFragmentShader = pParam;

}


};
EffectPass.prototype.setJSVertexShader = function(pFunc) {
if (!(this.pFuncHash)) {
this.pFuncHash =  {};

}

this.pFuncHash[pFunc.hash()] = pFunc;
this.pushCode(("me.sVertex=\"" + (pFunc.hash())) + "\";");

};
EffectPass.prototype.setJSFragmentShader = function(pFunc) {
if (!(this.pFuncHash)) {
this.pFuncHash =  {};

}

this.pFuncHash[pFunc.hash()] = pFunc;
this.pushCode(("me.sFragment=\"" + (pFunc.hash())) + "\";");

};
EffectPass.prototype.addGlobalVariable = function(pVar) {
if (!(this.pGlobalVariables)) {
this.pGlobalVariables =  {};

}

this.pGlobalVariables[pVar.sName] = pVar;

};
EffectPass.prototype.finalize = function() {
this._fnEval = new Function("me", "engine", "uniformValues", this.sJSCode);
if (this.isComplex) {
this.sJSCode = "";

}


};
EffectPass.prototype.prepare = function(pEngineStates, pUniforms) {
"use strict";
this.pStates =  {};
this.sFragment = null;
this.sVertex = null;
if ((this.isComplex) && ((!pEngineStates) && (!pUniforms))) {
if (!0) {
var err=((((((("Error:: " + "Place value of all variables") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Place value of all variables");

}


}

;
return ;

}

this._fnEval(this, pEngineStates, pUniforms);
if ((this.sVertex) !== null) {
this.pVertexShader = this.pFuncHash[this.sVertex];

}
else  {
this.pVertexShader = null;

}

if ((this.sFragment) !== null) {
this.pFragmentShader = this.pFuncHash[this.sFragment];

}
else  {
this.pFragmentShader = null;

}


};
EffectPass.prototype.setState = function(eState, eValue) {
this.pStates[eState] = eValue;

};
EffectPass.prototype.setJSState = function(eState, eValue) {
this.pushCode(((("me.pStates[" + eState) + "]=") + eValue) + ";");

};
EffectPass.prototype.addAnnotation = function(pAnnotation) {
this.pAnnotation = pAnnotation;

};
EffectPass.prototype.setName = function(sName) {
this.sName = sName;

};
EffectPass.prototype.checkMe = function() {
return true;

};
EffectPass.prototype.pushCode = function(pCodePart) {
if ((typeof pCodePart) === "string") {
this.sJSCode += pCodePart;
return ;

}

this.sJSCode += pCodePart.toCode();

};
EffectPass.prototype.generateListOfExternals = function() {
var pExV=null, pExF=null;
var i, j;
var pShader;
for (i in this.pVertexes) {
pShader = this.pVertexes[i];
for (j in pShader.pExternals) {
if (!pExV) {
pExV =  {};

}

pExV[j] = pShader.pExternals[j];

}


}

for (i in this.pFragments) {
pShader = this.pFragments[i];
for (j in pShader.pExternals) {
if (!pExF) {
pExF =  {};

}

pExF[j] = pShader.pExternals[j];

}


}

this.pExteranalsVertex = pExV;
this.pExteranalsFragment = pExF;

};
EffectPass.prototype.addGlobalsFromShader = function(pShader) {
if ((!(this.pGlobalsByName)) || (!(this.pGlobalsByRealName))) {
this.pGlobalsByName =  {};
this.pGlobalsByRealName =  {};
this.pGlobalsDefault =  {};
this.pTexturesByName =  {};
this.pTexturesByRealName =  {};

}

var i;
var sName, pVar;
for (i in pShader.pTexturesByName) {
sName = this.pTexturesByName[i] = pShader.pTexturesByName[i];
this.pTexturesByRealName[sName] = null;

}

for (i in pShader.pUniformsByName) {
if (this.pGlobalsByName[i]) {
continue ;

}

sName = pShader.pUniformsByName[i];
this.pGlobalsByName[i] = sName;
this.pGlobalsByRealName[sName] = pShader.pUniformsByRealName[sName];
this.pGlobalsDefault[sName] = pShader.pUniformsDefault[sName];

}


};
EffectPass.prototype.clear = function() {
if (this.isComplex) {
this.pVertexShader = null;
this.pFragmentShader = null;
this.pStates =  {};

}


};
function MemBlock() {
this._pCodeData = null;
this._pCodeIndex = null;
this._pCode = null;
if ((arguments.length) === 1) {
this._pVar = arguments[0];
this._iPointer = -1;
this._pBuffer = arguments[0].pBuffer;
this._pBaseBlock = null;

}
else if ((arguments.length) === 2) {
this._pBaseBlock = arguments[0];
this._iPointer = arguments[1];
this._pVar = arguments[0]._pVar;
this._pBuffer = arguments[0]._pBuffer;

}



}

MemBlock.prototype.toCode = function() {
if (this._pCode) {
return this._pCode;

}

var pCode=[];
var sCode="";
var nPointers=(!(this._pBaseBlock)? (this._pVar.pPointers.length) - 1 : this._iPointer);
var i, j;
var pCodeFr;
var pCodeIndex=(this._pCodeIndex) || (this._pBaseBlock._pCodeIndex);
var pCodeData=(this._pCodeData) || (this._pBaseBlock._pCodeData);
for (i = 0; i < nPointers; i++) {
pCodeFr = pCodeIndex[i];
for (j = 0; j < (pCodeFr.length); j++) {
if ((typeof (pCodeFr[j])) === "string") {
sCode += pCodeFr[j];

}
else  {
if (sCode !== "") {
pCode.push(sCode);

}

pCode.push(pCodeFr[j]);
sCode = "";

}


}


}

if ((pCodeIndex.length) > ((this._pVar.pPointers.length) - 1)) {
for (i = (this._pVar.pPointers.length) - 1; i < (pCodeIndex.length); i++) {
pCodeFr = pCodeIndex[i];
for (j = 0; j < (pCodeFr.length); j++) {
if ((typeof (pCodeFr[j])) === "string") {
sCode += pCodeFr[j];

}
else  {
if (sCode !== "") {
pCode.push(sCode);

}

pCode.push(pCodeFr[j]);
sCode = "";

}


}


}


}

if (sCode !== "") {
pCode.push(sCode);

}

sCode = "";
for (i = 0; i < (pCodeData.length); i++) {
pCodeFr = pCodeData[i];
if ((typeof pCodeFr) === "string") {
sCode += pCodeFr;

}
else  {
if (sCode !== "") {
pCode.push(sCode);

}

pCode.push(pCodeFr);
sCode = "";

}


}

pCode.push(sCode);
sCode = null;
this._pCode = pCode;
return this._pCode;

};
MemBlock.prototype.addIndexData = function(pEffect) {
if (this._pCodeIndex) {
return ;

}

var pVar=this._pVar;
if (!(this._pBaseBlock)) {
this._pCodeIndex = [];
pEffect._extractVariableIndex(pVar, this._pCodeIndex, this._pBuffer, a.fx.GLOBAL_VARS.INARRAY, false);

}
else  {
if (!0) {
var err=((((((("Error:: " + "Index data adds only for base memory blocks") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Index data adds only for base memory blocks");

}


}

;
return ;

}


};
function Effect(pManager, id) {
;
if (!pManager) {
if (!0) {
var err=((((((("Error:: " + "You must set ShaderManager for Effect correct work") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You must set ShaderManager for Effect correct work");

}


}

;
return ;

}

this._pRenderer = pManager;
this._id = id;
this.pParams =  {};
this.pTechniques =  {};
this.pPasses =  {};
this.nStep = 0;
this.pVariables =  {};
this.pAnnotations = [];
this._effectJS =  {};
this._effectJS_Constants =  {};
this._pConstants =  {};
this._isFuncParam = false;
this._isLocal = false;
this._pParseTree = null;
this._pCurrentType = null;
this._pTypeTable =  {};
this._pVariables =  {};
this._pCurrentAnnotation = null;
this._pCurrentStructFields = null;
this._pCurrentStructOrders = null;
this._isCurrentStructMixible = null;
this._pCurrentVar = null;
this._pCodeStack = [];
this._pCode = null;
this._sCode = "";
this._iScope = 0;
this._nScope = 0;
this._pScopeStack = [];
this._ppScopes =  {};
this._pCurrentScope = null;
this._isAnnotation = false;
this._isStruct = false;
this._isParam = false;
this._isFunction = false;
this._isToJS = false;
this._pFunctionTableByHash =  {};
this._pFunctionTableByName =  {};
this._pFunctionBlackList =  {};
this._pShaders =  {};
this._pShadersBlackList =  {};
this.nCurrentDecl = 0;
this._isVertex = false;
this._isFragment = false;
this._isSampler = false;
this._pCurrentFunction = null;
this._sVarName = null;
this._sLastFullName = null;
this._pVarNameStack = null;
this._isNewName = false;
this._isNewComplexName = false;
this._isTypeAnalayzed = false;
this._pExprType = null;
this._nAddr = 0;
this._isStrictMode = false;
this._isWriteVar = false;
this._pCurrentPass = null;
this._pVarPropertyStack = null;
this._pMemReadVars = null;
this._eVarProperty = 0;
this._eFuncProperty = 0;
this._pLastVar = null;
this._nTempStruct = 0;
this._nShaders = 0;
this._sProvideNameSpace = null;
this._pCurrentTechnique = null;
this._pUsedSeamntics =  {};
this.sComponents = null;
this.pComponents = null;
this.pComponentsShift = null;
this._isInLoop = false;
if (!(this.constructor.sTempStructName)) {
this.constructor.sTempStructName = "TEMPSTRUCTNAME_";

}

;
if (!(this.constructor.pBaseFunctionsHash)) {
this.constructor.pBaseFunctionsHash =  {};

}

;
if (!(this.constructor.pBaseFunctionsName)) {
this.constructor.pBaseFunctionsName =  {};

}

;
if (!(this.constructor.pBaseTypes)) {
this.constructor.pBaseTypes =  {"void": new EffectType("void", "void", true, 1), "float": new EffectType("float", "float", true, 1), "int": new EffectType("int", "int", true, 1), "bool": new EffectType("bool", "bool", true, 1), "float2": new EffectType("float2", "vec2", true, 2), "float3": new EffectType("float3", "vec3", true, 3), "float4": new EffectType("float4", "vec4", true, 4), "float2x2": new EffectType("float2x2", "mat2", true, 4), "float3x3": new EffectType("float3x3", "mat3", true, 9), "float4x4": new EffectType("float4x4", "mat4", true, 16), "int2": new EffectType("int2", "ivec2", true, 2), "int3": new EffectType("int3", "ivec3", true, 3), "int4": new EffectType("int4", "ivec4", true, 4), "bool2": new EffectType("bool2", "bvec2", true, 2), "bool3": new EffectType("bool3", "bvec3", true, 3), "bool4": new EffectType("bool4", "bvec4", true, 4), "string": new EffectType("string", "string", true, 1), "texture": new EffectType("texture", "texture", true, 1), "sampler": new EffectType("sampler", "sampler2D", true, 1), "sampler2D": new EffectType("sampler2D", "sampler2D", true, 1), "ptr": new EffectType("ptr", "float", true, 1), "video_buffer": new EffectType("video_buffer", "sampler2D", true, 1)};

}

;
if (!(this.constructor.pVectorSuffix)) {
this.constructor.pVectorSuffix =  {"x": null, "y": null, "z": null, "w": null, "xy": null, "xz": null, "xw": null, "yx": null, "yz": null, "yw": null, "zx": null, "zy": null, "zw": null, "wx": null, "wy": null, "wz": null, "xyz": null, "xyw": null, "xzy": null, "xzw": null, "xwy": null, "xwz": null, "yxz": null, "yxw": null, "yzx": null, "yzw": null, "ywx": null, "ywz": null, "zxy": null, "zxw": null, "zyx": null, "zyw": null, "zwx": null, "zwy": null, "wxy": null, "wxz": null, "wyx": null, "wyz": null, "wzx": null, "wzy": null, "xyzw": null, "xywz": null, "xzyw": null, "xzwy": null, "xwyz": null, "xwzy": null, "yxzw": null, "yxwz": null, "yzxw": null, "yzwx": null, "ywxz": null, "ywzx": null, "zxyw": null, "zxwy": null, "zyxw": null, "zywx": null, "zwxy": null, "zwyx": null, "wxyz": null, "wxzy": null, "wyxz": null, "wyzx": null, "wzxy": null, "wzyx": null, "s": null, "t": null, "st": null, "ts": null, "p": null, "q": null, "pq": null, "qp": null, "r": null, "g": null, "b": null, "a": null, "rg": null, "rb": null, "ra": null, "gr": null, "gb": null, "ga": null, "br": null, "bg": null, "ba": null, "ar": null, "ag": null, "ab": null, "rgb": null, "rga": null, "rbg": null, "rba": null, "rag": null, "rab": null, "grb": null, "gra": null, "gbr": null, "gba": null, "gar": null, "gab": null, "brg": null, "bra": null, "bgr": null, "bga": null, "bar": null, "bag": null, "arg": null, "arb": null, "agr": null, "agb": null, "abr": null, "abg": null, "rgba": null, "rgab": null, "rbga": null, "rbag": null, "ragb": null, "rabg": null, "grba": null, "grab": null, "gbra": null, "gbar": null, "garb": null, "gabr": null, "brga": null, "brag": null, "bgra": null, "bgar": null, "barg": null, "bagr": null, "argb": null, "arbg": null, "agrb": null, "agbr": null, "abrg": null, "abgr": null};

}

;
if (!(this.constructor.fnExtractFunctionToString)) {
this.constructor.fnExtractFunctionToString = function(sVarName, pType, sSampler, sHeader) {

};

}

;
this._initSystemData();

}

Effect.prototype._initSystemData = function() {
if (Effect._isInit) {
return true;

}

this._addSystemFunction("dot", "float", [null, null], ["float", "float2", "float3", "float4"], "dot($1,$2)");
this._addSystemFunction("mul", null, [null, null], ["float", "int", "float2", "float3", "float4"], "$1*$2");
this._addSystemFunction("tex2D", "float4", ["sampler", "float2"], null, "texture2D($1,$2)");
this._addSystemFunction("mod", "float", ["float", "float"], null, "mod($1,$2)");
this._addSystemFunction("floor", "float", ["float"], null, "floor($1)");
this._addSystemFunction("fract", "float", ["float"], null, "fract($1)");
this._addSystemFunction("abs", "float", ["float"], null, "abs($1)");
this._addSystemFunction("normalize", "float", [null], ["float", "float2", "float3", "float4"], "normalize($1)");
this._addSystemFunction("length", null, [null], ["float3", "float4"], "length($1)");
this._addSystemFunction("reflect", null, [null, null], ["float", "float2", "float3", "float4"], "reflect($1,$2)");
this._addSystemFunction("max", null, [null, null], ["float", "float2", "float3", "float4"], "max($1,$2)");
this._addSystemFunction("pow", null, [null, null], ["float", "float2", "float3", "float4"], "pow($1,$2)");
Effect._isInit = true;

};
Effect.prototype._addSystemFunction = function(sName, pReturn, pParamsType, pTemplate, pGLSL) {
var pGLSLExpr=((typeof pGLSL) === "string"? new GLSLExpr(pGLSL) : pGLSL);
if (!(this.constructor.pBaseFunctionsName[sName])) {
this.constructor.pBaseFunctionsName[sName] = [];

}

var i, j;
var pFunc;
var pTypes;
var sHash;
if (pTemplate) {
for (i = 0; i < (pTemplate.length); i++) {
pTypes = [];
for (j = 0; j < (pParamsType.length); j++) {
if ((pParamsType[j]) === null) {
pTypes.push(this.constructor.pBaseTypes[pTemplate[i]]);

}
else  {
pTypes.push(this.constructor.pBaseTypes[pParamsType[j]]);

}


}

pFunc = new EffectFunction(sName, pGLSLExpr, pTypes);
pFunc.pReturnType = (pReturn? this.constructor.pBaseTypes[pReturn] : this.constructor.pBaseTypes[pTemplate[i]]);
sHash = pFunc.calcHash();
if (this.constructor.pBaseFunctionsHash[sHash]) {
if (!0) {
var err=((((((("Error:: " + "bad 193") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 193");

}


}

;
return ;

}

this.constructor.pBaseFunctionsHash[sHash] = pFunc;
this.constructor.pBaseFunctionsName[sName].push(pFunc);

}

return ;

}

if (!pReturn) {
if (!0) {
var err=((((((("Error:: " + "bad 194") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 194");

}


}

;
return ;

}

pTypes = [];
for (j = 0; j < (pParamsType.length); j++) {
if ((pParamsType[j]) === null) {
if (!0) {
var err=((((((("Error:: " + "bad 195") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 195");

}


}

;
return ;

}
else  {
pTypes.push(this.constructor.pBaseTypes[pParamsType[j]]);

}


}

pFunc = new EffectFunction(sName, pGLSLExpr, pTypes);
pFunc.pReturnType = this.constructor.pBaseTypes[pReturn];
sHash = pFunc.calcHash();
if (this.constructor.pBaseFunctionsHash[sHash]) {
if (!0) {
var err=((((((("Error:: " + "bad 196") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 196");

}


}

;
return ;

}

this.constructor.pBaseFunctionsHash[sHash] = pFunc;
this.constructor.pBaseFunctionsName[sName].push(pFunc);
return ;

};
Effect.prototype.evalHLSL = function(pCode, pVar) {
if ((!pCode) || ((pCode.length) === 0)) {
return null;

}

if ((pCode.length) === 1) {
if ((typeof (pCode[0])) === "string") {
return pCode[0];

}


}
else  {
if (!(pVar.pType.isBase())) {
if (!0) {
var err=((((((("Error:: " + "default values only for base types") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("default values only for base types");

}


}

;
return ;

}

var sName=pVar.pType.pEffectType.sName;
var pData;
if (sName === "float2") {
pData = new Float32Array(2);

}
else if (sName === "float3") {
pData = new Float32Array(3);

}
else if (sName === "float4") {
pData = new Float32Array(4);

}
else if (sName === "int2") {
pData = new Int32Array(2);

}
else if (sName === "int3") {
pData = new Int32Array(3);

}
else if (sName === "int4") {
pData = new Int32Array(4);

}
else if (sName === "float2x2") {
pData = new Float32Array(4);

}
else if (sName === "float3x3") {
pData = new Float32Array(9);

}
else if (sName === "float4x4") {
pData = new Float32Array(16);

}
else  {
if (!0) {
var err=((((((("Error:: " + "Eval for another base type are not supported") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Eval for another base type are not supported");

}


}

;
return ;

}









if ((pData.length) !== (pCode.length)) {
if (!0) {
var err=((((((("Error:: " + "Type of var and literal are not same") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Type of var and literal are not same");

}


}

;
return ;

}

for (var i=0; i < (pCode.length); i++) {
pData[i] = pCode[i];

}

return pData;

}

trace("Need to eval this code: ", pCode, pVar, this._pExprType);

};
Effect.prototype.addComponent = function(pComponent, nShift) {
nShift = nShift || 0;
if ((!(this.sComponents)) || (!(this.pComponents))) {
this.sComponents = "";
this.pComponents = [];
this.pComponentsShift = [];

}

this.sComponents += (((pComponent.findResourceName()) + ">>") + nShift) + "&";
this.pComponents.push(pComponent);
this.pComponentsShift.push(nShift);
var i;
for (i in pComponent.pExteranalsVertex) {
this.addExternalVar(pComponent.pExteranalsVertex[i], a.fx.GLOBAL_VARS.EXTERNAL_V);

}

for (i in pComponent.pExteranalsFragment) {
this.addExternalVar(pComponent.pExteranalsVertex[i], a.fx.GLOBAL_VARS.EXTERNAL_F);

}


};
Effect.prototype.addExternalVar = function(pVar, eType) {
var pScopeStack=this._pScopeStack;
var pCurrentScope=this._pCurrentScope;
var iScope=this._iScope;
var pNewVar=pVar.cloneMe();
this._pScopeStack = [a.fx.GLOBAL_VARS.GLOBAL];
this._iScope = a.fx.GLOBAL_VARS.GLOBAL;
this._pCurrentScope = (this._ppScopes[0]) || null;
if (eType === (a.fx.GLOBAL_VARS.EXTERNAL_V)) {
pNewVar.isVertexOnly = true;

}
else  {
pNewVar.isFragmentOnly = true;

}

this.addVariable(pNewVar);
this._pScopeStack = pScopeStack;
this._iScope = pCurrentScope;
this._pCurrentScope = iScope;

};
Effect.prototype.newCode = function() {
this._pCode = [];
this._pCode.isWrite = true;
this._pCodeStack.push(this._pCode);

};
Effect.prototype.endCode = function() {
this._pCodeStack.pop();
var iLen=(this._pCodeStack.length) - 1;
if (iLen < 0) {
this._pCode = null;
return ;

}

this._pCode = (this._pCodeStack[iLen]) || null;

};
Effect.prototype.pushCode = function(pObj) {
if ((this._pCode) && (!(this._pCode.isWrite))) {
return ;

}

this._pCode.push(pObj);

};
Effect.prototype.setWrite = function(isWrite) {
this._pCode.isWrite = isWrite;

};
Effect.prototype.isCodeWrite = function() {
if ((this._pCode) && (this._pCode.isWrite)) {
return true;

}

return false;

};
Effect.prototype.newMemRead = function() {
this._pMemReadVars = [];

};
Effect.prototype.endMemRead = function() {
this._pMemReadVars = null;

};
Effect.prototype.newSampler = function() {
this._isSampler = true;

};
Effect.prototype.endSampler = function() {
this._isSampler = false;

};
Effect.prototype.newVarName = function() {
this._isNewName = true;
if (!(this._pVarNameStack)) {
this._pVarNameStack = [];

}

if (!(this._pVarPropertyStack)) {
this._pVarPropertyStack = [];

}

this._pVarNameStack.push(this._sVarName);
this._pVarPropertyStack.push(this._eVarProperty);
this._sVarName = "";
this._eVarProperty = 0;

};
Effect.prototype.endVarName = function() {
this._isNewName = false;
this._sLastFullName = this._sVarName;
this._sVarName = this._pVarNameStack.pop();
this._eVarProperty = (this._pVarPropertyStack.pop()) || (0);

};
Effect.prototype.newAddr = function() {
this._nAddr = 0;

};
Effect.prototype.endAddr = function() {
this._nAddr = 0;

};
Effect.prototype.newScope = function() {
this._pScopeStack.push(this._nScope);
if ((this._pCurrentFunction) && (this._pCurrentFunction.pScopeStack)) {
this._pCurrentFunction.pScopeStack.push(this._nScope);

}

this._iScope = this._nScope;
this._nScope++;
this._pCurrentScope = null;

};
Effect.prototype.endScope = function() {
if ((this._pCurrentScope) && (this._pCurrentScope.isStrict)) {
this._isStrictMode = false;

}

this._pScopeStack.pop();
this._iScope = this._pScopeStack[(this._pScopeStack.length) - 1];
if ((this._iScope) === undefined) {
this._iScope = -1;

}

this._pCurrentScope = (this._ppScopes[this._iScope]) || null;

};
Effect.prototype.newAnnotation = function() {
this._isAnnotation = true;
this._pCurrentAnnotation =  {};

};
Effect.prototype.endAnnotation = function() {
this._isAnnotation = false;
this._pCurrentAnnotation = null;

};
Effect.prototype.newStruct = function() {
this._isStruct = true;
this._isCurrentStructMixible = true;
this._pCurrentStructFields =  {};
this._pCurrentStructOrders = [];

};
Effect.prototype.endStruct = function() {
this._isStruct = false;
this._isCurrentStructMixible = false;
this._pCurrentStructFields = null;
this._pCurrentStructOrders = null;

};
Effect.prototype.newFunction = function() {
this._isFunction = true;

};
Effect.prototype.endFunction = function() {
this._isFunction = false;
this._isVertex = false;
this._isFragment = false;

};
Effect.prototype.addMemBlock = function(pVar, iPointer) {
if (!(this._pMemReadVars)) {
return ;

}

var pFunction=this._pCurrentFunction;
if (!pFunction) {
if (!0) {
var err=((((((("Error:: " + "You can`t doing something with memory in nonfunction scope") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You can`t doing something with memory in nonfunction scope");

}


}

;
return ;

}

var i;
var index=this._pMemReadVars.length;
var pBlock;
for (i = 0; i < (this._pMemReadVars.length); i++) {
pBlock = this._pMemReadVars[i];
if (((pBlock._pVar) === pVar) && ((pBlock._iPointer) === (-1))) {
return ;

}

if (((pBlock._pVar) === pVar) && ((iPointer === undefined) || ((pBlock._iPointer) > iPointer))) {
index = i;
break ;

}


}

this._pMemReadVars[index] = pFunction.memBlock(pVar, iPointer);

};
Effect.prototype.addBaseVarMemCode = function(pFunction, pBlock, pVar) {
pVar = pVar || (pBlock._pVar);
if (!(pVar.isUsed)) {
return ;

}

if (!(pBlock._pCodeData)) {
pBlock._pCodeData = [];

}

this._extractVariableData(pVar, pBlock._pCodeData, pBlock._pBuffer, pFunction, a.fx.GLOBAL_VARS.INARRAY);

};
Effect.prototype._extractVariableData = function(pVar, pData, pBuffer, pFunction, eMode, pPointer, iPadding) {
if (!(pVar.isUsed)) {
return false;

}

var isArray=false;
var iOffset=0;
var pCode;
var isShader=pFunction instanceof EffectVertex;
if (eMode === (a.fx.GLOBAL_VARS.INARRAY)) {
pCode = pData;

}
else if (eMode === (a.fx.GLOBAL_VARS.INOBJECT)) {
pCode = [];
pData[pVar.toCode(isShader)] = pCode;

}


pPointer = pPointer || (pVar.pPointers[0]);
if (pVar.pType.isBase()) {
if ((pVar.iLength) > 1) {
isArray = true;
iOffset = 0;
pCode.push("for(int i = 0; i <", pVar.iLength, ";i++){");

}

for (var i=0; i < (pVar.iLength); i++) {
pCode.push(pVar);
if (isArray) {
pCode.push("[i]");
iOffset += pVar.pType.pEffectType.iSize;

}

pCode.push("=(");
if ((pVar.pType.isEqual(this.hasType("float"))) || (pVar.pType.isEqual(this.hasType("bool")))) {
pCode.push("A_extractFloat(");
pFunction._pExtractFunctions["float"] = null;

}
else if (pVar.pType.isEqual(this.hasType("int"))) {
pCode.push("int(A_extractFloat(");
pFunction._pExtractFunctions["float"] = null;

}
else if (pVar.pType.isEqual(this.hasType("float2"))) {
pCode.push("A_extractVec2(");
pFunction._pExtractFunctions["float"] = null;
pFunction._pExtractFunctions["vec2"] = null;

}
else if (pVar.pType.isEqual(this.hasType("float3"))) {
pCode.push("A_extractVec3(");
pFunction._pExtractFunctions["float"] = null;
pFunction._pExtractFunctions["vec3"] = null;

}
else if (pVar.pType.isEqual(this.hasType("float4"))) {
pCode.push("A_extractVec4(");
pFunction._pExtractFunctions["float"] = null;
pFunction._pExtractFunctions["vec4"] = null;

}
else if (pVar.pType.isEqual(this.hasType("int2"))) {
pCode.push("ivec2(A_extractVec2(");
pFunction._pExtractFunctions["float"] = null;
pFunction._pExtractFunctions["vec2"] = null;

}
else if (pVar.pType.isEqual(this.hasType("int3"))) {
pCode.push("ivec3(A_extractVec3(");
pFunction._pExtractFunctions["float"] = null;
pFunction._pExtractFunctions["vec3"] = null;

}
else if (pVar.pType.isEqual(this.hasType("int4"))) {
pCode.push("ivec4(A_extractVec4(");
pFunction._pExtractFunctions["float"] = null;
pFunction._pExtractFunctions["vec4"] = null;

}
else if (pVar.pType.isEqual(this.hasType("bool2"))) {
pCode.push("bvec2(A_extractVec2(");
pFunction._pExtractFunctions["float"] = null;
pFunction._pExtractFunctions["vec2"] = null;

}
else if (pVar.pType.isEqual(this.hasType("bool3"))) {
pCode.push("bvec3(A_extractVec3(");
pFunction._pExtractFunctions["float"] = null;
pFunction._pExtractFunctions["vec3"] = null;

}
else if (pVar.pType.isEqual(this.hasType("bool4"))) {
pCode.push("bvec4(A_extractVec4(");
pFunction._pExtractFunctions["float"] = null;
pFunction._pExtractFunctions["vec4"] = null;

}
else if (pVar.pType.isEqual(this.hasType("float4x4"))) {
pCode.push("A_extractMat4(");
pFunction._pExtractFunctions["float"] = null;
pFunction._pExtractFunctions["vec4"] = null;
pFunction._pExtractFunctions["mat4"] = null;

}
else  {
if (!0) {
var err=((((((("Error:: " + "We don`t support another simple type") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("We don`t support another simple type");

}


}

;
return false;

}












pCode.push(pBuffer.pSampler, ",", pBuffer.pHeader, ",", pPointer);
if (iPadding > 0) {
pCode.push("+float(", pVar.iPadding, ")");

}

if (isArray) {
pCode.push("+float(", iOffset, ")");

}

pCode.push(")");
if (((((pVar.pType.isEqual(this.hasType("float"))) || (pVar.pType.isEqual(this.hasType("float4x4")))) || (pVar.pType.isEqual(this.hasType("float2")))) || (pVar.pType.isEqual(this.hasType("float3")))) || (pVar.pType.isEqual(this.hasType("float4")))) {
pCode.push(");");

}
else if (pVar.pType.isEqual(this.hasType("bool"))) {
pCode.push("!=0.0);");

}
else  {
pCode.push("));");

}



}

if (isArray) {
pCode.push(";");

}


}
else  {
var iScope=pVar.iScope;
var pOrders=pVar.pType.pEffectType.pDesc.pOrders;
var i;
var sName;
var pScope=this._ppScopes[iScope].pStructTable;
var pNewVar;
var isExtract;
if (!pScope) {
if (!0) {
var err=((((((("Error:: " + "Impossible to etract variable") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Impossible to etract variable");

}


}

;
return ;

}

var sPrevName=(pVar.sFullName) || (pVar.sName);
if (eMode === (a.fx.GLOBAL_VARS.INOBJECT)) {
pData[pVar.toCode(isShader)] = [];
pData[pVar.toCode(isShader)].isComplex = true;

}

for (i = 0; i < (pOrders.length); i++) {
sName = (sPrevName + ".") + (pOrders[i].sName);
pNewVar = pScope[sName];
isExtract = false;
if (pNewVar.isPointer) {
isExtract = this._extractVariableData(pNewVar, pData, pBuffer, pFunction, eMode);

}
else  {
isExtract = this._extractVariableData(pNewVar, pData, pBuffer, pFunction, eMode, pPointer, pNewVar.iPadding);

}

if ((eMode === (a.fx.GLOBAL_VARS.INOBJECT)) && isExtract) {
pData[pVar.toCode(isShader)].push(pNewVar.toCode(isShader));

}


}


}

return true;

};
Effect.prototype._extractVariableIndex = function(pVar, pData, pBuffer, eMode, isShader, pPointer) {
if (!(pVar.isUsed)) {
return false;

}

var pCodeIndex;
var i;
if (eMode === (a.fx.GLOBAL_VARS.INARRAY)) {
pCodeIndex = pData;

}
else if (eMode === (a.fx.GLOBAL_VARS.INOBJECT)) {
pCodeIndex = [];
pData[pVar.toCode(isShader)] = pCodeIndex;

}


if (pVar.isPointer) {
if (pPointer) {
var iPadding=((pVar.iPadding) > 0? pVar.iPadding : 0);
if (eMode === (a.fx.GLOBAL_VARS.INARRAY)) {
pCodeIndex.push([pVar.pPointers[(pVar.pPointers.length) - 1], "=A_extractFloat(", pBuffer.pSampler, ",", pBuffer.pHeader, ",", pPointer, "+", iPadding, ".0);"]);

}
else if (eMode === (a.fx.GLOBAL_VARS.INOBJECT)) {
pCodeIndex.push(pVar.pPointers[(pVar.pPointers.length) - 1], "=A_extractFloat(", pBuffer.pSampler, ",", pBuffer.pHeader, ",", pPointer, "+", iPadding, ".0);");

}



}

for (i = (pVar.pPointers.length) - 2; i >= 0; i--) {
if (eMode === (a.fx.GLOBAL_VARS.INARRAY)) {
pCodeIndex.push([pVar.pPointers[i], "=A_extractFloat(", pBuffer.pSampler, ",", pBuffer.pHeader, ",", pVar.pPointers[i + 1], ");"]);

}
else if (eMode === (a.fx.GLOBAL_VARS.INOBJECT)) {
pCodeIndex.push(pVar.pPointers[i], "=A_extractFloat(", pBuffer.pSampler, ",", pBuffer.pHeader, ",", pVar.pPointers[i + 1], ");");

}



}


}

if (!(pVar.pType.isBase())) {
pPointer = (pVar.isPointer? pVar.pPointers[0] : pPointer);
if (pVar._pIndexFields) {
for (i = 0; i < (pVar._pIndexFields.length); i++) {
this._extractVariableIndex(pVar._pIndexFields[i], pData, pBuffer, eMode, isShader, pPointer);

}


}


}


};
Effect.prototype.addVariable = function(pVar, isParams) {
isParams = isParams || false;
function fnExtractStruct(sName, pFirst, iPadding, sPrevRealV, sPrevRealP, pStruct, pTable, iDepth, me, pBufferMap) {
var pOrders=pStruct.pOrders;
var sNewName;
var pPointers;
var pBuffer;
var isPointer;
var sPrev;
var sPrevRealSaveP=sPrevRealP;
var sPrevRealSaveV=sPrevRealV;
var pNewVar;
for (var i=0; i < (pOrders.length); i++) {
sPrevRealP = sPrevRealSaveP;
sPrevRealV = sPrevRealSaveV;
sPrev = (sName + ".") + (pOrders[i].sName);
sNewName = (pFirst.sName) + sPrev;
pBuffer = null;
pPointers = null;
isPointer = false;
pNewVar = new EffectVariableBase(pOrders[i], pFirst, sPrevRealV, me._iScope, sNewName, iPadding);
if (!pNewVar) {
if (!0) {
var err=((((((("Error:: " + "good bad and ugly)") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("good bad and ugly)");

}


}

;
return ;

}

pTable[sNewName] = pNewVar;
if (pOrders[i].isPointer) {
pPointers = [];
for (var j=0; j < (pOrders[i].nDim); j++) {
pPointers.push(new EffectPointer(pNewVar, j, pFirst, sPrevRealSaveP, isParams));

}

if (isParams) {
pBuffer = pBufferMap || (new EffectBuffer());

}

isPointer = true;

}
else  {
if (((!(me._isStrictMode)) && isParams) && (iDepth === 0)) {
isPointer = undefined;
pPointers = [];
pPointers.push(new EffectPointer(pNewVar, 0, pFirst, sPrevRealSaveP, isParams));
pBuffer = pBufferMap || (new EffectBuffer());

}


}

pNewVar.isPointer = isPointer;
pNewVar.pPointers = pPointers;
pNewVar.pBuffer = pBuffer;
if (!(pOrders[i].pType.isBase())) {
sPrevRealP = (sPrevRealP !== ""? (sPrevRealP + "_") + (pOrders[i].sRealName) : pOrders[i].sRealName);
sPrevRealV = (sPrevRealV !== ""? (sPrevRealV + ".") + (pOrders[i].sRealName) : pOrders[i].sRealName);
fnExtractStruct(sPrev, pFirst, (pOrders[i].isPointer? 0 : pOrders[i].iPadding), sPrevRealV, sPrevRealP, pOrders[i].pType.pEffectType.pDesc, pTable, iDepth + 1, me, pBuffer);

}


}


}

if (!(this._hasValidName(pVar))) {
if (!0) {
var err=((((((("Error:: " + "Bad variable name!") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Bad variable name!");

}


}

;
return ;

}

if (this._hasVariableDecl(pVar.sName)) {
if (!0) {
var err=((((((("Error:: " + "Ohhh! You try to redeclarate varibale!") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Ohhh! You try to redeclarate varibale!");

}


}

;
return ;

}

if ((((this._iScope) === (a.fx.GLOBAL_VARS.GLOBAL)) && (!(pVar.pType.isBase()))) && (pVar.pType.pEffectType.pDesc.hasIndexData())) {
if (!0) {
var err=((((((("Error:: " + "Index data support only for attributes") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Index data support only for attributes");

}


}

;
return ;

}

if (!(this._pCurrentScope)) {
this._pCurrentScope =  {};
this._ppScopes[this._iScope] = this._pCurrentScope;

}

if (!(this._pCurrentScope.pVariableTable)) {
this._pCurrentScope.pVariableTable =  {};

}

this._pCurrentScope.pVariableTable[pVar.sName] = pVar;
if (!(pVar.isGlobal)) {
pVar.sRealName = ((((pVar.sName) + "_") + (this._iScope)) + "_") + (this._id);

}
else  {
if ((this._iScope) !== (a.fx.GLOBAL_VARS.GLOBAL)) {
if (!0) {
var err=((((((("Error:: " + "Usage 'global' available only in global scope of effect file") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Usage 'global' available only in global scope of effect file");

}


}

;
return ;

}

pVar.sRealName = pVar.sName;

}

pVar.iScope = this._iScope;
if ((this._iScope) === (a.fx.GLOBAL_VARS.GLOBAL)) {
if (pVar.sSemantic) {
if (!(this._isValidSemantic(pVar.sSemantic))) {
if (!0) {
var err=((((((("Error:: " + ("BAD semantic " + (pVar.sSemantic))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("BAD semantic " + (pVar.sSemantic)));

}


}

;
return ;

}

this._lockSemantic(pVar.sSemantic);

}


}

if (isParams) {
pVar.isParametr = true;

}

if (pVar.pType.isEqual(this.hasType("video_buffer"))) {
if (((this._iScope) !== (a.fx.GLOBAL_VARS.GLOBAL)) && (!(isParams && (pVar.isUniform)))) {
if (!0) {
var err=((((((("Error:: " + "You can not declarate video buffer here") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You can not declarate video buffer here");

}


}

;
return ;

}

pVar.pBuffer = new EffectBuffer(pVar);
pVar.pBuffer.isUniform = true;
this.addBuffer(pVar);

}

if (((pVar.isPointer) === true) || ((isParams && ((pVar.isUniform) === false)) && (pVar.sSemantic))) {
pVar.pPointers = [];
for (var i=0; i < ((pVar.nDim) || 1); i++) {
pVar.pPointers.push(new EffectPointer(pVar, i, null, "", true));

}

if (isParams) {
pVar.pBuffer = new EffectBuffer();
pVar.isPointer = undefined;
pVar.nDim = 1;

}


}

if ((pVar.isSampler()) && (pVar.isArray)) {
pVar.sRealName = ((((pVar.sName) + "_") + (this._iScope)) + "_") + (this._id);
pVar.sSemantic = null;

}

if (!(pVar.pType.isBase())) {
if (!(this._pCurrentScope.pStructTable)) {
this._pCurrentScope.pStructTable =  {};

}

fnExtractStruct("", pVar, 0, "", "", pVar.pType.pEffectType.pDesc, this._pCurrentScope.pStructTable, 0, this);

}


};
Effect.prototype._hasValidName = function(pVar) {
var sName=pVar.sName;
if ((a.fx.NAME_BLACKLIST[sName]) === null) {
return false;

}

return true;

};
Effect.prototype.addBuffer = function(pVar) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "][") + "") + "]") + "addBuffer ---> May be I should not be here");

};
Effect.prototype.hasVariable = function(sName) {
var ppScopes=this._ppScopes;
var pScopeStack=this._pScopeStack;
var i;
for (i = (pScopeStack.length) - 1; i >= 0; i--) {
if (((ppScopes[pScopeStack[i]]) && (ppScopes[pScopeStack[i]].pVariableTable)) && (ppScopes[pScopeStack[i]].pVariableTable[sName])) {
return ppScopes[pScopeStack[i]].pVariableTable[sName];

}


}

return false;

};
Effect.prototype.hasComplexVariable = function(sName) {
var ppScopes=this._ppScopes;
var pScopeStack=this._pScopeStack;
var i;
for (i = (pScopeStack.length) - 1; i >= 0; i--) {
if (((ppScopes[pScopeStack[i]]) && (ppScopes[pScopeStack[i]].pStructTable)) && (ppScopes[pScopeStack[i]].pStructTable[sName])) {
return ppScopes[pScopeStack[i]].pStructTable[sName];

}


}

return false;

};
Effect.prototype._hasVariableDecl = function(sName) {
var pScope=this._pCurrentScope;
if ((pScope && (pScope.pVariableTable)) && (pScope.pVariableTable[sName])) {
return pScope.pVariableTable[sName];

}

return false;

};
Effect.prototype.addType = function(pType) {
if (!(this._pCurrentScope)) {
this._pCurrentScope =  {};
this._ppScopes[this._iScope] = this._pCurrentScope;

}

if (!(this._pCurrentScope.pTypeTable)) {
this._pCurrentScope.pTypeTable =  {};

}

if (this._hasTypeDecl(pType.sName)) {
if (!0) {
var err=((((((("Error:: " + "Ohhh! You try to redifenition type((!") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Ohhh! You try to redifenition type((!");

}


}

;
return ;

}

this._pCurrentScope.pTypeTable[pType.sName] = pType;
pType.sRealName = ((((pType.sName) + "_") + (this._iScope)) + "_") + (this._id);
pType.iScope = this._iScope;
pType.calcHash();
pType.nOrder = this.nCurrentDecl;

};
Effect.prototype.hasType = function(sTypeName) {
var pType=this.isBaseType(sTypeName);
if (pType) {
return pType;

}

var ppScopes=this._ppScopes;
var pScopeStack=this._pScopeStack;
var i;
for (i = (pScopeStack.length) - 1; i >= 0; i--) {
if (((ppScopes[pScopeStack[i]]) && (ppScopes[pScopeStack[i]].pTypeTable)) && (ppScopes[pScopeStack[i]].pTypeTable[sTypeName])) {
return ppScopes[pScopeStack[i]].pTypeTable[sTypeName];

}


}

return false;

};
Effect.prototype._hasTypeDecl = function(sTypeName) {
var pType=this.isBaseType(sTypeName);
if (pType) {
return pType;

}

var pScope=this._pCurrentScope;
if ((pScope && (pScope.pTypeTable)) && (pScope.pTypeTable[sTypeName])) {
return pScope.pTypeTable[sTypeName];

}

return false;

};
Effect.prototype.isBaseType = function(sTypeName) {
return (this.constructor.pBaseTypes[sTypeName]) || false;

};
Effect.prototype.addFunction = function(pFunction) {
var sHash=pFunction.hash();
var pFunc=this._hasFunctionDecl(sHash);
if (pFunc && (pFunc.isSystem)) {
if (!0) {
var err=((((((("Error:: " + "Do not even think///^^^^-->") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Do not even think///^^^^-->");

}


}

;
return ;

}

if (pFunc) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "][") + "") + "]") + "It`s seen bad. You try to redeclarate function");
if ((pFunction.hasImplementation()) && (pFunc.hasImplementation())) {
if (!0) {
var err=((((((("Error:: " + "You should not try to redefinition function") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You should not try to redefinition function");

}


}

;
return ;

}
else if (pFunction.hasImplementation()) {
pFunc.pImplement = pFunction.pImplement;
return ;

}



}

this._pFunctionTableByHash[sHash] = pFunction;
if (!(this._pFunctionTableByName[pFunction.sName])) {
this._pFunctionTableByName[pFunction.sName] = [];

}

this._pFunctionTableByName[pFunction.sName].push(pFunction);
pFunction.sRealName = ((pFunction.sName) + "_") + (this._id);
pFunction.generateDefinitionCode();

};
Effect.prototype.hasFunction = function(sFuncName) {
return (this._pFunctionTableByName[sFuncName]) || false;

};
Effect.prototype._hasFunctionDecl = function(sFuncHash) {
return ((this.isBaseFunction(sFuncHash)) || (this._pFunctionTableByHash[sFuncHash])) || false;

};
Effect.prototype.isBaseFunction = function(sFuncHash) {
return (this.constructor.pBaseFunctionsHash[sFuncHash]) || false;

};
Effect.prototype.findBaseFunction = function(sName, pParams) {
var pFunctions=this.constructor.pBaseFunctionsName[sName];
var pFunc=null;
var i, j;
if (!pFunctions) {
return null;

}

for (i = 0; i < (pFunctions.length); i++) {
if ((pFunctions[i].pTypes.length) === (pParams.length)) {
for (j = 0; j < (pParams.length); j++) {
if (pFunctions[i].pTypes.isEqual(pParams[j])) {
if (!pFunc) {
pFunc = pFunctions[i];
return pFunc;

}


}
else  {
break ;

}


}


}


}

return pFunc;

};
Effect.prototype.findFunction = function(sName, pParams) {
var pFunctions=this._pFunctionTableByName[sName];
var pFunc=null;
var i, j;
if (pFunctions) {
if (pParams === null) {
if ((pFunctions.length) > 1) {
if (!0) {
var err=((((((("Error:: " + "Now so states are not support") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Now so states are not support");

}


}

;
return ;

}

return pFunctions[0];

}

for (i = 0; i < (pFunctions.length); i++) {
if ((pFunctions[i].nParamsNeeded) === (pParams.length)) {
if ((pParams.length) === 0) {
if (!pFunc) {
pFunc = pFunctions[i];

}
else  {
if (!0) {
var err=((((((("Error:: " + "I can`t choose function") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("I can`t choose function");

}


}

;
return ;

}

continue ;

}

for (j = 0; j < (pParams.length); j++) {
if (pFunctions[i].pParamOrders[j].pType.isEqual(pParams[j])) {
if (!pFunc) {
pFunc = pFunctions[i];

}
else  {
if (!0) {
var err=((((((("Error:: " + "I can`t choose function") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("I can`t choose function");

}


}

;
return ;

}


}
else  {
break ;

}


}


}


}

if (pFunc) {
return pFunc;

}


}

pFunctions = this.constructor.pBaseFunctionsName[sName];
if (!pFunctions) {
return null;

}

for (i = 0; i < (pFunctions.length); i++) {
if ((pFunctions[i].pTypes.length) === (pParams.length)) {
for (j = 0; j < (pParams.length); j++) {
if (pFunctions[i].pTypes[j].isEqual(pParams[j])) {
if (!pFunc) {
pFunc = pFunctions[i];
return pFunc;

}


}
else  {
break ;

}


}


}


}

return null;

};
Effect.prototype.addFunctionToBlackList = function(pFunction) {
this._pFunctionTableByHash[pFunction.hash()] = null;
this._pFunctionBlackList[pFunction.hash()] = pFunction;
var pTable=this._pFunctionTableByName[pFunction.sName];
var i;
if ((pTable.length) === 1) {
this._pFunctionTableByName[pFunction.sName] = null;
return ;

}

for (i = 0; i < (pTable.length); i++) {
if ((pTable[i]) === pFunction) {
this._pFunctionTableByName.splice(i, 1);
return ;

}


}


};
Effect.prototype.addShaderToBlackList = function(pShader) {
this._pShadersBlackList[pShader.pFunction.hash()] = pShader;
this._pShaders[pShader.pFunction.hash()] = null;
if (!0) {
var err=((((((("Error:: " + ("bad shader " + (pShader.pFunction.sName))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("bad shader " + (pShader.pFunction.sName)));

}


}

;
return ;

};
Effect.prototype.convertType = function(pNode) {
var pType;
var pChildren=pNode.pChildren;
if ((pNode.sName) === (a.fx.GLOBAL_VARS.T_TYPE_ID)) {
pType = this.hasType(pNode.sValue);
if (!pType) {
if (!0) {
var err=((((((("Error:: " + "bad 116") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 116");

}


}

;
return ;

}

return pType;

}

if ((pNode.sName) === (a.fx.GLOBAL_VARS.STRUCT)) {
pType = this.analyzeStruct(pNode);
return pType;

}

if ((pNode.sValue) === (a.fx.GLOBAL_VARS.T_KW_VOID)) {
pType = this.hasType("void");
return pType;

}

if (((pNode.sName) === (a.fx.GLOBAL_VARS.SCALARTYPE)) || ((pNode.sName) === (a.fx.GLOBAL_VARS.OBJECTTYPE))) {
pType = this.hasType(pChildren[(pChildren.length) - 1].sValue);
if (!pType) {
if (!0) {
var err=((((((("Error:: " + "Something going wrong with type names(") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Something going wrong with type names(");

}


}

;
return ;

}

return pType;

}

if (((pNode.sName) === (a.fx.GLOBAL_VARS.MATRIXTYPE)) || ((pNode.sName) === (a.fx.GLOBAL_VARS.VECTORTYPE))) {
if ((pChildren.length) === 1) {
pType = this.hasType(pChildren[0].sValue);
return pType;

}

var sTypeName;
if ((pNode.sName) === (a.fx.GLOBAL_VARS.MATRIXTYPE)) {
sTypeName = "matrix";
sTypeName += "<" + (this.convertType(pChildren[5]).toCode());
this.newCode();
sTypeName += "," + (this.evalHLSL(this.analyzeExpr(pChildren[3])));
this.endCode();
this.newCode();
sTypeName += "," + (this.evalHLSL(this.analyzeExpr(pChildren[1])));
this.endCode();
sTypeName += ">";

}
else  {
sTypeName = "vector";
sTypeName += "<" + (this.convertType(pChildren[3]).toCode());
this.newCode();
sTypeName += "," + (this.evalHLSL(this.analyzeExpr(pChildren[1])));
this.endCode();
sTypeName += ">";

}

pType = this.hasType(sTypeName);
return pType;

}

if (((pNode.sName) === (a.fx.GLOBAL_VARS.BASETYPE)) || ((pNode.sName) === (a.fx.GLOBAL_VARS.TYPE))) {
return this.convertType(pChildren[0]);

}

return pType;

};
Effect.prototype._isValidSemantic = function(sSemantic) {
if ((a.fx.SEMANTIC_BLACKLIST[sSemantic]) === null) {
return false;

}

if ((this._pUsedSeamntics[sSemantic]) === null) {
return false;

}

return true;

};
Effect.prototype._lockSemantic = function(sSemantic) {
if ((this._iScope) === (a.fx.GLOBAL_VARS.GLOBAL)) {
this._pUsedSeamntics[sSemantic] = null;

}


};
Effect.prototype._getAllPointers = function(pVar) {
if (pVar._pAllPointers) {
return pVar._pAllPointers;

}

if ((!(pVar.isPointer)) && ((pVar.pType.isBase()) || (!(pVar.pType.pEffectType.pDesc.hasIndexData())))) {
return null;

}

var pPointers;
if ((pVar.isPointer) !== false) {
pPointers = pVar.pPointers.concat();

}
else  {
pPointers = [];

}

pVar._pAllPointers = pPointers;
if (pVar.pType.isBase()) {
return pPointers;

}

var sVarName=(pVar.sFullName) || (pVar.sName);
var sName;
var pOrders=pVar.pType.pEffectType.pDesc.pOrders;
var i;
var pStructScope=this._ppScopes[pVar.iScope].pStructTable;
var pNewVar;
var pIndexes=[];
for (i = 0; i < (pOrders.length); i++) {
sName = (sVarName + ".") + (pOrders[i].sName);
pNewVar = pStructScope[sName];
if ((pNewVar.isPointer) || ((!(pNewVar.pType.isBase())) && (pNewVar.pType.pEffectType.pDesc.hasIndexData()))) {
pPointers = pPointers.concat(this._getAllPointers(pNewVar));
pIndexes.push(pNewVar);

}


}

pVar._pAllPointers = pPointers;
pVar._pIndexFields = pIndexes;
return pPointers;

};
Effect.prototype.addConstant = function(pVar) {
if (!(this._pConstants)) {
this._pConstants =  {};

}

this._pConstants[pVar.sName] = pVar;

};
Effect.prototype.clear = function() {
this.pTechniques =  {};
this.pPasses =  {};
this.nStep = 0;
this._pConstants =  {};
this._isLocal = false;
this._pCurrentType = null;
this._pCurrentAnnotation = null;
this._pCurrentStructFields = null;
this._pCurrentStructOrders = null;
this._pCurrentVar = null;
this._pCodeStack = [];
this._pCode = null;
this._iScope = 0;
this._nScope = 0;
this._pScopeStack = [];
this._ppScopes =  {};
this._pCurrentScope = null;
this._isAnnotation = false;
this._isStruct = false;
this._isParam = false;
this._pFunctionTableByHash =  {};
this._pFunctionTableByName =  {};
this._pFunctionBlackList =  {};
this._pShaders =  {};
this._pShadersBlackList =  {};
this.nCurrentDecl = 0;
this._pCurrentFunction = null;
this._sVarName = null;
this._sLastFullName = null;
this._pVarNameStack = null;
this._isNewName = false;
this._isNewComplexName = false;
this._isTypeAnalayzed = false;
this._pExprType = null;
this._nAddr = 0;
this._isStrictMode = false;
this._isWriteVar = false;
this._pCurrentPass = null;
this._pVarPropertyStack = null;
this._pMemReadVars = null;
this._eVarProperty = 0;
this._eFuncProperty = 0;
this._pLastVar = null;

};
Effect.prototype.analyze = function(pTree) {
if (!pTree) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "][") + "") + "]") + "Wrong argument! You must put an object of parse tree class!");
return false;

}

var pRoot=pTree.pRoot;
var time=a.now();
this._pParseTree = pTree;
this.newScope();
this.firstStep();
this.analyzeTypes();
this.preAnalyzeFunctions();
this.preAnalyzeVariables();
this.preAnalyzeTechniques();
this.secondStep();
this.analyzeEffect();
this.postAnalyzeEffect();
this.checkEffect();
this.endScope();
trace("Time of analyzing effect file(without parseing) ", (a.now()) - time);
return true;

};
Effect.prototype.firstStep = function() {
this.nStep = 1;

};
Effect.prototype.secondStep = function() {
this.nStep = 2;

};
Effect.prototype.analyzeTypes = function() {
var pChildren=this._pParseTree.pRoot.pChildren;
var i;
this.nCurrentDecl = 0;
for (i = (pChildren.length) - 1; i >= 0; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.TYPEDECL)) {
this.nCurrentDecl++;
this.analyzeTypeDecl(pChildren[i]);

}


}


};
Effect.prototype.preAnalyzeFunctions = function() {
var pChildren=this._pParseTree.pRoot.pChildren;
var i;
this.nCurrentDecl = 0;
for (i = (pChildren.length) - 1; i >= 0; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.FUNCTIONDECL)) {
this.nCurrentDecl++;
this.analyzeFunctionDecl(pChildren[i]);

}


}


};
Effect.prototype.preAnalyzeVariables = function() {
var pChildren=this._pParseTree.pRoot.pChildren;
var i;
this.nCurrentDecl = 0;
for (i = (pChildren.length) - 1; i >= 0; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.VARIABLEDECL)) {
this.nCurrentDecl++;
this.analyzeVariableDecl(pChildren[i]);

}

if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.VARSTRUCTDECL)) {
this.nCurrentDecl++;
this.analyzeVarStructDecl(pChildren[i]);

}


}


};
Effect.prototype.preAnalyzeTechniques = function() {
var pChildren=this._pParseTree.pRoot.pChildren;
var i;
this.nCurrentDecl = 0;
for (i = (pChildren.length) - 1; i >= 0; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.TECHIQUEDECL)) {
this.nCurrentDecl++;
this.analyzeTechniqueDecl(pChildren[i]);

}


}


};
Effect.prototype.analyzeEffect = function() {
var pChildren=this._pParseTree.pRoot.pChildren;
var i;
this.nCurrentDecl = 0;
for (i = (pChildren.length) - 1; i >= 0; i--) {
this.nCurrentDecl++;
this.analyzeDecl(pChildren[i]);

}


};
Effect.prototype.postAnalyzeEffect = function() {
var isNewDelete=true;
var i, j, k, l;
var pFunction;
while (isNewDelete) {
isNewDelete = false;
for (i in this._pFunctionTableByHash) {
pFunction = this._pFunctionTableByHash[i];
if (!pFunction) {
continue ;

}

for (j in pFunction.pFunctions) {
if (this._pFunctionBlackList[j]) {
this.addFunctionToBlackList(pFunction);
isNewDelete = true;

}


}


}


}
var isNewConstraint=true;
var isVertexOnly, isFragmentOnly;
while (isNewConstraint) {
isNewConstraint = false;
for (i in this._pFunctionTableByHash) {
pFunction = this._pFunctionTableByHash[i];
if (!pFunction) {
continue ;

}

for (j in pFunction.pFunctions) {
isVertexOnly = pFunction.pFunctions[j].isVertexOnly;
isFragmentOnly = pFunction.pFunctions[j].isFragmentOnly;
if (((pFunction.isVertexOnly) === false) && (isVertexOnly === true)) {
pFunction.isVertexOnly = isVertexOnly;
isNewConstraint = true;

}

if (((pFunction.isFragmentOnly) === false) && (isFragmentOnly === true)) {
pFunction.isFragmentOnly = isFragmentOnly;
isNewConstraint = true;

}


}


}


}
for (i in this._pFunctionTableByHash) {
pFunction = this._pFunctionTableByHash[i];
if (!pFunction) {
continue ;

}

if ((pFunction.isVertexOnly) && (pFunction.isFragmentOnly)) {
if (!0) {
var err=((((((("Error:: " + "Function cn`t be used as fragmentOnly and vertexOnly in same time") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Function cn`t be used as fragmentOnly and vertexOnly in same time");

}


}

;
return ;

}


}

var isNew=true;
var pGlobals, pUniforms, pExternals, pBuffers;
while (isNew) {
isNew = false;
for (i in this._pFunctionTableByHash) {
pFunction = this._pFunctionTableByHash[i];
if (!pFunction) {
continue ;

}

for (j in pFunction.pFunctions) {
pGlobals = pFunction.pFunctions[j].pGlobalVariables;
pUniforms = pFunction.pFunctions[j].pUniforms;
pExternals = pFunction.pFunctions[j].pExternals;
pBuffers = pFunction.pFunctions[j].pGlobalBuffers;
if (pFunction.addType(pFunction.pFunctions[j].globalUsedTypes())) {
isNew = true;

}

for (k in pExternals) {
if (pFunction.addExternal(pExternals[k])) {
isNew = true;

}


}

for (k in pUniforms) {
if (pFunction.addUniform(pUniforms[k])) {
isNew = true;

}


}

for (k in pGlobals) {
if (pFunction.addGlobalVariable(pGlobals[k])) {
isNew = true;

}


}

for (k in pBuffers) {
if (pFunction.addGlobalBuffer(pBuffers[k])) {
isNew = true;

}


}


}


}


}
var pBlock;
var pVar;
for (i in this._pFunctionTableByHash) {
pFunction = this._pFunctionTableByHash[i];
if (!pFunction) {
continue ;

}

if ((pFunction._pBaseMemBlocks) && ((pFunction._pExtractFunctions) === null)) {
pFunction._pExtractFunctions =  {};

}

for (j in pFunction._pBaseMemBlocks) {
pBlock = pFunction._pBaseMemBlocks[j];
pVar = pBlock._pVar;
pBlock.addIndexData(this);
if (!(pVar.pType.isBase())) {
if (!0) {
var err=((((((("Error:: " + "We haven`t support non base type yet") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("We haven`t support non base type yet");

}


}

;
return ;

}
else  {
this.addBaseVarMemCode(pFunction, pBlock);

}


}


}

var pShader;
var isVertex;
isNewDelete = true;
while (isNewDelete) {
isNewDelete = false;
for (i in this._pShaders) {
pShader = this._pShaders[i];
if (!pShader) {
continue ;

}

isVertex = pShader instanceof EffectVertex;
for (j in pShader.pFunctions) {
if (((this._pFunctionBlackList[pShader.pFunctions[j].hash()]) || (isVertex && (pShader.pFunctions[j].isFragmentOnly))) || ((!isVertex) && (pShader.pFunctions[j].isVertexOnly))) {
this.addShaderToBlackList(pShader);
isNewDelete = true;
break ;

}


}


}


}
isNew = true;
while (isNew) {
isNew = false;
for (i in this._pShaders) {
pShader = this._pShaders[i];
if (!pShader) {
continue ;

}

pFunction = pShader.pFunction;
if (pFunction.pImplement) {
continue ;

}

for (j in pShader.pFunctions) {
pGlobals = pShader.pFunctions[j].pGlobalVariables;
pUniforms = pShader.pFunctions[j].pUniforms;
pExternals = pShader.pFunctions[j].pExternals;
pBuffers = pShader.pFunctions[j].pGlobalBuffers;
if (pShader.addType(pShader.pFunctions[j].globalUsedTypes())) {
isNew = true;

}

for (k in pExternals) {
if (pShader.addExternal(pExternals[k])) {
isNew = true;

}


}

for (k in pUniforms) {
if (pShader.addUniform(pUniforms[k])) {
isNew = true;

}


}

for (k in pGlobals) {
if (pShader.addGlobalVariable(pGlobals[k])) {
isNew = true;

}


}

for (k in pBuffers) {
if (pFunction.addGlobalBuffer(pBuffers[k])) {
isNew = true;

}


}


}


}


}
for (i in this._pShaders) {
if (!(this._pShaders[i])) {
continue ;

}

this._nShaders++;

}

for (i in this._pShaders) {
if (!(this._pShaders[i])) {
continue ;

}

this._pShaders[i].generateDefinitionCode(this._nShaders, this._id);
this._pShaders[i].generateGlobalPointers();
this._nShaders++;

}

for (i in this._pShaders) {
pShader = this._pShaders[i];
if (!pShader) {
continue ;

}

if ((pShader._pBaseMemBlocks) && ((pShader._pExtractFunctions) === null)) {
pShader._pExtractFunctions =  {};

}

for (j in pShader._pBaseMemBlocks) {
pBlock = pShader._pBaseMemBlocks[j];
pVar = pBlock._pVar;
pBlock.addIndexData(this);
if (!(pVar.pType.isBase())) {
if (!0) {
var err=((((((("Error:: " + "We haven`t support non base type yet") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("We haven`t support non base type yet");

}


}

;
return ;

}
else  {
this.addBaseVarMemCode(pShader, pBlock);

}


}


}

for (i in this._pShaders) {
pShader = this._pShaders[i];
if (!pShader) {
continue ;

}

pShader.toCodeAll(this._id);

}

var pPass;
for (i in this.pTechniques) {
for (j = 0; j < (this.pTechniques[i].pPasses.length); j++) {
pPass = this.pTechniques[i].pPasses[j];
for (k in pPass.pFuncHash) {
pShader = this._pShaders[k];
if (!pShader) {
if (!0) {
var err=((((((("Error:: " + "You pass isn`t valid") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You pass isn`t valid");

}


}

;
return ;

}

pPass.pFuncHash[k] = pShader;
if (pShader instanceof EffectVertex) {
pPass.pVertexes[pShader.pFunction.hash()] = pShader;

}
else  {
pPass.pFragments[pShader.pFunction.hash()] = pShader;

}


}

pPass.generateListOfExternals();
if (!(pPass.isComplex)) {
pPass.prepare();

}


}


}

var sName;
for (i in this.pTechniques) {
for (j = 0; j < (this.pTechniques[i].pPasses.length); j++) {
pPass = this.pTechniques[i].pPasses[j];
for (k in pPass.pFuncHash) {
pShader = this._pShaders[k];
pPass.addGlobalsFromShader(pShader);

}

for (k in pPass.pGlobalVariables) {
pVar = pPass.pGlobalVariables[k];
pVar.sRealName = (pVar.sSemantic) || (pVar.sRealName);
sName = pVar.sRealName;
pPass.pGlobalsByName[k] = sName;
pPass.pGlobalsByRealName[sName] = pVar;
pPass.pGlobalsDefault[sName] = pVar.pDefaultValue;

}


}


}

for (i in this.pTechniques) {
this.pTechniques[i].generateListOfExternals();

}

for (i in this.pTechniques) {
this.pTechniques[i].finalize();

}


};
Effect.prototype.checkEffect = function() {

};
Effect.prototype.analyzeDecl = function(pNode) {
if ((pNode.pAnalyzed) !== undefined) {
return ;

}

switch(pNode.sName) {
case a.fx.GLOBAL_VARS.VARIABLEDECL:
this.analyzeVariableDecl(pNode);
break ;

case a.fx.GLOBAL_VARS.TYPEDECL:
this.analyzeTypeDecl(pNode);
break ;

case a.fx.GLOBAL_VARS.FUNCTIONDECL:
this.analyzeFunctionDecl(pNode);
break ;

case a.fx.GLOBAL_VARS.VARSTRUCTDECL:
this.analyzeVarStructDecl(pNode);
break ;

case a.fx.GLOBAL_VARS.TECHIQUEDECL:
this.analyzeTechniqueDecl(pNode);
break ;

case a.fx.GLOBAL_VARS.USEDECL:
this.analyzeUseDecl(pNode);
break ;

case a.fx.GLOBAL_VARS.PROVIDEDECL:
this.analyzeProvideDecl(pNode);
break ;

case a.fx.GLOBAL_VARS.IMPORTDECL:
this.analyzeImportDecl(pNode);
break ;
}

};
Effect.prototype.analyzeUseDecl = function(pNode) {
var pChildren=pNode.pChildren;
if ((pChildren[0].sValue) === (a.fx.GLOBAL_VARS.T_KW_STRICT)) {
if (!(this._isStrictMode)) {
this._pCurrentScope.isStrict = true;
this._isStrictMode = true;

}


}


};
Effect.prototype.analyzeVariableDecl = function(pNode) {
var pChildren=pNode.pChildren;
var i;
var pVar;
var pType=new VariableType();
this.analyzeUsageType(pChildren[(pChildren.length) - 1], pType);
if (((pType.pEffectType.iScope) === (a.fx.GLOBAL_VARS.GLOBAL)) && (((this._eFuncProperty) === (1)) || ((((this._eFuncProperty) === (2)) || ((this._eFuncProperty) === (3))) && ((this._pCurrentFunction.pFunction.pImplement) === null)))) {
this._pCurrentFunction.addType(pType.pEffectType);

}

if ((pType.isEqual(this.hasType("video_buffer"))) && ((this._iScope) !== (a.fx.GLOBAL_VARS.GLOBAL))) {
if (!0) {
var err=((((((("Error:: " + "Declarations of video buffer are available only in Global scope") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Declarations of video buffer are available only in Global scope");

}


}

;
return ;

}

var isSampler=false;
if (pType.pEffectType.isSampler()) {
isSampler = true;
this.newSampler();
if ((this._iScope) !== (a.fx.GLOBAL_VARS.GLOBAL)) {
if (!0) {
var err=((((((("Error:: " + "Only global samplers support") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Only global samplers support");

}


}

;
return ;

}


}

if (!(pType.checkMe((this._isStruct? a.fx.GLOBAL_VARS.STRUCTUSAGE : -1), (this._isLocal? a.fx.GLOBAL_VARS.LOCALUSAGE : -1)))) {
if (!0) {
var err=((((((("Error:: " + "You sucks. 1") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You sucks. 1");

}


}

;
return ;

}

this._pCurrentType = pType;
for (i = (pChildren.length) - 2; i >= 1; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.VARIABLE)) {
pVar = this.analyzeVariable(pChildren[i]);
pVar.setType(pType);
this.addVariableDecl(pVar);

}


}

this._pCurrentType = null;
if (isSampler) {
this.endSampler();

}

pNode.pAnalyzed = true;

};
Effect.prototype.analyzeUsageType = function(pNode, pType) {
pType = pType || (new VariableType());
var pChildren=pNode.pChildren;
var i;
for (i = (pChildren.length) - 1; i >= 0; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.TYPE)) {
pType.setType(this.convertType(pChildren[i]));

}

if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.USAGE)) {
pType.setUsage(pChildren[i].pChildren[0].sValue);

}


}

return pType;

};
Effect.prototype.analyzeVariable = function(pNode, pVar) {
var pChildren=pNode.pChildren;
if ((this._isAnnotation) || ((this._iScope) > (a.fx.GLOBAL_VARS.GLOBAL))) {
if ((pChildren.length) > 2) {
if (!0) {
var err=((((((("Error:: " + "Bad syntax! Bad variable declaration in annotation or local scope!") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Bad syntax! Bad variable declaration in annotation or local scope!");

}


}

;
return ;

}

if (((pChildren.length) === 2) && ((pChildren[0].sName) !== (a.fx.GLOBAL_VARS.INITIALIZER))) {
if (!0) {
var err=((((((("Error:: " + "Bad syntax! Bad variable declaration in annotation or local scope! Second must be Initializer.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Bad syntax! Bad variable declaration in annotation or local scope! Second must be Initializer.");

}


}

;
return ;

}


}

if (this._isStruct) {
if ((pChildren.length) > 2) {
if (!0) {
var err=((((((("Error:: " + "Bad syntax! Bad variable declaration in struct scope!") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Bad syntax! Bad variable declaration in struct scope!");

}


}

;
return ;

}

if (((pChildren.length) === 2) && ((pChildren[0].sName) !== (a.fx.GLOBAL_VARS.SEMANTIC))) {
if (!0) {
var err=((((((("Error:: " + "Bad syntax! Bad variable declaration in struct scope! Second must be Semantic") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Bad syntax! Bad variable declaration in struct scope! Second must be Semantic");

}


}

;
return ;

}


}

pVar = pVar || (new EffectVariable());
this._pCurrentVar = pVar;
this.analyzeVariableDim(pChildren[(pChildren.length) - 1], pVar);
var i;
var pResult=null;
for (i = (pChildren.length) - 2; i >= 0; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.ANNOTATION)) {
pResult = this.analyzeAnnotation(pChildren[i], pVar);

}
else if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.SEMANTIC)) {
pResult = this.analyzeSemantic(pChildren[i], pVar);

}
else if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.INITIALIZER)) {
pResult = this.analyzeInitializer(pChildren[i], pVar);

}




}

return pVar;

};
Effect.prototype.addVariableDecl = function(pVar) {
if (!(pVar.checkMe())) {
if (!0) {
var err=((((((("Error:: " + "You sucks 2") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You sucks 2");

}


}

;
return ;

}

if (this._isAnnotation) {
pVar.pDefaultValue = this.evalHLSL(pVar.pInitializer);
this._pCurrentAnnotation[pVar.sName] = pVar.sValue;
return true;

}

if (this._isStruct) {
this._pCurrentStructFields[pVar.sName] = pVar;
this._pCurrentStructOrders.push(pVar);
pVar.sRealName = (pVar.sSemantic) || (((pVar.sName) + "_") + (this._id));
if (!(pVar.sSemantic)) {
this._isCurrentStructMixible = false;

}

if (!(pVar.pType.canMixible())) {
this._isCurrentStructMixible = false;

}

return true;

}

if ((this._iScope) === (a.fx.GLOBAL_VARS.GLOBAL)) {
if ((pVar.isConstInit()) === false) {
if (!0) {
var err=((((((("Error:: " + "Don`t do this, bad boy") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Don`t do this, bad boy");

}


}

;
return ;

}

pVar.pDefaultValue = this.evalHLSL(pVar.pInitializer, pVar);
if ((pVar.isConst()) && (pVar.isConstInit())) {
this.addConstant(pVar);

}


}

if (((pVar.sName) === (a.fx.GLOBAL_VARS.SHADEROUT)) && ((this._eFuncProperty) === (2))) {
if (!(pVar.pType.isEqual(this._pCurrentFunction.pReturnType))) {
if (!0) {
var err=((((((("Error:: " + "Type of 'Out' variable are incorrect") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Type of 'Out' variable are incorrect");

}


}

;
return ;

}

this.addVariable(this._pCurrentFunction.pReturnVariable);

}
else  {
this.addVariable(pVar);
if (this.isCodeWrite()) {
this.pushCode(pVar.pType);
this.pushCode(" ");
this.pushCode(pVar);
if (pVar.pInitializer) {
this.pushCode("=");
var i;
var pCode=pVar.pInitializer;
for (i = 0; pCode && (i < (pCode.length)); i++) {
this.pushCode(pCode[i]);

}


}

this.pushCode(";");

}


}


};
Effect.prototype.analyzeVariableDim = function(pNode, pVar) {
pVar = pVar || (new EffectVariable());
var pChildren=pNode.pChildren;
var pCode;
if ((pChildren.length) === 1) {
pVar.sName = pChildren[0].sValue;
return pVar;

}

if ((pChildren.length) === 3) {
if (((!(this._isStruct)) && (!(this._isParam))) && ((this._eFuncProperty) === (0))) {
if (!0) {
var err=((((((("Error:: " + "For variables this are not good") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("For variables this are not good");

}


}

;
return ;

}

pVar.isPointer = true;
pVar.nDim++;

}
else if (((pChildren.length) === 4) && ((pChildren[0].sName) === (a.fx.GLOBAL_VARS.FROMEXPR))) {
pVar.isPointer = true;
pVar.nDim++;
pVar.pBuffer = this.analyzeFromExpr(pChildren[0]);

}
else  {
if (!(pVar.isArray)) {
pVar.isArray = true;

}
else  {
if (!0) {
var err=((((((("Error:: " + "Sorry but glsl does not support multidimensional arrays!") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Sorry but glsl does not support multidimensional arrays!");

}


}

;
return ;

}

this.newCode();
this.analyzeExpr(pChildren[(pChildren.length) - 3]);
pCode = this._pCode;
this.endCode();
pVar.iLength = this.evalHLSL(pCode);

}


this.analyzeVariableDim(pChildren[(pChildren.length) - 1], pVar);
return pVar;

};
Effect.prototype.analyzeFromExpr = function(pNode) {
var pChildren=pNode.pChildren;
var pMem;
if ((pChildren[1].sName) === (a.fx.GLOBAL_VARS.T_NON_TYPE_ID)) {
pMem = this.hasVariable(pChildren[1].sValue);
if (!pMem) {
if (!0) {
var err=((((((("Error:: " + "bad 1") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 1");

}


}

;
return ;

}

if (!(pMem.pBuffer)) {
if (!0) {
var err=((((((("Error:: " + "bad 2") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 2");

}


}

;

}

pMem = pMem.pBuffer;
if ((pMem.isUniform) && ((this._eFuncProperty) !== (0))) {
this._pCurrentFunction.addGlobalBuffer(pMem);

}


}
else  {
pMem = this.analyzeMemExpr(pChildren[1]);

}

this._pExprType = this.hasType("video_buffer");
return pMem;

};
Effect.prototype.analyzeMemExpr = function(pNode) {
var pChildren=pNode.pChildren;
var pMem;
var pVar;
var isCodeWrite;
if ((pChildren[0].sName) === (a.fx.GLOBAL_VARS.T_NON_TYPE_ID)) {
pMem = this.hasVariable(pChildren[0].sValue);
if (!pMem) {
if (!0) {
var err=((((((("Error:: " + "bad 3") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 3");

}


}

;
return ;

}

pMem = pMem.pBuffer;

}
else  {
isCodeWrite = this.isCodeWrite();
this.setWrite(false);
this.analyzeExpr(pChildren[0]);
this.setWrite(isCodeWrite);
if ((this._sLastFullName.indexOf(".")) !== (-1)) {
pVar = this.hasComplexVariable(this._sLastFullName);

}
else  {
pVar = this.hasVariable(this._sLastFullName);

}

if (!pVar) {
if (!0) {
var err=((((((("Error:: " + "Unknown variable 101") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Unknown variable 101");

}


}

;
return ;

}

if (!(pVar.pBuffer)) {
if (!0) {
var err=((((((("Error:: " + "Varibale has no buffer") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Varibale has no buffer");

}


}

;
return ;

}

pMem = pVar.pBuffer;

}

if (!pMem) {
if (!0) {
var err=((((((("Error:: " + "Oh-oh, don`t cool enough") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Oh-oh, don`t cool enough");

}


}

;

}

if (((this._eFuncProperty) === (1)) && (!(pMem.isUniform))) {
throw a.fx.GLOBAL_VARS.ERRORBADFUNCTION;

}

this._pExprType = this.hasType("video_buffer");
if ((pMem.isUniform) && ((this._eFuncProperty) !== (0))) {
this._pCurrentFunction.addGlobalBuffer(pMem);

}

return pMem;

};
Effect.prototype.analyzeAnnotation = function(pNode, pObj) {
this.newAnnotation();
var pChildren=pNode.pChildren;
var i;
for (i = (pChildren.length) - 1; i >= 0; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.VARIABLEDECL)) {
this.analyzeVariableDecl(pChildren[i]);

}


}

pObj.addAnnotation(this._pCurrentAnnotation);
this.endAnnotation();
return pObj;

};
Effect.prototype.analyzeSemantic = function(pNode, pObj) {
var sSemantic=pNode.pChildren[0].sValue;
pObj.addSemantic(sSemantic);
return pObj;

};
Effect.prototype.analyzeInitializer = function(pNode, pVar) {
pVar = pVar || (new EffectVariable());
var pChildren=pNode.pChildren;
var pInit;
this.newCode();
if ((pChildren[(pChildren.length) - 2].sValue) === "{") {
var i;
var iLength=(pVar.iLength) * (this._pCurrentType.pEffectType.iSize);
if ((((pChildren.length) - 3) !== ((iLength * 2) - 1)) && (!((((pChildren.length) - 3) === (iLength * 2)) && ((pChildren[1].sValue) === ",")))) {
if (!0) {
var err=((((((("Error:: " + "Bad constructor") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Bad constructor");

}


}

;

}

for (i = (pChildren.length) - 3; i >= 1; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.INITEXPR)) {
this.analyzeInitExpr(pChildren[i]);

}


}


}
else  {
this.analyzeExpr(pNode.pChildren[0]);

}

pInit = this._pCode;
this.endCode();
pVar.addInitializer(pInit);
return pVar;

};
Effect.prototype.analyzeInitExpr = function(pNode) {
var pChildren=pNode.pChildren;
if ((pChildren[(pChildren.length) - 1].sValue) === "{") {
var i;
for (i = (pChildren.length) - 2; i >= 1; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.INITEXPR)) {
this.analyzeInitExpr(pChildren[i]);

}


}


}
else  {
this.analyzeExpr(pChildren[0]);

}


};
Effect.prototype.analyzeExpr = function(pNode) {
var pChildren=pNode.pChildren;
var pRes;
var pVar;
var pType, pType1, pType2;
var sName=pNode.sName;
var pFunction=this._pCurrentFunction;
var pFunc;
var i, j;
var isNewVar=false;
var isComplexVar=false;
var sTypeName;
var pCodeFragment;
var isWriteMode=false;
var isCodeWrite;
var pCode, pCodeShader, pIndex;
var isFlag=false;
var pTemp=null;
switch(sName) {
case a.fx.GLOBAL_VARS.OBJECTEXPR:
if ((pChildren[(pChildren.length) - 1].sValue) === (a.fx.GLOBAL_VARS.T_KW_STATEBLOCK_STATE)) {
if (!0) {
var err=((((((("Error:: " + "I don`t know what is this") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("I don`t know what is this");

}


}

;
return ;

}

if ((pChildren[(pChildren.length) - 1].sValue) === (a.fx.GLOBAL_VARS.T_KW_COMPILE_FRAGMENT)) {
if (!0) {
var err=((((((("Error:: " + "Frog sucks") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Frog sucks");

}


}

;
return ;

}

if ((pChildren[(pChildren.length) - 1].sValue) === (a.fx.GLOBAL_VARS.T_KW_COMPILE)) {
pFunc = this.findFunction(pChildren[(pChildren.length) - 2].sValue, null);
if (!pFunc) {
if (!0) {
var err=((((((("Error:: " + "yo, error") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("yo, error");

}


}

;
return ;

}

if ((pChildren.length) > 4) {
if (!0) {
var err=((((((("Error:: " + "Sorry but we now don`t support this constructions") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Sorry but we now don`t support this constructions");

}


}

;
return ;

}

return pFunc;

}
else  {
this.analyzeStateBlock(pChildren[0]);
this._pExprType = null;

}

break ;

case a.fx.GLOBAL_VARS.COMPLEXEXPR:
if ((((this._nAddr) > 0) && ((pChildren.length) !== 3)) && ((((pChildren[1].sName) !== (a.fx.GLOBAL_VARS.POSTFIXEXPR)) || ((pChildren[1].sName) !== (a.fx.GLOBAL_VARS.PRIMARYEXPR))) || ((pChildren[1].sName) !== (a.fx.GLOBAL_VARS.COMPLEXEXPR)))) {
if (!0) {
var err=((((((("Error:: " + "Bad for dog 2") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Bad for dog 2");

}


}

;
break ;

}

if ((pChildren.length) === 1) {
this.analyzeExpr(pChildren[(pChildren.length) - 1]);
break ;

}

if (!(((pChildren.length) === 3) && ((((pChildren[1].sName) === (a.fx.GLOBAL_VARS.POSTFIXEXPR)) || ((pChildren[1].sName) === (a.fx.GLOBAL_VARS.COMPLEXEXPR))) || ((pChildren[1].sValue) !== undefined)))) {
this._isNewComplexName = false;

}

if (((pChildren.length) === 3) && ((pChildren[2].sValue) === "(")) {
this.pushCode("(");
this.analyzeExpr(pChildren[1]);
this.pushCode(")");
break ;

}

if ((pChildren[(pChildren.length) - 1].sName) === (a.fx.GLOBAL_VARS.T_NON_TYPE_ID)) {
var pTypes=[];
var pArguments=[];
var pCandidates;
isFlag = null;
for (i = (pChildren.length) - 3; i >= 1; i--) {
if ((pChildren[i].sValue) !== ",") {
this.newCode();
if ((this._eFuncProperty) === (2)) {
if (!(pFunction.isLocalOut)) {
isFlag = false;

}


}

this.analyzeExpr(pChildren[i]);
if ((this._eFuncProperty) === (2)) {
if ((pFunction.isLocalOut) && (isFlag === false)) {
isFlag = true;
pFunction.isLocalOut = false;
if (!pCandidates) {
pCandidates = [];

}

pCandidates.push(i);

}


}

pTypes.push(this._pExprType);
pArguments.push(this._pCode);
this.endCode();

}


}

pFunc = this.findFunction(pChildren[(pChildren.length) - 1].sValue, pTypes);
if (!pFunc) {
if (!0) {
var err=((((((("Error:: " + ("can not find function: " + (pChildren[(pChildren.length) - 1].sValue))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("can not find function: " + (pChildren[(pChildren.length) - 1].sValue)));

}


}

;
return ;

}

pType1 = pFunc.pReturnType;
for (i = 0; pCandidates && (i < (pCandidates.length)); i++) {
pVar = pFunc.pParamOrders[pCandidates[i]];
if ((pVar.isInput()) || ((!(pVar.isInput)) && (!(pVar.isOutput())))) {
pFunction.isLocalOut = true;
break ;

}


}

if (pFunc.isSystem) {
pCodeFragment = pFunc.pGLSLExpr.toGLSL(pArguments);
for (i = 0; i < (pCodeFragment.length); i++) {
this.pushCode(pCodeFragment[i]);

}


}
else  {
this.pushCode(pFunc);
this.pushCode("(");
for (i = 0; i < (pArguments.length); i++) {
for (j = 0; j < (pArguments[i].length); j++) {
this.pushCode(pArguments[i][j]);

}

if (i != ((pArguments.length) - 1)) {
this.pushCode(",");

}


}

this.pushCode(")");
if (((this._eFuncProperty) === (1)) || ((((this._eFuncProperty) === (2)) || ((this._eFuncProperty) === (3))) && ((pFunction.pFunction.pImplement) === null))) {
pFunction.addFunction(pFunc);
if (!(pFunc.isConstant)) {
pFunction.isConstant = false;

}


}


}

this._pExprType = pType1;
break ;

}
else if ((pChildren[(pChildren.length) - 1].sName) === (a.fx.GLOBAL_VARS.T_TYPE_ID)) {
pType1 = this.hasType(pChildren[(pChildren.length) - 1].sValue);
this.pushCode(pType1);

}
else if ((pChildren[(pChildren.length) - 1].sName) === (a.fx.GLOBAL_VARS.BASETYPE)) {
pType1 = this.convertType(pChildren[(pChildren.length) - 1]);
this.pushCode(pType1);

}



this.pushCode("(");
for (i = (pChildren.length) - 3; i >= 1; i--) {
if ((pChildren[i].sValue) === ",") {
this.pushCode(",");

}
else  {
this.analyzeExpr(pChildren[i]);

}


}

this.pushCode(")");
this._pExprType = pType1;
break ;

case a.fx.GLOBAL_VARS.PRIMARYEXPR:
if ((pChildren.length) === 1) {
this.analyzeExpr(pChildren[(pChildren.length) - 1]);
break ;

}

if (this._isNewName) {
if (!0) {
var err=((((((("Error:: " + "something going wrong. maybe you use @some.any but correct - @(some.any)") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("something going wrong. maybe you use @some.any but correct - @(some.any)");

}


}

;
return ;

}

var isNewAddr=false;
if ((this._nAddr) === 0) {
isCodeWrite = this.isCodeWrite();
this.setWrite(false);
this.newAddr();
isNewAddr = true;

}

this._nAddr++;
this.analyzeExpr(pChildren[0]);
if (isNewAddr) {
this.setWrite(isCodeWrite);
if ((this._sLastFullName.indexOf(".")) !== (-1)) {
pRes = this.hasComplexVariable(this._sLastFullName);

}
else  {
pRes = this.hasVariable(this._sLastFullName);

}

if (!pRes) {
if (!0) {
var err=((((((("Error:: " + "oh-ah") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("oh-ah");

}


}

;
break ;

}

if (!(pRes.pBuffer)) {
if (!0) {
var err=((((((("Error:: " + "Previously you must to definite buffer for variable") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Previously you must to definite buffer for variable");

}


}

;
return ;

}

if (((this._eFuncProperty) === (1)) && (!(pRes.pBuffer.isUniform))) {
throw a.fx.GLOBAL_VARS.ERRORBADFUNCTION;
return ;

}

if ((pRes.isPointer) === false) {
if (!0) {
var err=((((((("Error:: " + "only for index") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("only for index");

}


}

;
return ;

}

if ((pRes.isPointer) === undefined) {
pRes.isPointer = true;

}

this._pLastVar = pRes;
if (this._isWriteVar) {
this.addMemBlock(pRes, (this._nAddr) - 1);

}

pRes = pRes.pPointers[(this._nAddr) - 1];
if (!pRes) {
if (!0) {
var err=((((((("Error:: " + "@@@@ - why are you do this") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("@@@@ - why are you do this");

}


}

;
break ;

}

this.pushCode(pRes);
this.endAddr();

}

this._pExprType = this.hasType("ptr");
break ;

case a.fx.GLOBAL_VARS.POSTFIXEXPR:
if (((this._nAddr) > 0) && (((pChildren.length) === 2) || ((pChildren[0].sValue) === "]"))) {
if (!0) {
var err=((((((("Error:: " + "Bad for dog") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Bad for dog");

}


}

;
break ;

}

if ((((pChildren[(pChildren.length) - 1].sName) === (a.fx.GLOBAL_VARS.PRIMARYEXPR)) && ((pChildren.length) !== 2)) || ((pChildren[(pChildren.length) - 1].sName) === (a.fx.GLOBAL_VARS.OBJECTEXPR))) {
if (!0) {
var err=((((((("Error:: " + "Unssuported construction") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Unssuported construction");

}


}

;
return ;

}

if (((pChildren.length) === 2) && ((pChildren[1].sName) === (a.fx.GLOBAL_VARS.PRIMARYEXPR))) {
isWriteMode = this._isWriteVar;
this._isWriteVar = true;
this.analyzeExpr(pChildren[(pChildren.length) - 1]);
this._isWriteVar = isWriteMode;
this.pushCode(pChildren[0].sValue);
this._pExprType = this.hasType("ptr");
return ;

}

isNewVar = false;
isComplexVar = false;
isFlag = false;
if (!(this._isNewComplexName)) {
pTemp = pChildren[(pChildren.length) - 1];
while (true) {
if ((pTemp.sName) === (a.fx.GLOBAL_VARS.COMPLEXEXPR)) {
isFlag = true;
break ;

}

if ((pTemp.sValue) !== undefined) {
break ;

}

pTemp = pTemp.pChildren[(pTemp.pChildren.length) - 1];

}

}

if (isFlag) {
this._isNewComplexName = true;
isComplexVar = true;
isFlag = false;
if ((this._isNewName) && ((this._sVarName) !== "")) {
if (!0) {
var err=((((((("Error:: " + "you are very unlucky or stupid. You can choose)") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("you are very unlucky or stupid. You can choose)");

}


}

;
return ;

}


}
else  {
if (!(this._isNewName)) {
isNewVar = true;
this.newVarName();
if (((this._eFuncProperty) === (2)) || ((this._eFuncProperty) === (3))) {
this.newCode();

}


}


}

this.analyzeExpr(pChildren[(pChildren.length) - 1]);
if (isComplexVar) {
if (this._isNewComplexName) {
isNewVar = true;
this.newVarName();
if (((this._eFuncProperty) === (2)) || ((this._eFuncProperty) === (3))) {
this.newCode();

}

this._sVarName = this._sLastFullName;
this._isTypeAnalayzed = false;

}
else  {
this._isTypeAnalayzed = true;

}

this._isNewComplexName = false;

}

pType1 = this._pExprType;
if ((pChildren.length) === 2) {
this.pushCode(pChildren[0].sValue);

}
else if ((pChildren[(pChildren.length) - 2].sValue) === ".") {
if ((!isComplexVar) || isNewVar) {
this._sVarName += ".";

}

this.pushCode(".");
this.analyzeExpr(pChildren[(pChildren.length) - 3]);
pType1 = this._pExprType;
if ((pChildren.length) === 4) {
if (!isNewVar) {
if (!0) {
var err=((((((("Error:: " + "not this way") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("not this way");

}


}

;
return ;

}

pVar = this.hasComplexVariable(this._sVarName);
if (!pVar) {
if (!0) {
var err=((((((("Error:: " + "bad 50") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 50");

}


}

;
return ;

}

if ((pVar.isPointer) === false) {
if (!0) {
var err=((((((("Error:: " + "bad 51") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 51");

}


}

;
return ;

}

if ((pVar.isPointer) === undefined) {
pVar.isPointer = true;

}

if (isNewVar) {
this.endVarName();
if (((this._eFuncProperty) === (2)) || ((this._eFuncProperty) === (3))) {
this.endCode();

}

isNewVar = false;

}

if (isComplexVar) {
this._isTypeAnalayzed = false;
isComplexVar = false;

}

var pMem=this.analyzeFromExpr(pChildren[0]);
if (!pMem) {
if (!0) {
var err=((((((("Error:: " + "bad 49") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 49");

}


}

;
return ;

}

if (((this._eFuncProperty) === (1)) && (!(pMem.isUniform))) {
throw a.fx.GLOBAL_VARS.ERRORBADFUNCTION;

}

if ((this._iScope) !== (pVar.iScope)) {
if (!0) {
var err=((((((("Error:: " + "bad 52") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 52");

}


}

;
return ;

}

pVar.pBuffer = pMem;
this.addMemBlock(pVar);

}


}
else if ((pChildren[0].sValue) === "]") {
pVar = this._pLastVar;
this.newVarName();
if (pVar.isSampler()) {
if (!(pVar.isArray)) {
if (!0) {
var err=((((((("Error:: " + "Here must be array of samplers") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Here must be array of samplers");

}


}

;
return false;

}

if (((pVar.isParametr) === false) || ((pVar.isUniform) === true)) {
this.newCode();

}


}

this.pushCode("[");
this.analyzeExpr(pChildren[1]);
if (!(this._pExprType.isEqual(this.hasType("int")))) {
if (!0) {
var err=((((((("Error:: " + "bad 107") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 107");

}


}

;
return ;

}

this.pushCode("]");
this.endVarName();
if ((pVar.isSampler()) && (((pVar.isParametr) === false) || ((pVar.isUniform) === true))) {
pIndex = new SamplerIndex(this._pCode, pVar);
this.endCode();
this.pushCode(pIndex);

}
else if ((pType1 !== (a.fx.GLOBAL_VARS.UNDEFINEDTYPE)) && (pType1.isBase())) {
if (pType1.isEqual(this.hasType("float4x4"))) {
pType1 = this.hasType("float4");

}
else if (pType1.isEqual(this.hasType("float3x3"))) {
pType1 = this.hasType("float3");

}
else if (pType1.isEqual(this.hasType("float2x2"))) {
pType1 = this.hasType("float2");

}
else if (((pType1.isEqual(this.hasType("float4"))) || (pType1.isEqual(this.hasType("float3")))) || (pType1.isEqual(this.hasType("float2")))) {
pType1 = this.hasType("float");

}
else if (((pType1.isEqual(this.hasType("int4"))) || (pType1.isEqual(this.hasType("int3")))) || (pType1.isEqual(this.hasType("int2")))) {
pType1 = this.hasType("int");

}
else if (((pType1.isEqual(this.hasType("bool4"))) || (pType1.isEqual(this.hasType("bool3")))) || (pType1.isEqual(this.hasType("bool2")))) {
pType1 = this.hasType("bool");

}
else  {
if (!0) {
var err=((((((("Error:: " + "it`s not an array") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("it`s not an array");

}


}

;
return ;

}







}
else if (pType1 !== (a.fx.GLOBAL_VARS.UNDEFINEDTYPE)) {
if ((!pVar) || (!(pVar.isArray))) {
if (!0) {
var err=((((((("Error:: " + "[] - only for arrays") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("[] - only for arrays");

}


}

;
return ;

}


}




}



if (isNewVar) {
if (((this._eFuncProperty) === (2)) || ((this._eFuncProperty) === (3))) {
pCode = this._pCode;
this.endCode();
isFlag = false;
if (((this._eVarProperty) === (3)) || ((this._eVarProperty) === (2))) {
if (pType1.isBase()) {
for (i = 1; pCode && (i < (pCode.length)); i++) {
if (isFlag === true) {
this.pushCode(pCode[i]);

}
else  {
if ((pCode[i]) === ".") {
isFlag = true;

}


}


}


}
else  {
for (i = 0; pCode && (i < (pCode.length)); i++) {
if ((pCode[i]) === (this._pCurrentFunction.pMainInputVar)) {
if (this.isCodeWrite()) {
if (!(this._pCurrentFunction.pTwin)) {
this._pCurrentFunction.createTwinIn();

}

this.pushCode(this._pCurrentFunction.pTwin);

}


}
else  {
this.pushCode(pCode[i]);

}


}


}

this._eVarProperty = 0;

}
else  {
for (i = 0; pCode && (i < (pCode.length)); i++) {
this.pushCode(pCode[i]);

}


}


}

this.endVarName();

}

if (isComplexVar) {
this._isTypeAnalayzed = false;

}

this._pExprType = pType1;
break ;

case a.fx.GLOBAL_VARS.UNARYEXPR:
if ((pChildren.length) === 1) {
this.analyzeExpr(pChildren[(pChildren.length) - 1]);
break ;

}

this.pushCode(pChildren[(pChildren.length) - 1].sValue);
this.analyzeExpr(pChildren[0]);
if (!(this._pExprType.isBase())) {
if (!0) {
var err=((((((("Error:: " + "bad 106") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 106");

}


}

;
return ;

}

break ;

case a.fx.GLOBAL_VARS.CASTEXPR:
if ((pChildren.length) === 1) {
this.analyzeExpr(pChildren[(pChildren.length) - 1]);
break ;

}

this.pushCode("(");
this.analyzeConstTypeDim(pChildren[2]);
pType = this._pExprType;
this.pushCode("(");
this.analyzeExpr(pChildren[0]);
this.pushCode(")");
this.pushCode(")");
this._pExprType = pType;
if (((pType.iScope) === (a.fx.GLOBAL_VARS.GLOBAL)) && (((this._eFuncProperty) === (1)) || ((((this._eFuncProperty) === (2)) || ((this._eFuncProperty) === (3))) && ((this._pCurrentFunction.pFunction.pImplement) === null)))) {
pFunction.addType(pType);

}

break ;

case a.fx.GLOBAL_VARS.CONDITIONALEXPR:
this.analyzeExpr(pChildren[(pChildren.length) - 1]);
if (!(this._pExprType.isEqual(this.hasType("bool")))) {
if (!0) {
var err=((((((("Error:: " + "bad 105") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 105");

}


}

;
return ;

}

if ((pChildren.length) === 1) {
break ;

}
else  {
this.pushCode("?");
this.analyzeExpr(pChildren[2]);
pType1 = this._pExprType;
this.pushCode(":");
this.analyzeExpr(pChildren[0]);
pType2 = this._pExprType;
if (!(pType1.isEqual(pType2))) {
if (!0) {
var err=((((((("Error:: " + "104") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("104");

}


}

;
return ;

}

this._pExprType = pType1;

}

break ;

case a.fx.GLOBAL_VARS.MULEXPR:
;

case a.fx.GLOBAL_VARS.ADDEXPR:
;

case a.fx.GLOBAL_VARS.RELATIONALEXPR:
;

case a.fx.GLOBAL_VARS.EQUALITYEXPR:
;

case a.fx.GLOBAL_VARS.ANDEXPR:
;

case a.fx.GLOBAL_VARS.OREXPR:
if ((this._isWriteVar) === true) {
if (!0) {
var err=((((((("Error:: " + "you are doing so bad and ugly things(") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("you are doing so bad and ugly things(");

}


}

;
return ;

}

this.analyzeExpr(pChildren[(pChildren.length) - 1]);
pType1 = this._pExprType;
if ((pChildren.length) === 1) {
break ;

}
else  {
this.pushCode((" " + (pChildren[1].sValue)) + " ");
this.analyzeExpr(pChildren[0]);
pType2 = this._pExprType;

}

if ((sName === (a.fx.GLOBAL_VARS.OREXPR)) || (sName === (a.fx.GLOBAL_VARS.ANDEXPR))) {
pType = this.hasType("bool");
if (((pType1 !== (a.fx.GLOBAL_VARS.UNDEFINEDTYPE)) && (pType2 !== (a.fx.GLOBAL_VARS.UNDEFINEDTYPE))) && (!((pType1.isEqual(pType)) && (pType2.isEqual(pType))))) {
if (!0) {
var err=((((((("Error:: " + "bad 101") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 101");

}


}

;
return ;

}

this._pExprType = pType;

}
else if ((sName === (a.fx.GLOBAL_VARS.EQUALITYEXPR)) || (sName === (a.fx.GLOBAL_VARS.RELATIONALEXPR))) {
if (((pType1 !== (a.fx.GLOBAL_VARS.UNDEFINEDTYPE)) && (pType2 !== (a.fx.GLOBAL_VARS.UNDEFINEDTYPE))) && (!(pType1.isEqual(pType2)))) {
if (!0) {
var err=((((((("Error:: " + "bad 102") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 102");

}


}

;
return ;

}

this._pExprType = this.hasType("bool");

}
else if (sName === (a.fx.GLOBAL_VARS.ADDEXPR)) {
if (!((pType1.isBase()) && (pType2.isBase()))) {
if (!0) {
var err=((((((("Error:: " + "bad 103") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad 103");

}


}

;
return ;

}

this._pExprType = pType1;

}



break ;

case a.fx.GLOBAL_VARS.ASSIGNMENTEXPR:
if ((this._isWriteVar) === false) {
this._isWriteVar = true;
isWriteMode = true;

}

this.analyzeExpr(pChildren[(pChildren.length) - 1]);
if (isWriteMode) {
isWriteMode = false;
this._isWriteVar = false;

}

pType1 = this._pExprType;
this.pushCode(pChildren[1].sValue);
this.analyzeExpr(pChildren[0]);
pType2 = this._pExprType;
if ((sName === (a.fx.GLOBAL_VARS.ASSIGNMENTEXPR)) && ((pChildren.length) === 3)) {
this._pExprType = pType1;

}

break ;

case a.fx.GLOBAL_VARS.T_NON_TYPE_ID:
if ((this._eVarProperty) === (1)) {
this.pushCode(pNode.sValue);
return ;

}

pType = (this._pExprType? (this._pExprType.pEffectType? this._pExprType.pEffectType : this._pExprType) : null);
if (this._isTypeAnalayzed) {
if (pType.isBase()) {
if (((this.constructor.pVectorSuffix[pNode.sValue]) === null) && (((((((pType.sName) === "float2") || ((pType.sName) === "float3")) || ((pType.sName) === "float4")) || ((pType.sName) === "int2")) || ((pType.sName) === "int3")) || ((pType.sName) === "int4"))) {
sTypeName = "";
if ((((pType.sName) === "float2") || ((pType.sName) === "float3")) || ((pType.sName) === "float4")) {
sTypeName = "float";

}
else  {
sTypeName = "int";

}

sTypeName += ((pNode.sValue.length) === 1? "" : pNode.sValue.length);
this._pExprType = this.hasType(sTypeName);
pRes = pNode.sValue;

}


}
else  {
pVar = pType.pDesc.hasField(pNode.sValue);
if (!pVar) {
if (!0) {
var err=((((((("Error:: " + "Return type is not enough cool for you.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Return type is not enough cool for you.");

}


}

;
return ;

}

this._pLastVar = pVar;
this._pExprType = pVar.pType;
if (((this._pExprType.pEffectType.iScope) === (a.fx.GLOBAL_VARS.GLOBAL)) && (((this._eFuncProperty) === (1)) || ((((this._eFuncProperty) === (2)) || ((this._eFuncProperty) === (3))) && ((this._pCurrentFunction.pFunction.pImplement) === null)))) {
pFunction.addType(this._pExprType.pEffectType);

}

if (pVar.isMixible) {
if ((this._eVarProperty) === (2)) {
if ((this._eFuncProperty) === (2)) {
pRes = pFunction._pAttrSemantics[pVar.sSemantic];

}
else if ((this._eFuncProperty) === (3)) {
pRes = pFunction._pVaryingsSemantics[pVar.sSemantic];

}


this._eVarProperty = 3;

}
else  {
pRes = pVar.sSemantic;

}


}
else  {
pRes = pNode.sValue;

}


}


}
else if ((((this._sVarName) === "") && (this._isNewName)) || (!(this._isNewName))) {
isNewVar = false;
if (!(this._isNewName)) {
this.newVarName();
isNewVar = true;

}

if ((this._sVarName) && ((this._sVarName.length) > 0)) {
if (!0) {
var err=((((((("Error:: " + "Oh-no") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Oh-no");

}


}

;
return ;

}

this._sVarName = pNode.sValue;
if ((this._sVarName) === (a.fx.GLOBAL_VARS.SYSTEMVAR)) {
if (!(this._pCurrentPass)) {
if (!0) {
var err=((((((("Error:: " + "'engine' variable available only in pass") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("'engine' variable available only in pass");

}


}

;
return ;

}

this._eVarProperty = 1;
pRes = this._sVarName;
this._pExprType = a.fx.GLOBAL_VARS.UNDEFINEDTYPE;

}
else  {
pRes = this.hasVariable(this._sVarName);
if (!pRes) {
if (!0) {
var err=((((((("Error:: " + ("not good for you " + (this._sVarName))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("not good for you " + (this._sVarName)));

}


}

;
return ;

}

if (((pRes.pType.isEqual(this.hasType("video_buffer"))) && ((pRes.iScope) === (a.fx.GLOBAL_VARS.GLOBAL))) && ((this._eFuncProperty) !== (0))) {
pFunction.addGlobalBuffer(pRes);

}

if (pRes.isVertexOnly) {
if ((this._eFuncProperty) === (3)) {
if (!0) {
var err=((((((("Error:: " + "You try use global variable for vertex shader in pixel shader") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You try use global variable for vertex shader in pixel shader");

}


}

;
return ;

}
else if ((this._eFuncProperty) === (1)) {
pFunction.isVertexOnly = true;

}



}
else if (pRes.isFragmentOnly) {
if ((this._eFuncProperty) === (2)) {
if (!0) {
var err=((((((("Error:: " + "You try use global variable for vertex shader in pixel shader") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You try use global variable for vertex shader in pixel shader");

}


}

;
return ;

}
else if ((this._eFuncProperty) === (1)) {
pFunction.isFragmentOnly = true;

}



}


this._pLastVar = pRes;
pRes.isUsed = true;
if ((pRes.isGlobal) && (((this._eFuncProperty) === (1)) || ((((this._eFuncProperty) === (2)) || ((this._eFuncProperty) === (3))) && ((pFunction.pFunction.pImplement) === null)))) {
pFunction.addExternal(pRes);

}

if ((this._isWriteVar) === true) {
if (pRes.isUniform) {
trace(pRes);
if (!0) {
var err=((((((("Error:: " + "don`t even try to do this, bitch.1") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("don`t even try to do this, bitch.1");

}


}

;
return ;

}

if (pRes.isConst()) {
if (!0) {
var err=((((((("Error:: " + "don`t even try to do this, bitch.2") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("don`t even try to do this, bitch.2");

}


}

;
return ;

}

if ((((pRes.isParametr) && pFunction) && ((pFunction.isVertexShader) || (pFunction.isFragmentShader))) && ((this._nAddr) === 0)) {
if (!0) {
var err=((((((("Error:: " + "don`t even try to do this, bitch.3") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("don`t even try to do this, bitch.3");

}


}

;
return ;

}

if ((pFunction && ((pFunction.iScope) === (pRes.iScope))) && ((pRes.isInput()) && (!(pRes.isOutput())))) {
if (!0) {
var err=((((((("Error:: " + "don`t even try to do this, bitch.3") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("don`t even try to do this, bitch.3");

}


}

;

}


}
else if ((this._isWriteVar) === false) {
if ((pFunction && ((pFunction.iScope) === (pRes.iScope))) && ((pRes.isOutput()) && (!(pRes.isInput())))) {
if (!0) {
var err=((((((("Error:: " + "don`t even try to do this, bitch.4") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("don`t even try to do this, bitch.4");

}


}

;
return ;

}


}


if (((((this._eFuncProperty) === (2)) && (pRes === (pFunction.pReturnVariable))) && isNewVar) && ((this._isWriteVar) !== null)) {
pFunction.isLocalOut = true;

}

if (this._pCurrentPass) {
this._pCurrentPass.addGlobalVariable(pRes);
this.pushCode("uniformValues.");

}

if (((this._eFuncProperty) === (2)) && (pRes.isVSInput)) {
this._eVarProperty = 2;
this._pExprType = pRes.pType;
if (isNewVar) {
this.endVarName();
isNewVar = false;
if (!(pFunction.pTwin)) {
pFunction.createTwinIn();

}

this._eVarProperty = 0;
this.pushCode(pFunction.pTwin);
break ;

}


}

if (((this._eFuncProperty) === (3)) && (pRes.isFSInput)) {
this._eVarProperty = 2;
this._pExprType = pRes.pType;
if (isNewVar) {
this.endVarName();
isNewVar = false;
if (!(pFunction.pTwin)) {
pFunction.createTwinIn();

}

this._eVarProperty = 0;
this.pushCode(pFunction.pTwin);
break ;

}


}

if (pFunction && (!(pRes.isConst()))) {
if (((pRes.iScope) === (a.fx.GLOBAL_VARS.GLOBAL)) && (((this._eFuncProperty) === (1)) || ((((this._eFuncProperty) === (2)) || ((this._eFuncProperty) === (3))) && ((pFunction.pFunction.pImplement) === null)))) {
if ((this._isWriteVar) === true) {
pFunction.addGlobalVariable(pRes);

}
else  {
pFunction.addUniform(pRes);

}


}

pFunction.isConstant = false;

}

this._pExprType = pRes.pType;
if (((this._pExprType.pEffectType.iScope) === (a.fx.GLOBAL_VARS.GLOBAL)) && (((this._eFuncProperty) === (1)) || ((((this._eFuncProperty) === (2)) || ((this._eFuncProperty) === (3))) && ((this._pCurrentFunction.pFunction.pImplement) === null)))) {
pFunction.addType(this._pExprType.pEffectType);

}

if (isNewVar) {
this.endVarName();
isNewVar = false;

}


}


}
else  {
if (((this.constructor.pVectorSuffix[pNode.sValue]) === null) && (((((((pType.sName) === "float2") || ((pType.sName) === "float3")) || ((pType.sName) === "float4")) || ((pType.sName) === "int2")) || ((pType.sName) === "int3")) || ((pType.sName) === "int4"))) {
pRes = pNode.sValue;
sTypeName = "";
if ((((pType.sName) === "float2") || ((pType.sName) === "float3")) || ((pType.sName) === "float4")) {
sTypeName = "float";

}
else  {
sTypeName = "int";

}

sTypeName += ((pNode.sValue.length) === 1? "" : pNode.sValue.length);
this._pExprType = this.hasType(sTypeName);

}
else  {
this._sVarName += pNode.sValue;
pRes = this.hasComplexVariable(this._sVarName);
if (!pRes) {
if (!0) {
var err=((((((("Error:: " + ("Not this variable " + (this._sVarName))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("Not this variable " + (this._sVarName)));

}


}

;
return ;

}

this._pLastVar = pRes;
pRes.isUsed = true;
this._pExprType = pRes.pType;
if ((this._eVarProperty) === (2)) {
if ((this._eFuncProperty) === (2)) {
pRes = pFunction._pAttrSemantics[pRes.sName];

}
else if ((this._eFuncProperty) === (3)) {
pRes = pFunction._pVaryingsSemantics[pRes.sName];

}


this._eVarProperty = 3;
pRes.isUsed = true;
this._pExprType = pRes.pType;

}
else  {
pRes = pRes.sName;

}

if (((this._pExprType.pEffectType.iScope) === (a.fx.GLOBAL_VARS.GLOBAL)) && (((this._eFuncProperty) === (1)) || ((((this._eFuncProperty) === (2)) || ((this._eFuncProperty) === (3))) && ((this._pCurrentFunction.pFunction.pImplement) === null)))) {
pFunction.addType(this._pExprType.pEffectType);

}


}


}


if (!pRes) {
if (!0) {
var err=((((((("Error:: " + ("Unknown ID: " + (pNode.sValue))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("Unknown ID: " + (pNode.sValue)));

}


}

;
return ;

}

this.pushCode(pRes);
break ;

case a.fx.GLOBAL_VARS.T_STRING:
;

case a.fx.GLOBAL_VARS.T_UINT:
;

case a.fx.GLOBAL_VARS.T_FLOAT:
;

case a.fx.GLOBAL_VARS.T_KW_TRUE:
;

case a.fx.GLOBAL_VARS.T_KW_FALSE:
this.pushCode(pNode.sValue);
if (sName === (a.fx.GLOBAL_VARS.T_STRING)) {
this._pExprType = this.hasType("string");

}
else if (sName === (a.fx.GLOBAL_VARS.T_UINT)) {
this._pExprType = this.hasType("int");

}
else if (sName === (a.fx.GLOBAL_VARS.T_FLOAT)) {
this._pExprType = this.hasType("float");

}
else  {
this._pExprType = this.hasType("bool");

}



break ;

case a.fx.GLOBAL_VARS.MEMEXPR:
return this.analyzeMemExpr(pNode);
}

};
Effect.prototype.analyzeConstTypeDim = function(pNode) {
var pChildren=pNode.pChildren;
var pType;
if ((pChildren.length) > 1) {
if (!0) {
var err=((((((("Error:: " + "Bad type casting") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Bad type casting");

}


}

;
return ;

}

pType = this.convertType(pChildren[0]);
if (!(this.isBaseType(pType.sName))) {
if (!0) {
var err=((((((("Error:: " + "Don`t suppot so typecasting in webgl") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Don`t suppot so typecasting in webgl");

}


}

;
return ;

}

this.pushCode(pType);
this._pExprType = pType;

};
Effect.prototype.analyzeTypeDecl = function(pNode) {
var pChildren=pNode.pChildren;
var pType=new EffectType();
if ((pChildren.length) === 2) {
pType.fromStruct(this.analyzeStructDecl(pChildren[1]));

}

this.addType(pType);
pNode.pAnalyzed = pType;
if (this.isCodeWrite()) {
this.pushCode(pType);
this.pushCode(";");

}


};
Effect.prototype.analyzeStructDecl = function(pNode, pStruct) {
pStruct = pStruct || (new EffectStruct());
var pChildren=pNode.pChildren;
pStruct.sName = pChildren[(pChildren.length) - 2].sValue;
if (this.hasType(pStruct.sName)) {
if (!0) {
var err=((((((("Error:: " + "Very bad... You try to redefinition type(") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Very bad... You try to redefinition type(");

}


}

;
return ;

}

this.newStruct();
var i;
for (i = (pChildren.length) - 4; i >= 1; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.VARIABLEDECL)) {
this.analyzeVariableDecl(pChildren[i]);

}


}

pStruct.pFields = this._pCurrentStructFields;
pStruct.pOrders = this._pCurrentStructOrders;
pStruct._canMixible = this._isCurrentStructMixible;
this.endStruct();
return pStruct;

};
Effect.prototype.analyzeStruct = function(pNode) {
if (this._isStruct) {
if (!0) {
var err=((((((("Error:: " + "Embedded struct definition") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Embedded struct definition");

}


}

;
return ;

}

var pStruct=new EffectStruct();
var pChildren=pNode.pChildren;
pStruct.sName = (this.constructor.sTempStructName) + (this._nTempStruct);
this._nTempStruct++;
this.newStruct();
var i;
for (i = (pChildren.length) - 4; i >= 1; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.VARIABLEDECL)) {
this.analyzeVariableDecl(pChildren[i]);

}


}

pStruct.pFields = this._pCurrentStructFields;
pStruct.pOrders = this._pCurrentStructOrders;
pStruct._canMixible = this._isCurrentStructMixible;
this.endStruct();
var pType=new EffectType();
pType.fromStruct(pStruct);
this.addType(pType);
pNode.pAnalyzed = pType;
if (this.isCodeWrite()) {
this.pushCode(pType);
this.pushCode(";");

}

return pType;

};
Effect.prototype.analyzeFunctionDecl = function(pNode) {
var pChildren=pNode.pChildren;
var pFunction;
if ((this.nStep) === 1) {
pFunction = this.analyzeFunctionDef(pChildren[(pChildren.length) - 1]);
if ((pChildren[0].sValue) !== ";") {
pFunction.pImplement = true;

}
else  {
pNode.pAnalyzed = true;
return ;

}

var pFunc=this._hasFunctionDecl(pFunction.hash());
if (pFunc) {
if (!0) {
var err=((((((("Error:: " + "You try to redifinition function! Not good!") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You try to redifinition function! Not good!");

}


}

;
return ;

}

this.addFunction(pFunction);

}
else  {
pFunction = this.analyzeFunctionDef(pChildren[(pChildren.length) - 1]);
var pType=pFunction.pReturnType;
var pEffectType=pType.pEffectType;
this._eFuncProperty = 1;
this._pCurrentFunction = pFunction;
this.newScope();
pFunction.iScope = this._iScope;
pFunction.pScopeStack = [this._iScope];
var i, j;
for (i in pFunction.pParameters) {
this.addVariable(pFunction.pParameters[i], true);

}

if ((pChildren.length) === 3) {
this.analyzeAnnotation(pChildren[1], pFunction);

}

try {
this.newCode();
this.analyzeStmtBlock(pChildren[0]);
pFunction.setImplement(this._pCode);
this.endCode();

}
catch(e) {
if (e === (a.fx.GLOBAL_VARS.ERRORBADFUNCTION)) {
while ((this._iScope) !== (pFunction.iScope)) {
this.endScope();

}
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "][") + "") + "]") + ("Bad function: " + (pFunction.sName)));
pFunction.pImplement = null;
this._pCodeStack = [];
this._pCode = null;
this._nAddr = 0;
this._isWriteVar = false;
this._isNewName = false;
this._isNewComplexName = false;
this.addFunctionToBlackList(pFunction);

}
else  {
throw e;

}


}
if (pFunction.isVertexShader) {
if (!(pFunction.checkMe(a.fx.GLOBAL_VARS.VERTEXUSAGE))) {
if (!0) {
var err=((((((("Error:: " + "Vertex is not vertex enough") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Vertex is not vertex enough");

}


}

;

}

this._eFuncProperty = 2;
pFunction.pShader = new EffectVertex(pFunction);
pFunction.pShader.iScope = this._iScope;
pFunction.pShader.pScopeStack = [this._iScope];
this._pCurrentFunction = pFunction.pShader;
var sName, pAttr, pVar, pOrders;
for (i = 0; (pFunction.pParamOrders) && (i < (pFunction.pParamOrders.length)); i++) {
if ((pFunction.pParamOrders[i].isUniform) === false) {
pFunction.pShader.addAttribute(pFunction.pParamOrders[i], this);

}
else  {
pFunction.pShader.addUniform(pFunction.pParamOrders[i]);

}


}

if (pType.isStruct()) {
var pVars=pEffectType.pDesc.pOrders;
for (i = 0; i < (pVars.length); i++) {
if (((pVars[i].sSemantic) !== "POSITION") && ((pVars[i].sSemantic) !== "PSIZE")) {
pFunction.pShader.addVarying(pVars[i]);

}


}

pFunction.pShader.createReturnVar(pFunction.pReturnType);

}

this.newCode();
this.analyzeStmtBlock(pChildren[0]);
pFunction.pShader.setImplement(this._pCode);
this.endCode();
if (this._pShaders[pFunction.hash()]) {
if (!0) {
var err=((((((("Error:: " + "Blyat`") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Blyat`");

}


}

;
return ;

}

this._pShaders[pFunction.hash()] = pFunction.pShader;
for (i = 0; (pFunction.pParamOrders) && (i < (pFunction.pParamOrders.length)); i++) {
if ((pFunction.pParamOrders[i].isUniform) === false) {
pFunction.pShader.setAttributeUsed(pFunction.pParamOrders[i], this);

}


}


}
else if (pFunction.isFragmentShader) {
if (!(pFunction.checkMe(a.fx.GLOBAL_VARS.FRAGMENTUSAGE))) {
if (!0) {
var err=((((((("Error:: " + "Pixel is not pixel enough") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Pixel is not pixel enough");

}


}

;

}

this._eFuncProperty = 3;
pFunction.pShader = new EffectFragment(pFunction);
pFunction.pShader.iScope = this._iScope;
pFunction.pShader.pScopeStack = [this._iScope];
this._pCurrentFunction = pFunction.pShader;
for (i = 0; (pFunction.pParamOrders) && (i < (pFunction.pParamOrders.length)); i++) {
if ((pFunction.pParamOrders[i].isUniform) === false) {
pFunction.pShader.addVarying(pFunction.pParamOrders[i]);

}
else  {
pFunction.pShader.addUniform(pFunction.pParamOrders[i]);

}


}

this.newCode();
this.analyzeStmtBlock(pChildren[0]);
pFunction.pShader.setImplement(this._pCode);
this.endCode();
if (this._pShaders[pFunction.hash()]) {
if (!0) {
var err=((((((("Error:: " + "Blyat` 2") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Blyat` 2");

}


}

;
return ;

}

this._pShaders[pFunction.hash()] = pFunction.pShader;

}


this.endScope();
this._eVarProperty = 0;
this._pCurrentFunction = null;

}


};
Effect.prototype.analyzeFunctionDef = function(pNode, pFunction) {
if ((pNode.pAnalyzed) !== undefined) {
return pNode.pAnalyzed;

}

pFunction = pFunction || (new EffectFunction());
var pChildren=pNode.pChildren;
pFunction.pReturnType = this.analyzeUsageType(pChildren[(pChildren.length) - 1]);
pFunction.setName(pChildren[(pChildren.length) - 2].sValue);
if ((pChildren[0].sName) === (a.fx.GLOBAL_VARS.SEMANTIC)) {
pFunction.addSemantic(pChildren[0].pChildren[0].sValue);
this.analyzeParamList(pChildren[1], pFunction);

}
else  {
this.analyzeParamList(pChildren[0], pFunction);

}

pFunction.calcHash();
pNode.pAnalyzed = pFunction;
return pFunction;

};
Effect.prototype.analyzeStmtBlock = function(pNode) {
var pChildren=pNode.pChildren;
var i;
this.newScope();
this.pushCode("{");
for (i = (pChildren.length) - 2; i >= 1; i--) {
this.analyzeStmt(pChildren[i]);

}

this.pushCode("}");
this.endScope();

};
Effect.prototype.analyzeStmt = function(pNode) {
var pChildren=pNode.pChildren;
var isInLoop;
if ((pChildren.length) === 1) {
this.analyzeSimpleStmt(pChildren[0]);

}
else if ((pChildren[(pChildren.length) - 1].sValue) === (a.fx.GLOBAL_VARS.T_KW_WHILE)) {
this.pushCode("while");
this.pushCode("(");
this.analyzeExpr(pChildren[2]);
this.pushCode(")");
isInLoop = this._isInLoop;
this._isInLoop = true;
this.analyzeStmt(pChildren[0]);
this._isInLoop = isInLoop;

}
else if ((pChildren[(pChildren.length) - 1].sValue) === (a.fx.GLOBAL_VARS.T_KW_FOR)) {
this.pushCode("for");
this.pushCode("(");
this.newScope();
this.analyzeForInit(pChildren[4]);
this.analyzeForCond(pChildren[3]);
this.pushCode(";");
this.analyzeForStep(pChildren[2]);
this.pushCode(")");
isInLoop = this._isInLoop;
this._isInLoop = true;
this.analyzeStmt(pChildren[0]);
this._isInLoop = isInLoop;
this.endScope();

}
else if (((pChildren[(pChildren.length) - 1].sValue) === (a.fx.GLOBAL_VARS.T_KW_IF)) && ((pChildren.length) === 5)) {
this.pushCode("if");
this.pushCode("(");
this.analyzeExpr(pChildren[2]);
this.pushCode(")");
this.analyzeStmt(pChildren[0]);

}
else  {
this.pushCode("if");
this.pushCode("(");
this.analyzeExpr(pChildren[4]);
this.pushCode(")");
this.analyzeNonIfStmt(pChildren[2]);
this.pushCode("else ");
this.analyzeStmt(pChildren[0]);

}





};
Effect.prototype.analyzeForInit = function(pNode) {
pNode = pNode.pChildren[(pNode.pChildren.length) - 1];
var pChildren=pNode.pChildren;
if ((pNode.sName) !== (a.fx.GLOBAL_VARS.VARIABLEDECL)) {
if (!0) {
var err=((((((("Error:: " + "Sorry but webgl support only for-init-statement with variableDecl") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Sorry but webgl support only for-init-statement with variableDecl");

}


}

;
return ;

}

if ((pChildren.length) > 3) {
if (!0) {
var err=((((((("Error:: " + "Sorry but webgl support only for-init-statement with variableDecl") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Sorry but webgl support only for-init-statement with variableDecl");

}


}

;
return ;

}

this.analyzeVariableDecl(pNode);

};
Effect.prototype.analyzeForCond = function(pNode) {
pNode = pNode.pChildren[(pNode.pChildren.length) - 1];
if (((pNode.sName) !== (a.fx.GLOBAL_VARS.RELATIONALEXPR)) && ((pNode.sName) !== (a.fx.GLOBAL_VARS.EQUALITYEXPR))) {
if (!0) {
var err=((((((("Error:: " + "Something going wrong...in for cond") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Something going wrong...in for cond");

}


}

;
return ;

}

this.analyzeExpr(pNode);

};
Effect.prototype.analyzeForStep = function(pNode) {
if (pNode.pChildren) {
pNode = pNode.pChildren[(pNode.pChildren.length) - 1];

}

if (((pNode.sName) !== (a.fx.GLOBAL_VARS.POSTFIXEXPR)) && ((pNode.sName) !== (a.fx.GLOBAL_VARS.ASSIGNMENTEXPR))) {
if (!0) {
var err=((((((("Error:: " + "Something going wrong... in for step") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Something going wrong... in for step");

}


}

;
return ;

}

this.analyzeExpr(pNode);

};
Effect.prototype.analyzeNonIfStmt = function(pNode) {
var pChildren=pNode.pChildren;
var i;
var isInLoop;
if ((pChildren.length) === 1) {
this.analyzeSimpleStmt(pChildren[0]);

}
else if ((pChildren[(pChildren.length) - 1].sValue) === (a.fx.GLOBAL_VARS.T_KW_WHILE)) {
this.pushCode("while");
this.pushCode("(");
this.analyzeExpr(pChildren[2]);
this.pushCode(")");
isInLoop = this._isInLoop;
this._isInLoop = true;
this.analyzeNonIfStmt(pChildren[0]);
this._isInLoop = isInLoop;

}
else if ((pChildren[(pChildren.length) - 1].sValue) === (a.fx.GLOBAL_VARS.T_KW_FOR)) {
this.pushCode("for");
this.pushCode("(");
this.newScope();
this.analyzeForInit(pChildren[4]);
this.analyzeForCond(pChildren[3]);
this.pushCode(";");
this.analyzeForStep(pChildren[2]);
this.pushCode(")");
isInLoop = this._isInLoop;
this._isInLoop = true;
this.analyzeNonIfStmt(pChildren[0]);
this._isInLoop = isInLoop;
this.endScope();

}




};
Effect.prototype.analyzeSimpleStmt = function(pNode) {
var pChildren=pNode.pChildren;
var pFunction=this._pCurrentFunction;
var pCode;
var i;
var isMemRead=false;
var isInLoop;
if ((pChildren[(pChildren.length) - 1].sValue) === ";") {
return ;

}
else if ((pChildren[(pChildren.length) - 1].sName) === (a.fx.GLOBAL_VARS.STMTBLOCK)) {
this.analyzeStmtBlock(pChildren[0]);

}
else if (((pChildren[(pChildren.length) - 1].sValue) === (a.fx.GLOBAL_VARS.T_KW_RETURN)) && ((pChildren.length) === 2)) {
if ((!(pFunction.pReturnType.isVoid())) && ((this._eFuncProperty) === (1))) {
if ((pFunction.isVertexShader) || (pFunction.isFragmentShader)) {
throw a.fx.GLOBAL_VARS.ERRORBADFUNCTION;

}
else  {
if (!0) {
var err=((((((("Error:: " + "It`s not JS, baby.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("It`s not JS, baby.");

}


}

;
return ;

}


}

this.pushCode("return");
this.pushCode(";");

}
else if (((pChildren[(pChildren.length) - 1].sValue) === (a.fx.GLOBAL_VARS.T_KW_RETURN)) && ((pChildren.length) === 3)) {
if (pFunction.pReturnType.isVoid()) {
if (!0) {
var err=((((((("Error:: " + "Can not return anything in void function") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Can not return anything in void function");

}


}

;
return ;

}

if ((this._eFuncProperty) === (1)) {
this.pushCode("return ");
this.analyzeExpr(pChildren[1]);
this.pushCode(";");

}
else if ((this._eFuncProperty) === (2)) {
if (pFunction.pReturnType.isBase()) {
this.pushCode(a.fx.GLOBAL_VARS.SHADEROUT);
this.pushCode(".");
this.pushCode(pFunction.sSemantic);
this.pushCode("=");
this.analyzeExpr(pChildren[1]);
this.pushCode(";");
this.pushCode("return;");

}
else  {
var isWriteVar;
this.pushCode("return;");
this.newCode();
isWriteVar = this._isWriteVar;
this._isWriteVar = null;
this.analyzeExpr(pChildren[1]);
this._isWriteVar = isWriteVar;
pCode = this._pCode;
this.endCode();
var isFlag=false;
for (i = 0; i < (pCode.length); i++) {
if ((typeof (pCode[i])) !== "string") {
if (isFlag) {
if (!0) {
var err=((((((("Error:: " + "This return isn`t cool enough to work in vs") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("This return isn`t cool enough to work in vs");

}


}

;
return ;

}

if ((pCode[i]) === (pFunction.pReturnVariable)) {
isFlag = true;

}
else  {
if (!0) {
var err=((((((("Error:: " + "On no, but you must to return 'Out'") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("On no, but you must to return 'Out'");

}


}

;
return ;

}


}


}


}


}
else if ((this._eFuncProperty) === (3)) {
this.pushCode("gl_FragColor=(");
this.analyzeExpr(pChildren[1]);
if (!(this._pExprType.isEqual(this.hasType("float4")))) {
if (!0) {
var err=((((((("Error:: " + "For fragment shader return type must be float4") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("For fragment shader return type must be float4");

}


}

;
return ;

}

this.pushCode(");");
this.pushCode("return;");

}
else  {
if (!0) {
var err=((((((("Error:: " + "I don`t now how i get here") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("I don`t now how i get here");

}


}

;
return ;

}




}
else if ((pChildren[(pChildren.length) - 1].sValue) === (a.fx.GLOBAL_VARS.T_KW_DO)) {
isInLoop = this._isInLoop;
this.pushCode("do");
this._isInLoop = true;
this.analyzeStmt(pChildren[5]);
this._isInLoop = isInLoop;
this.pushCode("while");
this.pushCode("(");
this.analyzeExpr(pChildren[2]);
this.pushCode(")");
this.pushCode(";");

}
else if ((pChildren[(pChildren.length) - 1].sName) === (a.fx.GLOBAL_VARS.STATEBLOCK)) {
this.analyzeStmtBlock(pChildren[(pChildren.length) - 1]);

}
else if ((pChildren[(pChildren.length) - 1].sValue) === (a.fx.GLOBAL_VARS.T_KW_DISCARD)) {
if ((this._eFuncProperty) === (2)) {
if (!0) {
var err=((((((("Error:: " + "Discard only for fragment shaders") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Discard only for fragment shaders");

}


}

;
return ;

}

this._pCurrentFunction.isFragmentOnly = true;
this.pushCode("discard");
this.pushCode(";");

}
else if ((pChildren[(pChildren.length) - 1].sValue) === (a.fx.GLOBAL_VARS.T_KW_BREAK)) {
if ((this._isInLoop) === false) {
if (!0) {
var err=((((((("Error:: " + "Break statement can be used only in loop(or in switch in pass)") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Break statement can be used only in loop(or in switch in pass)");

}


}

;
return ;

}

this.pushCode("break");
this.pushCode(";");

}
else if ((pChildren[(pChildren.length) - 1].sName) === (a.fx.GLOBAL_VARS.TYPEDECL)) {
this.analyzeTypeDecl(pChildren[0]);

}
else if ((pChildren[(pChildren.length) - 1].sName) === (a.fx.GLOBAL_VARS.VARIABLEDECL)) {
this.newMemRead();
isMemRead = true;
this.analyzeVariableDecl(pChildren[0]);

}
else if ((pChildren[(pChildren.length) - 1].sName) === (a.fx.GLOBAL_VARS.VARSTRUCTDECL)) {
this.analyzeVarStructDecl(pChildren[0]);

}
else  {
this.newMemRead();
isMemRead = true;
this.analyzeExpr(pChildren[(pChildren.length) - 1]);
this.pushCode(";");

}











if (isMemRead) {
var pMemBlock;
for (i = 0; i < (this._pMemReadVars.length); i++) {
pMemBlock = this._pMemReadVars[i];
this.pushCode(pMemBlock);
if ((this._eFuncProperty) !== (0)) {
this._getAllPointers(pMemBlock._pVar);
this._pCurrentFunction.addPointers(pMemBlock._pVar);

}

this.pushCode(";");

}

this.endMemRead();

}


};
Effect.prototype.analyzeParamList = function(pNode, pFunction) {
var pChildren=pNode.pChildren;
var i;
var pVar;
this._isParam = true;
pFunction.pParameters =  {};
for (i = (pChildren.length) - 2; i >= 1; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.PARAMETERDECL)) {
pVar = this.analyzeParameterDecl(pChildren[i]);
if (!(pVar.checkMe())) {
if (!0) {
var err=((((((("Error:: " + "You sucks 2") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You sucks 2");

}


}

;
return ;

}

pFunction.addParameter(pVar);

}


}

this._isParam = false;
return pFunction;

};
Effect.prototype.analyzeParameterDecl = function(pNode) {
var pChildren=pNode.pChildren;
var pVar=new EffectVariable();
pVar.setType(this.analyzeParamUsageType(pChildren[1]));
if (!(pVar.pType.checkMe(a.fx.GLOBAL_VARS.PARAMETRUSAGE))) {
if (!0) {
var err=((((((("Error:: " + "You sucks 2") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You sucks 2");

}


}

;
return ;

}

pVar = this.analyzeVariable(pChildren[0], pVar);
return pVar;

};
Effect.prototype.analyzeParamUsageType = function(pNode, pType) {
pType = pType || (new VariableType());
var pChildren=pNode.pChildren;
var i;
for (i = (pChildren.length) - 1; i >= 0; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.TYPE)) {
pType.setType(this.convertType(pChildren[i]));

}

if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.PARAMUSAGE)) {
pType.setUsage(pChildren[i].pChildren[0].sValue);

}


}

return pType;

};
Effect.prototype.analyzeVarStructDecl = function(pNode) {
var pChildren=pNode.pChildren;
var i;
var pVar;
var pType=this.analyzeUsageStructDecl(pChildren[(pChildren.length) - 1]);
this._pCurrentType = pType;
if (this.isCodeWrite()) {
this.pushCode(pType);
this.pushCode(";");

}

for (i = (pChildren.length) - 2; i >= 0; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.VARIABLE)) {
pVar = this.analyzeVariable(pChildren[i]);
pVar.setType(pType);
this.addVariableDecl(pVar);

}


}

this._pCurrentType = null;
pNode.pAnalyzed = true;

};
Effect.prototype.analyzeUsageStructDecl = function(pNode, pType) {
pType = pType || (new VariableType());
var pChildren=pNode.pChildren;
var i;
for (i = (pChildren.length) - 1; i >= 1; i--) {
pType.setUsage(pChildren[i].pChildren[0].sValue);

}

var pEffectType=new EffectType();
pEffectType.fromStruct(this.analyzeStructDecl(pChildren[0]));
this.addType(pEffectType);
pType.setType(pEffectType);
return pType;

};
Effect.prototype.analyzeTechniqueDecl = function(pNode) {
var pChildren=pNode.pChildren;
var i=0;
var pTech=new EffectTechnique(this);
pTech.setName(this.analyzeComplexName(pChildren[(pChildren.length) - 2]));
if ((pChildren[(pChildren.length) - 2].pChildren.length) !== 1) {
pTech.hasComplexName(true);

}

this._pCurrentTechnique = pTech;
for (i = (pChildren.length) - 3; i >= 0; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.ANNOTATION)) {
this.analyzeAnnotation(pChildren[i], pTech);

}
else if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.SEMANTIC)) {
this.analyzeSemantic(pChildren[i], pTech);

}
else  {
this.analyzeTechniqueBody(pChildren[i], pTech);

}



}

this.addTechnique(pTech);
pNode.pAnalyzed = pTech;
return pTech;

};
Effect.prototype.addTechnique = function(pTechnique) {
this.pTechniques[pTechnique.sName] = pTechnique;

};
Effect.prototype.analyzeTechniqueBody = function(pNode, pTechnique) {
var pChildren=pNode.pChildren;
var i;
var pPass;
for (i = (pChildren.length) - 2; i >= 1; i--) {
pPass = this.analyzePassDecl(pChildren[i]);
if (!pPass) {
continue ;

}

if (!(pPass.checkMe())) {
if (!0) {
var err=((((((("Error:: " + "something bad with your pass") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("something bad with your pass");

}


}

;

}

pTechnique.addPass(pPass);

}

return pTechnique;

};
Effect.prototype.analyzePassDecl = function(pNode, pPass) {
var pChildren=pNode.pChildren;
var i=0;
if ((pChildren.length) === 1) {
if ((pChildren[0].sName) === (a.fx.GLOBAL_VARS.IMPORTDECL)) {
this.analyzeImportDecl(pChildren[0]);

}

return ;

}

pPass = pPass || (new EffectPass());
if (((pChildren[(pChildren.length) - 2].sName) === (a.fx.GLOBAL_VARS.T_NON_TYPE_ID)) || ((pChildren[(pChildren.length) - 2].sName) === (a.fx.GLOBAL_VARS.T_TYPE_ID))) {
pPass.setName(pChildren[(pChildren.length) - 2].sValue);

}

if ((pChildren[1].sName) === (a.fx.GLOBAL_VARS.ANNOTATION)) {
this.analyzeAnnotation(pChildren[1], pPass);

}

this._pCurrentPass = pPass;
this.analyzePassStateBlock(pChildren[0], pPass);
this._pCurrentPass = null;
pPass.finalize();
return pPass;

};
Effect.prototype.analyzePassStateBlock = function(pNode, pPass) {
var pChildren=pNode.pChildren;
var i;
pPass.pushCode("{");
for (i = (pChildren.length) - 2; i >= 1; i--) {
this.analyzePassState(pChildren[i], pPass);

}

pPass.pushCode("}");

};
Effect.prototype.analyzePassState = function(pNode, pPass) {
var pChildren=pNode.pChildren;
var i;
var eState=null;
if ((pChildren.length) === 1) {
if ((pChildren[0].sName) === (a.fx.GLOBAL_VARS.STATEIF)) {
this.analyzeStateIf(pChildren[0], pPass);

}
else  {
this.analyzeStateSwitch(pChildren[0], pPass);

}

return ;

}

if ((pChildren[(pChildren.length) - 2].sName) === (a.fx.GLOBAL_VARS.STATEINDEX)) {
if (!0) {
var err=((((((("Error:: " + "don`t very bad for state") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("don`t very bad for state");

}


}

;
return ;

}

var pStateExpr=pChildren[(pChildren.length) - 3];
var pExpr=pStateExpr.pChildren[(pStateExpr.pChildren.length) - 1];
var sType=pChildren[(pChildren.length) - 1].sValue.toUpperCase();
var isVertex=false;
var isPixel=false;
switch(sType) {
case "ZENABLE":
eState = 7;
break ;

case "ZWRITEENABLE":
eState = 14;
break ;

case "SRCBLEND":
eState = 19;
break ;

case "DESTBLEND":
eState = 20;
break ;

case "CULLMODE":
eState = 22;
break ;

case "ZFUNC":
eState = 23;
break ;

case "DITHERENABLE":
eState = 26;
break ;

case "ALPHABLENDENABLE":
eState = 27;
break ;

case "ALPHATESTENABLE":
eState = 28;
break ;

case "VERTEXSHADER":
isVertex = true;
break ;

case "PIXELSHADER":
isPixel = true;
break ;

default:
if (!0) {
var err=((((((("Error:: " + (("Unsupported render state type used: " + sType) + ". WebGl...")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("Unsupported render state type used: " + sType) + ". WebGl..."));

}


}

;
eState = null;
return pPass;
}
if (isVertex || isPixel) {
if ((pExpr.sName) !== (a.fx.GLOBAL_VARS.OBJECTEXPR)) {
if (!0) {
var err=((((((("Error:: " + "Bad compile state. I don`t know what bad, but something exactly going wrong.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Bad compile state. I don`t know what bad, but something exactly going wrong.");

}


}

;
return ;

}

var pFunc=this.analyzeExpr(pExpr);
var pParam;
var isInput=undefined;
if (isVertex) {
pPass.setJSVertexShader(pFunc);
pFunc.isVertexShader = true;
for (i = 0; (pFunc.pParamOrders) && (i < (pFunc.pParamOrders.length)); i++) {
pParam = pFunc.pParamOrders[i];
if ((!(pParam.sSemantic)) && ((pParam.isUniform) === false)) {
if (isInput === false) {
if (!0) {
var err=((((((("Error:: " + "You cannot use attribute in struct and attrib as paramters") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You cannot use attribute in struct and attrib as paramters");

}


}

;
return ;

}

isInput = true;
pParam.setVSInput();
pFunc.pMainInputVar = pParam;

}
else if ((pParam.sSemantic) && ((pParam.isUniform) === false)) {
if (isInput === true) {
if (!0) {
var err=((((((("Error:: " + "You cannot use attribute in struct and attrib as paramters") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You cannot use attribute in struct and attrib as paramters");

}


}

;
return ;

}

isInput = false;

}


if ((pParam.isUniform) === false) {
pParam.setMixible();

}


}

if (pFunc.pReturnType.pEffectType.pDesc) {
pFunc.pReturnType.setMixible();

}


}
else  {
pPass.setJSFragmentShader(pFunc);
pFunc.isFragmentShader = true;
isInput = null;
for (i = 0; (pFunc.pParamOrders) && (i < (pFunc.pParamOrders.length)); i++) {
pParam = pFunc.pParamOrders[i];
if ((pParam.isUniform) === false) {
if (isInput === true) {
if (!0) {
var err=((((((("Error:: " + "You should put all varyings in one struct") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You should put all varyings in one struct");

}


}

;
return ;

}
else if (!(pParam.sSemantic)) {
if (isInput === false) {
if (!0) {
var err=((((((("Error:: " + "If you use varyings as params do it honest") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("If you use varyings as params do it honest");

}


}

;
return ;

}

isInput = true;
pParam.setFSInput();
pParam.setMixible();
pFunc.pMainInputVar = pParam;

}
else  {
if (isInput === true) {
if (!0) {
var err=((((((("Error:: " + "If you use varyings as struct do it honest") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("If you use varyings as struct do it honest");

}


}

;
return ;

}

if (!(pParam.pType.isBase())) {
if (!0) {
var err=((((((("Error:: " + "For varyings only base types are availeable") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("For varyings only base types are availeable");

}


}

;
return ;

}

isInput = false;

}



}


}


}

return pPass;

}

if ((((pExpr.sValue) === "{") || ((pExpr.sValue) === "<")) || ((pExpr.sValue) === undefined)) {
if (!0) {
var err=((((((("Error:: " + "Too difficult for webgl") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Too difficult for webgl");

}


}

;

}

var sValue=pExpr.sValue.toUpperCase();
var eValue;
switch(eState) {
case 27:
;

case 28:
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "][") + "") + "]") + "ALPHABLENDENABLE/ALPHATESTENABLE not supported in WebGL.");

case 26:
;

case 7:
;

case 14:
switch(sValue) {
case "TRUE":
eValue = true;
break ;

case "FALSE":
eValue = false;
break ;

default:
if (!0) {
var err=((((((("Error:: " + (("Unsupported render state ALPHABLENDENABLE/ZENABLE/ZWRITEENABLE/DITHERENABLE value used: " + sValue) + ".")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("Unsupported render state ALPHABLENDENABLE/ZENABLE/ZWRITEENABLE/DITHERENABLE value used: " + sValue) + "."));

}


}

;
eValue = null;
}
break ;

case 19:
;

case 20:
switch(sValue) {
case "ZERO":
eValue = 0;
break ;

case "ONE":
eValue = 1;
break ;

case "SRCCOLOR":
eValue = 768;
break ;

case "INVSRCCOLOR":
eValue = 769;
break ;

case "SRCALPHA":
eValue = 770;
break ;

case "INVSRCALPHA":
eValue = 771;
break ;

case "DESTALPHA":
eValue = 772;
break ;

case "INVDESTALPHA":
eValue = 773;
break ;

case "DESTCOLOR":
eValue = 774;
break ;

case "INVDESTCOLOR":
eValue = 775;
break ;

case "SRCALPHASAT":
eValue = 776;
break ;

default:
if (!0) {
var err=((((((("Error:: " + (("Unsupported render state SRCBLEND/DESTBLEND value used: " + sValue) + ".")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("Unsupported render state SRCBLEND/DESTBLEND value used: " + sValue) + "."));

}


}

;
eValue = null;
}
break ;

case 22:
switch(sValue) {
case "NONE":
eValue = 0;
break ;

case "CW":
eValue = 1028;
break ;

case "CCW":
eValue = 1029;
break ;

case "FRONT_AND_BACK":
eValue = 1032;
break ;

default:
if (!0) {
var err=((((((("Error:: " + (("Unsupported render state SRCBLEND/DESTBLEND value used: " + sValue) + ".")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("Unsupported render state SRCBLEND/DESTBLEND value used: " + sValue) + "."));

}


}

;
eValue = null;
}
break ;

case 23:
switch(sValue) {
case "NEVER":
eValue = 1;
break ;

case "LESS":
eValue = 2;
break ;

case "EQUAL":
eValue = 3;
break ;

case "LESSEQUAL":
eValue = 4;
break ;

case "GREATER":
eValue = 5;
break ;

case "NOTEQUAL":
eValue = 6;
break ;

case "GREATEREQUAL":
eValue = 7;
break ;

case "ALWAYS":
eValue = 8;
break ;

default:
if (!0) {
var err=((((((("Error:: " + (("Unsupported render state ZFUNC value used: " + sValue) + ".")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("Unsupported render state ZFUNC value used: " + sValue) + "."));

}


}

;
eValue = null;
}
break ;
}
pPass.setJSState(eState, eValue);
return pPass;

};
Effect.prototype.analyzeStateIf = function(pNode, pPass) {
var pChildren=pNode.pChildren;
var pCode;
var i;
pPass.isComplex = true;
pPass.pushCode("if(");
this.newCode();
this.analyzeExpr(pChildren[4]);
pCode = this._pCode;
this.endCode();
for (i = 0; i < (pCode.length); i++) {
pPass.pushCode(pCode[i]);

}

pPass.pushCode(")");
this.analyzePassStateBlock(pChildren[2], pPass);
pPass.pushCode("else ");
if ((pChildren[0].sName) === (a.fx.GLOBAL_VARS.STATEIF)) {
this.analyzeStateIf(pChildren[0], pPass);

}
else  {
this.analyzePassStateBlock(pChildren[0], pPass);

}


};
Effect.prototype.analyzeStateSwitch = function(pNode, pPass) {
var pChildren=pNode.pChildren;
var pCode;
var i;
pPass.isComplex = true;
pPass.pushCode("switch(");
this.newCode();
this.analyzeExpr(pNode);
pCode = this._pCode;
this.endCode();
for (i = 0; i < (pCode.length); i++) {
pPass.pushCode(pCode[i]);

}

pPass.pushCode(")");
this.analyzeCaseBlock(pChildren[0], pPass);

};
Effect.prototype.analyzeCaseBlock = function(pNode, pPass) {
var pChildren=pNode.pChildren;
var i;
pPass.pushCode("{");
for (i = 0; i < (pChildren.length); i++) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.CASESTATE)) {
this.analyzeCaseState(pChildren[i], pPass);

}
else  {
this.analyzeDefaultState(pChildren[i], pPass);

}


}

pPass.pushCode("}");

};
Effect.prototype.analyzeCaseState = function(pNode, pPass) {
var pChildren=pNode.pChildren;
var pCode;
var i;
pPass.pushCode("case ");
this.newCode();
this.analyzeExpr(pChildren[(pChildren.length) - 2]);
pCode = this._pCode;
this.endCode();
for (i = 0; i < (pCode.length); i++) {
pPass.pushCode(pCode[i]);

}

pPass.pushCode(":");
for (i = (pChildren.length) - 4; i >= 0; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.PASSSTATE)) {
this.analyzePassState(pChildren[i], pPass);

}
else  {
pPass.pushCode(pChildren[i].sValue);

}


}


};
Effect.prototype.analyzeDefaultState = function(pNode, pPass) {
var pChildren=pNode.pChildren;
var i;
pPass.pushCode("default:");
for (i = (pChildren.length) - 3; i >= 0; i--) {
if ((pChildren[i].sName) === (a.fx.GLOBAL_VARS.PASSSTATE)) {
this.analyzePassState(pChildren[i], pPass);

}
else  {
pPass.pushCode(pChildren[i].sValue);

}


}


};
Effect.prototype.analyzeStateBlock = function(pNode, pVar) {
var pChildren=pNode.pChildren;
var i;
for (i = (pChildren.length) - 2; i >= 1; i--) {
this.analyzeState(pChildren[i]);

}

this._pCurrentVar.addSamplerState();

};
Effect.prototype.analyzeState = function(pNode) {
var pChildren=pNode.pChildren;
var i;
var eState=null;
if ((pChildren[(pChildren.length) - 2].sName) === (a.fx.GLOBAL_VARS.STATEINDEX)) {
if (!0) {
var err=((((((("Error:: " + "don`t very bad for state") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("don`t very bad for state");

}


}

;
return ;

}

var pStateExpr=pChildren[(pChildren.length) - 3];
var pExpr=pStateExpr.pChildren[(pStateExpr.pChildren.length) - 1];
var sType=pChildren[(pChildren.length) - 1].sValue.toUpperCase();
var isTexture=false;
switch(sType) {
case "TEXTURE":
isTexture = true;
break ;

case "ADDRESSU":
eState = "ADDRESSU";
break ;

case "ADDRESSV":
eState = "ADDRESSV";
break ;

case "ADDRESSW":
eState = "ADDRESSW";
break ;

case "BORDERCOLOR":
eState = "BORDERCOLOR";
break ;

case "MAGFILTER":
eState = "MAGFILTER";
break ;

case "MAXANISOTROPY":
eState = "MAXANISOTROPY";
break ;

case "MAXMIPLEVEL":
eState = "MAXMIPLEVEL";
break ;

case "MINFILTER":
eState = "MINFILTER";
break ;

case "MIPFILTER":
eState = "MIPFILTER";
break ;

case "MIPMAPLODBIAS":
eState = "MIPMAPLODBIAS";
break ;

default:
if (!0) {
var err=((((((("Error:: " + ("Oh no, but it is error " + sType)) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("Oh no, but it is error " + sType));

}


}

;
return ;
}
if (isTexture) {
var pTexture;
if ((((pExpr.sValue) === "{") || ((pExpr.sValue) === undefined)) || ((pStateExpr.pChildren[1].sName) !== (a.fx.GLOBAL_VARS.T_NON_TYPE_ID))) {
if (!0) {
var err=((((((("Error:: " + "Wrong wrong") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Wrong wrong");

}


}

;
return ;

}

pTexture = this.hasVariable(pStateExpr.pChildren[1].sValue);
pTexture.sRealName = (pTexture.sSemantic) || (pTexture.sRealName);
if (!pTexture) {
console.log(pStateExpr);
if (!0) {
var err=((((((("Error:: " + "bad with texture name") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("bad with texture name");

}


}

;
return ;

}

this._pCurrentVar.setTexture(pTexture);
return ;

}

this._pCurrentVar.setState(eState, pExpr.sValue);
return ;

};
Effect.prototype.analyzeComplexName = function(pNode) {
var pChildren=pNode.pChildren;
var sName="";
var i;
for (i = (pChildren.length) - 1; i >= 0; i--) {
if ((pChildren[i].sValue) === undefined) {
if (!0) {
var err=((((((("Error:: " + "something are very bad with you 10") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("something are very bad with you 10");

}


}

;
return ;

}

sName += pChildren[i].sValue;

}

return sName;

};
Effect.prototype.analyzeShiftOpt = function(pNode) {
var pChildren=pNode.pChildren;
var nShift=pChildren[0];
if ((pChildren.length) === 2) {
nShift *= 1;

}
else  {
nShift *= -1;

}

return nShift;

};
Effect.prototype.analyzeImportDecl = function(pNode) {
var pChildren=pNode.pChildren;
var pTech=this._pCurrentTechnique;
var sName=this.analyzeComplexName(pChildren[(pChildren.length) - 2]);
var nShift=0;
if ((pChildren.length) !== 2) {
nShift = this.analyzeShiftOpt(pChildren[0]);

}

var pComponent=this._pRenderer.getComponentByName(sName);
if (!pComponent) {
if (!0) {
var err=((((((("Error:: " + "You try import not existing component") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You try import not existing component");

}


}

;
return ;

}

if (pTech) {
pTech.addComponent(pComponent, nShift);

}
else  {
this.addComponent(pComponent, nShift);

}


};
Effect.prototype.analyzeProvideDecl = function(pNode) {
var pChildren=pNode.pChildren;
if ((pChildren.length) === 2) {
this._sProvideNameSpace = this.analyzeComplexName(pChildren[0]);

}
else  {
if (!0) {
var err=((((((("Error:: " + "I don`t know what i can doing with 'provide ... as ...'") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("I don`t know what i can doing with 'provide ... as ...'");

}


}

;
return ;

}


};
a["fx"]["Effect"] = Effect;
function EffectFileData(pEngine) {
var _pCtorValue=EffectFileData.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pEngine = pEngine;
this._pRenderer = pEngine.shaderManager();
this._sSource = "";
this.eStatus = 0;

}

a.extend(EffectFileData, a.ResourcePoolItem);
EffectFileData.prototype.createResource = function() {
this.notifyCreated();
this.notifyDisabled();
this.notifyLoaded();
return true;

};
EffectFileData.prototype.destroyResource = function() {
if (this.isResourceCreated()) {
this.disableResource();
this.notifyUnloaded();
this.notifyDestroyed();
return true;

}

return false;

};
EffectFileData.prototype.disableResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyDisabled();
return true;

};
EffectFileData.prototype.saveResource = function(sFileName) {
return true;

};
EffectFileData.prototype.restoreResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Effect.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyRestored();
return true;

};
EffectFileData.prototype.loadResource = function(sFileName) {
this.notifyUnloaded();
this._pRenderer._loadEffectFile(sFileName, this);
return true;

};
EffectFileData.prototype.create = function(sSource) {
this._sSource = sSource;
this.eStatus = 1;
this.notifyLoaded();

};
a["fx"]["EffectFileData"] = EffectFileData;
function Component(pEngine) {
var _pCtorValue=Component.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pEngine = pEngine;
this._pManager = (pEngine.pShaderManager) || null;
this.sName = null;
this.pTechnique = null;
this.pPasses = [];
this.pPassesNames =  {};
this.isPostEffect = false;
this.pAnnotation = null;
this.sName = "";
this.sComponents = null;
this.pComponents = null;
this.pComponentsShift = null;
this.pComponentsHash = null;
this.pExteranalsFragment = null;
this.pExteranalsVertex = null;

}

a.extend(Component, a.ResourcePoolItem);
Component.prototype.createResource = function() {
this._pManager.registerComponent(this);
this.notifyCreated();
this.notifyDisabled();
this.notifyLoaded();
return true;

};
Component.prototype.destroyResource = function() {
if (this.isResourceCreated()) {
this.disableResource();
this.notifyUnloaded();
this.notifyDestroyed();
return true;

}

return false;

};
Component.prototype.disableResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyDisabled();
return true;

};
Component.prototype.saveResource = function(sFileName) {
return true;

};
Component.prototype.restoreResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyRestored();
return true;

};
Component.prototype.loadResource = function(sFileName) {
this.notifyUnloaded();
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "][") + "") + "]") + ("TODO:: " + "Загрузка эффект ресурса"));
throw new Error("TODO::\n" + "Загрузка эффект ресурса");
return true;

};
Component.prototype.create = function(pTechnique) {
if (!(this._pManager.registerComponent(this))) {
return false;

}

this.sName = pTechnique.sName;
this.pPasses = pTechnique.pPasses;
this.pPassesNames = pTechnique.pPassesNames;
this.isPostEffect = pTechnique.isPostEffect;
this.pAnnotation = pTechnique.pAnnotation;
this.sComponents = pTechnique.sComponents;
this.pComponents = pTechnique.pComponents;
this.pComponentsShift = pTechnique.pComponentsShift;
this.pExteranalsFragment = pTechnique.pExteranalsFragment;
this.pExteranalsVertex = pTechnique.pExteranalsVertex;
return true;

};
Component.prototype.hash = function(pProp) {
return ((this.sName) + ">>>") + ((pProp.nShift) || 0);

};
Component.prototype.totalPasses = function() {
return this.pPasses.length;

};
a["fx"]["Component"] = Component;
function ComponentBlend() {
this.pPassBlends = null;
this.pUniformsBlend = null;
this.sHash = "";
this.pComponentsHash =  {};
this.pComponentsCount =  {};
this.pComponentsShift = [];
this.pComponents = [];
this._pMaps = null;
this._isReady = false;
this._id = 0;
this._nShiftMin = 0;
this._nShiftMax = 0;
this._nShiftCurrent = 0;
this._nTotalValidPasses = -1;
this._hasTextures = false;
if (!(this.constructor.fnAddUniform)) {
this.constructor.fnAddUniform = function(pVar, pUniforms, pPass, sPrevName, sPrevRealName) {
var sName, pVar1, sRealName;
sName = (sPrevName? (sPrevName + ".") + (pVar.sName) : pVar.sName);
sRealName = (sPrevRealName? (sPrevRealName + ".") + (pVar.sRealName) : pVar.sRealName);
pVar1 = pUniforms.pUniformsByRealName[sRealName];
if (pVar1 && (!(pVar1.pType.isEqual(pVar.pType)))) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "][") + "") + "]") + "You used uniforms with the same semantics. Now we work not very well with that.");
return false;

}

if (pVar.pType.isBase()) {
pUniforms.pUniformsByName[sName] = sRealName;
pUniforms.pUniformsByRealName[sRealName] = pVar;
pUniforms.pUniformsDefault[sRealName] = (pPass.pGlobalsDefault[sRealName]) || null;

}
else  {
var pOrders=pVar.pType.pEffectType.pDesc.pOrders;
for (var i=0; i < (pOrders.length); i++) {
ComponentBlend.fnAddUniform(pOrders[i], pUniforms, pPass, sName, sRealName);

}

pUniforms.pUniformsByName[sName] = sRealName;
pUniforms.pUniformsByRealName[sRealName] = pVar;
pUniforms.pUniformsDefault[sRealName] = (pPass.pGlobalsDefault[sRealName]) || null;

}

return true;

};

}

;

}

ComponentBlend.prototype.hasTextures = function() {
return this._hasTextures;

};
ComponentBlend.prototype.addComponent = function(pComponent, nShift) {
var i, j;
var sName;
sName = pComponent.hash(nShift);
if (this.pComponentsHash[sName]) {
this.pComponentsCount[sName]++;
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "][") + "") + "]") + "You try to add already used component in blend");
return ;

}

if (nShift < (this._nShiftMin)) {
this._nShiftMin = nShift;

}
else if (nShift > (this._nShiftMax)) {
this._nShiftMax = nShift;

}


this.sHash += sName + ":";
this.pComponentsHash[sName] = pComponent;
this.pComponentsCount[sName] = 1;
this.pComponents.push(pComponent);
this.pComponentsShift.push(nShift);
this._isReady = false;

};
ComponentBlend.prototype.addBlend = function(pBlend, nShift) {
var i;
var pNewBlend;
pNewBlend = this.cloneMe();
pNewBlend._nShiftCurrent = (nShift > 0? nShift : 0);
pNewBlend._nTotalValidPasses = pBlend.totalValidPasses();
for (i = 0; i < (pBlend.pComponents.length); i++) {
pNewBlend.addComponent(pBlend.pComponents[i], (pBlend.pComponentsShift[i]) + nShift);

}

return pNewBlend;

};
ComponentBlend.prototype.finalize = function() {
if (this._isReady) {
return true;

}

var i, j, k;
var pComponent;
var nShift;
var pPass;
var pUniforms;
var pVar1, pVar2;
var sName;
this.pPassBlends = [];
this.pUniformsBlend = [];
for (j = 0; j < (this.pComponents.length); j++) {
pComponent = this.pComponents[j];
nShift = (this.pComponentsShift[j]) - (this._nShiftMin);
for (i = 0; i < (pComponent.pPasses.length); i++) {
if (!(this.pPassBlends[i + nShift])) {
this.pPassBlends[i + nShift] = [];
this.pUniformsBlend[i + nShift] =  {"pUniformsByName":  {}, "pUniformsByRealName":  {}, "pUniformsDefault":  {}, "pTexturesByName":  {}, "pTexturesByRealName":  {}};

}

pPass = pComponent.pPasses[i];
this.pPassBlends[i + nShift].push(pPass);
pUniforms = this.pUniformsBlend[i + nShift];
for (k in pPass.pTexturesByName) {
sName = pUniforms.pTexturesByName[k] = pPass.pTexturesByName[k];
pUniforms.pTexturesByRealName[sName] = null;
this._hasTextures = true;

}

for (k in pPass.pGlobalsByName) {
ComponentBlend.fnAddUniform(pPass.pGlobalsByRealName[pPass.pGlobalsByName[k]], pUniforms, pPass);

}


}


}

for (i in this.pUniformsBlend) {
pUniforms = this.pUniformsBlend[i];
if (!(pUniforms._hasKeys)) {
pUniforms._hasKeys = true;
pUniforms._pUniformByNameKeys = Object.keys(pUniforms.pUniformsByName);
pUniforms._pTextureByNameKeys = Object.keys(pUniforms.pTexturesByName);
pUniforms._pTextureByRealNameKeys = Object.keys(pUniforms.pTexturesByRealName);
pUniforms._pUniformByRealNameKeys = Object.keys(pUniforms.pUniformsByRealName);

}


}

this._isReady = true;
return true;

};
ComponentBlend.prototype.cloneMe = function() {
var pClone=new a.fx.ComponentBlend();
var i;
for (i = 0; i < (this.pComponents.length); i++) {
pClone.pComponents[i] = this.pComponents[i];
pClone.pComponentsShift[i] = this.pComponentsShift[i];

}

for (i in this.pComponentsHash) {
pClone.pComponentsHash[i] = this.pComponentsHash[i];
pClone.pComponentsCount[i] = this.pComponentsCount[i];

}

pClone.sHash = this.sHash;
pClone._nShiftMin = this._nShiftMin;
pClone._nShiftMax = this._nShiftMax;
pClone._nShiftCurrent = this._nShiftCurrent;
pClone._nTotalValidPasses = this._nTotalValidPasses;
return pClone;

};
ComponentBlend.prototype.hasComponent = function(sComponent) {
return !(!(this.pComponentsHash[sComponent]));

};
ComponentBlend.prototype.isReady = function() {
return this._isReady;

};
ComponentBlend.prototype.totalPasses = function() {
return (this.pPassBlends? this.pPassBlends.length : 0);

};
ComponentBlend.prototype.totalValidPasses = function() {
return ((this._nTotalValidPasses) > 0? this._nTotalValidPasses : this.totalPasses());

};
a["fx"]["ComponentBlend"] = ComponentBlend;
function PassBlend(pEngine) {
this._pEngine = pEngine;
this.sHash = "";
this._id = null;
this.pPasses = [];
this.pVertexShaders = [];
this.pFragmentShaders = [];
this.pStates =  {};
this.pTypesBlockV =  {};
this.pTypesOrderV = [];
this.pUniformsV =  {};
this.pUniformsBlockV =  {};
this.pMixedTypesV =  {};
this.pFuncDefBlockV =  {};
this.pGlobalVarBlockV =  {};
this.pFuncDeclBlockV =  {};
this.pExternalsV =  {};
this.pExternalsBlockV =  {};
this.pVaryingsDef =  {};
this.pVaryingsBlock =  {};
this.pVaryings =  {};
this.sVaryingsOut = "";
this.pAttributes =  {};
this._pAttrDataDecl =  {};
this._pAttrIndexDecl =  {};
this._pAttrDataInit =  {};
this._pAttrIndexInit =  {};
this.pTypesBlockF =  {};
this.pTypesOrderF = [];
this.pUniformsF =  {};
this.pUniformsBlockF =  {};
this.pMixedTypesF =  {};
this.pFuncDefBlockF =  {};
this.pGlobalVarBlockF =  {};
this.pFuncDeclBlockF =  {};
this.pExternalsF =  {};
this.pExternalsBlockF =  {};
this.pGlobalBuffers =  {};
this.pGlobalBuffersV =  {};
this.pGlobalBuffersF =  {};
this.pAttrBuffers =  {};
this.pSamplers =  {};
this.pSamplersV =  {};
this.pSamplersF =  {};
this._pSamplersToReal =  {};
this._pBuffersToReal =  {};
this._pRealSamplersDecl = null;
this._pRealBuffesDecl = null;
this._pRealBuffesInit = null;
this._pRealAttrDecl = null;
this._pRealSamplersUsage = new Array(30);
this._initSystemData();
this.pExtrectedFunctionsV =  {};
this.pExtrectedFunctionsF =  {};
this.pUniforms =  {};
this._pBlendTypes =  {};
this._pBlendTypesDecl =  {};
this._nBlendTypes = 1;
if (!(this.constructor.pExtractedFunctions)) {
this.constructor.pExtractedFunctions =  {"header": ("void A_extractTextureHeader(const sampler2D src, out A_TextureHeader texture) {" + "vec4 v = texture2D(src, vec2(0.)); ") + "texture = A_TextureHeader(v.r, v.g, v.b, v.a);}\n", "float": (((((((((("float A_extractFloat(const sampler2D sampler, const A_TextureHeader header, const float offset) {" + "float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); ") + "float y = floor(pixelNumber / header.width) + .5; ") + "float x = mod(pixelNumber, header.width) + .5; ") + "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); ") + "\n#ifdef A_VB_COMPONENT4\n") + "if(shift == 0) return A_tex2D(sampler, header, x, y).r; ") + "else if(shift == 1) return A_tex2D(sampler, header, x, y).g; ") + "else if(shift == 2) return A_tex2D(sampler, header, x, y).b; ") + "else if(shift == 3) return A_tex2D(sampler, header, x, y).a; ") + "\n#endif\n") + "return 0.;}\n", "vec2": ((((((((((((((("vec2 A_extractVec2(const sampler2D sampler, const A_TextureHeader header, const float offset){" + "float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); ") + "float y = floor(pixelNumber / header.width) + .5; ") + "float x = mod(pixelNumber, header.width) + .5; ") + "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); ") + "\n#ifdef A_VB_COMPONENT4\n") + "if(shift == 0) return A_tex2D(sampler, header, x, y).rg; ") + "else if(shift == 1) return A_tex2D(sampler, header, x, y).gb; ") + "else if(shift == 2) return A_tex2D(sampler, header, x, y).ba; ") + "else if(shift == 3) { ") + "if(int(x) == int(header.width - 1.)) ") + "return vec2(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0., (y + 1.)).r); ") + "else ") + "return vec2(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).r); ") + "} ") + "\n#endif\n") + "return vec2(0.); }\n", "vec3": ((((((((((((((((((((((("vec3 A_extractVec3(const sampler2D sampler, const A_TextureHeader header, const float offset){" + "float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); ") + "float y = floor(pixelNumber / header.width) + .5; ") + "float x = mod(pixelNumber, header.width) + .5; ") + "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); ") + "\n#ifdef A_VB_COMPONENT4\n") + "if(shift == 0) return A_tex2D(sampler, header, x, y).rgb; ") + "else if(shift == 1) return A_tex2D(sampler, header, x, y).gba; ") + "else if(shift == 2){ ") + "if(int(x) == int(header.width - 1.))  return vec3(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, 0., (y + 1.)).r); ") + "else return vec3(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, (x + 1.), y).r);} ") + "else if(shift == 3){ ") + "if(int(x) == int(header.width - 1.))  return vec3(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0., (y + 1.)).rg); ") + "else return vec3(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).rg);} ") + "\n#endif\n") + "\n#ifdef A_VB_COMPONENT3\n") + "if(shift == 0) return A_tex2D(sampler, header,vec2(x,header.stepY*y)).rgb; ") + "else if(shift == 1){ ") + "if(x == header.width - 1.) return vec3(A_tex2D(sampler, header, x, y).gb, A_tex2D(sampler, header, 0., (y + 1.)).r); ") + "else return vec3(A_tex2D(sampler, header, x, y).gb, A_tex2D(sampler, header, (x + 1.), y).r);} ") + "else if(shift == 3){ ") + "if(x == header.width - 1.) return vec3(A_tex2D(sampler, header, x, y).b, A_tex2D(sampler, header, 0., (y + 1.)).rg); ") + "else return vec3(A_tex2D(sampler, header, x, y).b, A_tex2D(sampler, header, (x + 1)., y).rg);} ") + "\n#endif\n") + "return vec3(0);}\n", "vec4": ((((((((((((((((((((((("vec4 A_extractVec4(const sampler2D sampler, const A_TextureHeader header, const float offset){ " + "float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); ") + "float y = floor(pixelNumber / header.width) + .5; ") + "float x = mod(pixelNumber, header.width) + .5; ") + "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); ") + "\n#ifdef A_VB_COMPONENT4\n") + "if(shift == 0) return A_tex2D(sampler, header, x, y); ") + "else if(shift == 1){ ") + "if(int(x) == int(header.width - 1.)) ") + "return vec4(A_tex2D(sampler, header, x, y).gba, A_tex2D(sampler, header, 0., (y + 1.)).r); ") + "else ") + "return vec4(A_tex2D(sampler, header, x, y).gba, A_tex2D(sampler, header, (x + 1.), y).r);} ") + "else if(shift == 2){ ") + "if(int(x) == int(header.width - 1.)) ") + "return vec4(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, 0., (y + 1.)).rg); ") + "else ") + "return vec4(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, (x + 1.), y).rg);} ") + "else if(shift == 3){ ") + "if(int(x) == int(header.width - 1.)) ") + "return vec4(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0., (y + 1.)).rgb); ") + "else return vec4(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).rgb);} ") + "\n#endif\n") + "\n#ifdef A_VB_COMPONENT3\n") + "\n#endif\n") + "return vec4(0);}\n", "mat4": (((((("vec2 A_findPixel(const A_TextureHeader header, const float offset) {" + "float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); ") + "return vec2(header.stepX * (mod(pixelNumber, header.width) + .5), header.stepY * (floor(pixelNumber / header.width) + .5));}\n") + "mat4 A_extractMat4(const sampler2D sampler, const A_TextureHeader header, const float offset) {") + "return mat4(A_tex2Dv(sampler, header, A_findPixel(header, offset)),") + "A_tex2Dv(sampler, header, A_findPixel(header, offset + 4.)),") + "A_tex2Dv(sampler, header, A_findPixel(header, offset + 8.)),") + "A_tex2Dv(sampler, header, A_findPixel(header, offset + 12.)));}\n", "init": (((((((((((((((((((("\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n" + "//#define texture2D(sampler, ) texture2D\n") + "#else\n") + "#define texture2D(A, B) texture2DLod(A, B, 0.)\n") + "#endif\n") + "#ifndef A_VB_COMPONENT3\n") + "#define A_VB_COMPONENT4\n") + "#endif\n") + "#ifdef A_VB_COMPONENT4\n") + "#define A_VB_ELEMENT_SIZE 4.\n") + "#endif\n") + "#ifdef A_VB_COMPONENT3\n") + "#define A_VB_ELEMENT_SIZE 3.\n") + "#endif\n") + "#define A_tex2D(S, H, X, Y) texture2D(S, vec2(H.stepX * X , H.stepY * Y))\n") + "#define A_tex2Dv(S, H, V) texture2D(S, V)\n") + "struct A_TextureHeader {\n") + "float width; ") + "float height; ") + "float stepX; ") + "float stepY; ") + "};\n"};

}

;
if (!(this.constructor.sZeroSamplerDecl)) {
this.constructor.sZeroSamplerDecl = "uniform sampler2D A_zero_sampler;";

}

;
if (!(this.constructor.sZeroHeaderDecl)) {
this.constructor.sZeroHeaderDecl = "A_TextureHeader A_zero_header;";

}

;
if (!(this.constructor.sZeroSampler)) {
this.constructor.sZeroSampler = "A_zero_sampler";

}

;
if (!(this.constructor.sZeroHeader)) {
this.constructor.sZeroHeader = "A_zero_header";

}

;
if (!(this.constructor.fnAddUniform)) {
this.constructor.fnAddUniform = function(pVar, me, pShader, isVertex, sPrevRealName) {
var pVar1;
var sRealName=(sPrevRealName? (sPrevRealName + ".") + (pVar.sRealName) : pVar.sRealName);
var i;
var pUniforms, pUniformsBlock;
var iBlendStatus;
if (isVertex) {
pUniforms = me.pUniformsV;
pUniformsBlock = me.pUniformsBlockV;

}
else  {
pUniforms = me.pUniformsF;
pUniformsBlock = me.pUniformsBlockF;

}

pVar1 = pUniforms[sRealName];
if (pVar1) {
if (pVar1 instanceof Array) {
for (i = 0; i < (pVar1.length); i++) {
iBlendStatus = pVar1[i].canBlend(pVar, false);
if (iBlendStatus === 1) {
break ;

}

if (iBlendStatus === 0) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "][") + "") + "]") + "Types for blending uniforms must be mixible");
return false;

}


}

if (iBlendStatus === 2) {
pVar1.push(pVar);

}

return ;

}

iBlendStatus = pVar1.canBlend(pVar, false);
if (iBlendStatus === 0) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "][") + "") + "]") + "Types for blending uniforms must be mixible 1");
return false;

}
else if (iBlendStatus === 2) {
pUniforms[sRealName] = [pVar, pVar1];
pUniformsBlock[sRealName] = null;

}



}

if (!(pVar.pType.isBase())) {
var pOrders=pVar.pType.pEffectType.pDesc.pOrders;
for (i = 0; i < (pOrders.length); i++) {
PassBlend.fnAddUniform(pOrders[i], me, pShader, isVertex, sRealName);

}


}

if (!pVar1) {
pUniforms[sRealName] = pVar;
if (!sPrevRealName) {
pUniformsBlock[sRealName] = pShader.pUniformsBlock[sRealName];

}


}

return true;

};

}

;

}

PassBlend.prototype._initSystemData = function() {
if (PassBlend._pRealSamplersDecl) {
this._pRealSamplersDecl = PassBlend._pRealSamplersDecl;
this._pRealBuffesDecl = PassBlend._pRealBuffesDecl;
this._pRealBuffesInit = PassBlend._pRealBuffesInit;

}

var pSamplersDecl=new Array(30);
var pBufferDecl=new Array(30);
var pBufferInit=new Array(30);
var sSampler, sHeader, sAttr;
for (var i=0; i < (pSamplersDecl.length); i++) {
sSampler = (a.fx.SHADER_PREFIX.SAMPLER) + i;
sHeader = (a.fx.SHADER_PREFIX.HEADER) + i;
sAttr = (a.fx.SHADER_PREFIX.ATTRIBUTE) + i;
pSamplersDecl[i] = ("uniform sampler2D " + sSampler) + ";";
pBufferDecl[i] = ("A_TextureHeader " + sHeader) + ";";
pBufferInit[i] = ((("A_extractTextureHeader(" + sSampler) + ",") + sHeader) + ");";

}

this._pRealSamplersDecl = PassBlend._pRealSamplersDecl = pSamplersDecl;
this._pRealBuffesDecl = PassBlend._pRealBuffesDecl = pBufferDecl;
this._pRealBuffesInit = PassBlend._pRealBuffesInit = pBufferInit;

};
PassBlend.prototype.init = function(sHash, pBlend) {
this.sHash = sHash;
var i;
for (i = 0; i < (pBlend.length); i++) {
this.addPass(pBlend[i]);

}


};
PassBlend.prototype.addPass = function(pPass) {
this.pPasses.push(pPass);
var pVertex=pPass.pVertexShader;
var pFragment=pPass.pFragmentShader;
var i, j, k;
var pVar1, pVar2, pType1, pType2, pData1, pData2;
var isEqual=false;
var sName;
var iBlendStatus;
if (pVertex) {
this.pVertexShaders.push(pVertex);
for (i in pVertex.pTypesBlock) {
this.pTypesBlockV[i] = pVertex.pTypesBlock[i];
pType1 = pVertex.pTypesByName[i];
if ((this.pTypesOrderV.length) === 0) {
this.pTypesOrderV.push(pType1);
continue ;

}

isEqual = false;
for (j = 0; j < (this.pTypesOrderV.length); j++) {
pType2 = this.pTypesOrderV[j];
if (pType2 === pType1) {
isEqual = true;
break ;

}

if ((pType2.nOrder) > (pType1.nOrder)) {
break ;

}


}

if (!isEqual) {
this.pTypesOrderV.splice(j, 0, pType1);

}


}

for (i in pVertex.pFuncBlock) {
this.pFuncDefBlockV[i] = i + ";";
this.pFuncDeclBlockV[i] = pVertex.pFuncBlock[i];

}

for (i in pVertex.pGlobalVarBlock) {
if (this.pGlobalVarBlockV[i]) {
if (!0) {
var err=((((((("Error:: " + "It`s impossible, but some names of global vars are matched") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("It`s impossible, but some names of global vars are matched");

}


}

;
return ;

}

this.pGlobalVarBlockV[i] = pVertex.pGlobalVarBlock[i];

}

for (i in pVertex.pUniformsBlock) {
pVar1 = pVertex.pUniformsByRealName[i];
if (pVar1.isBuffer()) {
sName = pVar1.sRealName;
if (!(this.pGlobalBuffers[sName])) {
this.pGlobalBuffers[sName] = [];

}

this.pGlobalBuffers[sName].push(pVar1.pBuffer);
this._pBuffersToReal[sName] = null;
this.pGlobalBuffersV[sName] = null;
continue ;

}
else if (pVar1.isSampler()) {
sName = pVar1.sRealName;
if (!(this.pSamplers[sName])) {
this.pSamplers[sName] = [];

}

this.pSamplers[sName].push(pVar1);
this._pSamplersToReal[sName] = null;
this.pSamplersV[sName] = null;
continue ;

}


PassBlend.fnAddUniform(pVar1, this, pVertex, true);

}

for (i in pVertex.pExternals) {
this._addExternal(pVertex.pExternals[i], true);

}

for (i in pVertex.pAttrBuffers) {
if (!(this.pAttrBuffers[i])) {
this.pAttrBuffers[i] = [];

}

this.pAttrBuffers[i].push(pVertex.pAttrBuffers[i]);

}

for (i in pVertex._pExtractFunctions) {
this.pExtrectedFunctionsV[i] = null;

}

for (i in pVertex._pAttrSemantics) {
pVar1 = pVertex._pAttrSemantics[i];
pVar2 = this.pAttributes[i];
if (pVar2) {
if (pVar2 instanceof Array) {
for (j = 0; j < (pVar2.length); j++) {
iBlendStatus = pVar2[j].canBlend(pVar1, true);
if (iBlendStatus === 1) {
break ;

}

if (iBlendStatus === 0) {
if (!0) {
var err=((((((("Error:: " + "Types for blending attributes must be mixible 1") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Types for blending attributes must be mixible 1");

}


}

;
return ;

}


}

if (iBlendStatus === 2) {
pVar2.push(pVar1);

}

continue ;

}

iBlendStatus = pVar2.canBlend(pVar1, true);
if (iBlendStatus === 0) {
if (!0) {
var err=((((((("Error:: " + "Types for blending attributes must be mixible 2") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Types for blending attributes must be mixible 2");

}


}

;
return ;

}
else if (iBlendStatus === 2) {
this.pAttributes[i] = [pVar1, pVar2];

}


continue ;

}

this.pAttributes[i] = pVar1;

}

for (i in pVertex._pAttrDataDecl) {
this._pAttrDataDecl[i] = pVertex._pAttrDataDecl[i];

}

for (i in pVertex._pAttrDataInit) {
pData1 = this._pAttrDataInit[i];
pData2 = pVertex._pAttrDataInit[i];
if (((this.pAttributes[i]) instanceof Array) && pData1) {
for (j = 0; j < (pData2.length); j++) {
isEqual = false;
for (k = 0; k < (pData1.length); k++) {
if ((pData1[k]) === (pData2[j])) {
isEqual = true;
break ;

}


}

if (!isEqual) {
pData1.push(pData2[j]);

}


}


}
else  {
this._pAttrDataInit[i] = pData2;

}


}

for (i in pVertex._pAttrIndexDecl) {
this._pAttrIndexInit[i] = pVertex._pAttrIndexInit[i];
this._pAttrIndexDecl[i] = pVertex._pAttrIndexDecl[i];

}

for (i in pVertex._pVaryingsSemantics) {
pVar1 = pVertex._pVaryingsSemantics[i];
pVar2 = this.pVaryings[i];
if (!pVar2) {
this.pVaryings[i] = pVar1;
this.pVaryingsDef[i] = "varying " + (pVar1.toCodeDecl());
continue ;

}

if (!(pVar2.pType.isStrictEqual(pVar1.pType))) {
if (!0) {
var err=((((((("Error:: " + "Not equal types for varyings") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Not equal types for varyings");

}


}

;
return ;

}


}


}

if (pFragment) {
this.pFragmentShaders.push(pFragment);
for (i in pFragment.pTypesBlock) {
this.pTypesBlockF[i] = pFragment.pTypesBlock[i];
pType1 = pFragment.pTypesByName[i];
if ((this.pTypesOrderF.length) === 0) {
this.pTypesOrderF.push(pType1);
continue ;

}

isEqual = false;
for (j = 0; j < (this.pTypesOrderF.length); j++) {
pType2 = this.pTypesOrderF[j];
if (pType2 === pType1) {
isEqual = true;
break ;

}

if ((pType2.nOrder) > (pType1.nOrder)) {
break ;

}


}

if (!isEqual) {
this.pTypesOrderF.splice(j, 0, pType1);

}


}

for (i in pFragment.pFuncBlock) {
this.pFuncDefBlockF[i] = i + ";";
this.pFuncDeclBlockF[i] = pFragment.pFuncBlock[i];

}

for (i in pFragment.pGlobalVarBlock) {
if (this.pGlobalVarBlockF[i]) {
if (!0) {
var err=((((((("Error:: " + "It`s impossible, but some names of global vars are matched") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("It`s impossible, but some names of global vars are matched");

}


}

;
return ;

}

this.pGlobalVarBlockF[i] = pFragment.pGlobalVarBlock[i];

}

for (i in pFragment.pUniformsBlock) {
pVar1 = pFragment.pUniformsByRealName[i];
if (pVar1.isBuffer()) {
sName = pVar1.sRealName;
if (!(this.pGlobalBuffers[sName])) {
this.pGlobalBuffers[sName] = [];

}

this.pGlobalBuffers[sName].push(pVar1.pBuffer);
this._pBuffersToReal[sName] = null;
this.pGlobalBuffersF[sName] = null;
continue ;

}
else if (pVar1.isSampler()) {
sName = pVar1.sRealName;
if (!(this.pSamplers[sName])) {
this.pSamplers[sName] = [];

}

this.pSamplers[sName].push(pVar1);
this._pSamplersToReal[sName] = null;
this.pSamplersF[sName] = null;
continue ;

}


PassBlend.fnAddUniform(pVar1, this, pFragment, false);

}

for (i in pFragment._pExtractFunctions) {
this.pExtrectedFunctionsF[i] = null;

}

for (i in pFragment.pExternals) {
this._addExternal(pVertex.pExternals[i], false);

}


}

pPass.clear();

};
PassBlend.prototype.finalizeBlend = function() {
var i;
var sType;
var pAttr;
var pExternal;
var pUsedTypes;
for (i in this.pUniformsV) {
if ((this.pUniformsBlockV[i]) === null) {
sType = this._blendTypes(this.pUniformsV[i]);
this.pMixedTypesV[sType] = null;
this.pUniformsBlockV[i] = ((("uniform " + sType) + " ") + i) + ";";
this.pUniformsV[i] = this.pUniformsV[i][0];

}

if (this.pUniformsV[i].pType.isBase()) {
this.pUniforms[i] = this.pUniformsV[i];

}


}

for (i in this.pSamplers) {
this.pUniforms[i] = this.pSamplers[i][0];

}

for (i in this.pGlobalBuffers) {
this.pUniforms[i] = this.pGlobalBuffers[i][0];

}

for (i in this.pUniformsF) {
if ((this.pUniformsBlockF[i]) === null) {
sType = this._blendTypes(this.pUniformsF[i]);
this.pMixedTypesF[sType] = null;
this.pUniformsBlockF[i] = ((("uniform " + sType) + " ") + i) + ";";
this.pUniformsF[i] = this.pUniformsF[i][0];

}

if (this.pUniformsF[i].pType.isBase()) {
this.pUniforms[i] = this.pUniformsF[i];

}


}

for (i in this.pAttributes) {
pAttr = this.pAttributes[i];
if (pAttr instanceof Array) {
sType = this._blendTypes(pAttr);
this.pMixedTypesV[sType] = null;
this.pAttributes[i] = pAttr[0];
this._pAttrDataDecl[i] = ((sType + " ") + i) + ";";

}


}

for (i in this.pExternalsV) {
pExternal = this.pExternalsV[i];
pUsedTypes = [];
if (pExternal instanceof Array) {
sType = this._blendTypes(pExternal, pUsedTypes);
this._addTypes(pUsedTypes, true);
this.pExternalsBlockV[i] = ((sType + " ") + i) + ";";

}
else  {
pUsedTypes = this._getUsedTypes(pExternal, pUsedTypes);
this._addTypes(pUsedTypes, true);
this.pExternalsBlockV[i] = pExternal.toCodeDecl();

}


}

for (i in this.pExternalsF) {
pExternal = this.pExternalsF[i];
pUsedTypes = [];
if (pExternal instanceof Array) {
sType = this._blendTypes(pExternal, pUsedTypes);
this._addTypes(pUsedTypes, false);
this.pExternalsBlockF[i] = ((sType + " ") + i) + ";";

}
else  {
pUsedTypes = this._getUsedTypes(pExternal, pUsedTypes);
this._addTypes(pUsedTypes, false);
this.pExternalsBlockF[i] = pExternal.toCodeDecl();

}


}

this.sVaryingsOut = "struct { vec4 POSITION; float PSIZE;";
for (i in this.pVaryings) {
this.sVaryingsOut += (((this.pVaryings[i].pType.pEffectType.toCode()) + " ") + (this.pVaryings[i].sSemantic)) + ";";
this.pVaryingsBlock[i] = (((((this.pVaryings[i].sRealName) + "=") + (a.fx.GLOBAL_VARS.SHADEROUT)) + ".") + i) + ";";

}

this.pVaryingsBlock["POSITION"] = ("gl_Position=" + (a.fx.GLOBAL_VARS.SHADEROUT)) + ".POSITION;";
this.pVaryingsBlock["PSIZE"] = ("gl_PointSize=" + (a.fx.GLOBAL_VARS.SHADEROUT)) + ".PSIZE;";
this.sVaryingsOut += ("} " + (a.fx.GLOBAL_VARS.SHADEROUT)) + ";";

};
PassBlend.prototype.generateProgram = function(sHash, pAttrData, pKeys, pUniformData, pTextures, pTexcoords) {
var pProgram;
var pAttrBuf= {};
var i, j, k;
var pAttrToReal= {}, pAttrToBuffer= {};
var pRealSamplers= {};
var pSamplersUsage=this._pRealSamplersUsage, pSamplersArrayV=[], pSamplersArrayF=[];
var pSamplersToReal= {}, pBuffersToReal= {}, pSamplers;
var iRealSampler, nRealSamplers=0, sRealSampler;
var pAttrDecl= {};
var pAttrInit= {};
var pGlobalBufDecl;
var pRealAttrs, pRealBuffers, pAttr, pAttr1, pPointer, pBuffers, pBuffer, pSampler, pTexture, sTexture;
var sKey1, sKey2, sInit, sDecl, sAttr, sName1, sName2;
var sUniformOffset="";
var nAttr=0, nBuffer=0, iAttr, iBuffer;
var pData1, pData2, sData1, sData2;
var isNewBuffer=false;
var isZeroSamplerV=false;
var isZeroHeaderV=false;
var isZeroSamplerF=false;
var isZeroHeaderF=false;
var isExtractInitV=false;
var isExtractInitF=false;
var pUniformKeys=Object.keys(pUniformData);
var nSamplers=0;
var pTempVarsDecl= {};
for (i = 0; i < (pUniformKeys.length); i++) {
sKey1 = pUniformKeys[i];
pData1 = pUniformData[sKey1];
if ((this.pGlobalBuffers[sKey1]) !== undefined) {
if ((this.pGlobalBuffersV[sKey1]) === null) {
isExtractInitV = true;

}

if ((this.pGlobalBuffersF[sKey1]) === null) {
isExtractInitF = true;

}

if (pData1 === null) {
if (isExtractInitV) {
isZeroHeaderV = true;
isZeroSamplerV = true;

}

if (isExtractInitF) {
isZeroHeaderF = true;
isZeroSamplerF = true;

}

sData1 = PassBlend.sZeroSampler;
sData2 = PassBlend.sZeroHeader;
pBuffersToReal[sKey1] = null;

}
else  {
iRealSampler = pRealSamplers[pData1.toNumber()];
if (iRealSampler === undefined) {
iRealSampler = nRealSamplers;
nRealSamplers++;
pSamplersUsage[iRealSampler] = 0;
pRealSamplers[pData1.toNumber()] = iRealSampler;

}

if (isExtractInitV) {
pSamplersUsage[iRealSampler] |= 1 << 0;
pSamplersUsage[iRealSampler] |= 1 << 1;

}

if (isExtractInitF) {
pSamplersUsage[iRealSampler] |= 1 << 2;
pSamplersUsage[iRealSampler] |= 1 << 3;

}

sData1 = (a.fx.SHADER_PREFIX.SAMPLER) + iRealSampler;
sData2 = (a.fx.SHADER_PREFIX.HEADER) + iRealSampler;
pBuffersToReal[sKey1] = sData1;

}

for (j = 0; j < (this.pGlobalBuffers[sKey1].length); j++) {
pBuffer = this.pGlobalBuffers[sKey1][j];
pBuffer.pSampler.pData = sData1;
pBuffer.pHeader.pData = sData2;

}

continue ;

}

if ((this.pSamplers[sKey1]) !== undefined) {
pSampler = this.pSamplers[sKey1][0];
if (pSampler.isArray) {
if ((!pData1) || ((pData1.length) === 0)) {
if ((this.pSamplersV[sKey1]) === null) {
isZeroSamplerV = true;

}

if ((this.pSamplersF[sKey1]) === null) {
isZeroSamplerF = true;

}

pSampler._pSamplerData = PassBlend.sZeroSampler;
pSampler.isValid = false;
pSamplersToReal[sKey1] = null;
continue ;

}

var isCollapse=true;
sTexture = pData1[0][a.fx.GLOBAL_VARS.TEXTURE];
pTexture = pTextures[sTexture];
for (j = 1; j < (pData1.length); j++) {
sTexture = pData1[j][a.fx.GLOBAL_VARS.TEXTURE];
if (pTexture !== (pTextures[sTexture])) {
isCollapse = false;
break ;

}


}

if (isCollapse) {
pSampler.isValid = false;
if (!pTexture) {
if ((this.pSamplersV[sKey1]) === null) {
isZeroSamplerV = true;

}

if ((this.pSamplersF[sKey1]) === null) {
isZeroSamplerF = true;

}

pSampler._pSamplerData = PassBlend.sZeroSampler;
pSamplersToReal[sKey1] = null;
continue ;

}

iRealSampler = pRealSamplers[pTexture.toNumber()];
if (iRealSampler === undefined) {
iRealSampler = nRealSamplers;
nRealSamplers++;
pSamplersUsage[iRealSampler] = 0;
pRealSamplers[pTexture.toNumber()] = iRealSampler;

}

if ((this.pSamplersV[sKey1]) === null) {
pSamplersUsage[iRealSampler] |= 1 << 0;

}

if ((this.pSamplersF[sKey1]) === null) {
pSamplersUsage[iRealSampler] |= 1 << 2;

}

pSamplersToReal[sKey1] = pSampler._pSamplerData = (a.fx.SHADER_PREFIX.SAMPLER) + iRealSampler;
continue ;

}

if ((this.pSamplersV[sKey1]) === null) {
pSamplersArrayV.push(pSampler);

}

if ((this.pSamplersF[sKey1]) === null) {
pSamplersArrayF.push(pSampler);

}

pSampler._pSamplerData = pSampler.sRealName;
pSampler.isValid = true;
pSamplersToReal[sKey1] = new Array((pSampler.iLength) * 1);

}
else  {
sTexture = pData1[a.fx.GLOBAL_VARS.TEXTURE];
pTexture = pTextures[sTexture];
if (!pTexture) {
if ((this.pSamplersV[sKey1]) === null) {
isZeroSamplerV = true;

}

if ((this.pSamplersF[sKey1]) === null) {
isZeroSamplerF = true;

}

sData1 = PassBlend.sZeroSampler;
pSamplersToReal[sKey1] = null;

}
else  {
iRealSampler = pRealSamplers[pTexture.toNumber()];
if (iRealSampler === undefined) {
iRealSampler = nRealSamplers;
nRealSamplers++;
pSamplersUsage[iRealSampler] = 0;
pRealSamplers[pTexture.toNumber()] = iRealSampler;

}

if ((this.pSamplersV[sKey1]) === null) {
pSamplersUsage[iRealSampler] |= 1 << 0;

}

if ((this.pSamplersF[sKey1]) === null) {
pSamplersUsage[iRealSampler] |= 1 << 2;

}

sData1 = (a.fx.SHADER_PREFIX.SAMPLER) + iRealSampler;
pSamplersToReal[sKey1] = sData1;

}

for (j = 0; j < (this.pSamplers[sKey1].length); j++) {
this.pSamplers[sKey1][j]._pSamplerData = sData1;

}

continue ;

}


}


}

for (i = 0; i < (pKeys.length); i++) {
sKey1 = pKeys[i];
pData1 = pAttrData[sKey1];
pAttr = this.pAttributes[sKey1];
if (pData1 === null) {
continue ;

}

if ((pAttrToReal[sKey1]) !== undefined) {
continue ;

}

pAttrToReal[sKey1] = nAttr;
isNewBuffer = false;
if ((pData1.eType) !== (1)) {
if ((pAttr.isPointer) || (!(pAttr.pType.isBase()))) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "][") + "") + "]") + "Bad data in buffers 001");
return false;

}

pAttrInit[nAttr] = sKey1;
nAttr++;
continue ;

}
else if ((pAttrToBuffer[sKey1]) === undefined) {
iRealSampler = pRealSamplers[pData1.pData.buffer.toNumber()];
if (iRealSampler === undefined) {
iRealSampler = nRealSamplers;
nRealSamplers++;
pSamplersUsage[iRealSampler] = 0;
pRealSamplers[pData1.pData.buffer.toNumber()] = iRealSampler;

}

pAttrToBuffer[sKey1] = iRealSampler;
pSamplersUsage[iRealSampler] |= 1 << 0;
pSamplersUsage[iRealSampler] |= 1 << 1;

}


for (j = i; j < (pKeys.length); j++) {
sKey2 = pKeys[j];
pData2 = pAttrData[sKey2];
if (pData2 === null) {
continue ;

}

if (pData1 === pData2) {
pAttrToReal[sKey2] = nAttr;

}

if ((((pData1.eType) === (1)) && ((pData2.eType) === (1))) && ((pData1.pData._pVertexBuffer) === (pData2.pData._pVertexBuffer))) {
pAttrToBuffer[sKey2] = pAttrToBuffer[sKey1];

}


}

nAttr++;

}

pRealAttrs = new Array(nAttr);
for (i = 0; i < (pKeys.length); i++) {
sKey1 = pKeys[i];
if ((pAttrToBuffer[sKey1]) !== undefined) {
pBuffers = this.pAttrBuffers[sKey1];
sData1 = (a.fx.SHADER_PREFIX.SAMPLER) + (pAttrToBuffer[sKey1]);
sData2 = (a.fx.SHADER_PREFIX.HEADER) + (pAttrToBuffer[sKey1]);
if (!pBuffers) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "][") + "") + "]") + "You set data as buffer but the are not so");
return false;

}

for (j = 0; j < (pBuffers.length); j++) {
pBuffers[j].pSampler.pData = sData1;
pBuffers[j].pHeader.pData = sData2;

}


}


}

for (i = 0; i < nAttr; i++) {
sKey1 = pAttrInit[i];
sAttr = (a.fx.SHADER_PREFIX.ATTRIBUTE) + i;
if (sKey1 !== undefined) {
pAttr = this.pAttributes[sKey1];
pRealAttrs[i] = ((("attribute " + (pAttr.pType.pEffectType.toCode())) + " ") + sAttr) + ";";
continue ;

}

pRealAttrs[i] = ("attribute float " + sAttr) + ";";

}

for (i = 0; i < (pKeys.length); i++) {
sKey1 = pKeys[i];
pAttr = this.pAttributes[sKey1];
pData1 = pAttrData[sKey1];
iAttr = pAttrToReal[sKey1];
iBuffer = pAttrToBuffer[sKey1];
sInit = "";
sDecl = this._pAttrDataDecl[sKey1];
if (!pData1) {
if ((pAttr.isPointer) === true) {
sDecl += this._pAttrIndexDecl[sKey1];
isZeroSamplerV = true;
isZeroHeaderV = true;
isExtractInitV = true;
for (j = 0; j < (this.pAttrBuffers[sKey1].length); j++) {
pBuffer = this.pAttrBuffers[sKey1][j];
pBuffer.pSampler.pData = PassBlend.sZeroSampler;
pBuffer.pHeader.pData = PassBlend.sZeroHeader;

}


}


}
else  {
sAttr = (a.fx.SHADER_PREFIX.ATTRIBUTE) + iAttr;
if ((pData1.eType) !== (1)) {
sInit = (((pAttr.toCode()) + "=") + sAttr) + ";";

}
else  {
sDecl += this._pAttrIndexDecl[sKey1];
isExtractInitV = true;
this.pExtrectedFunctionsV["header"] = null;
sUniformOffset += ("uniform float " + (pAttr.toOffsetStr())) + ";";
sInit += (((((pAttr.pPointers[(pAttr.pPointers.length) - 1].toCode()) + "=") + sAttr) + "+") + (pAttr.toOffsetStr())) + ";";
sInit += this._toFinalCode(this._pAttrIndexInit[sKey1]);
if (this._pAttrDataInit[sKey1].isComplex) {
pData2 = this._pAttrDataInit[sKey1];
for (j = 0; j < (pData2.length); j++) {
if (this._pAttrIndexDecl[pData2[j]]) {
sDecl += this._pAttrIndexDecl[pData2[j]];
sInit += this._toFinalCode(this._pAttrIndexInit[pData2[j]]);

}

sInit += this._toFinalCode(this._pAttrDataInit[pData2[j]]);

}


}
else  {
sInit += this._toFinalCode(this._pAttrDataInit[sKey1]);

}


}


}

if (sDecl) {
pAttrDecl[sKey1] = sDecl;
pAttrInit[sKey1] = sInit;

}


}

for (i = 0; i < (pTexcoords.length); i++) {
if (((pTexcoords[i]) !== undefined) && ((pTexcoords[i]) !== null)) {
sName2 = (a.fx.SHADER_PREFIX.TEXCOORD) + (pTexcoords[i]);
if (!(pAttrData[sName2])) {
pTexcoords[i] = 0;

}

if (i !== (pTexcoords[i])) {
sName1 = (a.fx.SHADER_PREFIX.TEXCOORD) + i;
pAttr = this.pAttributes[sName1];
if (pAttr) {
pTempVarsDecl[sName1] = ((((((pAttr.pType.pEffectType.toCode()) + " ") + (a.fx.SHADER_PREFIX.TEMP)) + i) + "=") + sName1) + ";";

}


}


}


}

var sVertexCode="";
var sFragmentCode="";
var isExtract;
nSamplers = a.info.graphics.maxVertexTextureImageUnits(this._pEngine.pDevice);
isExtract = false;
if (isExtractInitV) {
sVertexCode += PassBlend.pExtractedFunctions["init"];
isExtract = true;

}

for (i in this.pExtrectedFunctionsV) {
if (!isExtract) {
sVertexCode += PassBlend.pExtractedFunctions["init"];
isExtract = true;

}

if (!(PassBlend.pExtractedFunctions[i])) {
trace("ERRRRRRRRRRRRRRRRRRRRRRROR", i, PassBlend.pExtractedFunctions[i]);

}

sVertexCode += PassBlend.pExtractedFunctions[i];

}

for (i = 0; i < (this.pTypesOrderV.length); i++) {
sVertexCode += (this.pTypesBlockV[this.pTypesOrderV[i].sRealName]) + ";";

}

for (i = 1; i < (this._nBlendTypes); i++) {
sName1 = (a.fx.SHADER_PREFIX.BLEND_TYPE) + i;
if ((this.pMixedTypesV[sName1]) === null) {
sVertexCode += this._pBlendTypesDecl[sName1];

}


}

for (i in this.pExternalsBlockV) {
sVertexCode += this.pExternalsBlockV[i];

}

for (i in this.pFuncDefBlockV) {
sVertexCode += i + ";";

}

if (isZeroSamplerV) {
nSamplers--;
sVertexCode += PassBlend.sZeroSamplerDecl;

}

for (i = 0; i < nRealSamplers; i++) {
if ((pSamplersUsage[i] & (1 << 0)) != 0) {
nSamplers--;
sVertexCode += this._pRealSamplersDecl[i];

}


}

for (i = 0; i < (pSamplersArrayV.length); i++) {
pSampler = pSamplersArrayV[i];
nSamplers -= pSampler.iLength;
sVertexCode += "uniform " + (pSampler.toCodeDecl());

}

for (i in this.pUniformsBlockV) {
sVertexCode += this.pUniformsBlockV[i];

}

if (isZeroHeaderV) {
sVertexCode += PassBlend.sZeroHeaderDecl;

}

for (i = 0; i < nRealSamplers; i++) {
if ((pSamplersUsage[i] & (1 << 1)) != 0) {
nSamplers--;
sVertexCode += this._pRealBuffesDecl[i];

}


}

for (i in this.pGlobalVarBlockV) {
sVertexCode += this.pGlobalVarBlockV[i];

}

for (i in this.pVaryingsDef) {
sVertexCode += this.pVaryingsDef[i];

}

for (i = 0; i < nAttr; i++) {
sVertexCode += pRealAttrs[i];

}

if (nSamplers < 0) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "][") + "") + "]") + "More samplers used than vertex shader can provide");
return false;

}

sVertexCode += sUniformOffset;
for (i = 0; i < (pKeys.length); i++) {
sKey1 = pKeys[i];
if (pAttrDecl[sKey1]) {
sVertexCode += pAttrDecl[sKey1];

}


}

sVertexCode += this.sVaryingsOut;
for (i in this.pFuncDeclBlockV) {
sVertexCode += (this._toFinalCode(this.pFuncDeclBlockV[i])) + "\n";

}

for (i = 0; i < (this.pVertexShaders.length); i++) {
sVertexCode += (this.pVertexShaders[i].toFinal()) + "\n";

}

sVertexCode += "void main(){";
for (i = 0; i < nRealSamplers; i++) {
if ((pSamplersUsage[i] & (1 << 1)) != 0) {
nSamplers--;
sVertexCode += this._pRealBuffesInit[i];

}


}

for (i = 0; i < (pKeys.length); i++) {
sKey1 = pKeys[i];
if (pAttrInit[sKey1]) {
sVertexCode += pAttrInit[sKey1];

}


}

for (i in pTempVarsDecl) {
sVertexCode += pTempVarsDecl[i];

}

for (i = 0; i < (pTexcoords.length); i++) {
if ((((pTexcoords[i]) !== undefined) && ((pTexcoords[i]) !== null)) && (i !== (pTexcoords[i]))) {
sName1 = (a.fx.SHADER_PREFIX.TEXCOORD) + i;
sName2 = (a.fx.SHADER_PREFIX.TEXCOORD) + (pTexcoords[i]);
pAttr = this.pAttributes[sName1];
pAttr1 = this.pAttributes[sName2];
if (pAttr && pAttr1) {
sVertexCode += ((((sName1 + "=") + (pAttr.pType.pEffectType.toCode())) + "(") + ((pTempVarsDecl[sName2]? (a.fx.SHADER_PREFIX.TEMP) + (pTexcoords[i]) : sName2))) + ");";

}


}


}

for (i = 0; i < (this.pVertexShaders.length); i++) {
sVertexCode += (this.pVertexShaders[i].sRealName) + "();";

}

for (i in this.pVaryingsBlock) {
sVertexCode += this.pVaryingsBlock[i];

}

sVertexCode += "}";
nSamplers = a.info.graphics.maxCombinedTextureImageUnits(this._pEngine.pDevice);
isExtract = false;
if (isExtractInitF) {
sFragmentCode += PassBlend.pExtractedFunctions["init"];
isExtract = true;

}

for (i in this.pExtrectedFunctionsF) {
if (!isExtract) {
sFragmentCode += PassBlend.pExtractedFunctions["init"];
isExtract = true;

}

sFragmentCode += PassBlend.pExtractedFunctions[i];

}

for (i = 0; i < (this.pTypesOrderF.length); i++) {
sFragmentCode += (this.pTypesBlockF[this.pTypesOrderF[i].sRealName]) + ";";

}

for (i = 1; i < (this._nBlendTypes); i++) {
sName1 = (a.fx.SHADER_PREFIX.BLEND_TYPE) + i;
if ((this.pMixedTypesF[sName1]) === null) {
sFragmentCode += this._pBlendTypesDecl[sName1];

}


}

for (i in this.pExternalsBlockF) {
sFragmentCode += this.pExternalsBlockF[i];

}

for (i in this.pFuncDefBlockF) {
sFragmentCode += i + ";";

}

if (isZeroSamplerF) {
nSamplers--;
sFragmentCode += PassBlend.sZeroSamplerDecl;

}

for (i = 0; i < nRealSamplers; i++) {
if ((pSamplersUsage[i] & (1 << 2)) != 0) {
nSamplers--;
sFragmentCode += this._pRealSamplersDecl[i];

}


}

for (i = 0; i < (pSamplersArrayF.length); i++) {
pSampler = pSamplersArrayF[i];
nSamplers -= pSampler.iLength;
sVertexCode += pSampler.toCodeDecl();

}

if (nSamplers < 0) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "][") + "") + "]") + "More samplers used than fragment shader can provide");
return false;

}

for (i in this.pUniformsBlockF) {
sFragmentCode += this.pUniformsBlockF[i];

}

if (isZeroHeaderF) {
sFragmentCode += PassBlend.sZeroHeaderDecl;

}

for (i = 0; i < nRealSamplers; i++) {
if ((pSamplersUsage[i] & (1 << 3)) != 0) {
nSamplers--;
sFragmentCode += this._pRealBuffesDecl[i];

}


}

for (i in this.pGlobalVarBlockF) {
sFragmentCode += this.pGlobalVarBlockF[i];

}

for (i in this.pVaryingsDef) {
sFragmentCode += this.pVaryingsDef[i];

}

for (i in this.pFuncDeclBlockF) {
sFragmentCode += (this._toFinalCode(this.pFuncDeclBlockF[i])) + "\n";

}

for (i = 0; i < (this.pFragmentShaders.length); i++) {
sFragmentCode += (this.pFragmentShaders[i].toFinal()) + "\n";

}

sFragmentCode += "void main(){";
for (i = 0; i < nRealSamplers; i++) {
if ((pSamplersUsage[i] & (1 << 3)) != 0) {
nSamplers--;
sFragmentCode += this._pRealBuffesDecl[i];

}


}

for (i = 0; i < (this.pFragmentShaders.length); i++) {
sFragmentCode += (this.pFragmentShaders[i].sRealName) + "();";

}

sFragmentCode += "}";
if (sFragmentCode !== "") {
sFragmentCode = "#ifdef GL_ES\nprecision lowp float;\n#endif\n" + sFragmentCode;

}

pProgram = this._pEngine.displayManager().shaderProgramPool().createResource(sHash);
pProgram._pPassBlend = this;
pProgram.setUniformVars(this.pUniforms, isZeroSamplerV || isZeroSamplerF);
pProgram.setAttrParams(pAttrToReal, pAttrToBuffer, pSamplersToReal, pBuffersToReal, nAttr, nRealSamplers);
if (!(pProgram.create(sHash, sVertexCode, sFragmentCode))) {
return false;

}

if (!(pProgram.setup(pAttrData, pUniformData, pTextures))) {
return false;

}

trace("Pass blend ---->", pProgram);
return pProgram;

};
PassBlend.prototype._toFinalCode = function(pCode) {
if ((typeof pCode) === "string") {
return pCode;

}

var sCode="";
for (var i=0; i < (pCode.length); i++) {
if (((typeof (pCode[i])) === "string") || ((typeof (pCode[i])) === "number")) {
sCode += pCode[i];

}
else  {
sCode += pCode[i].toDataCode();

}


}

return sCode;

};
PassBlend.prototype._blendTypes = function(pVars, pUsedTypes) {
var sNewType="";
var k, l, m, j;
var pType, pVar;
for (k = 0; k < (pVars.length); k++) {
pType = pVars[k].pType.pEffectType;
sNewType += (pType.sRealName) + "|";

}

if (this._pBlendTypes[sNewType]) {
return this._pBlendTypes[sNewType];

}

var pFields= {};
var sFields="";
var pTypes=[];
var pOrders;
var sTypeName;
var iBlendStatus;
var pUsedType;
var isUsed;
for (k = 0; k < (pVars.length); k++) {
pType = pVars[k].pType.pEffectType.pDesc;
pOrders = pType.pOrders;
for (l = 0; l < (pOrders.length); l++) {
if (pFields[pOrders[l].sRealName]) {
continue ;

}

if (pOrders[l].pType.isBase()) {
pFields[pOrders[l].sRealName] = pOrders[l].toCodeDecl();
continue ;

}

pTypes.length = 0;
pTypes.push(pOrders[l]);
for (m = k + 1; m < (pVars.length); m++) {
pVar = pVars[m].pType.pEffectType.pDesc._pSemantics[pOrders[l].sSemantic];
if (pVar) {
for (j = 0; j < (pTypes.length); j++) {
iBlendStatus = pTypes[j].canBlend(pVar);
if (iBlendStatus === 1) {
break ;

}


}

if (iBlendStatus === 2) {
pTypes.push(pVar);

}


}


}

if ((pTypes.length) === 1) {
pFields[pOrders[l].sRealName] = pOrders[l].toCodeDecl();
if (pUsedTypes) {
pUsedType = pOrders[l].pType.pEffectType;
isUsed = false;
for (m = 0; m < (pUsedTypes.length); m++) {
if ((pUsedTypes[m]) === pUsedType) {
isUsed = true;
break ;

}


}

if (!isUsed) {
pUsedTypes.push(pUsedType);

}


}


}
else  {
sTypeName = this._blendTypes(pTypes, pUsedTypes);
pFields[pOrders[l].sRealName] = ((sTypeName + " ") + (pOrders[l].sRealName)) + ";";

}


}


}

sTypeName = (a.fx.SHADER_PREFIX.BLEND_TYPE) + (this._nBlendTypes);
this._nBlendTypes++;
this._pBlendTypes[sNewType] = sTypeName;
for (k in pFields) {
sFields += pFields[k];

}

this._pBlendTypesDecl[sTypeName] = ((("struct " + sTypeName) + "{") + sFields) + "};";
return sTypeName;

};
PassBlend.prototype._addExternal = function(pVar, isVertex) {
var pExternals;
var sName=pVar.toCode();
var pPrevVar;
var i;
var iBlendStatus;
if (isVertex) {
pExternals = this.pExternalsV;

}
else  {
pExternals = this.pExternalsF;

}

if (!(pExternals[sName])) {
pExternals[sName] = pVar;
return true;

}

if ((pExternals[sName]) instanceof Array) {
pPrevVar = pExternals[sName];
for (i = 0; i < (pPrevVar.length); i++) {
iBlendStatus = pPrevVar[i].canBlend(pVar);
if (iBlendStatus === 0) {
if (!0) {
var err=((((((("Error:: " + "Types for blending external must be mixible 1") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Types for blending external must be mixible 1");

}


}

;
return false;

}

if (iBlendStatus === 1) {
break ;

}


}

if (iBlendStatus === 2) {
pExternals[sName].push(pVar);

}


}
else  {
pPrevVar = pExternals[sName];
iBlendStatus = pPrevVar.canBlend(pVar);
if (iBlendStatus === 0) {
if (!0) {
var err=((((((("Error:: " + "Types for blending external must be mixible 1") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/Component.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Types for blending external must be mixible 1");

}


}

;
return false;

}

if (iBlendStatus === 2) {
pExternals[sName] = [pPrevVar, pVar];

}


}

return true;

};
PassBlend.prototype._getUsedTypes = function(pVar, pUsedTypes) {
pUsedTypes = pUsedTypes || ([]);
if (pVar.pType.isBase()) {
return true;

}

var pType=pVar.pType.pEffectType;
var pOrders=pType.pDesc.pOrders;
var i;
var isUsed;
for (i = 0; i < (pOrders.length); i++) {
this._getUsedTypes(pOrders[i], pUsedTypes);

}

isUsed = false;
for (i = 0; i < (pUsedTypes.length); i++) {
if ((pUsedTypes[i]) === pType) {
isUsed = true;
break ;

}


}

if (!isUsed) {
pUsedTypes.push(pType);

}

return pUsedTypes;

};
PassBlend.prototype._addTypes = function(pUsedTypes, isVertex) {
var i;
var pType;
var pBlock, pOrder;
var sName;
if (isVertex) {
pBlock = (this.pTypesBlockV) || ( {});
pOrder = (this.pTypesOrderV) || ([]);

}
else  {
pBlock = (this.pTypesBlockF) || ( {});
pOrder = (this.pTypesOrderF) || ([]);

}

for (i = 0; i < (pUsedTypes.length); i++) {
pType = pUsedTypes[i];
sName = pType.toCodeString();
if (!(pBlock[sName])) {
pBlock[sName] = pType.toCode();
pOrder.push(pType);

}


}

if (isVertex) {
this.pTypesBlockV = pBlock;
this.pTypesOrderV = pOrder;

}
else  {
this.pTypesBlockF = pBlock;
this.pTypesOrderF = pOrder;

}


};
a["fx"]["PassBlend"] = PassBlend;
function RenderState(pEngine) {
this._pEngine = pEngine;
this._pDevice = pEngine.pDevice;
this.pVertexBuffer = null;
this.iVertexBufferState = -1;
this.pIndexBuffer = null;
this.iIndexBufferState = -1;
this.iFrameBuffer = null;
this.pFrameBuffer = null;
this.pProgram = null;
this.nAttrsUsed = 0;
this.pTexture = null;
this.iTextureSlot = -1;
this.pTextureSlotStates = new Array(a.info.graphics.maxTextureImageUnits(this._pDevice));
this.pTextureSlots = new Array(a.info.graphics.maxTextureImageUnits(this._pDevice));
for (var i=0; i < (this.pTextureSlots.length); i++) {
this.pTextureSlotStates[i] = false;
this.pTextureSlots[i] = null;

}


}

a["fx"]["RenderState"] = RenderState;
function FrameBuffer(pEngine) {
this._pEngine = pEngine;
var pDevice=this._pDevice = pEngine.pDevice;
this._pData = pDevice.createFramebuffer();
this._pColorAttachments = new Array(1);
this._eDepthAttachment = null;
this._eStencilAttachment = null;
this._iSystemId = a.sid();

}

FrameBuffer.prototype.toNumber = function() {
return this._iSystemId;

};
FrameBuffer.prototype.bind = function() {
this._pDevice.bindFramebuffer(this._pDevice.FRAMEBUFFER, this._pData);

};
FrameBuffer.prototype.release = function() {
var i;
var eTarget;
var pDevice=this._pDevice;
for (i = 0; i < (this._pColorAttachments.length); i++) {
eTarget = this._pColorAttachments[i];
if (eTarget) {
if (eTarget === (pDevice.RENDERBUFFER)) {
pDevice.framebufferRenderbuffer(pDevice.FRAMEBUFFER, (pDevice.COLOR_ATTACHMENT0) + i, eTarget, null);

}
else  {
pDevice.framebufferTexture2D(pDevice.FRAMEBUFFER, (pDevice.COLOR_ATTACHMENT0) + i, eTarget, null, 0);

}


}

this._pColorAttachments[i] = null;

}

eTarget = this._eDepthAttachment;
if (eTarget) {
if (eTarget === (pDevice.RENDERBUFFER)) {
pDevice.framebufferRenderbuffer(pDevice.FRAMEBUFFER, pDevice.DEPTH_ATTACHMENT, eTarget, null);

}
else  {
pDevice.framebufferTexture2D(pDevice.FRAMEBUFFER, pDevice.DEPTH_ATTACHMENT, eTarget, null, 0);

}


}

this._eDepthAttachment = null;
eTarget = this._eStencilAttachment;
if (eTarget) {
if (eTarget === (pDevice.RENDERBUFFER)) {
pDevice.framebufferRenderbuffer(pDevice.FRAMEBUFFER, pDevice.STENCIL_ATTACHMENT, eTarget, null);

}
else  {
pDevice.framebufferTexture2D(pDevice.FRAMEBUFFER, pDevice.STENCIL_ATTACHMENT, eTarget, null, 0);

}


}

this._eStencilAttachment = null;

};
FrameBuffer.prototype.frameBufferTexture2D = function(eAttachment, eTexTarget, pTexture) {
var pDevice=this._pDevice;
if (eAttachment === (pDevice.COLOR_ATTACHMENT0)) {
this._pColorAttachments[0] = eTexTarget;
pDevice.framebufferTexture2D(pDevice.FRAMEBUFFER, pDevice.COLOR_ATTACHMENT0, eTexTarget, pTexture, 0);

}
else if (eAttachment === (pDevice.DEPTH_ATTACHMENT)) {
this._eDepthAttachment = eTexTarget;
pDevice.framebufferTexture2D(pDevice.FRAMEBUFFER, pDevice.DEPTH_ATTACHMENT, eTexTarget, pTexture, 0);

}
else if (eAttachment === (pDevice.STENCIL_ATTACHMENT)) {
this._eStencilAttachment = eTexTarget;
pDevice.framebufferTexture2D(pDevice.FRAMEBUFFER, pDevice.STENCIL_ATTACHMENT, eTexTarget, pTexture, 0);

}
else  {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/ShaderUtil.js") + "][") + "") + "]") + "Bad attachment for frame buffer");
return false;

}



return true;

};
FrameBuffer.prototype.frameBufferRenderBuffer = function(eAttachment, eRenderBufferTarget, pRenderBuffer) {
var pDevice=this._pDevice;
if (eAttachment === (pDevice.COLOR_ATTACHMENT0)) {
this._pColorAttachments[0] = eRenderBufferTarget;
pDevice.framebufferRenderbuffer(pDevice.FRAMEBUFFER, pDevice.COLOR_ATTACHMENT0, eRenderBufferTarget, pRenderBuffer);

}
else if (eAttachment === (pDevice.DEPTH_ATTACHMENT)) {
this._eDepthAttachment = eRenderBufferTarget;
pDevice.framebufferRenderbuffer(pDevice.FRAMEBUFFER, pDevice.DEPTH_ATTACHMENT, eRenderBufferTarget, pRenderBuffer);

}
else if (eAttachment === (pDevice.STENCIL_ATTACHMENT)) {
this._eStencilAttachment = eRenderBufferTarget;
pDevice.framebufferRenderbuffer(pDevice.FRAMEBUFFER, pDevice.STENCIL_ATTACHMENT, eRenderBufferTarget, pRenderBuffer);

}
else  {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/shaders/ShaderUtil.js") + "][") + "") + "]") + "Bad attachment for frame buffer");
return false;

}



return true;

};
a["fx"]["FrameBuffer"] = FrameBuffer;
function PreRenderState(pEngine) {
this._pEngine = pEngine;
this.pBlend = null;
this.nShift = 0;
this.pAttributeData = [[], [], [], [], []];
this.pRenderObject = null;
this.pSurfaceMaterial = null;
this.pSnapshot = null;
this.pIndex = undefined;
this.iLength = null;
this.iOffset = null;
this.eDrawPrimitive = null;
this.pViewport =  {};

}

PreRenderState.prototype.setViewport = function() {
if ((arguments.length) === 1) {
this.pViewport.x = arguments[0].x;
this.pViewport.y = arguments[0].y;
this.pViewport.width = arguments[0].width;
this.pViewport.height = arguments[0].height;

}
else  {
this.pViewport.x = arguments[0];
this.pViewport.y = arguments[1];
this.pViewport.width = arguments[2];
this.pViewport.height = arguments[3];

}


};
PreRenderState.prototype.release = function() {
var i;
this.pBlend = null;
this.nShift = 0;
for (i = 0; i < (this.pAttributeData.length); i++) {
this.pAttributeData[i].length = 0;

}

this.pRenderObject = null;
this.pSurfaceMaterial = null;
this.pSnapshot = null;
this.pIndex = undefined;
this.iLength = null;
this.iOffset = null;
this.eDrawPrimitive = null;

};
a["fx"]["PreRenderState"] = PreRenderState;
function MaterialBase(sName) {
this._sName = sName || "unknown";
this._iID = 0;

}

window.$$enum_MATERIAL_COMPONENTS$_obj = {DIFFUSE: 'DIFFUSE', AMBIENT: 'AMBIENT', SPECULAR: 'SPECULAR', EMISSIVE: 'EMISSIVE', EMISSION: 'EMISSIVE', SHININESS: 'SHININESS', REFLECTIVE: 'REFLECTIVE', REFLECTIVITY: 'REFLECTIVITY', TRANSPARENT: 'TRANSPARENT', TRANSPARENCY: 'TRANSPARENCY', INDEXOFREFRACTION: 'INDEXOFREFRACTION'};
a.defineProperty(MaterialBase, "value", function() {
return this;

}
, function(pMaterialBase) {
if (!pMaterialBase) {
return ;

}

var pPoperties=$$enum_MATERIAL_COMPONENTS$_obj;
for (var i in pPoperties) {
if (i === "EMISSION") {
continue ;

}

this.setProperty(i, pMaterialBase.getProperty(i));

}


}
);
a.defineProperty(MaterialBase, "name", function() {
return this._sName;

}
, function(sName) {
this._sName = sName;

}
);
a.defineProperty(MaterialBase, "id", function() {
return this._iID;

}
, function(iID) {
this._iID = Number(iID);

}
);
a.defineProperty(MaterialBase, "data", function() {
return null;

}
, function(sName) {

}
);
MaterialBase.prototype.getProperty = function(eProperty) {
return null;

};
MaterialBase.prototype.setProperty = function(eProperty, pValue) {
return false;

};
a.MaterialBase = MaterialBase;
for (var m in $$enum_MATERIAL_COMPONENTS$_obj) {
(function(sComponent, eValue) {
a.defineProperty(MaterialBase, sComponent.toLowerCase(), function() {
return this.getProperty(eValue);

}
, function(c4fColor) {
this.setProperty(eValue, c4fColor);

}
);

}
)(m, $$enum_MATERIAL_COMPONENTS$_obj[m]);

}

MaterialBase.prototype.toDefault = function() {
"use strict";
this.diffuse = new Float32Array([0.5, 0.5, 0.5, 1]);
this.ambient = new Float32Array([0.8, 0.8, 0.8, 1]);
this.specular = new Float32Array([0.5, 0.5, 0.5, 1]);
this.shininess = 55;

};
MaterialBase.prototype.toString = function() {
"use strict";
var s="";
function printColor(pColor) {
var r=Math.floor((pColor[0]) * 255);
var g=Math.floor((pColor[1]) * 255);
var b=Math.floor((pColor[2]) * 255);
var a=Math.floor((pColor[3]) * 255);
return (((((((((((("0x" + (r.toHex(2))) + (g.toHex(2))) + (b.toHex(2))) + (a.toHex(2))) + "  (R: ") + (pColor[0].toFixed(2))) + ", G: ") + (pColor[1].toFixed(2))) + ", B: ") + (pColor[2].toFixed(2))) + ", A: ") + (pColor[3].toFixed(2))) + ")";

}

s += ("MATERIAL: " + (this.name)) + "\n";
s += "----------------------------------------------\n";
s += (" diffuse: " + (printColor(this.diffuse))) + "\n";
s += (" ambient: " + (printColor(this.ambient))) + "\n";
s += ("emissive: " + (printColor(this.emissive))) + "\n";
s += ("specular: " + (printColor(this.specular))) + "\n";
s += ("shininess: " + (this.shininess)) + "\n";
return s;

};
function Material(sName) {
var _pCtorValue=Material.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this.pDiffuse = new Float32Array(4);
this.pAmbient = new Float32Array(4);
this.pSpecular = new Float32Array(4);
this.pEmissive = new Float32Array(4);
this.pShininess = 0;

}

a.extend(Material, a.MaterialBase);
Material.prototype.getProperty = function(eProperty) {
switch(eProperty) {
case "DIFFUSE":
return this.pDiffuse;

case "AMBIENT":
return this.pAmbient;

case "SPECULAR":
return this.pSpecular;

case "EMISSIVE":
return this.pEmissive;

case "SHININESS":
return this.pShininess;
}
return null;

};
Material.prototype.setProperty = function(eProperty, pValue) {
switch(eProperty) {
case "DIFFUSE":
this.pDiffuse = pValue;
return true;

case "AMBIENT":
this.pAmbient = pValue;
return true;

case "SPECULAR":
this.pSpecular = pValue;
return true;

case "EMISSIVE":
this.pEmissive = pValue;
return true;

case "SHININESS":
this.pShininess = pValue;
return true;
}
return null;

};
a["Material"] = Material;
function MeshMaterial(sName, pVertexData) {
var _pCtorValue=MeshMaterial.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pData = pVertexData;

}

a.extend(MeshMaterial, a.MaterialBase);
MeshMaterial.vertexDeclaration = function() {
return new a.VertexDeclaration([ {nCount: 17, eType: 5126, eUsage: "MATERIAL"},  {nCount: 4, eType: 5126, eUsage: "DIFFUSE", iOffset: 0},  {nCount: 4, eType: 5126, eUsage: "AMBIENT"},  {nCount: 4, eType: 5126, eUsage: "SPECULAR"},  {nCount: 4, eType: 5126, eUsage: "EMISSIVE"},  {nCount: 1, eType: 5126, eUsage: "SHININESS"}]);

};
MeshMaterial.prototype.getProperty = function(eProperty) {
switch(eProperty) {
case "DIFFUSE":
return this._pData.getTypedData("DIFFUSE", 0, 1);

case "AMBIENT":
return this._pData.getTypedData("AMBIENT", 0, 1);

case "SPECULAR":
return this._pData.getTypedData("SPECULAR", 0, 1);

case "EMISSIVE":
return this._pData.getTypedData("EMISSIVE", 0, 1);

case "SHININESS":
return this._pData.getTypedData("SHININESS", 0, 1)[0];
}
return null;

};
MeshMaterial.prototype.setProperty = function(eProperty, pValue) {
switch(eProperty) {
case "DIFFUSE":
return this._pData.setData(pValue, "DIFFUSE");

case "AMBIENT":
return this._pData.setData(pValue, "AMBIENT");

case "SPECULAR":
return this._pData.setData(pValue, "SPECULAR");

case "EMISSIVE":
return this._pData.setData(pValue, "EMISSIVE");

case "SHININESS":
return this._pData.setData(new Float32Array([pValue]), "SHININESS");
}
return null;

};
a.defineProperty(MeshMaterial, "data", function() {
return this._pData.getTypedData("MATERIAL", 0, 1);

}
, function(pData) {
this._pData.setData(pData, "MATERIAL");

}
);
a["MeshMaterial"] = MeshMaterial;
function SurfaceMaterial(pEngine) {
var _pCtorValue=SurfaceMaterial.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pMaterial = new a.Material();
this._nTotalTextures = 0;
this._iTextureFlags = 0;
this._iTextureMatrixFlags = 0;
this._pTexture = new Array(16);
this._pTexcoord = new Array(16);
for (var i=0; i < (16); i++) {
this._pTexcoord[i] = i;

}

;
this._pTextureMatrix = new Array(16);
this.setMaterial();

}

a.extend(SurfaceMaterial, a.ResourcePoolItem);
a.defineProperty(SurfaceMaterial, "material", function() {
return this._pMaterial;

}
, function(pMaterial) {
if (pMaterial) {
this._pMaterial.value = pMaterial;

}
else  {
this._pMaterial.pDiffuse = new Float32Array([0.5, 0.5, 0.5, 1]);
this._pMaterial.pSpecular = new Float32Array([0.5, 0.5, 0.5, 1]);

}


}
);
a.defineProperty(SurfaceMaterial, "totalTextures", function() {
return this._nTotalTextures;

}
);
a.defineProperty(SurfaceMaterial, "textureFlags", function() {
return this._iTextureFlags;

}
);
a.defineProperty(SurfaceMaterial, "textureMatrixFlags", function() {
return this._iTextureMatrixFlags;

}
);
SurfaceMaterial.prototype.setMaterial = function(pMaterial) {
this.material = pMaterial || null;

};
SurfaceMaterial.prototype.isEqual = function(pSurfaceMaterial) {
"use strict";
if ((((this._nTotalTextures) === (pSurfaceMaterial._nTotalTextures)) && ((this._iTextureFlags) === (pSurfaceMaterial._iTextureFlags))) && ((this._iTextureMatrixFlags) === (pSurfaceMaterial._iTextureMatrixFlags))) {
if (((this._pMaterial) && (this._pMaterial.isEqual(pSurfaceMaterial._pMaterial))) || ((pSurfaceMaterial._pMaterial) === null)) {
for (var i=0; i < (this._pTexture.length); i++) {
if ((this._pTexture[i]) !== (pSurfaceMaterial._pTexture[i])) {
return false;

}


}

;
for (var i=0; i < (this._pTextureMatrix); ++i) {
for (var j=0; j < (this._pTextureMatrix[i].length); j++) {
if ((this._pTextureMatrix[i][j]) !== (pSurfaceMaterial._pTextureMatrix[i][j])) {
return false;

}


}

;

}

return true;

}


}

return false;

};
SurfaceMaterial.prototype.texture = function(iSlot) {
if (!((iSlot >= 0) && (iSlot < (16)))) {
var err=((((((("Error:: " + "invalid texture slot") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/SurfaceMaterial.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid texture slot");

}


}

;
return this._pTexture[iSlot];

};
SurfaceMaterial.prototype.texcoord = function(iSlot) {
"use strict";
if (!((iSlot >= 0) && (iSlot < (16)))) {
var err=((((((("Error:: " + "invalid texture slot") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/SurfaceMaterial.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid texture slot");

}


}

;
return this._pTexcoord[iSlot];

};
SurfaceMaterial.prototype.textureMatrix = function(iSlot) {
if (!(iSlot < (16))) {
var err=((((((("Error:: " + "invalid texture slot") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/SurfaceMaterial.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid texture slot");

}


}

;
return this._pTextureMatrix[iSlot];

};
SurfaceMaterial.prototype.createResource = function() {
if (!(!(this.isResourceCreated()))) {
var err=((((((("Error:: " + "The resource has already been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/SurfaceMaterial.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has already been created.");

}


}

;
this.material = 0;
this.notifyLoaded();
this.notifyCreated();
this.notifyDisabled();
return true;

};
SurfaceMaterial.prototype.destroyResource = function() {
for (var i=0; i < (16); ++i) {
delete (this._pTexture[i]);
delete (this._pTextureMatrix[i]);
this._iTextureFlags &= ~(1 << i);
this._iTextureMatrixFlags &= ~(1 << i);

}

this._nTotalTextures = 0;
if (this.isResourceCreated()) {
this.disableResource();
this.notifyUnloaded();
this.notifyDestroyed();
return true;

}

return false;

};
SurfaceMaterial.prototype.restoreResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/SurfaceMaterial.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyRestored();
return true;

};
SurfaceMaterial.prototype.disableResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/SurfaceMaterial.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyDisabled();
return true;

};
SurfaceMaterial.prototype.loadResource = function(sFileName, sURI) {
sFileName = sFileName || (this.findResourceName());
var isResult=false;
return isResult;

};
SurfaceMaterial.prototype.saveResource = function(sFileName) {
sFileName = sFileName || (this.findResourceName());
var isResult=false;
return isResult;

};
SurfaceMaterial.prototype.setTexture = function(iIndex, pTexture, iTexcoord) {
iTexcoord = (iTexcoord === undefined? 0 : iTexcoord);
if (!(iIndex < (16))) {
var err=((((((("Error:: " + "invalid texture slot") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/SurfaceMaterial.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid texture slot");

}


}

;
var pDisplayManager=this._pEngine.pDisplayManager;
this._pTexcoord[iIndex] = iTexcoord;
if ((typeof pTexture) == "string") {
if (this._pTexture[iIndex]) {
a.safeRelease(this._pTexture[iIndex]);
this._iTextureFlags &= ~(1 << iIndex);
--this._nTotalTextures;

}

this._pTexture[iIndex] = pDisplayManager.texturePool().loadResource(pTexture);
if (this._pTexture[iIndex]) {
this._iTextureFlags |= 1 << iIndex;
++this._nTotalTextures;
this.connect(this._pTexture[iIndex], 1);

}

return true;

}
else if (pTexture instanceof (a.Texture)) {
if ((!(this._pTexture[iIndex])) || (pTexture != (this._pTexture[iIndex]))) {
if (this._pTexture[iIndex]) {
a.safeRelease(this._pTexture[iIndex]);
this._iTextureFlags &= ~(1 << iIndex);
--this._nTotalTextures;

}

this._pTexture[iIndex] = pTexture;
this._pTexture[iIndex].addRef();
this._iTextureFlags |= 1 << iIndex;
++this._nTotalTextures;
this.connect(this._pTexture[iIndex], 1);

}

return true;

}
else if ((typeof pTexture) == "number") {
if ((!(this._pTexture[iIndex])) || ((this._pTexture[iIndex].resourceHandle()) != pTexture)) {
if (this._pTexture[iIndex]) {
a.safeRelease(this._pTexture[iIndex]);
this._iTextureFlags &= ~(1 << iIndex);
--this._nTotalTextures;

}

this._pTexture[iIndex] = pDisplayManager.texturePool().getResource(pTexture);
if (this._pTexture[iIndex]) {
this._iTextureFlags |= 1 << iIndex;
++this._nTotalTextures;
this.connect(this._pTexture[iIndex], 1);

}


}

return true;

}



this._pTexcoord[iIndex] = iIndex;
return false;

};
SurfaceMaterial.prototype.setTextureMatrix = function(index, matrix) {
if (!(index < (16))) {
var err=((((((("Error:: " + "invalid texture slot") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/SurfaceMaterial.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid texture slot");

}


}

;
if (!matrix) {
this._pTextureMatrix[index] = new Mat4();

}
else  {
this._pTextureMatrix[index] = new Mat4(matrix);

}

this._textureMatrixFlags.setBit(index);
return true;

};
a.SurfaceMaterial = SurfaceMaterial;
function EffectResource(pEngine) {
EffectResource.superclass.constructor.apply(this, arguments);
this._pShaderManager = pEngine.pShaderManager;
this._nTotalPasses = 0;
this._iMode = 0;
this._pPassStates = [];
this._pModificationCallbacks = [];

}

a.extend(EffectResource, a.ResourcePoolItem);
EffectResource.prototype.isEqual = function(pEffect) {
"use strict";
if (((this._iMode) === (pEffect._iMode)) && ((this._nTotalPasses) === (pEffect._nTotalPasses))) {
return (this.magicMethod()) === (pEffect.magicMethod());

}

return false;

};
EffectResource.prototype.getManager = function() {
return this._pShaderManager;

};
EffectResource.prototype.replicable = function(bValue) {
bValue = bValue || true;
(bValue? this._iMode |= 1 << 1 : this._iMode &= ~(1 << 1));

};
EffectResource.prototype.isReplicated = function() {
return (this._iMode & (1 << 1)) != 0;

};
EffectResource.prototype.miscible = function(bValue) {
bValue = bValue || true;
(bValue? this._iMode |= 1 << 2 : this._iMode &= ~(1 << 2));

};
EffectResource.prototype.isMixid = function() {
return (this._iMode & (1 << 2)) != 0;

};
EffectResource.prototype.isParameterUsed = function(pParameter, iPass) {
return (this.findParameter(pParameter, iPass)? true : false);

};
EffectResource.prototype.totalComponents = function() {
return this._pShaderManager.getComponentCount(this);

};
EffectResource.prototype.getComponent = function(i) {
return this._pShaderManager.getComponent(this, i);

};
EffectResource.prototype.findParameter = function(pParameter, iPass) {
iPass = (iPass === undefined? (-1) : iPass);
return this._pShaderManager.findParameter(this, pParameter, iPass, 1);

};
EffectResource.prototype.totalPasses = function() {
return this._pShaderManager.totalPasses(this);

};
EffectResource.prototype.create = function() {
if (!(this._pShaderManager.registerEffect(this))) {
return false;

}

this.notifyLoaded();
this.notifyRestored();
return true;

};
EffectResource.prototype.createResource = function() {
this.miscible();
this.notifyCreated();
this.notifyDisabled();
this.notifyLoaded();
return true;

};
EffectResource.prototype.destroyResource = function() {
if (this.isResourceCreated()) {
this.disableResource();
this.notifyUnloaded();
this.notifyDestroyed();
return true;

}

return false;

};
EffectResource.prototype.disableResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/EffectResource.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyDisabled();
return true;

};
EffectResource.prototype.restoreResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/EffectResource.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyRestored();
return true;

};
EffectResource.prototype.loadResource = function(sFileName) {
this.notifyUnloaded();
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/EffectResource.js") + "][") + "") + "]") + ("TODO:: " + "Загрузка эффект ресурса"));
throw new Error("TODO::\n" + "Загрузка эффект ресурса");
return true;

};
EffectResource.prototype.use = function(iComponentHandle, nShift, isSet) {
nShift = (nShift === undefined? 0 : nShift);
isSet = (isSet === undefined? true : isSet);
var pManager=this._pShaderManager;
nShift = nShift || 0;
if ((typeof iComponentHandle) === "object") {
iComponentHandle = iComponentHandle.resourceHandle();

}
else if ((typeof iComponentHandle) === "string") {
iComponentHandle = pManager.getComponentByName(iComponentHandle).resourceHandle();

}


if (isSet) {
if (!(pManager.activateComponent(this, iComponentHandle, nShift))) {
if (!0) {
var err=((((((("Error:: " + "Невозможно добавить ингридиент.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/EffectResource.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Невозможно добавить ингридиент.");

}


}

;
return false;

}


}
else  {
if (!(pManager.deactivateComponent(this, iComponentHandle, nShift))) {
if (!0) {
var err=((((((("Error:: " + "Невозможно убрать ингридиент.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/EffectResource.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Невозможно убрать ингридиент.");

}


}

;
return false;

}


}

this.notifyAltered();
if (((this.totalComponents()) === 1) && isSet) {
this.notifyRestored();

}
else if (((this.totalComponents()) === 0) && (!isSet)) {
this.notifyDisabled();

}


return true;

};
EffectResource.prototype.unUse = function(iComponentHandle, nShift) {
return this.use(iComponentHandle, nShift, false);

};
EffectResource.prototype._updateParameterList = function(iComponentHandle, isSet) {
var pManager=this._pShaderManager;
var pParameterList, pParameter, pReservedParameter;
var nTotalPasses;
var pPassState=this._pPassStates;
var i;
nTotalPasses = pManager.getTotalPasses(iComponentHandle);
this._nTotalPasses = Math.max(this._nTotalPasses, nTotalPasses);
for (i = 0; i < nTotalPasses; i++) {
pParameterList = pManager.getParameterList(iComponentHandle, i, a.Renderer.PARAMETER_FLAG_NONSYTEM);
if (!pParameterList) {
continue ;

}

if (!(pPassState[i])) {
pPassState[i] = pPassState =  {};

}

for (var j=0; j < (pParameterList.length); ++j) {
pParameter = pParameterList[j];
pReservedParameter = pPassState[pParameter.name];
if ((pReservedParameter === undefined) && isSet) {
pReservedParameter =  {nUses: 0, pValue: null};
if (pParameter.isArray()) {
pReservedParameter.pValue = GEN_ARRAY(null, pParameter.numElements());

}

pPassState[pParameter.name] = pReservedParameter;

}

pReservedParameter.nUses += (isSet? 1 : -1);
if ((pReservedParameter.nUses) === 0) {
delete (pPassState[pParameter.name]);

}


}


}

for (var i=0; i < (this._pModificationCallbacks.length); i++) {
if ((this._pModificationCallbacks[i]) == fn) {
this._pModificationCallbacks(this);

}


}

;
return true;

};
EffectResource.prototype.saveResource = function(sFileName) {
return true;

};
a.EffectResource = EffectResource;
function RenderEntry() {
this.pProgram = null;
this.pAttributes = null;
this.pUniforms = null;
this.pTextures = null;
this.pIndexData = null;
this.iOffset = 0;
this.iLength = 0;
this.eDrawPrim = null;
this.iViewportX = 0;
this.iViewportY = 0;
this.iViewportWidth = 0;
this.iViewportHeight = 0;
this.iFrameBuffer = null;

}

a["RenderEntry"] = RenderEntry;
RenderEntry.prototype.clear = function() {
this.pProgram = null;
this.pAttributes = null;
this.pUniforms = null;
this.pTextures = null;
this.pIndexData = null;
this.iOffset = 0;
this.iLength = 0;
this.eDrawPrim = null;
this.iViewportX = 0;
this.iViewportY = 0;
this.iViewportWidth = 0;
this.iViewportHeight = 0;
this.iFrameBuffer = null;

};
RenderEntry.prototype.set = function(pProgram, pAttrs, pUniformValues, pTextures, pIndex, iOffset, iLength, eDrawPrimitive, iVeiwportX, iViewportY, iViewportWidth, iViewportHeight, iFrameBuffer) {
this.pProgram = pProgram;
this.pAttributes = pAttrs;
this.pUniforms = pUniformValues;
this.pTextures = pTextures;
this.pIndexData = pIndex;
this.iOffset = iOffset;
this.iLength = iLength;
this.eDrawPrim = eDrawPrimitive;
this.iViewportX = iVeiwportX;
this.iViewportY = iViewportY;
this.iViewportWidth = iViewportWidth;
this.iViewportHeight = iViewportHeight;
this.iFrameBuffer = iFrameBuffer;

};
function RenderQueue(pEngine) {
;
this._pEngine = pEngine;
this._iIncrement = 0;
this._nCount = 0;
this._pFreeEntrys = null;
this._nSortCount = 0;
this._pSortEntrys = null;

}

a["RenderQueue"] = RenderQueue;
RenderQueue.prototype.init = function(nCount, iIncrement) {
nCount = nCount || (200);
iIncrement = iIncrement || (20);
this._iIncrement = iIncrement;
this._nCount = nCount;
this._pFreeEntrys = new Array(nCount);
this._pSortEntrys = new Array(nCount);
var i;
for (i = 0; i < nCount; i++) {
this._pFreeEntrys[i] = new a.RenderEntry();

}


};
RenderQueue.prototype.getEmptyEntry = function() {
var pEntry;
var iElement;
if ((this._nCount) <= 0) {
this._addNewEntrys();

}

iElement = (this._nCount) - 1;
pEntry = this._pFreeEntrys[iElement];
this._pFreeEntrys[iElement] = null;
this._nCount--;
return pEntry;

};
RenderQueue.prototype._releaseEntry = function(pEntry) {
pEntry.clear();
this._pFreeEntrys[(this._nCount) - 1] = pEntry;
this._nSortCount--;

};
RenderQueue.prototype._addNewEntrys = function() {
var pNewEntrys=new Array(this._iIncrement);
var i;
for (i = 0; i < (this._iIncrement); i++) {
pNewEntrys[i] = new a.RenderEntry();

}

this._pFreeEntrys = pNewEntrys.concat(this._pFreeEntrys);
this._pSortEntrys.length += this._iIncrement;
this._nCount = this._iIncrement;

};
RenderQueue.prototype.addSortEntry = function(pEntry) {
var iIndex=this._nSortCount;
var iLength=this._pSortEntrys.length;
if (iLength === iIndex) {
this._addNewEntrys();

}

this._pSortEntrys[iIndex] = pEntry;
this._nSortCount++;

};
RenderQueue.prototype.execute = function() {
var i;
var iLength=this._nSortCount;
var pRenderer=this._pEngine.shaderManager();
for (i = 0; i < iLength; i++) {
pRenderer.render(this._pSortEntrys[i]);

}

this._nSortCount = 0;

};
RenderQueue.prototype.reset = function() {
this._nSortCount = 0;

};
function findPosX(pObj) {
var curleft=0;
if (pObj.offsetParent) {
while (1) {
curleft += pObj.offsetLeft;
if (!(pObj.offsetParent)) {
break ;

}

pObj = pObj.offsetParent;

}

}
else if (pObj.x) {
curleft += pObj.x;

}


return curleft;

}

;
function findPosY(pObj) {
var curtop=0;
if (pObj.offsetParent) {
while (1) {
curtop += pObj.offsetTop;
if (!(pObj.offsetParent)) {
break ;

}

pObj = pObj.offsetParent;

}

}
else if (pObj.y) {
curtop += pObj.y;

}


return curtop;

}

;
function Font2D(iSize, sColor, sFontFamily, isBold, isItalic) {
iSize = iSize || 12;
sColor = sColor || "#000000";
sFontFamily = sFontFamily || "times";
isBold = isBold || false;
isItalic = isItalic || false;
this._sFontSize = (String(iSize)) + "px";
if ((sColor[0]) != "#") {
this._sFontColor = "#" + sColor;

}
else  {
this._sFontColor = sColor;

}

this._sFontFamily = sFontFamily;
if (isBold) {
this._sBold = "bold";

}
else  {
this._sBold = "normal";

}

if (isItalic) {
this._sItalic = "italic";

}
else  {
this._sItalic = "normal";

}


}

;
function String2D(iX, iY, pFont, sStr, pDiv) {
pFont = pFont || (new a.Font2D());
var pSpan=document.createElement("span");
pSpan.style.position = "absolute";
pSpan.style.left = (String(iX)) + "px";
pSpan.style.top = (String(iY)) + "px";
pSpan.style.fontSize = pFont._sFontSize;
pSpan.style.color = pFont._sFontColor;
pSpan.style.fontFamily = pFont._sFontFamily;
pSpan.style.fontWeight = pFont._sBold;
pSpan.style.fontStyle = pFont._sItalic;
pSpan.style.webkitUserSelect = "none";
pSpan.style.mozUserSelect = "none";
pSpan.innerHTML = sStr;
pDiv.appendChild(pSpan);
this._pSpan = pSpan;
this._pLastSpan = pSpan;

}

;
String2D.prototype.append = function(sStr, pFont) {
if (pFont != undefined) {
var pStyle=this._pLastSpan.style;
if ((((((pStyle.fontSize) != (pFont._sFontSize)) || ((pStyle.color) != (pFont._sFontColor))) || ((pStyle.fontFamily) != (pFont._sFontFamily))) || ((pStyle.fontWeight) != (pFont._sFontWeight))) || ((pStyle.fontStyle) != (pFont._sFontStyle))) {
this._addSpan(sStr, pFont);

}
else  {
this._pLastSpan.innerHTML += sStr;

}


}
else  {
this._pLastSpan.innerHTML += sStr;

}


};
String2D.prototype._addSpan = function(sStr, pFont) {
var pSpan=document.createElement("span");
pSpan.style.fontSize = pFont._sFontSize;
pSpan.style.color = pFont._sFontColor;
pSpan.style.fontFamily = pFont._sFontFamily;
pSpan.style.fontWeight = pFont._sBold;
pSpan.style.fontStyle = pFont._sItalic;
pSpan.style.webkitUserSelect = "none";
pSpan.style.mozUserSelect = "none";
pSpan.innerHTML = sStr;
this._pSpan.appendChild(pSpan);
this._pLastSpan = pSpan;

};
String2D.prototype.hide = function() {
this._pSpan.style.visibility = "hidden";

};
String2D.prototype.show = function() {
this._pSpan.style.visibility = "visible";

};
String2D.prototype.clear = function() {
this._pSpan.innerHTML = null;
this._pLastSpan = this._pSpan;

};
String2D.prototype.toString = function() {
return this._pSpan.innerHTML;

};
String2D.prototype.edit = function(sStr) {
this._pSpan.innerHTML = sStr;
this._pLastSpan = this._pSpan;

};
function DisplayManager(pEngine) {
this._pEngine = pEngine;
this._pDevice = pEngine.pDevice;
this._pCanvas = pEngine.pCanvas;
this._pResourceManager = pEngine.pResourceManager;
this._bEnabled = false;
this._bClearEachFrame = true;
this._surfaceMaterialPool = new a.ResourcePool(pEngine, a.SurfaceMaterial);
this._surfaceMaterialPool.initialize(16);
this._effectPool = new a.ResourcePool(pEngine, a.EffectResource);
this._effectPool.initialize(16);
this._renderMethodPool = new a.ResourcePool(pEngine, a.RenderMethod);
this._renderMethodPool.initialize(16);
this._vertexBufferPool = new a.ResourcePool(pEngine, a.VertexBuffer);
this._vertexBufferPool.initialize(16);
this._indexBufferPool = new a.ResourcePool(pEngine, a.IndexBuffer);
this._indexBufferPool.initialize(16);
this._modelPool = new a.ResourcePool(pEngine, a.ModelResource);
this._modelPool.initialize(16);
this._imagePool = new a.ResourcePool(pEngine, a.Img);
this._imagePool.initialize(16);
this._texturePool = new a.ResourcePool(pEngine, a.Texture);
this._texturePool.initialize(16);
this._videoBufferPool = new a.ResourcePool(pEngine, a.VideoBuffer);
this._videoBufferPool.initialize(16);
this._shaderProgramPool = new a.ResourcePool(pEngine, a.ShaderProgram);
this._shaderProgramPool.initialize(1);
this._componentPool = new a.ResourcePool(pEngine, a.fx.Component);
this._componentPool.initialize(10);
this._pFontTexture = null;
this._pTextDiv = null;

}

;
DisplayManager.prototype.texturePool = function() {
;
return this._texturePool;

};
DisplayManager.prototype.surfaceMaterialPool = function() {
;
return this._surfaceMaterialPool;

};
DisplayManager.prototype.vertexBufferPool = function() {
;
return this._vertexBufferPool;

};
DisplayManager.prototype.videoBufferPool = function() {
;
return this._videoBufferPool;

};
DisplayManager.prototype.shaderProgramPool = function() {
;
return this._shaderProgramPool;

};
DisplayManager.prototype.indexBufferPool = function() {
;
return this._indexBufferPool;

};
DisplayManager.prototype.effectPool = function() {
;
return this._effectPool;

};
DisplayManager.prototype.renderMethodPool = function() {
;
return this._renderMethodPool;

};
DisplayManager.prototype.componentPool = function() {
;
return this._componentPool;

};
DisplayManager.prototype.modelPool = function() {
;
return this._modelPool;

};
DisplayManager.prototype.imagePool = function() {
;
return this._imagePool;

};
DisplayManager.prototype.queue = function() {
;
return this._renderQueue;

};
DisplayManager.prototype.enable = function() {
;
this._bEnabled = true;

};
DisplayManager.prototype.disable = function() {
;
this._bEnabled = false;

};
DisplayManager.prototype.enableFrameClearing = function(isCleared) {
;
this._bClearEachFrame = isCleared;

};
DisplayManager.prototype.draw2DText = function(iX, iY, pFont, sStr) {
;
return new a.String2D(iX, iY, pFont, sStr, this._pTextDiv);

};
DisplayManager.prototype.getTextLayer = function() {
return this._pTextDiv;

};
DisplayManager.prototype.initialize = function() {
this._pDevice.clearColor(0, 0, 0.5, 1);
this._pDevice.clearStencil(0);
this._pDevice.clearDepth(1);
this.registerDeviceResources();
this.initText2Dlayer();
return true;

};
DisplayManager.prototype.initText2Dlayer = function() {
var x=findPosX(this._pCanvas);
var y=findPosY(this._pCanvas);
var pDiv=document.createElement("div");
pDiv.setAttribute("id", "akra-canvas-overlay");
var pStyle=pDiv.style;
pStyle.width = (String(this._pCanvas.width)) + "px";
pStyle.height = (String(this._pCanvas.height)) + "px";
var iBorder=0;
if ((this._pCanvas.style.border) != "none") {
iBorder = parseInt(this._pCanvas.style.border);

}

pStyle.position = "absolute";
pStyle.left = (String(x)) + "px";
pStyle.top = (String(y)) + "px";
pStyle.overflow = "hidden";
pStyle.whiteSpace = "nowrap";
if (this._pCanvas.style.zIndex) {
pStyle.zIndex = (this._pCanvas.style.zIndex) + 1;

}
else  {
pStyle.zIndex = 2;

}

document.body.appendChild(pDiv);
this._pTextDiv = pDiv;

};
DisplayManager.prototype.destroy = function() {
this.unregisterDeviceResources();

};
DisplayManager.prototype.clearRenderSurface = function() {
if (this._pDevice) {
this._pDevice.clear(((this._pDevice.COLOR_BUFFER_BIT) | (this._pDevice.DEPTH_BUFFER_BIT)) | (this._pDevice.STENCIL_BUFFER_BIT));

}


};
DisplayManager.prototype.clearDepthBuffer = function() {
if (this._pDevice) {
this._pDevice.clear((this._pDevice.DEPTH_BUFFER_BIT) | (this._pDevice.STENCIL_BUFFER_BIT));

}


};
DisplayManager.prototype.clearScreen = function() {
if (this._pDevice) {
this.clearRenderSurface();

}


};
DisplayManager.prototype.registerDeviceResources = function() {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/DisplayManager.js") + "][") + "") + "]") + "Registering Video Device Resources\n");
this._texturePool.registerResourcePool(new a.ResourceCode(0, 0));
this._vertexBufferPool.registerResourcePool(new a.ResourceCode(0, 2));
this._indexBufferPool.registerResourcePool(new a.ResourceCode(0, 3));
this._effectPool.registerResourcePool(new a.ResourceCode(0, 4));
this._renderMethodPool.registerResourcePool(new a.ResourceCode(0, 5));
this._modelPool.registerResourcePool(new a.ResourceCode(0, 6));
this._imagePool.registerResourcePool(new a.ResourceCode(0, 8));
this._surfaceMaterialPool.registerResourcePool(new a.ResourceCode(0, 9));
this._videoBufferPool.registerResourcePool(new a.ResourceCode(0, 1));
this._shaderProgramPool.registerResourcePool(new a.ResourceCode(0, 10));
this._componentPool.registerResourcePool(new a.ResourceCode(0, 11));

};
DisplayManager.prototype.unregisterDeviceResources = function() {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/DisplayManager.js") + "][") + "") + "]") + "Unregistering Video Device Resources\n");
this._texturePool.unregisterResourcePool();
this._vertexBufferPool.unregisterResourcePool();
this._videoBufferPool.unregisterResourcePool();
this._indexBufferPool.unregisterResourcePool();
this._effectPool.unregisterResourcePool();
this._renderMethodPool.unregisterResourcePool();
this._modelPool.unregisterResourcePool();
this._imagePool.unregisterResourcePool();
this._surfaceMaterialPool.unregisterResourcePool();
this._shaderProgramPool.unregisterResourcePool();

};
DisplayManager.prototype.createDeviceResources = function() {
return true;

};
DisplayManager.prototype.destroyDeviceResources = function() {
this.disableDeviceResources();
if (this._pFontTexture) {
var safe_release_refcount=this._pFontTexture.release();
if (safe_release_refcount != 0) {
if (!0) {
var err=((((((("Error:: " + (("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/DisplayManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n"));

}


}

;

}

this._pFontTexture = 0;

}

;
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/DisplayManager.js") + "][") + "") + "]") + "Destroying Video Device Resources\n");
this._pResourceManager.destroyResourceFamily(0);
return true;

};
DisplayManager.prototype.restoreDeviceResources = function() {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/DisplayManager.js") + "][") + "") + "]") + "Restoring Video Device Resources\n");
this._pResourceManager.restoreResourceFamily(0);
return true;

};
DisplayManager.prototype.disableDeviceResources = function() {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/DisplayManager.js") + "][") + "") + "]") + "Disabling Video Device Resources\n");
this._pResourceManager.disableResourceFamily(0);
return true;

};
DisplayManager.prototype.beginRenderSession = function() {
if (this._bClearEachFrame) {
this.clearRenderSurface();

}

this.setDefaultRenderStates();
return true;

};
DisplayManager.prototype.setViewPort = function(fX0, fY0, fXSize, fYSize) {
this._pDevice.viewport(fX0, fY0, fXSize, fYSize);

};
DisplayManager.prototype.endRenderSession = function() {
this._pDevice.flush();
return true;

};
DisplayManager.prototype.setDefaultRenderStates = function() {
this._pDevice.setRenderState(19, 1);
this._pDevice.setRenderState(20, 1);
this._pDevice.setRenderState(22, 1029);
this._pDevice.setRenderState(26, false);
this._pDevice.setRenderState(7, true);
this._pDevice.setRenderState(14, true);
this._pDevice.setRenderState(23, 2);

};
function TLVertex() {
this.fX = 0;
this.fY = 0;
this.fZ = 0;
this.fW = 1;
this.v4fSpecular = new Float32Array([0, 0, 0, 1]);
this.v4fColor = new Float32Array([0, 0, 0, 1]);
this.fTu = 0;
this.fTv = 0;

}

Object.defineProperty(TLVertex.prototype, "v4fSpecular",  {set: function(value) {
this.v4fSpecular[0] = value[0], this.v4fSpecular[1] = value[1], this.v4fSpecular[2] = value[2], this.v4fSpecular[3] = value[3];

}
, get: function() {
return this.v4fSpecular;

}
});
Object.defineProperty(TLVertex.prototype, "v4fColor",  {set: function(value) {
this.v4fColor[0] = value[0], this.v4fColor[1] = value[1], this.v[2] = value[2], this.v4fColor[3] = value[3];

}
, get: function() {
return this.v4fColor;

}
});
a.TLVertex = TLVertex;
DisplayManager.prototype.checkResourceFormatSupport = function(fmt, resType, dwUsage) {
return true;

};
a.DisplayManager = DisplayManager;
a.String2D = String2D;
a.Font2D = Font2D;
var SHADER_PREFIX= {SAMPLER: "A_s_", HEADER: "A_h_", ATTRIBUTE: "A_a_", OFFSET: "A_o_", TEXTURE: "TEXTURE", TEXCOORD: "TEXCOORD", TEXMATRIX: "TEXMATRIX", TEMP: "TEMP_", BLEND_TYPE: "AUTO_BLEND_TYPE_"};
a["fx"]["SHADER_PREFIX"] = SHADER_PREFIX;
a.fx.ZEROSAMPLER = 19;
function Renderer(pEngine) {
;
this.pEngine = pEngine;
this.pDevice = pEngine.pDevice;
this._pEngineStates = pEngine.pEngineStates;
this._nEffectFile = 1;
this._pEffectFileStack = [];
this._pEffectFileDataPool = new a.ResourcePool(pEngine, a.fx.EffectFileData);
this._pEffectFileDataPool.initialize(16);
this._pComponentBlendsHash =  {"EMPTY": null};
this._pComponentBlendsId =  {0: null};
this._nComponentBlends = 1;
this._pPassBlends =  {};
this._pEffectResoureId =  {};
this._pEffectResoureBlend =  {};
this._pActiveSceneObject = null;
this._pActiveRenderObject = null;
this._pSceneObjectStack = [];
this._pPreRenderStateStack = [];
this._pPreRenderState = null;
this._pPreRenderStatePool = new Array(20);
for (var i=0; i < (this._pPreRenderStatePool.length); i++) {
this._pPreRenderStatePool[i] = new a.fx.PreRenderState(this.pEngine);

}

this._pCurrentViewport =  {x: this.pEngine.getActiveViewport().x, y: this.pEngine.getActiveViewport().y, width: this.pEngine.getActiveViewport().width, height: this.pEngine.getActiveViewport().height};
this._pPrograms =  {};
this._pRenderResources =  {};
this._pRenderResourceCounter =  {};
this._pRenderResourceCounterKeys = [];
this._pRenderState = new a.fx.RenderState(this.pEngine);
this._pStreamState = new Array(a.info.graphics.maxVertexAttributes(this.pDevice));
this._pFramebufferPool = new Array(10);
this._pEmptyFrameBuffers = new Array(10);
this._pFrameBufferCounters = new Array(10);
for (var i=0; i < (this._pFramebufferPool.length); i++) {
this._pFramebufferPool[i] = new a.fx.FrameBuffer(this.pEngine);
this._pEmptyFrameBuffers[i] = null;
this._pFrameBufferCounters[i] = 0;

}

this._pSystemUniforms = null;
this._pRenderQueue = new a.RenderQueue(pEngine);
this._initSystemUniforms();

}

Renderer.prototype._initSystemUniforms = function() {
if (Renderer._pSystemUniforms) {
this._pSystemUniforms = Renderer._pSystemUniforms;

}

var pEnum=$$enum_SYSTEM_SEMANTICS$_obj;
var pUniforms= {};
for (var i in pEnum) {
pUniforms[pEnum[i]] = null;

}

this._pSystemUniforms = Renderer._pSystemUniforms = pUniforms;
return true;

};
Renderer.prototype.loadEffectFile = function(sFileName, isSync) {
var reExt=/^(.+)(\.afx|\.abf|\.fx)$/;
var pRes=reExt.exec(sFileName);
isSync = isSync || false;
if (!pRes) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "File has wrong extension! It must be .fx!");
return false;

}

if (isSync) {
var pRequest=a.ajax( {url: sFileName, async: false});
if ((pRequest.xhr.status) === (200)) {
var sSource=pRequest.data;
var pResource=this._pEffectFileDataPool.createResource(sFileName);
pResource.create(sSource);
a.util.parser.parse(sSource, true, this._analyzeEffect, this);
return true;

}
else  {
error("Could not load file in ", sFileName);
return false;

}


}
else  {
return this._pEffectFileDataPool.loadResource(sFileName);

}


};
Renderer.prototype._initComponent = function(pTechnique) {
var sName=pTechnique.sName;
var pComponentManager=this.pEngine.displayManager().componentPool();
if (pComponentManager.findResource(sName)) {
return false;

}

var pComponent=pComponentManager.createResource(sName);
pComponent.create(pTechnique);
var pComponents=pComponent.pComponents;
var pProps=pComponent.pComponentsShift;
if (pComponents) {
var pNewComponents=[];
var pNewComponentsProp=[];
var pComponentsHash= {};
var pCompComp;
var pCompProp;
var i, j;
for (i = 0; i < (pComponents.length); i++) {
sName = pComponents[i].hash(pProps[i]);
if (!(pComponentsHash[sName])) {
if (pComponents[i].pComponents) {
pCompComp = pComponents[i].pComponents;
pCompProp = pComponents[i].pComponentsShift;
for (j = 0; j < (pCompComp.length); j++) {
sName = pCompComp[j].hash(pCompProp[j]);
if (!(pComponentsHash[sName])) {
pComponentsHash[sName] = pCompComp[j];
pNewComponents.push(pCompComp[j]);
pNewComponentsProp.push(pCompProp[j]);

}


}


}

sName = pComponents[i].hash(pProps[i]);
pComponentsHash[sName] = pComponents[i];
pNewComponents.push(pComponents[i]);
pNewComponentsProp.push(pProps[i]);

}


}

pComponent.pComponents = pNewComponents;
pComponent.pComponentsShift = pNewComponentsProp;
pComponent.pComponentsHash = pComponentsHash;

}

return true;

};
Renderer.prototype._loadEffectFile = function(sFileName, pEffectResource) {
var me=this;
this._pEffectFileStack.push(pEffectResource);
a.fopen(sFileName, "r").read(function(pData) {
var sSource=pData;
var pFirst=me._pEffectFileStack[0];
pEffectResource.eStatus = 1;
pEffectResource._sSource = sSource;
if (pEffectResource === pFirst) {
a.util.parser.parse(sSource, false, me._loadedEffect, me);

}


}
, function() {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "It is impossible to load effect file");
var pFirst=me._pEffectFileStack[0];
me._deleteElementFromLoadQueue(pEffectResource);
if (pEffectResource === pFirst) {
me._nextEffect();

}


}
);

};
Renderer.prototype._analyzeEffect = function(eCode) {
if (eCode === (200)) {
var pEffect=new a.fx.Effect(this, this._nEffectFile);
this._nEffectFile++;
if (pEffect.analyze(a.util.parser.pSyntaxTree)) {
var i;
var pTechniques=pEffect.pTechniques;
for (i in pTechniques) {
if (!(this._initComponent(pTechniques[i]))) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + ((("Can not initialize component from effect " + " with name ") + (pTechniques[i].sName)) + "!"));

}


}


}
else  {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "Some semantic error was found during analyze of effect file");

}


}
else  {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + ("Some error was occur during syntax analyze of effect file. Code: " + eCode));

}

return true;

};
Renderer.prototype._loadedEffect = function(eCode) {
this._analyzeEffect(eCode);
this._pEffectFileStack.shift().notifyLoaded();
this._nextEffect();
return true;

};
Renderer.prototype._deleteElementFromLoadQueue = function(pElement) {
var i, pStack=this._pEffectFileStack;
for (i = pStack.length; i >= 0; i++) {
if ((pStack[i]) === pElement) {
pStack.splice(i, 1);
return true;

}


}

return false;

};
Renderer.prototype._nextEffect = function() {
var pElement=this._pEffectFileStack[0];
if (pElement && ((pElement.eStatus) === 1)) {
a.util.parser.parse(pElement._sSource, false, this._analyzeEffect, this);

}

return true;

};
Renderer.prototype.getComponentByName = function(sName) {
return this.pEngine.displayManager().componentPool().findResource(sName);

};
Renderer.prototype._blendComponents = function() {
var pComponents=arguments;
if ((pComponents.length) === 0) {
return 0;

}
else  {
var i, j;
var pBlend=new a.fx.ComponentBlend();
var pComponent;
for (i = 0; i < (pComponents.length); i++) {
pComponent = pComponents[i];
if (!(pBlend.hasComponent(pComponent.hash(0)))) {
if (pComponent.pComponents) {
for (j = 0; j < (pComponent.pComponents.length); j++) {
pBlend.addComponent(pComponent.pComponents[j], pComponent.pComponentsShift[j]);

}


}

pBlend.addComponent(pComponent, 0);

}


}

if (this._pComponentBlendsHash[pBlend.sHash]) {
return this._pComponentBlendsHash[pBlend.sHash];

}
else  {
if (!(this._registerComponentBlend(pBlend))) {
return false;

}

return pBlend;

}


}


};
Renderer.prototype._registerComponentBlend = function(pBlend) {
if (this._pComponentBlendsHash[pBlend.sHash]) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + (("Component with hash: \'" + (pBlend.sHash)) + "\' are already used!"));
return false;

}

this._pComponentBlendsHash[pBlend.sHash] = pBlend;
this._pComponentBlendsId[this._nComponentBlends] = pBlend;
pBlend._id = this._nComponentBlends;
this._nComponentBlends++;
return pBlend._id;

};
Renderer.prototype._addComponentToBlend = function(pBlend, pComponent, nShift) {
var pComponentManager=this.pEngine.displayManager().componentPool();
var i;
var pNewBlend;
nShift = nShift || 0;
if (!pBlend) {
pNewBlend = new a.fx.ComponentBlend();

}
else if (!(pBlend.pComponentsHash[pComponent.hash(nShift)])) {
pNewBlend = pBlend.cloneMe();

}


if (pNewBlend) {
if (pComponent.pComponents) {
for (i = 0; i < (pComponent.pComponents.length); i++) {
pNewBlend.addComponent(pComponent.pComponents[i], (pComponent.pComponentsShift[i]) + nShift);

}


}

pNewBlend.addComponent(pComponent, nShift);
if (this._pComponentBlendsHash[pNewBlend.sHash]) {
return this._pComponentBlendsHash[pNewBlend.sHash];

}
else  {
if (!(this._registerComponentBlend(pNewBlend))) {
return false;

}

return pNewBlend;

}


}

return pBlend;

};
Renderer.prototype._removeComponentFromBlend = function(pBlend, pComponent, nShift) {
var pComponentManager=this.pEngine.displayManager().componentPool();
var i;
var pNewBlend;
var pComp;
nShift = nShift || 0;
if (!pBlend) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "You try remove component from empty blend!");
return false;

}

if (!(pBlend.pComponentsHash[pComponent.hash(nShift)])) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "You try remove component from blend where it doesn`t exist!");
return false;

}

var sName=pComponent.hash(nShift);
if ((pBlend.pComponentsCount[sName]) > 1) {
pBlend.pComponentsCount[sName]--;
for (i = 0; i < (pComponent.pComponents.length); i++) {
pBlend.pComponentsCount[pComponent.pComponents[i].hash((pComponent.pComponentsShift[i]) + nShift)]--;

}

return pBlend;

}

pNewBlend = pBlend.cloneMe();
for (i = 0; i < (pBlend.pComponents.length); i++) {
pComp = pBlend.pComponents[i];
sName = pComp.hash(pBlend.pComponentsShift[i]);
if ((pComp !== pComponent) && (!(((pComponent.pComponentsHash[sName]) === pComp) && ((pBlend.pComponentsCount[sName]) === 1)))) {
pNewBlend.addComponent(pComp, pBlend.pComponentsShift[i]);

}


}

if (this._pComponentBlendsHash[pNewBlend.sHash]) {
return this._pComponentBlendsHash[pNewBlend.sHash];

}
else  {
if (!(this._registerComponentBlend(pNewBlend))) {
return false;

}

return pNewBlend;

}


};
Renderer.prototype._addBlendToBlend = function(pBlendA, pBlendB, nShift) {
var sHash=pBlendA.sHash;
var sName;
var i;
for (i = 0; i < (pBlendB.pComponents.length); i++) {
sName = pBlendB.pComponents[i].hash((pBlendB.pComponentsShift[i]) + nShift);
if (!(pBlendA.pComponentsHash[sName])) {
sHash += sName + ":";

}


}

if (this._pComponentBlendsHash[sHash]) {
return this._pComponentBlendsHash[sHash];

}

var pNewBlend;
pNewBlend = pBlendA.addBlend(pBlendB, nShift);
if (!(this._registerComponentBlend(pNewBlend))) {
return false;

}

return pNewBlend;

};
Renderer.prototype.registerEffect = function(pEffectResource) {
var id=pEffectResource.resourceHandle();
if (this._pEffectResoureId[id]) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "This effect resource are already loaded");
return false;

}

this._pEffectResoureId[id] = pEffectResource;
this._pEffectResoureBlend[id] = null;
return true;

};
Renderer.prototype.registerComponent = function(pComponent) {
return true;

};
Renderer.prototype.activateComponent = function(pEffectResource, iComponentHandle, nShift) {
var pComponentManager=this.pEngine.displayManager().componentPool();
var pEffectManager=this.pEngine.displayManager().effectPool();
var rId=pEffectResource;
var pBlend;
nShift = nShift || 0;
if ((typeof rId) === "object") {
rId = rId.resourceHandle();

}

pBlend = this._pEffectResoureBlend[rId];
var pComponent=pComponentManager.getResource(iComponentHandle);
if (!pComponent) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + ("Can`t find component with id: " + iComponentHandle));
return false;

}

pBlend = this._addComponentToBlend(pBlend, pComponent, nShift);
if (!pBlend) {
return false;

}

this._pEffectResoureBlend[rId] = pBlend;
return true;

};
Renderer.prototype.deactivateComponent = function(pEffectResource, iComponentHandle, nShift) {
var pComponentManager=this.pEngine.displayManager().componentPool();
var pEffectManager=this.pEngine.displayManager().effectPool();
var rId=pEffectResource;
var pBlend;
nShift = nShift || 0;
if ((typeof rId) === "object") {
rId = rId.resourceHandle();

}

pBlend = this._pEffectResoureBlend[rId];
var pComponent=pComponentManager.getResource(iComponentHandle);
if (!pComponent) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + ("Can`t find component with id: " + iComponentHandle));
return false;

}

pBlend = this._removeComponentFromBlend(pBlend, pComponent, nShift);
if (!pBlend) {
return false;

}

this._pEffectResoureBlend[rId] = pBlend;
return true;

};
Renderer.prototype.getComponentCount = function(pEffectResource) {
var id=pEffectResource.resourceHandle();
return this._pEffectResoureBlend[id].pComponents.length;

};
Renderer.prototype.findEffect = function(sName) {
return new EffectResource(this.pEngine);

};
Renderer.prototype.push = function(pSnapshot, pRenderObject) {
var rId=pSnapshot.method.effect.resourceHandle();
var pBlend=this._pEffectResoureBlend[rId];
var isUpdate=pSnapshot.isUpdated();
if (!pBlend) {
if (!0) {
var err=((((((("Error:: " + "There are no any blend for this effect") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("There are no any blend for this effect");

}


}

;
return false;

}

if (!(pBlend.isReady())) {
isUpdate = true;

}

if (!(pBlend.finalize())) {
return false;

}

var pUniforms, pTextures;
var pUniformKeys, pTextureKeys;
var i, j;
if (isUpdate) {
pUniforms = [];
if (pBlend.hasTextures()) {
pTextures = [];
for (i = 0; i < (pBlend.totalValidPasses()); i++) {
pTextures[i] =  {};
pTextureKeys = pBlend.pUniformsBlend[i]._pTextureByRealNameKeys;
for (j = 0; j < (pTextureKeys.length); j++) {
pTextures[i][pTextureKeys[j]] = null;

}


}


}

for (i = 0; i < (pBlend.totalValidPasses()); i++) {
pUniforms[i] =  {};
pUniformKeys = pBlend.pUniformsBlend[i]._pUniformByRealNameKeys;
for (j = 0; j < (pUniformKeys.length); j++) {
pUniforms[i][pUniformKeys[j]] = null;

}


}

pSnapshot.setPassStates(pUniforms, pTextures);

}

var pState=this._getPreRenderState();
pState.pSnapshot = pSnapshot;
pState.nShift = ((this._pPreRenderState) === null? 0 : this._pPreRenderState.nShift);
pState.pBlend = pBlend;
pState.pAttributeData.length = pBlend.totalValidPasses();
pState.pRenderObject = pRenderObject;
this._pPreRenderStateStack.push(pState);
this._pPreRenderState = pState;
pSnapshot.isUpdated(false);
return true;

};
Renderer.prototype.pop = function() {
var pState=this._pPreRenderStateStack.pop();
this._releasePreRenderState(pState);
this._pPreRenderState = (this._pPreRenderStateStack[(this._pPreRenderStateStack.length) - 1]) || null;
return true;

};
Renderer.prototype.activatePass = function(pSnapshot, iPass) {
this._pPreRenderState.nShift += iPass;
return true;

};
Renderer.prototype.deactivatePass = function(pSnapshot) {
this._pPreRenderState.nShift -= pSnapshot._iCurrentPass;
return true;

};
Renderer.prototype.activateSceneObject = function(pSceneObject) {
this._pSceneObjectStack.push(this._pActiveSceneObject);
this._pActiveSceneObject = pSceneObject;

};
Renderer.prototype.deactivateSceneObject = function() {
this._pActiveSceneObject = (this._pSceneObjectStack.pop()) || null;

};
Renderer.prototype.finishPass = function(iPass) {
trace(("Render Pass #" + iPass) + " start!");
if ((this._pPreRenderState.pBlend.totalValidPasses()) <= iPass) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "You try finish bad pass");
return false;

}

var pUniformValues, pNotDefaultUniforms, pTextures, pNewPassBlend;
var i, j, k;
var pSnapshot, pUniforms, pPasses, pPass, pValues, pBlend;
var nShift;
var sName, sHash, sKey;
var pCurrentState=this._pPreRenderState, pStateStack=this._pPreRenderStateStack, pState, iStackLength=pStateStack.length;
var nPass=(pCurrentState.nShift) + iPass;
var index;
var sPassBlendHash="";
var pPassBlend;
var pMaterialTexcoords=new Array(16);
pUniformValues =  {};
pNotDefaultUniforms =  {};
pTextures =  {};
for (i = 0; i < iStackLength; i++) {
nShift = pStateStack[i].nShift;
pBlend = pStateStack[i].pBlend;
pSnapshot = pStateStack[i].pSnapshot;
index = nPass - nShift;
if ((pBlend.totalValidPasses()) <= index) {
continue ;

}

pUniforms = pBlend.pUniformsBlend[index];
if (pSnapshot._pTextures) {
pValues = pSnapshot._pTextures[index];
for (j = 0; j < (pUniforms._pTextureByRealNameKeys.length); j++) {
sKey = pUniforms._pTextureByRealNameKeys[j];
if ((pValues[sKey]) !== undefined) {
pTextures[sKey] = pValues[sKey];

}

if ((pTextures[sKey]) === undefined) {
pTextures[sKey] = null;

}


}


}

pValues = pSnapshot._pPassStates[index];
for (j = 0; j < (pUniforms._pUniformByRealNameKeys.length); j++) {
sKey = pUniforms._pUniformByRealNameKeys[j];
if (((pValues[sKey]) !== undefined) && ((pValues[sKey]) !== null)) {
pUniformValues[sKey] = pValues[sKey];
pNotDefaultUniforms[sKey] = true;
continue ;

}

if (!(pNotDefaultUniforms[sKey])) {
if ((this._pSystemUniforms[sKey]) === null) {
pUniformValues[sKey] = this._getSystemUniformValue(sKey);

}
else  {
pUniformValues[sKey] = pUniforms.pUniformsDefault[sKey];

}


}


}


}

pNewPassBlend = [];
for (i = 0; i < iStackLength; i++) {
nShift = pStateStack[i].nShift;
pBlend = pStateStack[i].pBlend;
index = nPass - nShift;
if ((pBlend.totalValidPasses()) <= index) {
continue ;

}

pPasses = pBlend.pPassBlends[index];
for (j = 0; j < (pPasses.length); j++) {
pPass = pPasses[j];
if (!(pPass.isEval)) {
if (pPass.isComplex) {
pPass.prepare(this._pEngineStates, pUniformValues);

}

sPassBlendHash += "V::" + (((pPass.pVertexShader) && (pPass.pVertexShader.sRealName)? pPass.pVertexShader.sRealName : "EMPTY"));
sPassBlendHash += "F::" + (((pPass.pFragmentShader) && (pPass.pFragmentShader.sRealName)? pPass.pFragmentShader.sRealName : "EMPTY"));
pNewPassBlend.push(pPass);
pPass.isEval = true;

}


}


}

for (j = 0; j < (pPasses.length); j++) {
pPasses[j].isEval = false;

}

if (this._pPassBlends[sPassBlendHash]) {
pPassBlend = this._pPassBlends[sPassBlendHash];

}
else  {
pPassBlend = new a.fx.PassBlend(this.pEngine);
pPassBlend.init(sPassBlendHash, pNewPassBlend);
if (!(this._registerPassBlend(pPassBlend))) {
return false;

}

pPassBlend.finalizeBlend();

}

var pAttrSemantics= {};
var pDataStackByPass, pDataStack, pMaterial, pData, pVertexElement;
var pAttrKeys=Object.keys(pPassBlend.pAttributes);
for (i = 0; i < (pAttrKeys.length); i++) {
pAttrSemantics[pAttrKeys[i]] = null;

}

for (i = iStackLength - 1; i >= 0; i--) {
nShift = pStateStack[i].nShift;
pDataStackByPass = pStateStack[i].pAttributeData;
pMaterial = pStateStack[i].pSurfaceMaterial;
index = nPass - nShift;
if ((pDataStackByPass.length) <= index) {
continue ;

}

pDataStack = pDataStackByPass[index];
if (pMaterial) {
pBlend = pStateStack[i].pBlend;
pUniforms = pBlend.pUniformsBlend[index];
for (j = 0; j < (16); j++) {
if ((((pMaterialTexcoords[j]) !== undefined) && ((pMaterialTexcoords[j]) !== null)) || (!(pMaterial._pTexture[j]))) {
continue ;

}

pMaterialTexcoords[j] = pMaterial._pTexcoord[j];
sKey = (a.fx.SHADER_PREFIX.TEXTURE) + j;
if ((pUniforms.pTexturesByRealName[sKey]) === null) {
pTextures[sKey] = pMaterial._pTexture[j];
sKey = (a.fx.SHADER_PREFIX.TEXMATRIX) + j;
if ((pUniforms.pUniformsByRealName[sKey]) && (pMaterial._pTextureMatrix[j])) {
pUniformValues[sKey] = pMaterial._pTextureMatrix[j];

}


}


}

if ((pUniforms.pUniformsByRealName["DIFFUSE"]) && (!(pUniformValues["DIFFUSE"]))) {
pUniformValues["DIFFUSE"] = pMaterial.material.pDiffuse;

}

if ((pUniforms.pUniformsByRealName["AMBIENT"]) && (!(pUniformValues["AMBIENT"]))) {
pUniformValues["AMBIENT"] = pMaterial.material.pAmbient;

}

if ((pUniforms.pUniformsByRealName["SPECULAR"]) && (!(pUniformValues["SPECULAR"]))) {
pUniformValues["SPECULAR"] = pMaterial.material.pSpecular;

}

if ((pUniforms.pUniformsByRealName["EMISSIVE"]) && (!(pUniformValues["EMISSIVE"]))) {
pUniformValues["EMISSIVE"] = pMaterial.material.pEmissive;

}

if ((pUniforms.pUniformsByRealName["SHININESS"]) && (!(pUniformValues["SHININESS"]))) {
pUniformValues["SHININESS"] = pMaterial.material.pShininess;

}

sName = (("MATERIAL") + ".") + ("DIFFUSE");
if ((pUniforms.pUniformsByRealName[sName]) && (!(pUniformValues[sName]))) {
pUniformValues[sName] = pMaterial.material.pDiffuse;

}

sName = (("MATERIAL") + ".") + ("AMBIENT");
if ((pUniforms.pUniformsByRealName[sName]) && (!(pUniformValues[sName]))) {
pUniformValues[sName] = pMaterial.material.pAmbient;

}

sName = (("MATERIAL") + ".") + ("SPECULAR");
if ((pUniforms.pUniformsByRealName[sName]) && (!(pUniformValues[sName]))) {
pUniformValues[sName] = pMaterial.material.pSpecular;

}

sName = (("MATERIAL") + ".") + ("EMISSIVE");
if ((pUniforms.pUniformsByRealName[sName]) && (!(pUniformValues[sName]))) {
pUniformValues[sName] = pMaterial.material.pEmissive;

}

sName = (("MATERIAL") + ".") + ("SHININESS");
if ((pUniforms.pUniformsByRealName[sName]) && (!(pUniformValues[sName]))) {
pUniformValues[sName] = pMaterial.material.pShininess;

}


}

for (j = 0; j < (pAttrKeys.length); j++) {
sKey2 = pAttrKeys[j];
if ((pAttrSemantics[sKey2]) === null) {
for (k = 0; k < (pDataStack.length); k++) {
pData = pDataStack[k];
if ((pData.eType) === (1)) {
pVertexElement = pData.pData.getVertexDeclaration().element(sKey2);

}
else  {
pVertexElement = pData.getVertexDeclaration().element(sKey2);

}

if (pVertexElement) {
pAttrSemantics[sKey2] = pData;
break ;

}


}


}


}


}

sHash = sPassBlendHash + "|-|__|/|";
var sKey1, sKey2;
var sSame1, sSame2;
for (i = 0; i < (pAttrKeys.length); i++) {
sKey1 = pAttrKeys[i];
sHash += sKey1 + "|";
if ((pAttrSemantics[sKey1]) === null) {
sHash += "EMPTY";

}
else  {
sHash += "SAME:";
sSame1 = "";
sSame2 = "";
for (j = 0; j < (pAttrKeys.length); j++) {
sKey2 = pAttrKeys[j];
if ((i !== j) && ((pAttrSemantics[sKey2]) === (pAttrSemantics[sKey1]))) {
sSame1 += sKey2 + ",";

}


}

sHash += sSame1 + "!";
sHash += "SAME_VIDEO_BUFFER:" + sSame2;

}

sHash += "..";

}

var pProgram;
pProgram = this._pPrograms[sHash];
if (!pProgram) {
pProgram = pPassBlend.generateProgram(sHash, pAttrSemantics, pAttrKeys, pUniformValues, pTextures, pMaterialTexcoords);
if (!pProgram) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "It`s impossible to generate shader program");
return false;

}


}

var pAttrs=pProgram.generateInputData(pAttrSemantics, pUniformValues);
if ((this._pRenderState.iFrameBuffer) !== null) {
this._pFrameBufferCounters[this._pRenderState.iFrameBuffer]--;

}

var pEntry=this._pRenderQueue.getEmptyEntry();
pEntry.set(pProgram, pAttrs, pUniformValues, pTextures, pCurrentState.pIndex, pCurrentState.iOffset, pCurrentState.iLength, pCurrentState.eDrawPrimitive, pCurrentState.pViewport.x, pCurrentState.pViewport.y, pCurrentState.pViewport.width, pCurrentState.pViewport.height, this._pRenderState.iFrameBuffer);
this._pRenderQueue.addSortEntry(pEntry);
trace(("Render Pass #" + iPass) + " finish!");
return pEntry;

};
Renderer.prototype._registerProgram = function(sHash, pProgram) {
if (this._pPrograms[sHash]) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "You try to register already used hash");
return false;

}

this._pPrograms[sHash] = pProgram;
return true;

};
Renderer.prototype._registerPassBlend = function(pBlend) {
if (this._pPassBlends[pBlend.sHash]) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "Cannot register pass blend with this hash");
return false;

}

this._pPassBlends[pBlend.sHash] = pBlend;
return true;

};
Renderer.prototype._getPreRenderState = function() {
var pPool=this._pPreRenderStatePool;
var pState;
if ((pPool.length) === 0) {
pState = new a.fx.PreRenderState(this.pEngine);

}
else  {
pState = pPool.pop();

}

pState.setViewport(this._pCurrentViewport);
return pState;

};
Renderer.prototype._releasePreRenderState = function(pState) {
pState.release();
this._pPreRenderStatePool.push(pState);
return true;

};
Renderer.prototype._getSystemUniformValue = function(sName) {
var pSceneObject=this._pActiveSceneObject;
var pRenderObject=this._pPreRenderState.pRenderObject;
var pCamera=this.pEngine.getActiveCamera();
switch(sName) {
case "MODEL_MATRIX":
if (pSceneObject && (pSceneObject._m4fWorldMatrix)) {
return (pSceneObject.worldMatrix()) || null;

}

return null;

case "NORMAL_MATRIX":
if (pSceneObject && (pSceneObject._m4fWorldMatrix)) {
return (pSceneObject.normalMatrix()) || null;

}

return null;

case "VIEW_MATRIX":
return pCamera.viewMatrix();

case "PROJ_MATRIX":
return pCamera.projectionMatrix();

case "EYE_POSITION":
trace(pCamera.worldPosition().x, pCamera.worldPosition().y, pCamera.worldPosition().z);
return pCamera.worldPosition();

case "BIND_SHAPE_MATRIX":
return (pRenderObject && (pRenderObject.skin)? pRenderObject.skin.getBindMatrix() : null);

default:
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "Unsupported system semantic");
return null;
}

};
Renderer.prototype.applyBufferMap = function(pMap) {
if (!pMap) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "Don`t have bufferMap");
return true;

}

var pState=this._pPreRenderState;
if (((pState.iOffset) === null) || ((pState.iLength) === null)) {
pState.iLength = pMap.length;
pState.iOffset = pMap.offset;
pState.pIndex = pMap.index;
pState.eDrawPrimitive = pMap.primType;

}
else if ((((pState.iLength) !== (pMap.length)) || ((pState.iOffset) !== (pMap.offset))) || (((pState.eDrawPrimitive) !== null) && ((pState.eDrawPrimitive) !== (pMap.primType)))) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "Can not blend buffer maps 1");
return false;

}
else if (((pState.pIndex) !== undefined) && ((pState.pIndex) !== (pMap.index))) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "Can not blend buffer maps 2");
return false;

}



var iPass=pState.pSnapshot._iCurrentPass;
if (!(pState.pAttributeData[iPass])) {
pState.pAttributeData[iPass] = [];

}

var pData=pState.pAttributeData[iPass];
var i, pFlow;
for (i = 0; i < (pMap._nCompleteFlows); i++) {
pFlow = pMap._pCompleteFlows[i];
if ((pFlow.eType) === (1)) {
pData.push(pFlow);

}
else  {
pData.push(pFlow.pData);

}


}


};
Renderer.prototype.applyVertexData = function(pData, ePrimType) {
ePrimType = (ePrimType !== undefined? ePrimType : null);
if (!pData) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "Don`t have vertex data");
return true;

}

var pState=this._pPreRenderState;
if (((pState.iOffset) === null) || ((pState.iLength) === null)) {
pState.iLength = pData.length;
pState.iOffset = pData.offset;
pState.eDrawPrimitive = ePrimType;

}
else if ((((pState.iLength) !== (pData.length)) || ((pState.iOffset) !== (pData.offset))) || ((((pState.eDrawPrimitive) !== null) && (ePrimType !== null)) && ((pState.eDrawPrimitive) !== ePrimType))) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "Can not blend buffer maps 1");
return false;

}


var iPass=pState.pSnapshot._iCurrentPass;
if (!(pState.pAttributeData[iPass])) {
pState.pAttributeData[iPass] = [pData];

}

pState.pAttributeData[iPass].push(pData);

};
Renderer.prototype.applyFrameBufferTexture = function(pTexture, eAttachment, eTexTarget, iLevel) {
if ((this._pRenderState.iFrameBuffer) === null) {
return false;

}

var pDevice=this.pEngine.pDevice;
eAttachment = (eAttachment === undefined? pDevice.COLOR_ATTACHMENT0 : eAttachment);
eTexTarget = (eTexTarget === undefined? pDevice.TEXTURE_2D : eTexTarget);
iLevel = 0;
trace("Attach texture to farme buffer #" + (this._pRenderState.iFrameBuffer));
this._pRenderState.pFrameBuffer.frameBufferTexture2D(eAttachment, eTexTarget, pTexture._pTexture);

};
Renderer.prototype.applySurfaceMaterial = function(pMaterial) {
this._pPreRenderState.pSurfaceMaterial = pMaterial;
var pSnapshot=this._pPreRenderState.pSnapshot;

};
Renderer.prototype.setViewport = function(x, y, width, height) {
if (this._pPreRenderState) {
this._pPreRenderState.setViewport(x, y, width, height);

}

this._pCurrentViewport.x = x;
this._pCurrentViewport.y = y;
this._pCurrentViewport.width = width;
this._pCurrentViewport.height = height;

};
Renderer.prototype.getUniformRealName = function(sName) {
var pSnapshot=this._pPreRenderState.pSnapshot;
var pBlend=this._pPreRenderState.pBlend;
if ((!pBlend) || (!pSnapshot)) {
return false;

}

return pBlend.pUniformsBlend[pSnapshot._iCurrentPass].pUniformsByName[sName];

};
Renderer.prototype.isUniformTypeBase = function(sRealName) {
var pSnapshot=this._pPreRenderState.pSnapshot;
var pBlend=this._pPreRenderState.pBlend;
if ((!pBlend) || (!pSnapshot)) {
return false;

}

return pBlend.pUniformsBlend[pSnapshot._iCurrentPass].pUniformsByRealName[sRealName].pType.isBase();

};
Renderer.prototype.getTextureRealName = function(sName) {
var pSnapshot=this._pPreRenderState.pSnapshot;
var pBlend=this._pPreRenderState.pBlend;
if ((!pBlend) || (!pSnapshot)) {
return false;

}

return pBlend.pUniformsBlend[pSnapshot._iCurrentPass].pTexturesByName[sName];

};
Renderer.prototype.getActiveProgram = function() {
return this._pRenderState.pActiveProgram;

};
Renderer.prototype.totalPasses = function(pEffect) {
var id=pEffect.resourceHandle();
if (this._pEffectResoureBlend[id]) {
return this._pEffectResoureBlend[id].totalValidPasses();

}

return 0;

};
Renderer.prototype.getActiveTexture = function(iSlot) {
return this._pRenderState.pTextureSlots[iSlot];

};
Renderer.prototype.getTextureSlot = function(pTexture) {
if (!pTexture) {
var err=((((((("Error:: " + "Texture must be") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Texture must be");

}


}

;
var i;
for (i = 0; i < (this._pRenderState.pTextureSlots.length); i++) {
if (pTexture === (this._pRenderState.pTextureSlots[i])) {
return i;

}


}

return -1;

};
Renderer.prototype.getViewport = function() {
return this._pCurrentViewport;

};
Renderer.prototype._getEmptyTextureSlot = function() {
var i;
for (i = 0; i < (this._pRenderState.pTextureSlots.length); i++) {
if (!(this._pRenderState.pTextureSlots[i])) {
return i;

}


}

return this._pRenderState.pActiveProgram.getEmptyTextureSlot();

};
Renderer.prototype._getEmptyFrameBuffer = function() {
var pDevice=this.pEngine.pDevice;
var pEmptyBuffers=this._pEmptyFrameBuffers;
var pFrameBuffer=null;
var i=0;
for (i = 0; i < (pEmptyBuffers.length); i++) {
if ((pEmptyBuffers[i]) === null) {
pEmptyBuffers[i] = this._pFramebufferPool[i];
this._pFrameBufferCounters[i] = 0;
return i;

}


}

pFrameBuffer = new a.fx.FrameBuffer(this.pEngine);
this._pFramebufferPool.push(pFrameBuffer);
this._pFrameBufferCounters.push(0);
pEmptyBuffers.push(0);
return (pEmptyBuffers.length) - 1;

};
Renderer.prototype._releaseFrameBuffer = function(id) {
trace("Release frame buffer");
this._pFrameBufferCounters[id] = 0;
this._pEmptyFrameBuffers[id] = null;
this._pFramebufferPool[id].release();
this._activateFrameBuffer();

};
Renderer.prototype._tryReleaseFrameBuffer = function(id) {
var nCount=this._pFrameBufferCounters[id];
if (nCount > 0) {
nCount--;
this._pFrameBufferCounters[id] = nCount;

}

if (nCount === 0) {
this._releaseFrameBuffer(id);

}


};
Renderer.prototype._getTextureSlot = function(pTexture) {
var i;
for (i = 0; i < (this._pRenderState.pTextureSlots.length); i++) {
if (pTexture === (this._pRenderState.pTextureSlots[i])) {
return i;

}


}

return -1;

};
Renderer.prototype.activateVertexBuffer = function(pBuffer, isAttribute) {
if (!(this._isRegisterResource(pBuffer))) {
this.registerRenderResource(pBuffer);

}

if (((this._pRenderState.pVertexBuffer) === pBuffer) && ((this._pRenderState.iVertexBufferState) === (this._pRenderResourceCounter[pBuffer.toNumber()]))) {
return true;

}

this._pRenderState.pVertexBuffer = pBuffer;
this._pRenderState.iVertexBufferState = this._pRenderResourceCounter[pBuffer.toNumber()];
trace("Real bind buffer #" + (pBuffer.toNumber()));
pBuffer.bind();
return true;

};
Renderer.prototype.activateIndexBuffer = function(pBuffer) {
if (!(this._isRegisterResource(pBuffer))) {
this.registerRenderResource(pBuffer);

}

if (((this._pRenderState.pIndexBuffer) === pBuffer) && ((this._pRenderState.iIndexBufferState) === (this._pRenderResourceCounter[pBuffer.toNumber()]))) {
return true;

}

this._pRenderState.pIndexBuffer = pBuffer;
this._pRenderState.iIndexBufferState = this._pRenderResourceCounter[pBuffer.toNumber()];
trace("Real bind index buffer #" + (pBuffer.resourceHandle()));
pBuffer.bind();
return true;

};
Renderer.prototype.activateProgram = function(pProgram) {
if ((this._pRenderState.pActiveProgram) === pProgram) {
trace("Program already active");
pProgram._nActiveTimes++;
return true;

}

var pDevice=this.pEngine.pDevice;
var i;
pProgram.activate();
for (i = pProgram.getStreamNumber(); i < (this._pRenderState.nAttrsUsed); i++) {
trace("Disable attrib #" + i);
pDevice.disableVertexAttribArray(i);

}

for (i = this._pRenderState.nAttrsUsed; i < (pProgram.getStreamNumber()); i++) {
trace("Enable attrib #" + i);
pDevice.enableVertexAttribArray(i);

}

this._pRenderState.pActiveProgram = pProgram;
this._pRenderState.nAttrsUsed = pProgram.getStreamNumber();

};
Renderer.prototype.activateFrameBuffer = function(iId) {
iId = (iId === undefined? this._getEmptyFrameBuffer() : iId);
this._pRenderState.iFrameBuffer = iId;
this._activateFrameBuffer(iId);
return iId;

};
Renderer.prototype.deactivateFrameBuffer = function(iId) {
if (iId !== undefined) {
this._releaseFrameBuffer(iId);
return true;

}

iId = this._pRenderState.iFrameBuffer;
if (iId !== null) {
if ((this._pFrameBufferCounters[iId]) === 0) {
this._releaseFrameBuffer(iId);

}
else  {
this._pFrameBufferCounters[iId] *= -1;

}


}

this._pRenderState.iFrameBuffer = null;
return true;

};
Renderer.prototype._activateFrameBuffer = function(iId) {
var pFrameBuffer=((iId === undefined) || (iId === null)? null : this._pFramebufferPool[iId]);
if ((this._pRenderState.pFrameBuffer) === pFrameBuffer) {
return true;

}

this._pRenderState.pFrameBuffer = pFrameBuffer;
if (pFrameBuffer) {
trace("activateFrameBuffer #" + iId);
pFrameBuffer.bind();

}
else  {
trace("activateFrameBuffer DefaultRender");
this.pDevice.bindFramebuffer(this.pDevice.FRAMEBUFFER, null);

}


};
Renderer.prototype.bindTexture = function(pTexture) {
if (((this._pRenderState.pTexture) === pTexture) && ((this._pRenderState.pTexture._isTextureChanged) === false)) {
return true;

}

trace("Real bind texture #" + (pTexture.toNumber()));
this._pRenderState.pTexture = pTexture;
pTexture._isTextureChanged = false;
if ((this._pRenderState.iTextureSlot) >= (-1)) {
this._pRenderState.pTextureSlotStates[this._pRenderState.iTextureSlot] = true;

}

pTexture.bind();
return true;

};
Renderer.prototype.activateTexture = function(pTexture) {
var i;
var pSlots=this._pRenderState.pTextureSlots;
var iSlot;
iSlot = this._getTextureSlot(pTexture);
if (iSlot >= 0) {
if (this._pRenderState.pActiveProgram) {
this._pRenderState.pActiveProgram.setTextureSlot(iSlot, pTexture);

}

return iSlot;

}

iSlot = this._getEmptyTextureSlot();
pSlots[iSlot] = pTexture;
this._pRenderState.pTextureSlotStates[iSlot] = true;
if (this._pRenderState.pActiveProgram) {
this._pRenderState.pActiveProgram.setTextureSlot(iSlot, pTexture);

}

return iSlot;

};
Renderer.prototype._activateTextureSlot = function(iSlot, pParams) {
var pTexture=this._pRenderState.pTextureSlots[iSlot];
var isBind=false;
var isParamsEqual=pTexture._hasParams(pParams);
var pDevice=this.pDevice;
if (this._pRenderState.pTextureSlotStates[iSlot]) {
this._pRenderState.iTextureSlot = iSlot;
this._pRenderState.pTextureSlotStates[iSlot] = false;
this.pDevice.activeTexture((33984) + (iSlot || 0));
this._forceBindTexture(pTexture);
isBind = true;

}

if (!isParamsEqual) {
trace("TEXTURE PARAMS NOT EQUAL", pTexture);
if (!isBind) {
trace("Real activate slot");
this.pDevice.activeTexture((33984) + (iSlot || 0));
this._forceBindTexture(pTexture);

}

var eTarget=pTexture.target;
pDevice.texParameteri(eTarget, 10240, pParams[10240]);
pDevice.texParameteri(eTarget, 10241, pParams[10241]);
pDevice.texParameteri(eTarget, 10242, pParams[10242]);
pDevice.texParameteri(eTarget, 10243, pParams[10243]);

}

return true;

};
Renderer.prototype._forceBindTexture = function(pTexture) {
trace("Real bind texture(FORCE) #" + (pTexture.toNumber()));
this._pRenderState.pTexture = pTexture;
pTexture.bind();
return true;

};
Renderer.prototype.render = function(pEntry) {
var pProgram=pEntry.pProgram;
var pAttrs=pEntry.pAttributes;
var pUniforms=pEntry.pUniforms;
var pTextures=pEntry.pTextures;
var pDevice=this.pDevice;
var i;
trace("-------START REAL RENDER---------");
this._activateFrameBuffer(pEntry.iFrameBuffer);
this.activateProgram(pProgram);
pProgram.setCurrentTextureSet(pTextures);
for (i = 0; i < (pAttrs.length); i++) {
pProgram.applyData(pAttrs[i], i);

}

var pUniformKeys=Object.keys(pUniforms);
for (i = 0; i < (pUniformKeys.length); i++) {
pProgram.applyUniform(pUniformKeys[i], pUniforms[pUniformKeys[i]]);

}

pProgram.activateTextures();
pProgram.setCurrentTextureSet(null);
pProgram.resetActivationStreams();
this._setViewport(pEntry.iViewportX, pEntry.iViewportY, pEntry.iViewportWidth, pEntry.iViewportHeight);
if ((pEntry.eDrawPrim) === null) {
pEntry.eDrawPrim = 0;
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Renderer.js") + "][") + "") + "]") + "Primitive type are not passed. Set to POINTS");

}

if (pEntry.pIndexData) {
this.activateIndexBuffer(pEntry.pIndexData);
pDevice.drawElements(pEntry.eDrawPrim, pEntry.pIndexData.getCount(), pEntry.pIndexData.getType(), pEntry.pIndexData.getOffset());

}
else  {
pDevice.drawArrays(pEntry.eDrawPrim, pEntry.iOffset, pEntry.iLength);

}

if ((pEntry.iFrameBuffer) !== null) {
this._tryReleaseFrameBuffer(pEntry.iFrameBuffer);

}

this._pRenderQueue._releaseEntry(pEntry);
trace("-------STOP REAL RENDER---------");

};
Renderer.prototype._setViewport = function(x, y, width, height) {
this.pDevice.viewport(x, y, width, height);

};
Renderer.prototype.processRenderQueue = function() {
this._pRenderQueue.execute();

};
Renderer.prototype.clearScreen = function(eValue) {
this.pDevice.clear(eValue);

};
Renderer.prototype.vertexBufferChanged = function(pBuffer) {
pBuffer = pBuffer || (this._pRenderState.pVertexBuffer);
if (!pBuffer) {
return false;

}

trace("Vertex buffer changed #" + (pBuffer.resourceHandle()));
this._renderResourceChanged(pBuffer);

};
Renderer.prototype.indexBufferChanged = function(pBuffer) {
pBuffer = pBuffer || (this._pRenderState.pIndexBuffer);
if (!pBuffer) {
return false;

}

this._renderResourceChanged(pBuffer);

};
Renderer.prototype.getRenderResourceState = function(pResource) {
if (!(this._pRenderResources[pResource.toNumber()])) {
return false;

}

return this._pRenderResourceCounter[pResource.toNumber()];

};
Renderer.prototype.registerRenderResource = function(pResource) {
var id=pResource.toNumber();
if (this._pRenderResources[id]) {
this._pRenderResources[id] = pResource;
this._pRenderResourceCounter[id]++;

}
else  {
this._pRenderResources[id] = pResource;
this._pRenderResourceCounter[id] = 0;
this._pRenderResourceCounterKeys.push(id);

}


};
Renderer.prototype.releaseRenderResource = function(pResource) {
var id=pResource.toNumber();
var pCounters=this._pRenderResourceCounter;
var pResources=this._pRenderResources;
if (pResources[id]) {
pCounters[id]++;
pResources[id] = null;

}


};
Renderer.prototype._renderResourceChanged = function(pResource) {
var id=pResource.toNumber();
var pCounters=this._pRenderResourceCounter;
if (!(pCounters[id])) {
this.registerRenderResource(pResource);

}

pCounters[id]++;

};
Renderer.prototype._clearRenderResources = function() {
var i;
var pCounters=this._pRenderResourceCounter;
var pResources=this._pRenderResources;
var pKeys=this._pRenderResourceCounterKeys;
var id;
for (i = 0; i < (pKeys.length); i++) {
id = pKeys[i];
if ((pResources[id]) !== null) {
pCounters[id] = 0;

}
else  {
delete (pCounters[id]);
delete (pResources[id]);
pKeys.splice(i, 1);
i--;

}


}


};
Renderer.prototype._isRegisterResource = function(pResource) {
return !(!(this._pRenderResources[pResource.toNumber()]));

};
Renderer.prototype._disableShaderProgram = function(pProgram) {
this._pPrograms[pProgram._sHash] = null;

};
Renderer.prototype._getStreamState = function(iStream) {
return this._pStreamState[iStream];

};
Renderer.prototype._occupyStream = function(iStream, pProgram) {
this._pStreamState[iStream] = pProgram.toNumber();

};
Renderer.prototype.initialize = function() {
this._pRenderQueue.init();
this._pEffectFileDataPool.registerResourcePool(new a.ResourceCode(0, 7));
return true;

};
Renderer.prototype.destroy = function() {
return true;

};
Renderer.prototype.restoreDeviceResources = function() {
return true;

};
Renderer.prototype.destroyDeviceResources = function() {
return true;

};
Renderer.prototype.createDeviceResources = function() {
return true;

};
Renderer.prototype.disableDeviceResources = function() {
return true;

};
a.Renderer = Renderer;
function RenderableObject() {
this._pEngine = null;
this._pSnapshots = [];
this._pActiveSnapshot = null;
this._hasShadow = false;

}

a.defineProperty(RenderableObject, "renderMethod", function() {
return this._pActiveSnapshot._pRenderMethod;

}
, function(pRenderMethod) {
this.switchRenderMethod(this.addRenderMethod(pRenderMethod));

}
);
a.defineProperty(RenderableObject, "effect", function() {
return this._pActiveSnapshot._pRenderMethod._pEffect;

}
);
a.defineProperty(RenderableObject, "surfaceMaterial", function() {
return this._pActiveSnapshot._pRenderMethod._pMaterial;

}
, function(pSurfaceMaterial) {
"use strict";
this._pActiveSnapshot._pRenderMethod._pMaterial = pSurfaceMaterial;

}
);
a.defineProperty(RenderableObject, "material", function() {
var pSurfaceMaterial=this.surfaceMaterial;
return (pSurfaceMaterial? pSurfaceMaterial.material : null);

}
);
RenderableObject.prototype.getEngine = function() {
return this._pEngine;

};
RenderableObject.prototype.setup = function(pEngine, sDefaulMethodName) {
this._pEngine = pEngine;
if (((this.addRenderMethod(sDefaulMethodName)) < 0) || ((this.switchRenderMethod(0)) === false)) {
if (!0) {
var err=((((((("Error:: " + "cannot add & switch render method to default") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderableObjects.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("cannot add & switch render method to default");

}


}

;

}


};
RenderableObject.prototype.destructor = function() {
this._pShaderManager = null;
this._pActiveSnapshot = null;
 {
if (this._pSnapshots) {
for (var _s=0; _s < (this._pSnapshots.length); ++_s) {
 {
if (this._pSnapshots[_s]) {
if (this._pSnapshots[_s].destructor) {
this._pSnapshots[_s].destructor();

}

delete this._pSnapshots[_s];
this._pSnapshots[_s] = null;

}


};

}

delete this._pSnapshots;
this._pSnapshots = null;

}


};

};
RenderableObject.prototype.addRenderMethod = function(pRenderMethod, sName) {
var pRenderSnapshot=new a.RenderSnapshot();
if (((arguments.length) < 2) && ((typeof (arguments[0])) === "string")) {
sName = arguments[0];
pRenderMethod = this.getEngine().displayManager().renderMethodPool().createResource(("render-method-" + (sName || "")) + (a.sid()));
pRenderMethod.setMaterial();
pRenderMethod.setEffect();

}

if (!((pRenderMethod.getEngine()) === (this._pEngine))) {
var err=((((((("Error:: " + "Render method should belong to the same engine instance that the renderable object.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderableObjects.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Render method should belong to the same engine instance that the renderable object.");

}


}

;
pRenderSnapshot.method = pRenderMethod;
pRenderSnapshot.name = sName || ".default";
for (var i=0; i < (this._pSnapshots.length); i++) {
if ((this._pSnapshots[i]) === null) {
this._pSnapshots[i] = pRenderSnapshot;
return i;

}


}

;
this._pSnapshots.push(pRenderSnapshot);
return (this._pSnapshots.length) - 1;

};
RenderableObject.prototype.findRenderMethod = function() {
var iMethod;
var sMethodName;
if ((typeof (arguments[0])) === "string") {
sMethodName = arguments[0];
for (var i=0; i < (this._pSnapshots.length); i++) {
if ((this._pSnapshots[i].name) === sMethodName) {
return i;

}


}

;
return -1;

}

iMethod = arguments[0];
if (iMethod < 0) {
iMethod = Math.abs((this._pSnapshots.length) + iMethod);

}

if (iMethod >= (this._pSnapshots.length)) {
return -1;

}

return iMethod;

};
RenderableObject.prototype.switchRenderMethod = function() {
var iSnapshot=this.findRenderMethod(arguments[0]);
if (iSnapshot < 0) {
return false;

}

this._pActiveSnapshot = this._pSnapshots[iSnapshot];
return true;

};
RenderableObject.prototype.removeRenderMethod = function() {
var iSnapshot=this.findRenderMethod(arguments[0]);
if (iSnapshot < 0) {
return false;

}

 {
if (this._pSnapshots[iSnapshot]) {
if (this._pSnapshots[iSnapshot].destructor) {
this._pSnapshots[iSnapshot].destructor();

}

delete this._pSnapshots[iSnapshot];
this._pSnapshots[iSnapshot] = null;

}


};
return true;

};
RenderableObject.prototype.isReadyForRender = function() {
return this._pActiveSnapshot.isReady();

};
RenderableObject.prototype.isAllMethodsLoaded = function() {
for (var i=0; i < (this._pSnapshots); ++i) {
if (!(this._pSnapshots[i].isMethodLoaded())) {
return false;

}


}

return true;

};
RenderableObject.prototype.getRenderMethod = function() {
var iMethod=this.findRenderMethod(arguments[0]);
return this._pSnapshots[iMethod]._pRenderMethod;

};
RenderableObject.prototype.draw = function() {
"use strict";
return false;

};
RenderableObject.prototype.startRender = function() {
if (!(this._pActiveSnapshot)) {
return false;

}

return this._pActiveSnapshot.begin(this);

};
RenderableObject.prototype.finishRender = function() {
if (!(this._pActiveSnapshot)) {
return false;

}

return this._pActiveSnapshot.end();

};
RenderableObject.prototype.totalPasses = function() {
if (!(this._pActiveSnapshot)) {
return 0;

}

return this._pActiveSnapshot.totalPasses();

};
RenderableObject.prototype.activatePass = function(iPass) {
if (!(this._pActiveSnapshot)) {
return false;

}

return this._pActiveSnapshot.activatePass(iPass);

};
RenderableObject.prototype.deactivatePass = function() {
if (!(this._pActiveSnapshot)) {
return false;

}

return this._pActiveSnapshot.deactivatePass();

};
RenderableObject.prototype.renderPass = function(iPass) {
if (!(this._pActiveSnapshot)) {
return false;

}

var pEntry=this._pActiveSnapshot.renderPass(iPass);
if (!pEntry) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderableObjects.js") + "][") + "") + "]") + "Pass don`t add to render queue");
return false;

}

return pEntry;

};
RenderableObject.prototype.applyBufferMap = function(pData) {
if (!(this._pActiveSnapshot)) {
return false;

}

return this._pActiveSnapshot.applyBufferMap(pData);

};
RenderableObject.prototype.applyRenderData = function(pData) {
if (!(this._pActiveSnapshot)) {
return false;

}

return this._pActiveSnapshot.applyRenderData(pData);

};
RenderableObject.prototype.applyVertexData = function(pData, ePrimType) {
if (!(this._pActiveSnapshot)) {
return false;

}

return this._pActiveSnapshot.applyVertexData(pData, ePrimType);

};
RenderableObject.prototype.applySurfaceMaterial = function(pMaterial) {
if (!(this._pActiveSnapshot)) {
return false;

}

return this._pActiveSnapshot.applySurfaceMaterial(pMaterial);

};
RenderableObject.prototype.hasShadow = function(hasShadow) {
if (hasShadow !== undefined) {
this._hasShadow = hasShadow;

}

return this._hasShadow;

};
a.RenderableObject = RenderableObject;
function Img(pEngine) {
Img.superclass.constructor.apply(this, arguments);
this._iFlags = 0;
this._pData = new Array(0);
this._iWidth = 0;
this._iHeight = 0;
this._eFormat = 0;
this._iCubeFlags = 0;

}

;
a.extend(Img, a.ResourcePoolItem);
Img.prototype.createResource = function() {
if (!(!(this.isResourceCreated()))) {
var err=((((((("Error:: " + "The resource has already been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has already been created.");

}


}

;
this.notifyCreated();
this.notifyDisabled();
return true;

};
Img.prototype.destroyResource = function() {
if (this.isResourceCreated()) {
this.disableResource();
this.releaseImg();
this.notifyUnloaded();
this.notifyDestroyed();
return true;

}

return false;

};
Img.prototype.releaseImg = function() {
this._iFlags = 0;
this._pData = null;
this._iWidth = 0;
this._iHeight = 0;
this._eFormat = 0;
this._iCubeFlags = 0;

};
Img.prototype.restoreResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyRestored();
return true;

};
Img.prototype.disableResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyDisabled();
return true;

};
Img.prototype.saveResource = function(sFilename) {
var pBaseTexture;
var isOk;
if (!sFilename) {
var pString=this.findResourceName();
if (pString) {
sFilename = pString;

}


}

pBaseTexture = this.getTexture();
isOk = false;
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "][") + "") + "]") + ("TODO:: " + "Texture::saveResource()"));
throw new Error("TODO::\n" + "Texture::saveResource()");
return isOk;

};
Img.prototype.getDivSize = function() {
if (((((((this._eFormat) == (33776)) || ((this._eFormat) == (33777))) || ((this._eFormat) == (33780))) || ((this._eFormat) == (33778))) || ((this._eFormat) == (33781))) || ((this._eFormat) == (33779))) {
return 4;

}
else  {
return 1;

}


};
Img.prototype.getBlockBytes = function() {
if (((((this._eFormat) == (33780)) || ((this._eFormat) == (33778))) || ((this._eFormat) == (33781))) || ((this._eFormat) == (33779))) {
return 16;

}

if (((this._eFormat) == (33776)) || ((this._eFormat) == (33777))) {
return 8;

}
else if (((this._eFormat) == (6408)) || ((this._eFormat) == (6409))) {
return 4;

}
else if (((this._eFormat) == (32864)) || ((this._eFormat) == (6407))) {
return 3;

}
else if (((((((this._eFormat) == (32854)) || ((this._eFormat) == (32857))) || ((this._eFormat) == (32855))) || ((this._eFormat) == (32856))) || ((this._eFormat) == (36194))) || ((this._eFormat) == (36195))) {
return 2;

}
else  {
return 0;

}





};
Img.prototype.getWidth = function(iMipLevel) {
if ((iMipLevel == undefined) || (iMipLevel == 0)) {
return this._iWidth;

}
else  {
if (!(iMipLevel < (this.getMipLevels()))) {
var err=((((((("Error:: " + "Запрашивается размер митмап которого нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается размер митмап которого нет");

}


}

;
return (this._iWidth) / (1 << iMipLevel);

}


};
Img.prototype.getHeight = function(iMipLevel) {
if ((iMipLevel == undefined) || (iMipLevel == 0)) {
return this._iHeight;

}
else  {
if (!(iMipLevel < (this.getMipLevels()))) {
var err=((((((("Error:: " + "Запрашивается размер митмапа которого нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается размер митмапа которого нет");

}


}

;
return (this._iHeight) / (1 << iMipLevel);

}


};
Img.prototype.getMipLevels = function() {
if ((this._iFlags & (1 << 2)) != 0) {
if ((this._iFlags & (1 << 1)) != 0) {
return this._pData[0][Math.lowestBitSet(this._iCubeFlags)].length;

}
else  {
return this._pData[0][0].length;

}


}

return undefined;

};
Img.prototype.getCubeFlags = function() {
if ((this._iFlags & (1 << 1)) != 0) {
return this._iCubeFlags;

}

return undefined;

};
Img.prototype.getVolumeLevels = function() {
if ((this._iFlags & (1 << 0)) != 0) {
return this._pData.length;

}

return undefined;

};
Img.prototype.getData = function(iMipLevel, eCubeFlag, iVolumeLevel) {
if (iMipLevel == undefined) {
iMipLevel = 0;

}

if ((this.getMipLevels()) == undefined) {
if (!(iMipLevel == 0)) {
var err=((((((("Error:: " + "Запрашивается мипмап, которого нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается мипмап, которого нет");

}


}

;

}
else  {
if (!(iMipLevel < (this.getMipLevels()))) {
var err=((((((("Error:: " + "Запрашивается мипмап, которого нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается мипмап, которого нет");

}


}

;

}

if (eCubeFlag == undefined) {
eCubeFlag = 0;

}

if ((this._iFlags & (1 << 1)) != 0) {
if (!(this._iCubeFlags & (1 << eCubeFlag)) != 0) {
var err=((((((("Error:: " + "Запрашивается часть кубической текстуры которой нет, которого нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается часть кубической текстуры которой нет, которого нет");

}


}

;

}
else  {
if (!(eCubeFlag == 0)) {
var err=((((((("Error:: " + "Запрашивается часть кубической текстуры которой нет, которого нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается часть кубической текстуры которой нет, которого нет");

}


}

;

}

if (iVolumeLevel == undefined) {
iVolumeLevel = 0;

}

if ((this._iFlags & (1 << 0)) != 0) {
if (!(iVolumeLevel < (this.getVolumeLevels()))) {
var err=((((((("Error:: " + "Запрашивается часть объемной картинки, которой нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается часть объемной картинки, которой нет");

}


}

;

}
else  {
if (!(iVolumeLevel == 0)) {
var err=((((((("Error:: " + "Запрашивается часть объемной картинки, которой нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается часть объемной картинки, которой нет");

}


}

;

}

return this._pData[iVolumeLevel][eCubeFlag][iMipLevel];

};
Img.prototype.isCompressed = function() {
if (((((((this._eFormat) == (33776)) || ((this._eFormat) == (33777))) || ((this._eFormat) == (33780))) || ((this._eFormat) == (33778))) || ((this._eFormat) == (33781))) || ((this._eFormat) == (33779))) {
return true;

}
else  {
return false;

}


};
Img.prototype.isAlpha = function() {
if ((((((((((((this._eFormat) == (33777)) || ((this._eFormat) == (33780))) || ((this._eFormat) == (33778))) || ((this._eFormat) == (33781))) || ((this._eFormat) == (33779))) || ((this._eFormat) == (6408))) || ((this._eFormat) == (6409))) || ((this._eFormat) == (32854))) || ((this._eFormat) == (32857))) || ((this._eFormat) == (32855))) || ((this._eFormat) == (32856))) {
return true;

}
else  {
return false;

}


};
Img.prototype.getFormat = function() {
return this._eFormat;

};
Img.prototype.getFormatShort = function() {
if (((((((this._eFormat) == (33780)) || ((this._eFormat) == (33778))) || ((this._eFormat) == (33781))) || ((this._eFormat) == (33779))) || ((this._eFormat) == (33776))) || ((this._eFormat) == (33777))) {
return this._eFormat;

}
else if (((((((this._eFormat) == (6408)) || ((this._eFormat) == (6409))) || ((this._eFormat) == (32854))) || ((this._eFormat) == (32857))) || ((this._eFormat) == (32855))) || ((this._eFormat) == (32856))) {
return 6408;

}
else if (((((this._eFormat) == (32864)) || ((this._eFormat) == (6407))) || ((this._eFormat) == (36194))) || ((this._eFormat) == (36195))) {
return 6407;

}
else  {
return null;

}




};
Img.prototype.getType = function() {
if (((((((this._eFormat) == (33776)) || ((this._eFormat) == (33777))) || ((this._eFormat) == (33780))) || ((this._eFormat) == (33778))) || ((this._eFormat) == (33781))) || ((this._eFormat) == (33779))) {
return null;

}
else if (((((this._eFormat) == (32864)) || ((this._eFormat) == (6407))) || ((this._eFormat) == (6408))) || ((this._eFormat) == (6409))) {
return 5121;

}
else if (((this._eFormat) == (32854)) || ((this._eFormat) == (32857))) {
return 32819;

}
else if (((this._eFormat) == (32855)) || ((this._eFormat) == (32856))) {
return 32820;

}
else if (((this._eFormat) == (36194)) || ((this._eFormat) == (36195))) {
return 33635;

}
else  {
return null;

}






};
Img.prototype.create = function(iWidth, iHeight, eFormat, iFlags, nVolume) {
var pBuffer;
var nTemp=0;
this._eFormat = eFormat;
this._iWidth = (Math.ceil(iWidth / (this.getDivSize()))) * (this.getDivSize());
this._iHeight = (Math.ceil(iHeight / (this.getDivSize()))) * (this.getDivSize());
this._pData = null;
nTemp = 1;
if ((((iFlags & (1 << 0)) != 0) && (nVolume > 0)) && (nVolume != undefined)) {
this._iFlags |= 1 << 0;
nTemp = nVolume;

}

this._pData = new Array(nTemp);
nTemp = 1;
if ((iFlags & (1 << 1)) != 0) {
this._iFlags |= 1 << 1;
nTemp = 6;

}

for (var i=0; i < (this._pData.length); i++) {
this._pData[i] = new Array(nTemp);

}

nTemp = 1;
if ((iFlags & (1 << 2)) != 0) {
this._iFlags |= 1 << 2;
nTemp = (Math.ceil(Math.max((Math.log(this._iWidth)) / (Math.LN2), (Math.log(this._iHeight)) / (Math.LN2)))) + 1;

}

for (var i=0; i < (this._pData.length); i++) {
for (var k=0; k < (this._pData[i].length); k++) {
this._pData[i][k] = new Array(nTemp);

}


}

for (var i=0; i < (this._pData.length); i++) {
for (var k=0; k < (this._pData[i].length); k++) {
for (var l=0; l < (this._pData[i][k].length); l++) {
this._pData[i][k][l] = new ArrayBuffer((((Math.ceil(iWidth / (this.getDivSize()))) * (Math.ceil(iHeight / (this.getDivSize())))) * (this.getBlockBytes())) >>> (l * 2));

}


}


}

;
this.notifyLoaded();
return true;

};
Img.prototype.loadResource = function(sFileName) {
if (!sFileName) {
var sResourceName=this.findResourceName();
if (sResourceName) {
sFileName = sResourceName;

}


}

var me=this;
this.load(sFileName, function() {
me.notifyLoaded();

}
);

};
Img.prototype.load = function(sFileName, fnCallBack) {
var me=this;
var nMipMap=1;
var nCubeMap=1;
var nVolume=1;
var sExt;
if ((sFileName.nodeName) && ((sFileName.nodeName.toLowerCase()) == "canvas")) {
me._iFlags = 0;
me._iWidth = sFileName.width;
me._iHeight = sFileName.height;
var pTempContext=sFileName.getContext("2d");
if (!pTempContext) {
if (fnCallBack) {
fnCallBack(false);

}

return ;

}

var pImageData=pTempContext.getImageData(0, 0, sFileName.heigh, sFileName.heigh);
me._pData = new Array(nVolume);
me._pData[0] = new Array(nCubeMap);
me._pData[0][0] = new Array(nMipMap);
me._pData[0][0][0] = new ArrayBuffer(pImageData.data.buffer.slice(0, pImageData.data.buffer.byteLength));
me._eFormat = 6408;
me._iCubeFlags = 0;
if (fnCallBack) {
fnCallBack(true);

}

return ;

}
else if ((sExt = a.pathinfo(sFileName).ext) && ((((sExt == "bmp") || (sExt == "jpeg")) || (sExt == "gif")) || (sExt == "png"))) {
var pImg=new Image();
var pTempCanvas=document.createElement("canvas");
if (!pTempCanvas) {
if (fnCallBack) {
fnCallBack(false);

}

return ;

}

pImg.onerror = function() {
if (fnCallBack) {
fnCallBack(false);

}


};
pImg.onabort = function() {
if (fnCallBack) {
fnCallBack(false);

}


};
pImg.onload = function() {
me._iFlags = 0;
me._iWidth = pImg.width;
me._iHeight = pImg.height;
pTempCanvas.width = pImg.width;
pTempCanvas.height = pImg.height;
var pTempContext=pTempCanvas.getContext("2d");
if (!pTempContext) {
if (fnCallBack) {
fnCallBack(false);

}

return ;

}

pTempContext.drawImage(pImg, 0, 0);
var pImageData=pTempContext.getImageData(0, 0, pTempCanvas.heigh, pTempCanvas.heigh);
me._pData = new Array(nVolume);
me._pData[0] = new Array(nCubeMap);
me._pData[0][0] = new Array(nMipMap);
me._pData[0][0][0] = new ArrayBuffer(pImageData.data.buffer.slice(0, pImageData.data.buffer.byteLength));
me._eFormat = 6408;
me._iCubeFlags = 0;
if (fnCallBack) {
fnCallBack(true);

}


};
pImg.src = sFileName;
return ;

}
else  {
a.fopen(sFileName, "rb").onread = function(pData) {
var iOffset=0;
var isOk=false;
var pData8=new Uint8Array(pData);
var pDataTemp;
me._iFlags = 0;
var dwMagic4=new Uint32Array(pData, 0, 1)[0];
var dwMagic2=new Uint16Array(pData, 0, 1)[0];
var dwMagic8_1=dwMagic4;
var dwMagic8_2=new Uint32Array(pData, 4, 1)[0];
if (dwMagic4 == 542327876) {
var pDDSHeader=new Uint32Array(pData, 4, 31);
var header= {};
header.dwSize = pDDSHeader[0];
header.dwFlags = pDDSHeader[1];
header.dwHeight = pDDSHeader[2];
header.dwWidth = pDDSHeader[3];
header.dwPitchOrLinearSize = pDDSHeader[4];
header.dwDepth = pDDSHeader[5];
header.dwMipMapCount = pDDSHeader[6];
header.dwReserved1 = [];
header.dwReserved1[0] = pDDSHeader[7];
header.dwReserved1[1] = pDDSHeader[8];
header.dwReserved1[2] = pDDSHeader[9];
header.dwReserved1[3] = pDDSHeader[10];
header.dwReserved1[4] = pDDSHeader[11];
header.dwReserved1[5] = pDDSHeader[12];
header.dwReserved1[6] = pDDSHeader[13];
header.dwReserved1[7] = pDDSHeader[14];
header.dwReserved1[8] = pDDSHeader[15];
header.dwReserved1[9] = pDDSHeader[16];
header.dwReserved1[10] = pDDSHeader[17];
header.ddspf =  {};
header.ddspf.dwSize = pDDSHeader[18];
header.ddspf.dwFlags = pDDSHeader[19];
header.ddspf.dwFourCC = pDDSHeader[20];
header.ddspf.dwRGBBitCount = pDDSHeader[21];
header.ddspf.dwRBitMask = pDDSHeader[22];
header.ddspf.dwGBitMask = pDDSHeader[23];
header.ddspf.dwBBitMask = pDDSHeader[24];
header.ddspf.dwABitMask = pDDSHeader[25];
header.dwCaps = pDDSHeader[26];
header.dwCaps2 = pDDSHeader[27];
header.dwCaps3 = pDDSHeader[28];
header.dwCaps4 = pDDSHeader[29];
header.dwReserved2 = pDDSHeader[30];
iOffset += 128;
if ((header.dwSize) != 124)if (!0) {
var err=((((((("Error:: " + "Размер заголовка DDS всегда должэен равняться 124") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Размер заголовка DDS всегда должэен равняться 124");

}


}

;

if (!((header.dwFlags) & 1))if (!0) {
var err=((((((("Error:: " + "Флаг DDSD_CAPS в заголовке DDS всегда должен быть") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Флаг DDSD_CAPS в заголовке DDS всегда должен быть");

}


}

;

if (!((header.dwFlags) & 2))if (!0) {
var err=((((((("Error:: " + "Флаг DDSD_HEIGHT в заголовке DDS всегда должен быть") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Флаг DDSD_HEIGHT в заголовке DDS всегда должен быть");

}


}

;

if (!((header.dwFlags) & 4))if (!0) {
var err=((((((("Error:: " + "Флаг DDSD_WIDTH в заголовке DDS всегда должен быть") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Флаг DDSD_WIDTH в заголовке DDS всегда должен быть");

}


}

;

if (!((header.dwFlags) & 4096))if (!0) {
var err=((((((("Error:: " + "Флаг DDSD_PIXELFORMAT в заголовке DDS всегда должен быть") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Флаг DDSD_PIXELFORMAT в заголовке DDS всегда должен быть");

}


}

;

me._iWidth = header.dwWidth;
me._iHeight = header.dwHeight;
if ((header.dwFlags) & 131072) {
me._iFlags |= 1 << 2;
nMipMap = header.dwMipMapCount;

}
else  {
nMipMap = 1;

}

if (((me._iFlags & (1 << 2)) != 0) && ((((me._iWidth) >>> (nMipMap - 1)) != 1) || (((me._iHeight) >>> (nMipMap - 1)) != 1))) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "][") + "") + "]") + (((((("Количество мипмапов не такое чтобы уменьшить размер картинки до 1x1" + nMipMap) + ",") + (me._iWidth)) + "x") + (me._iHeight)) + ")"));

}

if ((header.ddspf.dwSize) != 32) {
if (!0) {
var err=((((((("Error:: " + "Размер DDS_PIXELFORMAT всегда должен равняться 32") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Размер DDS_PIXELFORMAT всегда должен равняться 32");

}


}

;

}

if ((header.ddspf.dwFlags) & 4) {
if ((header.ddspf.dwFourCC) == 827611204) {
me._eFormat = 33777;

}
else if ((header.ddspf.dwFourCC) == 844388420) {
me._eFormat = 33780;

}
else if ((header.ddspf.dwFourCC) == 861165636) {
me._eFormat = 33778;

}
else if ((header.ddspf.dwFourCC) == 877942852) {
me._eFormat = 33781;

}
else if ((header.ddspf.dwFourCC) == 894720068) {
me._eFormat = 33779;

}
else if ((header.ddspf.dwFourCC) == 808540228) {
var pDDS10Header=new Uint32Array(pData, 128, 5);
var header10= {};
header10.dxgiFormat = pDDS10Header[0];
header10.resourceDimension = pDDS10Header[1];
header10.miscFlag = pDDS10Header[2];
header10.arraySize = pDDS10Header[3];
header10.reserved = pDDS10Header[4];
if (!0) {
var err=((((((("Error:: " + "Формат D3DFMT_DX10 не поддерживается") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Формат D3DFMT_DX10 не поддерживается");

}


}

;
iOffset += 20;

}
else  {
if (!0) {
var err=((((((("Error:: " + "Флаг DDPF_FOURCC стоит, а подходящего dwFourCC нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Флаг DDPF_FOURCC стоит, а подходящего dwFourCC нет");

}


}

;

}







}

if ((header.ddspf.dwFlags) & 64) {
if ((((((me._eFormat) == (33777)) || ((me._eFormat) == (33780))) || ((me._eFormat) == (33778))) || ((me._eFormat) == (33781))) || ((me._eFormat) == (33779))) {
if (!0) {
var err=((((((("Error:: " + "Флаг DDPF_RGB стоит при сжатом формате картинки") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Флаг DDPF_RGB стоит при сжатом формате картинки");

}


}

;

}

if ((header.ddspf.dwFlags) & 1) {
if ((((((header.ddspf.dwRGBBitCount) == 32) && ((header.ddspf.dwRBitMask) == 16711680)) && ((header.ddspf.dwGBitMask) == 65280)) && ((header.ddspf.dwBBitMask) == 255)) && ((header.ddspf.dwABitMask) == 4278190080)) {
me._eFormat = 6409;

}
else if ((((((header.ddspf.dwRGBBitCount) == 16) && ((header.ddspf.dwRBitMask) == 31744)) && ((header.ddspf.dwGBitMask) == 992)) && ((header.ddspf.dwBBitMask) == 31)) && ((header.ddspf.dwABitMask) == 32768)) {
me._eFormat = 32856;

}
else if ((((((header.ddspf.dwRGBBitCount) == 16) && ((header.ddspf.dwRBitMask) == 3840)) && ((header.ddspf.dwGBitMask) == 240)) && ((header.ddspf.dwBBitMask) == 15)) && ((header.ddspf.dwABitMask) == 61440)) {
me._eFormat = 32857;

}
else if ((((((header.ddspf.dwRGBBitCount) == 32) && ((header.ddspf.dwRBitMask) == 255)) && ((header.ddspf.dwGBitMask) == 65280)) && ((header.ddspf.dwBBitMask) == 16711680)) && ((header.ddspf.dwABitMask) == 4278190080)) {
me._eFormat = 6408;

}
else  {
if (!0) {
var err=((((((("Error:: " + "Флаг DDS_RGBA стоит, а подходящего формата не найдено") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Флаг DDS_RGBA стоит, а подходящего формата не найдено");

}


}

;

}





}
else  {
if ((((((header.ddspf.dwRGBBitCount) == 24) && ((header.ddspf.dwRBitMask) == 16711680)) && ((header.ddspf.dwGBitMask) == 65280)) && ((header.ddspf.dwBBitMask) == 255)) && ((header.ddspf.dwABitMask) == 0)) {
me._eFormat = 32864;

}
else if ((((((header.ddspf.dwRGBBitCount) == 16) && ((header.ddspf.dwRBitMask) == 63488)) && ((header.ddspf.dwGBitMask) == 2016)) && ((header.ddspf.dwBBitMask) == 31)) && ((header.ddspf.dwABitMask) == 0)) {
me._eFormat = 36195;

}
else  {
if (!0) {
var err=((((((("Error:: " + "Флаг DDS_RGB стоит, а подходящего формата не найдено") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Флаг DDS_RGB стоит, а подходящего формата не найдено");

}


}

;

}



}


}

if (((!(header.ddspf.dwFlags)) & 64) && ((!(header.ddspf.dwFlags)) & 4)) {
if (!0) {
var err=((((((("Error:: " + "Флаги DDPF_RGB или DDPF_FOURCC не выставлены, остальные являются устаревшими") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Флаги DDPF_RGB или DDPF_FOURCC не выставлены, остальные являются устаревшими");

}


}

;

}

nCubeMap = 1;
me._iCubeFlags = 0;
if ((header.dwCaps2) & 512) {
nCubeMap = 0;
me._iFlags |= 1 << 1;
if ((header.dwCaps2) & 1024) {
nCubeMap++;
me._iCubeFlags |= 1 << 0;

}

if ((header.dwCaps2) & 2048) {
nCubeMap++;
me._iCubeFlags |= 1 << 1;

}

if ((header.dwCaps2) & 4096) {
nCubeMap++;
me._iCubeFlags |= 1 << 2;

}

if ((header.dwCaps2) & 8192) {
nCubeMap++;
me._iCubeFlags |= 1 << 3;

}

if ((header.dwCaps2) & 16384) {
nCubeMap++;
me._iCubeFlags |= 1 << 4;

}

if ((header.dwCaps2) & 32768) {
nCubeMap++;
me._iCubeFlags |= 1 << 5;

}

if (!(nCubeMap != 0)) {
var err=((((((("Error:: " + "Выставлен фдлаг с кубической текстурой, а самих текстур нету") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Выставлен фдлаг с кубической текстурой, а самих текстур нету");

}


}

;

}

isOk = true;

}
else if ((((dwMagic2 == 19786) || ((dwMagic8_1 == 1196314761) && (dwMagic8_2 == 169478669))) || (dwMagic2 == 55551)) || 944130375) {
if (!0) {
var err=((((((("Error:: " + "Должны были прогрузиться через canvas") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Должны были прогрузиться через canvas");

}


}

;

}
else  {
trace(sFileName);
if (!0) {
var err=((((((("Error:: " + (("Данный тип графического файла не поддерживается(" + dwMagic) + ")")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("Данный тип графического файла не поддерживается(" + dwMagic) + ")"));

}


}

;
isOk = false;

}


if (me.isCompressed()) {
if ((!(header.dwFlags)) & 524288) {
if (!0) {
var err=((((((("Error:: " + "У сжатой текстуры не выставлен флаг DDS_HEADER_FLAGS_LINEARSIZE в заголовке") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("У сжатой текстуры не выставлен флаг DDS_HEADER_FLAGS_LINEARSIZE в заголовке");

}


}

;

}


}

var iX=me._iWidth;
var iY=me._iHeight;
var iSizeData=((Math.ceil(iX / (me.getDivSize()))) * (Math.ceil(iY / (me.getDivSize())))) * (me.getBlockBytes());
if (iSizeData != (header.dwPitchOrLinearSize)) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "][") + "") + "]") + (((("Несовпадают размеры картинки вычисленный и в файле(" + iSizeData) + ",") + (header.dwPitchOrLinearSize)) + ")"));

}

if ((!(header.dwFlags)) & 524288) {
if (!0) {
var err=((((((("Error:: " + "У сжатой текстуры не выставлен флаг DDS_HEADER_FLAGS_LINEARSIZE в заголовке") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("У сжатой текстуры не выставлен флаг DDS_HEADER_FLAGS_LINEARSIZE в заголовке");

}


}

;

}

if ((me._iFlags & (1 << 1)) != 0) {
me._pData = new Array(nVolume);
for (k = 0; k < nVolume; k++) {
me._pData[k] = new Array(6);
for (l = 0; l < 6; l++) {
if ((me._iCubeFlags & (1 << ((0) + l))) != 0) {
me._pData[k][l] = new Array(nMipMap);

}


}


}

for (k = 0; k < nVolume; k++) {
for (l = 0; l < 6; l++) {
if ((me._iCubeFlags & (1 << ((0) + l))) != 0) {
iX = me._iWidth;
iY = me._iHeight;
iSizeData = ((Math.ceil(iX / (me.getDivSize()))) * (Math.ceil(iY / (me.getDivSize())))) * (me.getBlockBytes());
for (var b=0; b < nMipMap; b++) {
me._pData[k][l][b] = new ArrayBuffer(iSizeData);
pDataTemp = new Uint8Array(me._pData[k][l][b]);
for (var a=0; a < iSizeData; a++) {
pDataTemp[a] = pData8[a + iOffset];

}

iOffset += iSizeData;
iX = Math.ceil(iX / 2);
iY = Math.ceil(iY / 2);
iSizeData = (Math.ceil((iX * iY) / ((me.getDivSize()) * (me.getDivSize())))) * (me.getBlockBytes());

}


}


}


}


}
else  {
me._pData = new Array(nVolume);
for (k = 0; k < nVolume; k++) {
me._pData[k] = new Array(6);
me._pData[k][0] = new Array(nMipMap);

}

for (k = 0; k < nVolume; k++) {
iX = me._iWidth;
iY = me._iHeight;
iSizeData = ((Math.ceil(iX / (me.getDivSize()))) * (Math.ceil(iY / (me.getDivSize())))) * (me.getBlockBytes());
for (var b=0; b < nMipMap; b++) {
me._pData[k][0][b] = new ArrayBuffer(iSizeData);
pDataTemp = new Uint8Array(me._pData[k][0][b]);
for (var a=0; a < iSizeData; a++) {
pDataTemp[a] = pData8[a + iOffset];

}

iOffset += iSizeData;
iX = Math.ceil(iX / 2);
iY = Math.ceil(iY / 2);
iSizeData = (Math.ceil((iX * iY) / ((me.getDivSize()) * (me.getDivSize())))) * (me.getBlockBytes());

}


}


}

if (fnCallBack) {
fnCallBack(isOk);

}


};
return ;

}



};
Img.prototype.getPixelRGBA = function(iX, iY, pPixel, iMipLevel, eCubeFlag, iVolumeLevel) {
if (iMipLevel == undefined) {
iMipLevel = 0;

}
else  {
if (!(this._iFlags & (1 << 2)) != 0) {
var err=((((((("Error:: " + "Запрашиваются мипмапы, а их нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашиваются мипмапы, а их нет");

}


}

;
if (!(iMipLevel < (this.getMipMapLevels()))) {
var err=((((((("Error:: " + "Запрашивается мипмап, которого нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается мипмап, которого нет");

}


}

;

}

if (eCubeFlag == undefined) {
if (!(!((this._iFlags & (1 << 1)) != 0))) {
var err=((((((("Error:: " + "Не выставлена часть кубической картинки") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Не выставлена часть кубической картинки");

}


}

;
eCubeFlag = 0;

}
else  {
if (!(this._iFlags & (1 << 1)) != 0) {
var err=((((((("Error:: " + "Выставлена часть кубической куртинки, хотя картинка не является кубической") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Выставлена часть кубической куртинки, хотя картинка не является кубической");

}


}

;
if (!(this._iCubeFlags & (1 << eCubeFlag)) != 0) {
var err=((((((("Error:: " + "Запрашивается часть кубической текстуры которой нет, которого нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается часть кубической текстуры которой нет, которого нет");

}


}

;

}

if (iVolumeLevel == undefined) {
iVolumeLevel = 0;

}
else  {
if (!(this._iFlags & (1 << 0)) != 0) {
var err=((((((("Error:: " + "Запрашивается часть объемной картинки, а картинка не объемная") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается часть объемной картинки, а картинка не объемная");

}


}

;
if (!(iVolumeLevel < (this.getVolumeLevels()))) {
var err=((((((("Error:: " + "Запрашивается часть объемной картинки, которой нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается часть объемной картинки, которой нет");

}


}

;

}

return this._getPixelRGBA(iX, iY, pPixel, iMipLevel, eCubeFlag, iVolumeLevel);

};
Img.prototype._getPixelRGBA = function(iX, iY, pPixel, iMipLevel, eCubeFlag, iVolumeLevel) {
var iOffset;
var pColor;
var iOffset;
if ((this._eFormat) == (6409)) {
iOffset = ((iY * (this.getWidth(iMipLevel))) + iX) * (this.getBlockBytes());
pColor = new Uint32Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1)[0];
pPixel[0] = (pColor & 16711680) >>> 16;
pPixel[1] = (pColor & 65280) >>> 8;
pPixel[2] = pColor & 255;
pPixel[3] = (pColor & 4278190080) >>> 24;

}
else if ((this._eFormat) == (6408)) {
iOffset = ((iY * (this.getWidth(iMipLevel))) + iX) * (this.getBlockBytes());
pColor = new Uint32Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1)[0];
pPixel[0] = pColor & 255;
pPixel[1] = (pColor & 65280) >>> 8;
pPixel[2] = (pColor & 16711680) >>> 16;
pPixel[3] = (pColor & 4278190080) >>> 24;

}
else if ((this._eFormat) == (32856)) {
iOffset = ((iY * (this.getWidth(iMipLevel))) + iX) * (this.getBlockBytes());
pColor = new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1)[0];
pPixel[0] = ((pColor & 31744) >>> 10) * 7;
pPixel[1] = ((pColor & 992) >>> 5) * 7;
pPixel[2] = (pColor & 31) * 7;
pPixel[3] = ((pColor & 32768) >>> 15) * 255;

}
else if ((this._eFormat) == (32855)) {
iOffset = ((iY * (this.getWidth(iMipLevel))) + iX) * (this.getBlockBytes());
pColor = new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1)[0];
pPixel[0] = (pColor & 31) * 7;
pPixel[1] = ((pColor & 992) >>> 5) * 7;
pPixel[2] = ((pColor & 31744) >>> 10) * 7;
pPixel[3] = ((pColor & 32768) >>> 15) * 255;

}
else if ((this._eFormat) == (32857)) {
iOffset = ((iY * (this.getWidth(iMipLevel))) + iX) * (this.getBlockBytes());
pColor = new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1)[0];
pPixel[0] = ((pColor & 3840) >>> 8) * 15;
pPixel[1] = ((pColor & 240) >>> 4) * 15;
pPixel[2] = (pColor & 15) * 15;
pPixel[3] = ((pColor & 61440) >>> 12) * 15;

}
else if ((this._eFormat) == (32854)) {
iOffset = ((iY * (this.getWidth(iMipLevel))) + iX) * (this.getBlockBytes());
pColor = new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1)[0];
pPixel[0] = (pColor & 15) * 15;
pPixel[1] = ((pColor & 240) >>> 4) * 15;
pPixel[2] = ((pColor & 3840) >>> 8) * 15;
pPixel[3] = ((pColor & 61440) >>> 12) * 15;

}
else if ((this._eFormat) == (32864)) {
iOffset = ((iY * (this.getWidth(iMipLevel))) + iX) * (this.getBlockBytes());
pColor = new Uint8Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 3);
pPixel[0] = pColor[2];
pPixel[1] = pColor[1];
pPixel[2] = pColor[0];
pPixel[3] = 255;

}
else if ((this._eFormat) == (32864)) {
iOffset = ((iY * (this.getWidth(iMipLevel))) + iX) * (this.getBlockBytes());
pColor = new Uint8Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 3);
pPixel[0] = pColor[0];
pPixel[1] = pColor[1];
pPixel[2] = pColor[2];
pPixel[3] = 255;

}
else if ((this._eFormat) == (36195)) {
iOffset = ((iY * (this.getWidth(iMipLevel))) + iX) * (this.getBlockBytes());
pColor = new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1)[0];
pPixel[0] = ((pColor & 63488) >>> 11) * 7;
pPixel[1] = ((pColor & 2016) >>> 5) * 3;
pPixel[2] = (pColor & 31) * 7;
pPixel[3] = 255;

}
else if ((this._eFormat) == (36194)) {
iOffset = ((iY * (this.getWidth(iMipLevel))) + iX) * (this.getBlockBytes());
pColor = new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1)[0];
pPixel[0] = (pColor & 31) * 7;
pPixel[1] = ((pColor & 2016) >>> 5) * 3;
pPixel[2] = ((pColor & 63488) >>> 11) * 7;
pPixel[3] = 255;

}
else if ((this._eFormat) == (33777)) {
iOffset = (((Math.ceil((this.getWidth(iMipLevel)) / (this.getDivSize()))) * (Math.floor(iY / (this.getDivSize())))) + (Math.floor(iX / (this.getDivSize())))) * (this.getBlockBytes());
var pColor0=new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1)[0];
var pColor1=new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 2, 1)[0];
pColor = new Uint32Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 4, 1)[0];
var iX0=iX % (this.getDivSize());
var iY0=iY % (this.getDivSize());
var iCode=(pColor >>> (2 * (((this.getDivSize()) * iY0) + iX0))) & 3;
if (pColor0 > pColor1) {
if (iCode == 0) {
pPixel[0] = ((pColor0 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor0 & 2016) >>> 5) * 4;
pPixel[2] = (pColor0 & 31) * 8;
pPixel[3] = 255;

}
else if (iCode == 1) {
pPixel[0] = ((pColor1 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor1 & 2016) >>> 5) * 4;
pPixel[2] = (pColor1 & 31) * 8;
pPixel[3] = 255;

}
else if (iCode == 2) {
pPixel[0] = ((((2 * (pColor0 & 63488)) >>> 11) * 8) + (((pColor1 & 63488) >>> 11) * 8)) / 3;
pPixel[1] = ((((2 * (pColor0 & 2016)) >>> 5) * 4) + (((pColor1 & 2016) >>> 5) * 4)) / 3;
pPixel[2] = (((2 * (pColor0 & 31)) * 8) + ((pColor1 & 31) * 8)) / 3;
pPixel[3] = 255;

}
else if (iCode == 3) {
pPixel[0] = ((((2 * (pColor1 & 63488)) >>> 11) * 8) + (((pColor0 & 63488) >>> 11) * 8)) / 3;
pPixel[1] = ((((2 * (pColor1 & 2016)) >>> 5) * 4) + (((pColor0 & 2016) >>> 5) * 4)) / 3;
pPixel[2] = (((2 * (pColor1 & 31)) * 8) + ((pColor0 & 31) * 8)) / 3;
pPixel[3] = 255;

}





}
else  {
if (iCode == 0) {
pPixel[0] = ((pColor0 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor0 & 2016) >>> 5) * 4;
pPixel[2] = (pColor0 & 31) * 8;
pPixel[3] = 255;

}
else if (iCode == 1) {
pPixel[0] = ((pColor1 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor1 & 2016) >>> 5) * 4;
pPixel[2] = (pColor1 & 31) * 8;
pPixel[3] = 255;

}
else if (iCode == 2) {
pPixel[0] = ((((pColor0 & 63488) >>> 11) * 8) + (((pColor1 & 63488) >>> 11) * 8)) / 2;
pPixel[1] = ((((pColor0 & 2016) >>> 5) * 4) + (((pColor1 & 2016) >>> 5) * 4)) / 2;
pPixel[2] = (((pColor0 & 31) * 8) + ((pColor1 & 31) * 8)) / 2;
pPixel[3] = 255;

}
else if (iCode == 3) {
pPixel[0] = 0;
pPixel[1] = 0;
pPixel[2] = 0;
pPixel[3] = 0;

}





}


}
else if ((this._eFormat) == (33776)) {
iOffset = (((Math.ceil((this.getWidth(iMipLevel)) / (this.getDivSize()))) * (Math.floor(iY / (this.getDivSize())))) + (Math.floor(iX / (this.getDivSize())))) * (this.getBlockBytes());
var pColor0=new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1)[0];
var pColor1=new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 2, 1)[0];
pColor = new Uint32Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 4, 1)[0];
var iX0=iX % (this.getDivSize());
var iY0=iY % (this.getDivSize());
var iCode=(pColor >>> (2 * (((this.getDivSize()) * iY0) + iX0))) & 3;
if (pColor0 > pColor1) {
if (iCode == 0) {
pPixel[0] = ((pColor0 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor0 & 2016) >>> 5) * 4;
pPixel[2] = (pColor0 & 31) * 8;
pPixel[3] = 255;

}
else if (iCode == 1) {
pPixel[0] = ((pColor1 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor1 & 2016) >>> 5) * 4;
pPixel[2] = (pColor1 & 31) * 8;
pPixel[3] = 255;

}
else if (iCode == 2) {
pPixel[0] = ((((2 * (pColor0 & 63488)) >>> 11) * 8) + (((pColor1 & 63488) >>> 11) * 8)) / 3;
pPixel[1] = ((((2 * (pColor0 & 2016)) >>> 5) * 4) + (((pColor1 & 2016) >>> 5) * 4)) / 3;
pPixel[2] = (((2 * (pColor0 & 31)) * 8) + ((pColor1 & 31) * 8)) / 3;
pPixel[3] = 255;

}
else if (iCode == 3) {
pPixel[0] = ((((2 * (pColor1 & 63488)) >>> 11) * 8) + (((pColor0 & 63488) >>> 11) * 8)) / 3;
pPixel[1] = ((((2 * (pColor1 & 2016)) >>> 5) * 4) + (((pColor0 & 2016) >>> 5) * 4)) / 3;
pPixel[2] = (((2 * (pColor1 & 31)) * 8) + ((pColor0 & 31) * 8)) / 3;
pPixel[3] = 255;

}





}
else  {
if (iCode == 0) {
pPixel[0] = ((pColor0 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor0 & 2016) >>> 5) * 4;
pPixel[2] = (pColor0 & 31) * 8;
pPixel[3] = 255;

}
else if (iCode == 1) {
pPixel[0] = ((pColor1 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor1 & 2016) >>> 5) * 4;
pPixel[2] = (pColor1 & 31) * 8;
pPixel[3] = 255;

}
else if (iCode == 2) {
pPixel[0] = ((((pColor0 & 63488) >>> 11) * 8) + (((pColor1 & 63488) >>> 11) * 8)) / 2;
pPixel[1] = ((((pColor0 & 2016) >>> 5) * 4) + (((pColor1 & 2016) >>> 5) * 4)) / 2;
pPixel[2] = (((pColor0 & 31) * 8) + ((pColor1 & 31) * 8)) / 2;
pPixel[3] = 255;

}
else if (iCode == 3) {
pPixel[0] = 0;
pPixel[1] = 0;
pPixel[2] = 0;
pPixel[3] = 255;

}





}


}
else if ((this._eFormat) == (33780)) {
iOffset = (((Math.ceil((this.getWidth(iMipLevel)) / (this.getDivSize()))) * (Math.floor(iY / (this.getDivSize())))) + (Math.floor(iX / (this.getDivSize())))) * (this.getBlockBytes());
var pColor0=new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 8, 1)[0];
var pColor1=new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 10, 1)[0];
pColor = new Uint32Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 12, 1)[0];
var pAlpha=new Uint8Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 8);
var iX0=iX % (this.getDivSize());
var iY0=iY % (this.getDivSize());
var iCode=(pColor >>> (2 * (((this.getDivSize()) * iY0) + iX0))) & 3;
pPixel[3] = (((pAlpha[Math.floor((((this.getDivSize()) * iY0) + iX0) / 2)]) >>> (4 * ((((this.getDivSize()) * iY0) + iX0) % 2))) & 15) * 15;
if (iCode == 0) {
pPixel[0] = ((pColor0 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor0 & 2016) >>> 5) * 4;
pPixel[2] = (pColor0 & 31) * 8;

}
else if (iCode == 1) {
pPixel[0] = ((pColor1 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor1 & 2016) >>> 5) * 4;
pPixel[2] = (pColor1 & 31) * 8;

}
else if (iCode == 2) {
pPixel[0] = ((((2 * (pColor0 & 63488)) >>> 11) * 8) + (((pColor1 & 63488) >>> 11) * 8)) / 3;
pPixel[1] = ((((2 * (pColor0 & 2016)) >>> 5) * 4) + (((pColor1 & 2016) >>> 5) * 4)) / 3;
pPixel[2] = (((2 * (pColor0 & 31)) * 8) + ((pColor1 & 31) * 8)) / 3;

}
else if (iCode == 3) {
pPixel[0] = ((((2 * (pColor1 & 63488)) >>> 11) * 8) + (((pColor0 & 63488) >>> 11) * 8)) / 3;
pPixel[1] = ((((2 * (pColor1 & 2016)) >>> 5) * 4) + (((pColor0 & 2016) >>> 5) * 4)) / 3;
pPixel[2] = (((2 * (pColor1 & 31)) * 8) + ((pColor0 & 31) * 8)) / 3;

}




pPixel[0] = ((pPixel[0]) * 255) / (pPixel[3]);
pPixel[1] = ((pPixel[1]) * 255) / (pPixel[3]);
pPixel[2] = ((pPixel[2]) * 255) / (pPixel[3]);

}
else if ((this._eFormat) == (33778)) {
iOffset = (((Math.ceil((this.getWidth(iMipLevel)) / (this.getDivSize()))) * (Math.floor(iY / (this.getDivSize())))) + (Math.floor(iX / (this.getDivSize())))) * (this.getBlockBytes());
var pColor0=new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 8, 1)[0];
var pColor1=new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 10, 1)[0];
pColor = new Uint32Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 12, 1)[0];
var pAlpha=new Uint8Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 8);
var iX0=iX % (this.getDivSize());
var iY0=iY % (this.getDivSize());
var iCode=(pColor >>> (2 * (((this.getDivSize()) * iY0) + iX0))) & 3;
if (iCode == 0) {
pPixel[0] = ((pColor0 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor0 & 2016) >>> 5) * 4;
pPixel[2] = (pColor0 & 31) * 8;
pPixel[3] = (((pAlpha[Math.floor((((this.getDivSize()) * iY0) + iX0) / 2)]) >>> (4 * ((((this.getDivSize()) * iY0) + iX0) % 2))) & 15) * 15;

}
else if (iCode == 1) {
pPixel[0] = ((pColor1 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor1 & 2016) >>> 5) * 4;
pPixel[2] = (pColor1 & 31) * 8;
pPixel[3] = (((pAlpha[Math.floor((((this.getDivSize()) * iY0) + iX0) / 2)]) >>> (4 * ((((this.getDivSize()) * iY0) + iX0) % 2))) & 15) * 15;

}
else if (iCode == 2) {
pPixel[0] = ((((2 * (pColor0 & 63488)) >>> 11) * 8) + (((pColor1 & 63488) >>> 11) * 8)) / 3;
pPixel[1] = ((((2 * (pColor0 & 2016)) >>> 5) * 4) + (((pColor1 & 2016) >>> 5) * 4)) / 3;
pPixel[2] = (((2 * (pColor0 & 31)) * 8) + ((pColor1 & 31) * 8)) / 3;
pPixel[3] = (((pAlpha[Math.floor((((this.getDivSize()) * iY0) + iX0) / 2)]) >>> (4 * ((((this.getDivSize()) * iY0) + iX0) % 2))) & 15) * 15;

}
else if (iCode == 3) {
pPixel[0] = ((((2 * (pColor1 & 63488)) >>> 11) * 8) + (((pColor0 & 63488) >>> 11) * 8)) / 3;
pPixel[1] = ((((2 * (pColor1 & 2016)) >>> 5) * 4) + (((pColor0 & 2016) >>> 5) * 4)) / 3;
pPixel[2] = (((2 * (pColor1 & 31)) * 8) + ((pColor0 & 31) * 8)) / 3;
pPixel[3] = (((pAlpha[Math.floor((((this.getDivSize()) * iY0) + iX0) / 2)]) >>> (4 * ((((this.getDivSize()) * iY0) + iX0) % 2))) & 15) * 15;

}





}
else if ((this._eFormat) == (33781)) {
iOffset = (((Math.ceil((this.getWidth(iMipLevel)) / (this.getDivSize()))) * (Math.floor(iY / (this.getDivSize())))) + (Math.floor(iX / (this.getDivSize())))) * (this.getBlockBytes());
var pColor0=new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 8, 1)[0];
var pColor1=new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 10, 1)[0];
pColor = new Uint32Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 12, 1)[0];
var pAlpha0=new Uint8Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1)[0];
var pAlpha1=new Uint8Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 1, 1)[0];
var pAlpha=new Uint8Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 2, 6);
var iX0=iX % (this.getDivSize());
var iY0=iY % (this.getDivSize());
var iCode=(pColor >>> (2 * (((this.getDivSize()) * iY0) + iX0))) & 3;
var iAlphaCode;
switch((iY0 * (this.getDivSize())) + iX0) {
case 0:
iAlphaCode = (pAlpha[0]) & 7;
break ;

case 1:
iAlphaCode = ((pAlpha[0]) & 56) >>> 3;
break ;

case 2:
iAlphaCode = (((pAlpha[0]) & 192) >> 6) + (((pAlpha[1]) & 1) << 2);
break ;

case 3:
iAlphaCode = ((pAlpha[1]) & 14) >>> 1;
break ;

case 4:
iAlphaCode = ((pAlpha[1]) & 112) >>> 4;
break ;

case 5:
iAlphaCode = (((pAlpha[1]) & 128) >>> 7) + (((pAlpha[2]) & 3) << 1);
break ;

case 6:
iAlphaCode = ((pAlpha[2]) & 28) >>> 2;
break ;

case 7:
iAlphaCode = ((pAlpha[2]) & 224) >>> 5;
break ;

case 8:
iAlphaCode = (pAlpha[3]) & 7;
break ;

case 9:
iAlphaCode = ((pAlpha[3]) & 56) >>> 3;
break ;

case 10:
iAlphaCode = (((pAlpha[3]) & 192) >> 6) + (((pAlpha[4]) & 1) << 2);
break ;

case 11:
iAlphaCode = ((pAlpha[4]) & 14) >>> 1;
break ;

case 12:
iAlphaCode = ((pAlpha[4]) & 112) >>> 4;
break ;

case 13:
iAlphaCode = (((pAlpha[4]) & 128) >>> 7) + (((pAlpha[5]) & 3) << 1);
break ;

case 14:
iAlphaCode = ((pAlpha[5]) & 28) >>> 2;
break ;

case 15:
iAlphaCode = ((pAlpha[5]) & 224) >>> 5;
break ;
}
if (pAlpha0 > pAlpha1) {
if (iAlphaCode == 0) {
pPixel[3] = pAlpha0;

}
else if (iAlphaCode == 1) {
pPixel[3] = pAlpha1;

}
else if (iAlphaCode == 2) {
pPixel[3] = ((6 * pAlpha0) + (1 * pAlpha1)) / 7;

}
else if (iAlphaCode == 3) {
pPixel[3] = ((5 * pAlpha0) + (2 * pAlpha1)) / 7;

}
else if (iAlphaCode == 4) {
pPixel[3] = ((4 * pAlpha0) + (3 * pAlpha1)) / 7;

}
else if (iAlphaCode == 5) {
pPixel[3] = ((3 * pAlpha0) + (4 * pAlpha1)) / 7;

}
else if (iAlphaCode == 6) {
pPixel[3] = ((2 * pAlpha0) + (5 * pAlpha1)) / 7;

}
else if (iAlphaCode == 7) {
pPixel[3] = ((1 * pAlpha0) + (6 * pAlpha1)) / 7;

}









}
else  {
if (iAlphaCode == 0) {
pPixel[3] = pAlpha0;

}
else if (iAlphaCode == 1) {
pPixel[3] = pAlpha1;

}
else if (iAlphaCode == 2) {
pPixel[3] = ((4 * pAlpha0) + (1 * pAlpha1)) / 5;

}
else if (iAlphaCode == 3) {
pPixel[3] = ((3 * pAlpha0) + (2 * pAlpha1)) / 5;

}
else if (iAlphaCode == 4) {
pPixel[3] = ((2 * pAlpha0) + (3 * pAlpha1)) / 5;

}
else if (iAlphaCode == 5) {
pPixel[3] = ((1 * pAlpha0) + (4 * pAlpha1)) / 5;

}
else if (iAlphaCode == 6) {
pPixel[3] = 0;

}
else if (iAlphaCode == 7) {
pPixel[3] = 1;

}









}

if (iCode == 0) {
pPixel[0] = ((pColor0 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor0 & 2016) >>> 5) * 4;
pPixel[2] = (pColor0 & 31) * 8;

}
else if (iCode == 1) {
pPixel[0] = ((pColor1 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor1 & 2016) >>> 5) * 4;
pPixel[2] = (pColor1 & 31) * 8;

}
else if (iCode == 2) {
pPixel[0] = ((((2 * (pColor0 & 63488)) >>> 11) * 8) + (((pColor1 & 63488) >>> 11) * 8)) / 3;
pPixel[1] = ((((2 * (pColor0 & 2016)) >>> 5) * 4) + (((pColor1 & 2016) >>> 5) * 4)) / 3;
pPixel[2] = (((2 * (pColor0 & 31)) * 8) + ((pColor1 & 31) * 8)) / 3;

}
else if (iCode == 3) {
pPixel[0] = ((((2 * (pColor1 & 63488)) >>> 11) * 8) + (((pColor0 & 63488) >>> 11) * 8)) / 3;
pPixel[1] = ((((2 * (pColor1 & 2016)) >>> 5) * 4) + (((pColor0 & 2016) >>> 5) * 4)) / 3;
pPixel[2] = (((2 * (pColor1 & 31)) * 8) + ((pColor0 & 31) * 8)) / 3;

}




pPixel[0] = ((pPixel[0]) * 255) / (pPixel[3]);
pPixel[1] = ((pPixel[1]) * 255) / (pPixel[3]);
pPixel[2] = ((pPixel[2]) * 255) / (pPixel[3]);

}
else if ((this._eFormat) == (33779)) {
iOffset = (((Math.ceil((this.getWidth(iMipLevel)) / (this.getDivSize()))) * (Math.floor(iY / (this.getDivSize())))) + (Math.floor(iX / (this.getDivSize())))) * (this.getBlockBytes());
var pColor0=new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 8, 1)[0];
var pColor1=new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 10, 1)[0];
pColor = new Uint32Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 12, 1)[0];
var pAlpha0=new Uint8Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1)[0];
var pAlpha1=new Uint8Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 1, 1)[0];
var pAlpha=new Uint8Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset + 2, 6);
var iX0=iX % (this.getDivSize());
var iY0=iY % (this.getDivSize());
var iCode=(pColor >>> (2 * (((this.getDivSize()) * iY0) + iX0))) & 3;
var iAlphaCode;
switch((iY0 * (this.getDivSize())) + iX0) {
case 0:
iAlphaCode = (pAlpha[0]) & 7;
break ;

case 1:
iAlphaCode = ((pAlpha[0]) & 56) >>> 3;
break ;

case 2:
iAlphaCode = (((pAlpha[0]) & 192) >> 6) + (((pAlpha[1]) & 1) << 2);
break ;

case 3:
iAlphaCode = ((pAlpha[1]) & 14) >>> 1;
break ;

case 4:
iAlphaCode = ((pAlpha[1]) & 112) >>> 4;
break ;

case 5:
iAlphaCode = (((pAlpha[1]) & 128) >>> 7) + (((pAlpha[2]) & 3) << 1);
break ;

case 6:
iAlphaCode = ((pAlpha[2]) & 28) >>> 2;
break ;

case 7:
iAlphaCode = ((pAlpha[2]) & 224) >>> 5;
break ;

case 8:
iAlphaCode = (pAlpha[3]) & 7;
break ;

case 9:
iAlphaCode = ((pAlpha[3]) & 56) >>> 3;
break ;

case 10:
iAlphaCode = (((pAlpha[3]) & 192) >> 6) + (((pAlpha[4]) & 1) << 2);
break ;

case 11:
iAlphaCode = ((pAlpha[4]) & 14) >>> 1;
break ;

case 12:
iAlphaCode = ((pAlpha[4]) & 112) >>> 4;
break ;

case 13:
iAlphaCode = (((pAlpha[4]) & 128) >>> 7) + (((pAlpha[5]) & 3) << 1);
break ;

case 14:
iAlphaCode = ((pAlpha[5]) & 28) >>> 2;
break ;

case 15:
iAlphaCode = ((pAlpha[5]) & 224) >>> 5;
break ;
}
if (pAlpha0 > pAlpha1) {
if (iAlphaCode == 0) {
pPixel[3] = pAlpha0;

}
else if (iAlphaCode == 1) {
pPixel[3] = pAlpha1;

}
else if (iAlphaCode == 2) {
pPixel[3] = ((6 * pAlpha0) + (1 * pAlpha1)) / 7;

}
else if (iAlphaCode == 3) {
pPixel[3] = ((5 * pAlpha0) + (2 * pAlpha1)) / 7;

}
else if (iAlphaCode == 4) {
pPixel[3] = ((4 * pAlpha0) + (3 * pAlpha1)) / 7;

}
else if (iAlphaCode == 5) {
pPixel[3] = ((3 * pAlpha0) + (4 * pAlpha1)) / 7;

}
else if (iAlphaCode == 6) {
pPixel[3] = ((2 * pAlpha0) + (5 * pAlpha1)) / 7;

}
else if (iAlphaCode == 7) {
pPixel[3] = ((1 * pAlpha0) + (6 * pAlpha1)) / 7;

}









}
else  {
if (iAlphaCode == 0) {
pPixel[3] = pAlpha0;

}
else if (iAlphaCode == 1) {
pPixel[3] = pAlpha1;

}
else if (iAlphaCode == 2) {
pPixel[3] = ((4 * pAlpha0) + (1 * pAlpha1)) / 5;

}
else if (iAlphaCode == 3) {
pPixel[3] = ((3 * pAlpha0) + (2 * pAlpha1)) / 5;

}
else if (iAlphaCode == 4) {
pPixel[3] = ((2 * pAlpha0) + (3 * pAlpha1)) / 5;

}
else if (iAlphaCode == 5) {
pPixel[3] = ((1 * pAlpha0) + (4 * pAlpha1)) / 5;

}
else if (iAlphaCode == 6) {
pPixel[3] = 0;

}
else if (iAlphaCode == 7) {
pPixel[3] = 1;

}









}

if (iCode == 0) {
pPixel[0] = ((pColor0 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor0 & 2016) >>> 5) * 4;
pPixel[2] = (pColor0 & 31) * 8;

}
else if (iCode == 1) {
pPixel[0] = ((pColor1 & 63488) >>> 11) * 8;
pPixel[1] = ((pColor1 & 2016) >>> 5) * 4;
pPixel[2] = (pColor1 & 31) * 8;

}
else if (iCode == 2) {
pPixel[0] = ((((2 * (pColor0 & 63488)) >>> 11) * 8) + (((pColor1 & 63488) >>> 11) * 8)) / 3;
pPixel[1] = ((((2 * (pColor0 & 2016)) >>> 5) * 4) + (((pColor1 & 2016) >>> 5) * 4)) / 3;
pPixel[2] = (((2 * (pColor0 & 31)) * 8) + ((pColor1 & 31) * 8)) / 3;

}
else if (iCode == 3) {
pPixel[0] = ((((2 * (pColor1 & 63488)) >>> 11) * 8) + (((pColor0 & 63488) >>> 11) * 8)) / 3;
pPixel[1] = ((((2 * (pColor1 & 2016)) >>> 5) * 4) + (((pColor0 & 2016) >>> 5) * 4)) / 3;
pPixel[2] = (((2 * (pColor1 & 31)) * 8) + ((pColor0 & 31) * 8)) / 3;

}





}
















return pPixel;

};
Img.prototype.convert = function(eFormat) {
var iLength;
var iOffset;
var iColor1;
var iColor2;
var iColor3;
var iColor4;
var pOldBuffer;
var pNewBuffer;
var pNewData;
var pPixel=new Uint8Array(4);
var nMipMap=this.getMipLevels();
if (nMipMap == undefined) {
nMipMap = 1;

}

var nVolume=this.getVolumeLevels();
if (nVolume == undefined) {
nVolume = 1;

}

var iCubeFlags=this._iCubeFlags;
if (!((this._iFlags & (1 << 1)) != 0)) {
iCubeFlags = 1;

}

if ((this._eFormat) == eFormat) {
return 1;

}

if ((this._eFormat) == (32864)) {
if (eFormat == (6407)) {
for (k = 0; k < nVolume; k++) {
for (l = 0; l < 6; l++) {
if ((iCubeFlags & (1 << ((0) + l))) != 0) {
for (var m=0; m < nMipMap; m++) {
iLength = this._pData[k][l][b].length;
pNewBuffer = new Uint8Array(this._pData[k][l][b]);
for (var b=0; b < iLength; b += 3) {
iColor1 = pNewBuffer[b];
pNewBuffer[b] = pNewBuffer[b + 2];
pNewBuffer[b + 2] = iColor1;

}


}


}


}


}

this._eFormat = 6407;
return 1;

}
else if (eFormat == (6408)) {
pNewData = new Array(nVolume);
for (k = 0; k < nVolume; k++) {
pNewData[k] = new Array(6);
for (l = 0; l < 6; l++) {
if ((iCubeFlags & (1 << ((0) + l))) != 0) {
pNewData[k][l] = new Array(nMipMap);
for (var m=0; m < nMipMap; m++) {
iLength = this._pData[k][l][m].length;
pNewData[k][l][m] = new ArrayBuffer((iLength * 4) / 3);
pNewBuffer = new Uint8Array(pNewData[k][l][m]);
pOldBuffer = new Uint8Array(this._pData[k][l][m]);
for (var b=0, d=0; b < iLength; b += 3, d += 4) {
pNewBuffer[d] = pOldBuffer[b + 2];
pNewBuffer[d + 1] = pOldBuffer[b + 1];
pNewBuffer[d + 2] = pOldBuffer[b];
pNewBuffer[d + 3] = 256;

}


}


}


}


}

this._pData = pNewData;
this._eFormat = 6408;
return 1;

}
else if (eFormat == (6409)) {
pNewData = new Array(nVolume);
for (k = 0; k < nVolume; k++) {
pNewData[k] = new Array(6);
for (l = 0; l < 6; l++) {
if ((iCubeFlags & (1 << ((0) + l))) != 0) {
pNewData[k][l] = new Array(nMipMap);
for (var m=0; m < nMipMap; m++) {
iLength = this._pData[k][l][m].length;
pNewData[k][l][m] = new ArrayBuffer((iLength * 4) / 3);
pNewBuffer = new Uint8Array(pNewData[k][l][m]);
pOldBuffer = new Uint8Array(this._pData[k][l][m]);
for (var b=0, d=0; b < iLength; b += 3, d += 4) {
pNewBuffer[d] = pOldBuffer[b];
pNewBuffer[d + 1] = pOldBuffer[b + 1];
pNewBuffer[d + 2] = pOldBuffer[b + 2];
pNewBuffer[d + 3] = 256;

}


}


}


}


}

this._pData = pNewData;
this._eFormat = 6409;
return 1;

}
else if (eFormat == (32854)) {
pNewData = new Array(nVolume);
for (k = 0; k < nVolume; k++) {
pNewData[k] = new Array(6);
for (l = 0; l < 6; l++) {
if ((iCubeFlags & (1 << ((0) + l))) != 0) {
pNewData[k][l] = new Array(nMipMap);
for (var m=0; m < nMipMap; m++) {
iLength = this._pData[k][l][m].length;
pOldBuffer = new Uint8Array(this._pData[k][l][m]);
pNewData[k][l][m] = new ArrayBuffer((iLength * 2) / 3);
pNewBuffer = new Uint16Buffer(pNewData[k][l][m]);
for (var b=0, d=0; b < iLength; b += 3, d += 1) {
pNewBuffer[d] = 0;
pNewBuffer[d] |= ((pOldBuffer[b + 2]) / 16) << 12;
pNewBuffer[d] |= ((pOldBuffer[b + 1]) / 16) << 8;
pNewBuffer[d] |= ((pOldBuffer[b]) / 16) << 4;
pNewBuffer[d] |= 15;

}


}


}


}


}

this._pData = pNewData;
this._eFormat = 32854;
return 1;

}
else  {
if (!0) {
var err=((((((("Error:: " + (((("Перевод из формата " + (this._eFormat)) + " в ") + eFormat) + " не поддерживается")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((((("Перевод из формата " + (this._eFormat)) + " в ") + eFormat) + " не поддерживается"));

}


}

;
return 0;

}





}
else if (((((((this._eFormat) == (33779)) || ((this._eFormat) == (33781))) || ((this._eFormat) == (33778))) || ((this._eFormat) == (33780))) || ((this._eFormat) == (33777))) || ((this._eFormat) == (33776))) {
if (eFormat == (6408)) {
pNewData = new Array(nVolume);
for (k = 0; k < nVolume; k++) {
pNewData[k] = new Array(6);
for (l = 0; l < 6; l++) {
if ((iCubeFlags & (1 << ((0) + l))) != 0) {
pNewData[k][l] = new Array(nMipMap);
for (var m=0; m < nMipMap; m++) {
iHeight = this.getHeight(m, l, k);
iWidth = this.getWidth(m, l, k);
iLength = (iWidth * iHeight) * 4;
pNewData[k][l][m] = new ArrayBuffer(iLength);
pNewBuffer = new Uint8Array(pNewData[k][l][m]);
for (var y=0; y < iHeight; y++) {
for (var x=0; x < iWidth; x++) {
iOffset = ((y * iWidth) + x) * 4;
this._getPixelRGBA(x, y, pPixel, m, l, k);
pNewBuffer[iOffset + 0] = pPixel[0];
pNewBuffer[iOffset + 1] = pPixel[1];
pNewBuffer[iOffset + 2] = pPixel[2];
pNewBuffer[iOffset + 3] = pPixel[3];

}


}


}


}


}


}

this._pData = pNewData;
this._eFormat = 6408;
return 1;

}

if (eFormat == (6407)) {
var iHeight;
var iWidth;
pNewData = new Array(nVolume);
for (k = 0; k < nVolume; k++) {
pNewData[k] = new Array(6);
for (l = 0; l < 6; l++) {
if ((iCubeFlags & (1 << ((0) + l))) != 0) {
pNewData[k][l] = new Array(nMipMap);
for (var m=0; m < nMipMap; m++) {
iHeight = this.getHeight(m, l, k);
iWidth = this.getWidth(m, l, k);
iLength = (iWidth * iHeight) * 3;
pNewData[k][l][m] = new ArrayBuffer(iLength);
pNewBuffer = new Uint8Array(pNewData[k][l][m]);
for (var y=0; y < iHeight; y++) {
for (var x=0; x < iWidth; x++) {
iOffset = ((y * iWidth) + x) * 3;
this._getPixelRGBA(x, y, pPixel, m, l, k);
pNewBuffer[iOffset + 0] = pPixel[0];
pNewBuffer[iOffset + 1] = pPixel[1];
pNewBuffer[iOffset + 2] = pPixel[2];

}


}


}


}


}


}

this._pData = pNewData;
this._eFormat = 6407;
return 1;

}
else  {
if (!0) {
var err=((((((("Error:: " + (((("Перевод из формата " + (this._eFormat)) + " в ") + eFormat) + " не поддерживается")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((((("Перевод из формата " + (this._eFormat)) + " в ") + eFormat) + " не поддерживается"));

}


}

;
return 0;

}


}


if (!0) {
var err=((((((("Error:: " + (((("Перевод из формата " + (this._eFormat)) + " в ") + eFormat) + " не поддерживается")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((((("Перевод из формата " + (this._eFormat)) + " в ") + eFormat) + " не поддерживается"));

}


}

;
return 0;

};
Img.prototype.setPixelRGBA = function(iX, iY, pPixel, iMipLevel, eCubeFlag, iVolumeLevel) {
if (iMipLevel == undefined) {
iMipLevel = 0;

}
else  {
if (!(this._iFlags & (1 << 2)) != 0) {
var err=((((((("Error:: " + "Запрашиваются мипмапы, а их нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашиваются мипмапы, а их нет");

}


}

;
if (!(iMipLevel < (this.getMipMapLevels()))) {
var err=((((((("Error:: " + "Запрашивается мипмап, которого нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается мипмап, которого нет");

}


}

;

}

if (eCubeFlag == undefined) {
if (!(!((this._iFlags & (1 << 1)) != 0))) {
var err=((((((("Error:: " + "Не выставлена часть кубической картинки") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Не выставлена часть кубической картинки");

}


}

;
eCubeFlag = 0;

}
else  {
if (!(this._iFlags & (1 << 1)) != 0) {
var err=((((((("Error:: " + "Выставлена часть кубической куртинки, хотя картинка не является кубической") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Выставлена часть кубической куртинки, хотя картинка не является кубической");

}


}

;
if (!(this._iCubeFlags & (1 << eCubeFlag)) != 0) {
var err=((((((("Error:: " + "Запрашивается часть кубической текстуры которой нет, которого нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается часть кубической текстуры которой нет, которого нет");

}


}

;

}

if (iVolumeLevel == undefined) {
iVolumeLevel = 0;

}
else  {
if (!(this._iFlags & (1 << 0)) != 0) {
var err=((((((("Error:: " + "Запрашивается часть объемной картинки, а картинка не объемная") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается часть объемной картинки, а картинка не объемная");

}


}

;
if (!(iVolumeLevel < (this.getVolumeLevels()))) {
var err=((((((("Error:: " + "Запрашивается часть объемной картинки, которой нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается часть объемной картинки, которой нет");

}


}

;

}

return this._setPixelRGBA(iX, iY, pPixel, iMipLevel, eCubeFlag, iVolumeLevel);

};
Img.prototype._setPixelRGBA = function(iX, iY, pPixel, iMipLevel, eCubeFlag, iVolumeLevel) {
var iOffset;
var pColor;
var iOffset;
if ((this._eFormat) == (6409)) {
iOffset = ((iY * (this._iWidth)) + iX) * (this.getBlockBytes());
pColor = new Uint32Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1);
pColor[0] = 0;
pColor[0] |= (pPixel[0]) << 16;
pColor[0] |= (pPixel[1]) << 8;
pColor[0] |= pPixel[2];
pColor[0] |= (pPixel[3]) << 24;

}
else if ((this._eFormat) == (6408)) {
iOffset = ((iY * (this._iWidth)) + iX) * (this.getBlockBytes());
pColor = new Uint32Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1);
pColor[0] = 0;
pColor[0] |= pPixel[0];
pColor[0] |= (pPixel[1]) << 8;
pColor[0] |= (pPixel[2]) << 16;
pColor[0] |= (pPixel[3]) << 24;

}
else if ((this._eFormat) == (32856)) {
iOffset = ((iY * (this._iWidth)) + iX) * (this.getBlockBytes());
pColor = new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1);
pColor = 0;
pColor |= ([0]((pPixel[0]) / 7)) << 10;
pColor |= ([0]((pPixel[1]) / 7)) << 5;
pColor |= [0]((pPixel[2]) / 7);
pColor |= ([0]((pPixel[3]) / 255)) << 15;

}
else if ((this._eFormat) == (32855)) {
iOffset = ((iY * (this._iWidth)) + iX) * (this.getBlockBytes());
pColor = new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1);
pColor[0] = 0;
pColor[0] |= (pPixel[0]) / 7;
pColor[0] |= ((pPixel[1]) / 7) << 5;
pColor[0] |= ((pPixel[2]) / 7) << 10;
pColor[0] |= ((pPixel[3]) / 255) << 15;

}
else if ((this._eFormat) == (32857)) {
iOffset = ((iY * (this._iWidth)) + iX) * (this.getBlockBytes());
pColor = new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1);
pColor[0] = 0;
pColor[0] |= ((pPixel[0]) / 15) << 8;
pColor[0] |= ((pPixel[1]) / 15) << 4;
pColor[0] |= (pPixel[2]) / 15;
pColor[0] |= ((pPixel[3]) / 15) << 12;

}
else if ((this._eFormat) == (32854)) {
iOffset = ((iY * (this._iWidth)) + iX) * (this.getBlockBytes());
pColor = new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1);
pColor[0] = 0;
pColor[0] |= (pPixel[0]) / 15;
pColor[0] |= ((pPixel[1]) / 15) << 4;
pColor[0] |= ((pPixel[2]) / 15) << 8;
pColor[0] |= ((pPixel[3]) / 15) << 12;

}
else if ((this._eFormat) == (6407)) {
iOffset = ((iY * (this._iWidth)) + iX) * (this.getBlockBytes());
pColor = new Uint8Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 3);
pColor[0] = pPixel[0];
pColor[1] = pPixel[1];
pColor[2] = pPixel[2];

}
else if ((this._eFormat) == (32864)) {
iOffset = ((iY * (this._iWidth)) + iX) * (this.getBlockBytes());
pColor = new Uint8Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 3);
pColor[2] = pPixel[2];
pColor[1] = pPixel[1];
pColor[0] = pPixel[0];

}
else if ((this._eFormat) == (36195)) {
iOffset = ((iY * (this._iWidth)) + iX) * (this.getBlockBytes());
pColor = new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1);
pColor[0] = 0;
pColor[0] |= ((pPixel[0]) / 7) << 11;
pColor[0] |= ((pPixel[1]) / 3) << 5;
pColor[0] |= (pPixel[2]) / 7;

}
else if ((this._eFormat) == (36194)) {
iOffset = ((iY * (this._iWidth)) + iX) * (this.getBlockBytes());
pColor = new Uint16Array(this._pData[iVolumeLevel][eCubeFlag][iMipLevel], iOffset, 1);
pColor[0] = 0;
pColor[0] |= (pPixel[0]) / 7;
pColor[0] |= ((pPixel[1]) / 3) << 5;
pColor[0] |= ((pPixel[2]) / 7) << 11;

}
else  {
if (!0) {
var err=((((((("Error:: " + "Установка цвета в такой формат не поддерживается") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Установка цвета в такой формат не поддерживается");

}


}

;

}











};
Img.prototype.generatePerlinNoise = function(fScale, iOctaves, fFalloff) {
var pPerlin=new PerlinNoise();
var pColor=new Uint8Array(4);
if (!((this._pData) != null)) {
var err=((((((("Error:: " + "Картинка еще не cоздана") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Картинка еще не cоздана");

}


}

;
if (!((this._iFlags) == 0)) {
var err=((((((("Error:: " + "Картинка не является простой") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Картинка не является простой");

}


}

;
for (var y=0; y < (this.getHeight()); y++) {
for (var x=0; x < (this.getWidth()); x++) {
var fX=x;
var fY=y;
var fAccum=0;
var fFrequency=fScale;
var fAmplitude=1;
for (var i=0; i < iOctaves; ++i) {
fAccum += (pPerlin.noise(fX, fY, fFrequency)) * fAmplitude;
fAmplitude *= fFalloff;
fFrequency *= 2;

}

fAccum = Math.max((-1), Math.min(fAccum, 1));
fAccum *= 0.5;
fAccum += 0.5;
fAccum *= 255;
pColor[0] = fAccum;
pColor[1] = fAccum;
pColor[2] = fAccum;
pColor[3] = 255;
this._setPixelRGBA(x, y, pColor, 0, 0, 0);

}


}


};
Img.prototype.randomChannelNoise = function(iChannel, iMinRange, iMaxRange) {
if (!(iChannel < 4)) {
var err=((((((("Error:: " + "invalid image channel") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid image channel");

}


}

;
if (!((this._pData) != null)) {
var err=((((((("Error:: " + "Картинка еще не cоздана") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Картинка еще не cоздана");

}


}

;
if (!((this._iFlags) == 0)) {
var err=((((((("Error:: " + "Картинка не является простой") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Img.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Картинка не является простой");

}


}

;
var pColor=new Uint8Array(4);
var iNoise;
var iHeight=this.getHeight();
var iWidth=this.getWidth();
for (var y=0; y < iHeight; y++) {
for (var x=0; x < iWidth; x++) {
this._getPixelRGBA(x, y, pColor, 0, 0, 0);
iNoise = iMinRange + ((Math.random()) * (iMaxRange - iMinRange));
pColor[iChannel] = iNoise;
this._setPixelRGBA(x, y, pColor, 0, 0, 0);

}


}


};
a.Img = Img;
function Texture(pEngine) {
var _pCtorValue=Texture.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pDevice = pEngine.pDevice;
this._iFlags = 0;
this._pTexture = null;
this._pFrameBuffer = null;
this._pTextureParams =  {};
this._iWidth = 0;
this._iHeight = 0;
this._eFormat = 6408;
this._eType = 5121;
this._iSlot = -1;
this._pEngine = pEngine;
this._pRepackTexture = null;
this._pSystemVertexDataTexture = null;
this._isTextureChanged = false;
this._initSystemStorageTexture(pEngine);

}

a.extend(Texture, a.ResourcePoolItem, a.RenderableObject);
a.defineProperty(Texture, "texture", function() {
return this._pTexture;

}
);
a.defineProperty(Texture, "height", function() {
if (this._pTexture) {
return this._iHeight;

}

return 0;

}
, function(iValue) {
this.resize(this._iWidth, iValue);

}
);
a.defineProperty(Texture, "width", function() {
if (this._pTexture) {
return this._iWidth;

}

return 0;

}
, function(iValue) {
this.resize(iValue, this.height);

}
);
a.defineProperty(Texture, "typeSize", function() {
return a.getTypeSize(this._eType);

}
);
a.defineProperty(Texture, "numElementsPerPixel", function() {
return a.getIFormatNumElements(this._eFormat);

}
);
a.defineProperty(Texture, "type", function() {
return this._eType;

}
, function(eValue) {
if (this._pTexture) {
this.repack(this._iWidth, this._iHeight, this.format, eValue);

}

this._eType = eValue;

}
);
a.defineProperty(Texture, "format", function() {
return this._eFormat;

}
, function(eValue) {
if (this._pTexture) {
this.repack(this._iWidth, this._iHeight, eValue, this.type);

}

this._eFormat = eValue;

}
);
a.defineProperty(Texture, "magFilter", function() {
return this._getParameter(10240);

}
, function(eValue) {
this.applyParameter(10240, eValue);

}
);
a.defineProperty(Texture, "minFilter", function() {
return this._getParameter(10241);

}
, function(eValue) {
this.applyParameter(10241, eValue);

}
);
a.defineProperty(Texture, "wraps", function() {
return this._getParameter(10242);

}
, function(eValue) {
this.applyParameter(10242, eValue);

}
);
a.defineProperty(Texture, "wrapt", function() {
return this._getTexParameter(10243);

}
, function(eValue) {
this.applyParameter(10243, eValue);

}
);
a.defineProperty(Texture, "target", function() {
return ((this._iFlags & (1 << 1)) != 0? 34067 : 3553);

}
);
Texture.prototype._initSystemStorageTexture = function(pEngine) {
this._pEngine = pEngine;
var pBuffer, pData, pMethod;
if (pEngine._pSystemVertexDataTexture) {
this._pSystemVertexDataTexture = pEngine._pSystemVertexDataTexture;
pMethod = pEngine.pDisplayManager.renderMethodPool().findResource(".repack_texture");
this.addRenderMethod(pMethod, ".repack_texture");
return true;

}

pBuffer = pEngine.pDisplayManager.vertexBufferPool().createResource(".VERTEXBUFFER_TEX");
if (!pBuffer.create(0, 1 << 3)) {
var err=((((((("Error:: " + "Cannot create system vertex buffer") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Cannot create system vertex buffer");

}


}

;
pData = pBuffer.getEmptyVertexData(0, [new Object( {nCount: 1, eType: 5126, eUsage: "SERIALNUMBER", iOffset: undefined})]);
pEngine._pSystemVertexDataTexture = this._pSystemVertexDataTexture = pData;
pMethod = pEngine.pDisplayManager.renderMethodPool().createResource(".repack_texture");
this.addRenderMethod(pMethod, ".repack_texture");
this._setSystemEffect();
return true;

};
Texture.prototype._setSystemEffect = function() {
var pEngine=this._pEngine;
var pEffect;
if (pEngine.displayManager().componentPool().findResource("akra.system.texture_repack")) {
trace("Texture.prototype._setSystemEffect----------------->>>>");
pEffect = pEngine.pDisplayManager.effectPool().createResource(".repack_texture");
pEffect.create();
pEffect.use("akra.system.texture_repack");
this.switchRenderMethod(".repack_texture");
this._pActiveSnapshot.method.effect = pEffect;
return true;

}

return false;

};
Texture.prototype.flipY = function(bValue) {
this._pDevice.pixelStorei(37440, (bValue === undefined? true : bValue));

};
Texture.prototype._getParameter = function(eName) {
return this._pTextureParams[eName];

};
Texture.prototype.applyParameter = function(eParam, eValue) {
var pDevice=this._pDevice;
if (this._pTexture) {
var eTarget=this.target;
this._pEngine.shaderManager().bindTexture(this);
pDevice.texParameteri(eTarget, eParam, eValue);
this._pTextureParams[eParam] = eValue;

}


};
Texture.prototype._hasParams = function(pParams) {
return ((((this._getParameter(10240)) === (pParams[10240])) && ((this._getParameter(10241)) === (pParams[10241]))) && ((this._getParameter(10242)) === (pParams[10242]))) && ((this._getParameter(10243)) === (pParams[10243]));

};
Texture.prototype.isCubeTexture = function() {
return (this._iFlags & (1 << 1)) != 0;

};
Texture.prototype.is2DTexture = function() {
return !((this._iFlags & (1 << 1)) != 0);

};
Texture.prototype.isCompressed = function() {
return ((this._eFormat) >= (33776)) && ((this._eFormat) <= (33781));

};
Texture.prototype.getMipLevels = function() {
if ((this._iFlags & (1 << 2)) != 0) {
return (Math.ceil(Math.max((Math.log(this._iWidth)) / (Math.LN2), (Math.log(this._iHeight)) / (Math.LN2)))) + 1;

}
else  {
return undefined;

}


};
Texture.prototype.getPixelRGBA = function(iX, iY, iWidth, iHeight, pPixel, iMipMap, eCubeFlag) {
var pDevice=this._pEngine.pDevice;
if ((!((this._iFlags & (1 << 2)) != 0)) && (iMipMap != undefined)) {
if (!0) {
var err=((((((("Error:: " + "Запрашивается уровень мип мапа, хотя текстура их не содрежит") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается уровень мип мапа, хотя текстура их не содрежит");

}


}

;

}

if (iMipMap == undefined) {
iMipMap = 0;

}

if ((this._iFlags & (1 << 2)) != 0) {
if (!(iMipMap < (Math.ceil((Math.max((Math.log(this._iWidth)) / (Math.LN2), (Math.log(this._iHeight)) / (Math.LN2))) + 1)))) {
var err=((((((("Error:: " + "Запрашивается уровень мип мапа, которого нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается уровень мип мапа, которого нет");

}


}

;

}

if ((this._pFrameBuffer) && (this._pTexture)) {
pDevice.bindFramebuffer(36160, this._pFrameBuffer);
if (this.isCubeTexture()) {
if (!(eCubeFlag != undefined)) {
var err=((((((("Error:: " + "тип текстуры кубическая,а eCubeFlag - undefined") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("тип текстуры кубическая,а eCubeFlag - undefined");

}


}

;
pDevice.framebufferTexture2D(36160, 36064, eCubeFlag, this._pTexture, iMipMap);

}
else  {
if (!(eCubeFlag == undefined)) {
var err=((((((("Error:: " + "тип текстуры 2D,а eCubeFlag выставлен") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("тип текстуры 2D,а eCubeFlag выставлен");

}


}

;
pDevice.framebufferTexture2D(36160, 36064, 3553, this._pTexture, iMipMap);

}

pDevice.readPixels(iX, iY, iWidth, iHeight, 6408, 5121, pPixel);
pDevice.bindFramebuffer(36160, null);
return pPixel;

}
else  {
return null;

}


};
Texture.prototype.setPixelRGBA = function(iX, iY, iWidth, iHeight, pPixel, iMipMap, eCubeFlag) {
iMipMap = iMipMap || 0;
eCubeFlag = eCubeFlag || 0;
var pDevice=this._pEngine.pDevice;
var pRenderer=this._pEngine.shaderManager();
if (!(!((!((this._iFlags & (1 << 2)) != 0)) && iMipMap))) {
var err=((((((("Error:: " + "Запрашивается уровень мип мапа, хотя текстура их не содрежит") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается уровень мип мапа, хотя текстура их не содрежит");

}


}

;
if ((this._iFlags & (1 << 2)) != 0) {
if (!(iMipMap < (Math.ceil((Math.max((Math.log(this._iWidth)) / (Math.LN2), (Math.log(this._iHeight)) / (Math.LN2))) + 1)))) {
var err=((((((("Error:: " + "Запрашивается уровень мип мапа, которого нет") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Запрашивается уровень мип мапа, которого нет");

}


}

;

}

if ((this._pTexture) === null) {
return false;

}

if (this.isCubeTexture()) {
if (!(eCubeFlag != undefined)) {
var err=((((((("Error:: " + "тип текстуры кубическая,а eCubeFlag - undefined") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("тип текстуры кубическая,а eCubeFlag - undefined");

}


}

;
pRenderer.bindTexture(this);
pDevice.texSubImage2D(eCubeFlag, iMipMap, iX, iY, iWidth, iHeight, this._eFormat, this._eType, pPixel);

}
else  {
pRenderer.bindTexture(this);
if (this.isCompressed()) {
pDevice.compressedTexSubImage2D(3553, iMipMap, iX, iY, iWidth, iHeight, this._eFormat, pPixel);

}
else  {
pDevice.texSubImage2D(3553, iMipMap, iX, iY, iWidth, iHeight, this._eFormat, this._eType, pPixel);

}


}

return true;

};
Texture.prototype.createResource = function() {
if (!(!(this.isResourceCreated()))) {
var err=((((((("Error:: " + "The resource has already been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has already been created.");

}


}

;
this.notifyCreated();
this.notifyDisabled();
return true;

};
Texture.prototype.releaseTexture = function() {
var pDevice=this._pEngine.pDevice;
if (this._pTexture) {
pDevice.deleteTexture(this._pTexture);

}

if (this._pFrameBuffer) {
pDevice.deleteFramebuffer(this._pFrameBuffer);

}

this._pTexture = null;
this._pFrameBuffer = null;

};
Texture.prototype.generateNormalMap = function(pHeightMap, iChannel, fAmplitude) {
var pDevice=this._pEngine.pDevice;
var pRenderer=this._pEngine.shaderManager();
this.releaseTexture();
this._pTexture = pDevice.createTexture();
this._pFrameBuffer = pDevice.createFramebuffer();
this._iWidth = pHeightMap.getWidth();
this._iHeight = pHeightMap.getHeight();
pRenderer.bindTexture(this);
pDevice.texImage2D(3553, 0, 6408, this._iWidth, this._iHeight, 0, 6408, 5121, null);
var pColor=new Uint8Array(((this._iWidth) * (this._iHeight)) * 4);
var pNormalTable=new Array((this._iWidth) * (this._iHeight));
for (var i=0; i < ((this._iWidth) * (this._iHeight)); i++) {
pNormalTable[i] = Vec3.create();

}

a.computeNormalMap(pDevice, pHeightMap, pNormalTable, iChannel, fAmplitude, 4);
var iIndex;
var iOffset;
for (var y=0; y < (this.height); y++) {
for (var x=0; x < (this._iWidth); x++) {
iIndex = (y * (this._iWidth)) + x;
iOffset = iIndex * 4;
pColor[iOffset + 0] = pNormalTable[iIndex][0];
pColor[iOffset + 1] = pNormalTable[iIndex][1];
pColor[iOffset + 2] = pNormalTable[iIndex][2];
pColor[iOffset + 3] = 255;

}


}

this.setPixelRGBA(0, 0, this._iWidth, this._iHeight, pColor);

};
Texture.prototype.generateNormalizationCubeMap = function() {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture::generateNormalizationCubeMap()"));
throw new Error("TODO::\n" + "Texture::generateNormalizationCubeMap()");

};
Texture.prototype.maskWithImage = function(pImage) {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture::maskWithImage()"));
throw new Error("TODO::\n" + "Texture::maskWithImage()");

};
Texture.prototype.convertToNormalMap = function(iChannel, iFlags, fAmplitude) {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture::convertToNormalMap()"));
throw new Error("TODO::\n" + "Texture::convertToNormalMap()");

};
Texture.prototype.getSurfaceLevel = function(iLevel, ppSurface) {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture::getSurfaceLevel()"));
throw new Error("TODO::\n" + "Texture::getSurfaceLevel()");

};
Texture.prototype._loadFromResourceFile = function(InputFile) {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture::_loadFromResourceFile()"));
throw new Error("TODO::\n" + "Texture::_loadFromResourceFile()");

};
Texture.prototype._checkCubeTextureRequirements = function() {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture::_checkCubeTextureRequirements()"));
throw new Error("TODO::\n" + "Texture::_checkCubeTextureRequirements()");

};
Texture.prototype.destroyResource = function() {
if (this.isResourceCreated()) {
this.disableResource();
this.releaseTexture();
this.notifyUnloaded();
this.notifyDestroyed();
return true;

}

return false;

};
Texture.prototype.restoreResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyRestored();
return true;

};
Texture.prototype.disableResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyDisabled();
return true;

};
Texture.prototype._checkTextureRequirements = function(iWidth, iHeight, iMipLevels, eFormat) {
return true;

};
Texture.prototype._loadTextureFromMemory = function(pMemory) {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture::_loadTextureFromMemory()"));
throw new Error("TODO::\n" + "Texture::_loadTextureFromMemory()");

};
Texture.prototype._loadCubeTextureFromImageFile = function(sFilename) {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture::_loadCubeTextureFromImageFile()"));
throw new Error("TODO::\n" + "Texture::_loadCubeTextureFromImageFile()");

};
Texture.prototype._loadCubeTextureFromMemory = function(pMemory) {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture::_loadCubeTextureFromMemory()"));
throw new Error("TODO::\n" + "Texture::_loadCubeTextureFromMemory()");

};
Texture.prototype.loadResource = function(sFileName) {
if (!sFileName) {
var sResourceName=this.findResourceName();
if (sResourceName) {
sFileName = sResourceName;

}


}

var me=this;
if ((sFileName.nodeName) && ((((sFileName.nodeName.toLowerCase()) == "canvas") || ((sFileName.nodeName.toLowerCase()) == "img")) || ((sFileName.nodeName.toLowerCase()) == "video"))) {
me.uploadHTMLElement(sFileName);
return true;

}
else if ((sExt = a.pathinfo(sFileName).ext) && ((((sExt == "bmp") || (sExt == "jpeg")) || (sExt == "gif")) || (sExt == "png"))) {
var pImage=new Image();
pImage.onload = function() {
me.uploadHTMLElement(pImage);

};
pImage.src = sFileName;
return true;

}
else  {
var pImage=new a.Img(this._pEngine);
pImage.load(sFileName, function() {
me.uploadImage(pImage);

}
);
return true;

}



};
Texture.prototype.saveResource = function(sFilename) {
var pBaseTexture;
var isOk;
if (!sFilename) {
var pString=this.findResourceName();
if (pString) {
sFilename = pString;

}


}

pBaseTexture = this._pTexture;
isOk = false;
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture::saveResource()"));
throw new Error("TODO::\n" + "Texture::saveResource()");
return isOk;

};
Texture.prototype.uploadCubeFace = function(pImage, eFace, isCopyAll) {
isCopyAll = isCopyAll || true;
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture::uploadCubeFace()"));
throw new Error("TODO::\n" + "Texture::uploadCubeFace()");

};
Texture.prototype.uploadHTMLElement = function(pElement) {
var pDevice=this._pEngine.pDevice;
this.releaseTexture();
this._pTexture = pDevice.createTexture();
this._pFrameBuffer = pDevice.createFramebuffer();
this._iWidth = pElement.width;
this._iHeight = pElement.height;
this._eFormat = 6408;
this._eType = 5121;
if ((pElement.nodeName.toLowerCase()) == "video") {
this._iFlags |= 1 << 5;

}

this._pEngine.shaderManager().bindTexture(this);
this.flipY();
pDevice.texImage2D(3553, 0, this._eFormat, this._eFormat, this._eType, pElement);
this.applyParameter(10241, 9729);
this.applyParameter(10240, 9729);
this.applyParameter(10242, 10497);
this.applyParameter(10243, 10497);
this.flipY(false);
this.notifyLoaded();
this.notifyRestored();

};
Texture.prototype.uploadImage = function(pImage) {
var pDevice=this._pEngine.pDevice;
var nMipMaps;
var iCubeFlags;
var pRenderer=this._pEngine.shaderManager();
this.releaseTexture();
this._pTexture = pDevice.createTexture();
this._pFrameBuffer = pDevice.createFramebuffer();
if (!(a.info.graphics.checkFormat(pDevice, pImage.getFormat()))) {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + "Формат не поддерживается, происходит переконвертация");
pImage.convert(6408);

}

this._iWidth = pImage.getWidth();
this._iHeight = pImage.getHeight();
this._eFormat = pImage.getFormatShort();
this._eType = pImage.getType();
nMipMaps = pImage.getMipLevels();
if ((nMipMaps == undefined) || (nMipMaps != ((Math.ceil(Math.max((Math.log(this._iWidth)) / (Math.LN2), (Math.log(this._iHeight)) / (Math.LN2)))) + 1))) {
this._iFlags &= ~(1 << 2);
nMipMaps = 1;

}
else  {
this._iFlags |= 1 << 2;

}

iCubeFlags = pImage.getCubeFlags();
if ((iCubeFlags == undefined) || (iCubeFlags != ((((((1 << 0) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)))) {
this._iFlags &= ~(1 << 1);
pRenderer.bindTexture(this);
this.flipY();
for (var i=0; i < nMipMaps; i++) {
if (!(pImage.isCompressed())) {
pDevice.texImage2D(3553, i, this._eFormat, pImage.getWidth(i), pImage.getHeight(i), 0, this._eFormat, this._eType, new Uint8Array(pImage.getData(i)));

}
else  {
pDevice.compressedTexImage2D(3553, i, this._eFormat, pImage.getWidth(i), pImage.getHeight(i), 0, new Uint8Array(pImage.getData(i)));

}


}


}
else  {
this._iFlags |= 1 << 1;
pRenderer.bindTexture(this);
this.flipY();
for (var k=0; k < 6; k++) {
for (var i=0; i < nMipMaps; i++) {
if (!(pImage.isCompressed())) {
pDevice.texImage2D((34069) + k, i, this._eFormat, pImage.getWidth(i), pImage.getHeight(i), 0, this._eFormat, this._eType, new Uint8Array(pImage.getData(i, k)));

}
else  {
pDevice.compressedTexImage2D((34069) + k, i, this._eFormat, pImage.getWidth(i), pImage.getHeight(i), 0, new Uint8Array(pImage.getData(i, k)));

}


}


}


}

if (((this._iFlags & (1 << 2)) != 0) && (((this.minFilter) == (9729)) || ((this.minFilter) == (9728)))) {
this.applyParameter(10241, 9987);

}
else if (((!((this._iFlags & (1 << 2)) != 0)) && ((this.minFilter) != (9729))) && ((this.minFilter) != (9728))) {
this.applyParameter(10241, ((Math.floor((this.minFilter) - (9984))) / 2) + (9728));

}


this.applyParameter(10240, 9729);
this.applyParameter(10242, 10497);
this.applyParameter(10243, 10497);
this.flipY(false);
this.notifyLoaded();
this.notifyRestored();

};
Texture.prototype.resize = function(iWidth, iHeight) {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture:: resize with scale"));
throw new Error("TODO::\n" + "Texture:: resize with scale");
return false;

};
Texture.prototype.extend = function(iWidth, iHeight) {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "extend texture"));
throw new Error("TODO::\n" + "extend texture");
return false;

};
Texture.prototype.repack = function(iWidth, iHeight, eFormat, eType) {
;
if (!this._pTexture) {
var err=((((((("Error:: " + "Cannot repack, because texture not created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Cannot repack, because texture not created.");

}


}

;
trace("REPACK TEXTURE #" + (this.toNumber()));
eFormat = eFormat || (this._eFormat);
eType = eType || (this._eType);
var pDevice=this._pEngine.pDevice;
var pRenderer=this._pEngine.shaderManager();
if (!(this._pRepackTexture)) {
this._pRepackTexture = this._pEngine.displayManager().texturePool().createResource(".DuplicateTexture" + (a.sid()));

}

var pDestinationTexture=this._pRepackTexture;
pDestinationTexture.createTexture(iWidth, iHeight, 0, eFormat, eType, [null]);
pDestinationTexture.applyParameter(10242, 33071);
pDestinationTexture.applyParameter(10243, 33071);
pDestinationTexture.applyParameter(10240, 9728);
pDestinationTexture.applyParameter(10241, 9728);
this.switchRenderMethod(".repack_texture");
var pVertexData=this._pSystemVertexDataTexture;
var nCount=(this._iWidth) * (this._iHeight);
var pRenderIndexData=new Float32Array(nCount);
for (var i=0; i < nCount; i++) {
pRenderIndexData[i] = i;

}

pVertexData.resize(nCount);
pVertexData.setData(pRenderIndexData, "SERIALNUMBER");
var pSnapshot=this._pActiveSnapshot;
var pEntry=null;
trace("<<<<<<<<<<<<<TEXTURE REPACK RENDER>>>>>>>>>>>>>>>>");
pRenderer.setViewport(0, 0, iWidth, iHeight);
pRenderer.activateFrameBuffer();
pRenderer.applyFrameBufferTexture(pDestinationTexture);
this.startRender();
for (var i=0; i < (this.totalPasses()); i++) {
trace("Pass #" + i);
this.activatePass(i);
pSnapshot.applyTextureBySemantic("TEXTURE0", this);
pSnapshot.applyVertexData(pVertexData, 0);
pSnapshot.setParameter("sourceTextureSize", [this._iWidth, this._iHeight]);
pSnapshot.setParameter("destinationTextureSize", [iWidth, iHeight]);
pEntry = this.renderPass();
this.deactivatePass();

}

this.finishRender();
pRenderer.deactivateFrameBuffer();
pRenderer.render(pEntry);
pDevice.flush();
trace("<<<<<<<<<<<<<END_TEXTURE REPACK RENDER>>>>>>>>>>>>>>>>");
this.releaseTexture();
this._pTexture = pDestinationTexture._pTexture;
pDestinationTexture._pTexture = null;
this._isTextureChanged = true;
pDestinationTexture._isTextureChanged = true;
this._eFormat = eFormat;
this._eType = eType;
this._iWidth = iWidth;
this._iHeight = iHeight;
return true;

};
Texture.prototype.createTexture = function(iWidth, iHeight, eFlags, eFormat, eType, pData) {
var pDevice=this._pEngine.pDevice;
var pRenderer=this._pEngine.shaderManager();
var nMipMaps=1;
this._iWidth = iWidth;
this._iHeight = iHeight;
if (eFlags == undefined) {
eFlags = 0;

}

this.releaseTexture();
this._pTexture = pDevice.createTexture();
this._iFlags = eFlags;
this._eFormat = eFormat || (this._eFormat);
this._eType = eType || (this._eType);
if (!(pData instanceof Array)) {
pData = [pData];

}

pRenderer.bindTexture(this);
pDevice.pixelStorei(pDevice.UNPACK_ALIGNMENT, 1);
if ((eFlags & (1 << 2)) != 0) {
nMipMaps = (Math.ceil(Math.max((Math.log(this._iWidth)) / (Math.LN2), (Math.log(this._iHeight)) / (Math.LN2)))) + 1;

}

if ((eFlags & (1 << 1)) != 0) {
for (var k=0; k < 6; k++) {
for (var i=0; i < nMipMaps; i++) {
pDevice.texImage2D((34069) + k, i, this._eFormat, this._iWidth, this._iHeight, 0, this._eFormat, this._eType, (pData[i]? pData[i] : null));

}


}


}
else  {
if (this.isCompressed()) {
for (var i=0; i < nMipMaps; i++) {
pDevice.compressedTexImage2D(3553, i, this._eFormat, this._iWidth, this._iHeight, 0, (pData[i]? pData[i] : null));

}


}
else  {
for (var i=0; i < nMipMaps; i++) {
pDevice.texImage2D(3553, i, this._eFormat, this._iWidth, this._iHeight, 0, this._eFormat, this._eType, (pData[i]? pData[i] : null));

}


}


}

this.applyParameter(10242, 10497);
this.applyParameter(10243, 10497);
this.applyParameter(10240, 9729);
this.applyParameter(10241, 9729);
this.notifyLoaded();
this.notifyRestored();
return true;

};
Texture.prototype.bind = function() {
;
this._pEngine.pDevice.bindTexture(this.target, this._pTexture);
return true;

};
Texture.prototype.unbind = function() {
this._pEngine.pDevice.bindTexture(this.target, null);

};
Texture.prototype.activate = function() {
var pManager=this._pEngine.pShaderManager;
pManager.activateTexture(this);

};
Texture.prototype.setSlot = function(iSlot) {
this._iSlot = iSlot;

};
Texture.prototype.getSlot = function() {
return this._iSlot;

};
Texture.prototype.createCubeTexture = function(iSize, iMipLevels, eFormat) {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture::createCubeTexture()"));
throw new Error("TODO::\n" + "Texture::createCubeTexture()");

};
Texture.prototype.convertToNormalMap = function(iChannel, iFlags, fAmplitude) {
console.log((((("[DEBUG][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/Texture.js") + "][") + "") + "]") + ("TODO:: " + "Texture::convertToNormalMap()"));
throw new Error("TODO::\n" + "Texture::convertToNormalMap()");

};
Texture.prototype.useAlignment = function() {

};
a.Texture = Texture;
function VBufferBase() {
this._pBuffer = null;
this._pBackupCopy = null;
this._iTypeFlags = 0;
this._pVertexDataArray = new Array();
this._iNextID = 0;

}

;
VBufferBase.prototype.create = function(iByteSize, iFlags, pData) {

};
VBufferBase.prototype.destroy = function() {

};
VBufferBase.prototype.getData = function(iOffset, iSize) {

};
VBufferBase.prototype.setData = function(pData, iOffset, iSize, nCountStart, nCount) {

};
VBufferBase.prototype.resize = function(iSize) {

};
VBufferBase.prototype.getNextID = function() {
return this._iNextID++;

};
VBufferBase.prototype.clone = function(pSrc) {
var isSuccess=false;
this.destroy();
isSuccess = this.create(pSrc.getCount(), pSrc.getStride(), pSrc.getTypeFlags(), pSrc.getData());
return isSuccess;

};
VBufferBase.prototype.isValid = function() {
return ((this._pBuffer) != null? true : false);

};
VBufferBase.prototype.isDynamic = function() {
return ((this._iTypeFlags & (1 << 0)) != 0) && ((this._iTypeFlags & (1 << 1)) != 0);

};
VBufferBase.prototype.isStatic = function() {
return (!((this._iTypeFlags & (1 << 0)) != 0)) && ((this._iTypeFlags & (1 << 1)) != 0);

};
VBufferBase.prototype.isStream = function() {
return (!((this._iTypeFlags & (1 << 0)) != 0)) && (!((this._iTypeFlags & (1 << 1)) != 0));

};
VBufferBase.prototype.isReadable = function() {
return (this._iTypeFlags & (1 << 2)) != 0;

};
VBufferBase.prototype.isRAMBufferPresent = function() {
return ((this._pBackupCopy) != null? true : false);

};
VBufferBase.prototype.isSoftware = function() {
return (this._iTypeFlags & (1 << 4)) != 0;

};
VBufferBase.prototype.isAlignment = function() {
return (this._iTypeFlags & (1 << 5)) != 0;

};
VBufferBase.prototype.getBuffer = function() {
return this._pBuffer;

};
VBufferBase.prototype.getTypeFlags = function() {
return this._iTypeFlags;

};
VBufferBase.prototype.getVertexData = function(iOffset, iCount, pVertexDeclaration) {
pVertexDeclaration = a.normalizeVertexDecl(pVertexDeclaration);
var pVertexData=new a.VertexData(this, iOffset, iCount, pVertexDeclaration);
this._pVertexDataArray.push(pVertexData);
return pVertexData;

};
VBufferBase.prototype.freeVertexData = function(pVertexData) {
if ((arguments.length) == 0) {
for (var i in this._pVertexDataArray) {
this._pVertexDataArray[i].destroy();

}

this._pVertexDataArray = null;

}
else  {
for (var i=0; i < (this._pVertexDataArray.length); i++) {
if ((this._pVertexDataArray[i]) == pVertexData) {
this._pVertexDataArray.splice(i, 1);
return true;

}


}

pVertexData.destroy();
return false;

}


};
VBufferBase.prototype.allocateData = function(pVertexDecl, pData) {
pVertexDecl = a.normalizeVertexDecl(pVertexDecl);
var pVertexData;
var iCount=(pData.byteLength) / (pVertexDecl.stride);
if (!(iCount === (Math.floor(iCount)))) {
var err=((((((("Error:: " + "Data size should be a multiple of the vertex declaration.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VBufferBase.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Data size should be a multiple of the vertex declaration.");

}


}

;
pVertexData = this.getEmptyVertexData(iCount, pVertexDecl);
pVertexData.setData(pData, 0, pVertexDecl.stride);
return pVertexData;

};
VBufferBase.prototype.getEmptyVertexData = function(iCount, pVertexDeclaration, pVertexDataIn) {
while (1) {
var pHole=new Array();
var i;
var pVertexData;
pHole[0] =  {start: 0, end: this.size};
for (var k in this._pVertexDataArray) {
pVertexData = this._pVertexDataArray[k];
for (i = 0; i < (pHole.length); i++) {
if (((pVertexData.getOffset()) > (pHole[i].start)) && (((pVertexData.getOffset()) + (pVertexData.size)) < (pHole[i].end))) {
var iTemp=pHole[i].end;
pHole[i].end = pVertexData.getOffset();
pHole.splice(i + 1, 0,  {start: (pVertexData.getOffset()) + (pVertexData.size), end: iTemp});
i--;

}
else if (((pVertexData.getOffset()) == (pHole[i].start)) && (((pVertexData.getOffset()) + (pVertexData.size)) < (pHole[i].end))) {
pHole[i].start = (pVertexData.getOffset()) + (pVertexData.size);

}
else if (((pVertexData.getOffset()) > (pHole[i].start)) && (((pVertexData.getOffset()) + (pVertexData.size)) == (pHole[i].end))) {

}
else if (((pVertexData.getOffset()) == (pHole[i].start)) && ((pVertexData.size) == (pHole[i].size))) {
pHole.splice(i, 1);
i--;

}
else if ((((pVertexData.getOffset()) < (pHole[i].start)) && (((pVertexData.getOffset()) + (pVertexData.size)) > (pHole[i].start))) && (((pVertexData.getOffset()) + (pVertexData.size)) < (pHole[i].end))) {
pHole.start = (pVertexData.getOffset()) + (pVertexData.size);

}
else if ((((pVertexData.getOffset()) < (pHole[i].start)) && (((pVertexData.getOffset()) + (pVertexData.size)) > (pHole[i].start))) && (((pVertexData.getOffset()) + (pVertexData.size)) == (pHole[i].end))) {
pHole.splice(i, 1);
i--;

}
else if (((((pVertexData.getOffset()) + (pVertexData.size)) > (pHole[i].end)) && ((pVertexData.getOffset()) > (pHole[i].start))) && ((pVertexData.getOffset()) < (pHole[i].end))) {
pHole.end = pVertexData.getOffset();

}
else if (((((pVertexData.getOffset()) + (pVertexData.size)) > (pHole[i].end)) && ((pVertexData.getOffset()) == (pHole[i].start))) && ((pVertexData.getOffset()) < (pHole[i].end))) {
pHole.splice(i, 1);
i--;

}
else if (((pVertexData.getOffset()) < (pHole[i].start)) && (((pVertexData.getOffset()) + (pVertexData.size)) > (pHole[i].end))) {
i--;

}










}


}

function order(a, b) {
return ((a.end) - (a.start)) - ((b.end) - (b.start));

}

pHole.sort(order);
var iStride=0;
if ((typeof pVertexDeclaration) != "number") {
pVertexDeclaration = a.normalizeVertexDecl(pVertexDeclaration);
iStride = pVertexDeclaration.iStride;

}
else  {
iStride = pVertexDeclaration;

}

for (i = 0; i < (pHole.length); i++) {
var iAligStart=(this.isAlignment()? Math.alignUp(pHole[i].start, Math.nok(iStride, 4)) : Math.alignUp(pHole[i].start, iStride));
if (((pHole[i].end) - iAligStart) >= (iCount * iStride)) {
if ((arguments.length) == 2) {
var pVertexData=new a.VertexData(this, iAligStart, iCount, pVertexDeclaration);
this._pVertexDataArray.push(pVertexData);
return pVertexData;

}
else if ((arguments.length) == 3) {
pVertexDataIn.constructor.call(pVertexDataIn, this, iAligStart, iCount, pVertexDeclaration);
this._pVertexDataArray.push(pVertexDataIn);
return pVertexDataIn;

}
else  {
return null;

}



}


}

if ((this.resize(Math.max((this.size) * 2, (this.size) + (iCount * iStride)))) == false) {
break ;

}


}
return null;

};
a.VBufferBase = VBufferBase;
function IndexBuffer(pEngine) {
this._pEngine = pEngine;
this._pDevice = pEngine.pDevice;
this._pBuffer = null;
this._pBackupCopy = null;
this._iTypeFlags = 0;
this._iByteSize = undefined;
this._pIndexDataArray = new Array();
IndexBuffer.superclass.constructor.apply(this, arguments);

}

a.extend(IndexBuffer, a.ResourcePoolItem);
IndexBuffer.prototype.isValid = function() {
return ((this._pBuffer) != null? true : false);

};
IndexBuffer.prototype.isDynamic = function() {
return ((this._iTypeFlags & (1 << 0)) != 0) && ((this._iTypeFlags & (1 << 1)) != 0);

};
IndexBuffer.prototype.isStatic = function() {
return (!((this._iTypeFlags & (1 << 0)) != 0)) && ((this._iTypeFlags & (1 << 1)) != 0);

};
IndexBuffer.prototype.isStream = function() {
return (!((this._iTypeFlags & (1 << 0)) != 0)) && (!((this._iTypeFlags & (1 << 1)) != 0));

};
IndexBuffer.prototype.isReadable = function() {
return (this._iTypeFlags & (1 << 2)) != 0;

};
IndexBuffer.prototype.isRAMBufferPresent = function() {
return ((this._pBackupCopy) != null? true : false);

};
IndexBuffer.prototype.isSoftware = function() {
return (this._iTypeFlags & (1 << 4)) != 0;

};
IndexBuffer.prototype.getBuffer = function() {
return this._pBuffer;

};
IndexBuffer.prototype.getUsage = function() {
return this._iTypeFlags;

};
IndexBuffer.prototype.getSize = function() {
return this._iByteSize;

};
IndexBuffer.prototype.create = function(iByteSize, iFlags, pData) {
if (!((this._pBuffer) == null)) {
var err=((((((("Error:: " + "d3d buffer already allocated") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("d3d buffer already allocated");

}


}

;
if (!((this._pBackupCopy) == null)) {
var err=((((((("Error:: " + "backup buffer already allocated") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("backup buffer already allocated");

}


}

;
var eUsage=0;
this._iByteSize = iByteSize;
this._iTypeFlags = iFlags;
if (!(!((this._iTypeFlags & (1 << 4)) != 0))) {
var err=((((((("Error:: " + "no sftware rendering") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("no sftware rendering");

}


}

;
if (((this._iTypeFlags & (1 << 0)) != 0) && (!((this._iTypeFlags & (1 << 1)) != 0))) {
if (!(this._iTypeFlags & (1 << 4)) != 0) {
var err=((((((("Error:: " + "crazy... more update bun one draw") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("crazy... more update bun one draw");

}


}

;

}

if ((this._iTypeFlags & (1 << 3)) != 0) {
this._iTypeFlags |= 1 << 2;

}
else  {
if ((this._iTypeFlags & (1 << 2)) != 0) {
this._iTypeFlags |= 1 << 3;

}


}

if (pData) {
if (!((pData.byteLength) <= iByteSize)) {
var err=((((((("Error:: " + "Размер переданного массива больше переданного размера буфера") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Размер переданного массива больше переданного размера буфера");

}


}

;

}

if ((this._iTypeFlags & (1 << 3)) != 0) {
this._pBackupCopy = new Uint8Array(this._iByteSize);
if (pData) {
this._pBackupCopy.set(pData.buffer, 0);

}


}

if (((this._iTypeFlags & (1 << 0)) != 0) && ((this._iTypeFlags & (1 << 1)) != 0)) {
eUsage = 35048;

}
else if ((!((this._iTypeFlags & (1 << 0)) != 0)) && ((this._iTypeFlags & (1 << 1)) != 0)) {
eUsage = 35044;

}
else  {
eUsage = 35040;

}


this._pBuffer = this._pDevice.createBuffer();
if (!(this._pBuffer)) {
this._pBuffer = null;
if (!0) {
var err=((((((("Error:: " + "Не удалось создать буфер") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Не удалось создать буфер");

}


}

;
this.destroy();
return false;

}

var pRenderer=this._pEngine.shaderManager();
pRenderer.activateIndexBuffer(this);
pRenderer.indexBufferChanged(this);
this._pDevice.bufferData(34963, this._iByteSize, eUsage);
if (pData) {
this._pDevice.bufferSubData(34963, 0, new Uint16Array(pData.buffer));

}

return true;

};
IndexBuffer.prototype.destroy = function() {
if (this._pDevice.isBuffer(this._pBuffer)) {
this._pDevice.deleteBuffer(this._pBuffer);

}

this._pBuffer = null;
this._pBackupCopy = null;
this._iByteSize = undefined;
for (var i in this._pIndexDataArray) {
this._pIndexDataArray[i].destroy();

}

this._pIndexDataArray = null;
this._iTypeFlags = 0;
this._pEngine.shaderManager().releaseRenderResource(this);
this.notifyUnloaded();

};
IndexBuffer.prototype.clone = function(pSrc) {
var isSuccess=false;
this.destroy();
this.create(pSrc.getByteSize(), pSrc.getUsage(), pSrc.getData(0, pSrc.getByteSize()));
return isSuccess;

};
IndexBuffer.prototype.getData = function(iOffset, iSize) {
if (!this._pBuffer) {
var err=((((((("Error:: " + "Буффер еще не создан") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Буффер еще не создан");

}


}

;
if (!(((this._iTypeFlags & (1 << 3)) != 0) == true)) {
var err=((((((("Error:: " + "Нельзя отдать данные если они не храняться локально") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Нельзя отдать данные если они не храняться локально");

}


}

;
return this._pBackupCopy.buffer.slice(iOffset, iOffset + iSize);

};
IndexBuffer.prototype.setData = function(pData, iOffset, iSize) {
if (!this._pBuffer) {
var err=((((((("Error:: " + "Буффер еще не создан") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Буффер еще не создан");

}


}

;
var pRenderer=this._pEngine.shaderManager();
pRenderer.activateIndexBuffer(this);
this._pDevice.bindBuffer(34963, this._pBuffer);
if (!((pData.byteLength) <= iSize)) {
var err=((((((("Error:: " + "Размер переданного массива больше переданного размера") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Размер переданного массива больше переданного размера");

}


}

;
pRenderer.indexBufferChanged(this);
this._pDevice.bufferSubData(34963, iOffset, pData.slice(0, iSize));
if ((this._iTypeFlags & (1 << a.VertexBuffer.RamBackupBit)) != 0) {
this._pBackupCopy.set(new Uint8Array(pData.slice(0, iSize)), iOffset);

}

return true;

};
IndexBuffer.prototype.activate = function() {
if (!this.isValid()) {
var err=((((((("Error:: " + "Attempting to activate an invalid buffer") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Attempting to activate an invalid buffer");

}


}

;
this._pDevice.bindBuffer(34963, this._pBuffer);

};
IndexBuffer.prototype.createResource = function() {
this.notifyCreated();
return true;

};
IndexBuffer.prototype.destroyResource = function() {
this.destroy();
this.notifyDestroyed();
return true;

};
IndexBuffer.prototype.restoreResource = function() {
this.notifyRestored();
return true;

};
IndexBuffer.prototype.disableResource = function() {
this.notifyDisabled();
return true;

};
IndexBuffer.prototype.loadResource = function() {
return true;

};
IndexBuffer.prototype.saveResource = function() {
return true;

};
IndexBuffer.prototype.getIndexData = function(iOffset, iCount, ePrimitiveType, eElementsType) {
var pIndexData=new a.IndexData(this, iOffset, iCount, ePrimitiveType, eElementsType);
this._pIndexDataArray.push(pIndexData);
return pIndexData;

};
IndexBuffer.prototype.freeIndexData = function(pIndexData) {
for (var i=0; i < (this._pIndexDataArray.length); i++) {
if ((this._pIndexDataArray[i]) == pIndexData) {
this._pIndexDataArray.splice(i, 1);
return true;

}


}

pIndexData.destroy();
return false;

};
IndexBuffer.prototype.getEmptyIndexData = function(iCount, ePrimitiveType, eElementsType) {
var pHole=new Array();
var i;
var pIndexData;
pHole[0] =  {start: 0, end: this.getSize()};
for (var k in this._pIndexDataArray) {
pIndexData = this._pIndexDataArray[k];
for (i = 0; i < (pHole.length); i++) {
if (((pIndexData.getOffset()) > (pHole[i].start)) && (((pIndexData.getOffset()) + (pIndexData.getSize())) < (pHole[i].end))) {
var iTemp=pHole[i].end;
pHole[i].end = pIndexData.getOffset();
pHole.splice(i + 1, 0,  {start: (pIndexData.getOffset()) + (pIndexData.getSize()), end: iTemp});
i--;

}
else if (((pIndexData.getOffset()) == (pHole[i].start)) && (((pIndexData.getOffset()) + (pIndexData.getSize())) < (pHole[i].end))) {
pHole[i].start = (pIndexData.getOffset()) + (pIndexData.getSize());

}
else if (((pIndexData.getOffset()) > (pHole[i].start)) && (((pIndexData.getOffset()) + (pIndexData.getSize())) == (pHole[i].end))) {

}
else if (((pIndexData.getOffset()) == (pHole[i].start)) && ((pIndexData.getSize()) == (pHole[i].size))) {
pHole.splice(i, 1);
i--;

}
else if ((((pIndexData.getOffset()) < (pHole[i].start)) && (((pIndexData.getOffset()) + (pIndexData.getSize())) > (pHole[i].start))) && (((pIndexData.getOffset()) + (pIndexData.getSize())) < (pHole[i].end))) {
pHole.start = (pIndexData.getOffset()) + (pIndexData.getSize());

}
else if ((((pIndexData.getOffset()) < (pHole[i].start)) && (((pIndexData.getOffset()) + (pIndexData.getSize())) > (pHole[i].start))) && (((pIndexData.getOffset()) + (pIndexData.getSize())) == (pHole[i].end))) {
pHole.splice(i, 1);
i--;

}
else if (((((pIndexData.getOffset()) + (pIndexData.getSize())) > (pHole[i].end)) && ((pIndexData.getOffset()) > (pHole[i].start))) && ((pIndexData.getOffset()) < (pHole[i].end))) {
pHole.end = pIndexData.getOffset();

}
else if (((((pIndexData.getOffset()) + (pIndexData.getSize())) > (pHole[i].end)) && ((pIndexData.getOffset()) == (pHole[i].start))) && ((pIndexData.getOffset()) < (pHole[i].end))) {
pHole.splice(i, 1);
i--;

}
else if (((pIndexData.getOffset()) < (pHole[i].start)) && (((pIndexData.getOffset()) + (pIndexData.getSize())) > (pHole[i].end))) {
i--;

}










}


}

function order(a, b) {
return ((a.end) - (a.start)) - ((b.end) - (b.start));

}

pHole.sort(order);
for (i = 0; i < (pHole.length); i++) {
if (((pHole[i].end) - (pHole[i].start)) >= (iCount * (a.getTypeSize(eElementsType)))) {
var pIndexData=new a.IndexData(this, pHole[i].start, iCount, ePrimitiveType, eElementsType);
this._pIndexDataArray.push(pIndexData);
return pIndexData;

}


}

return null;

};
IndexBuffer.prototype.getCountIndexForStripGrid = function(iXVerts, iYVerts) {
var iTotalStrips=iYVerts - 1;
var iTotalIndexesPerStrip=iXVerts << 1;
var iTotalIndexes=((iTotalStrips * iTotalIndexesPerStrip) + (iTotalStrips << 1)) - 2;
return iTotalIndexes;

};
a.IndexBuffer = IndexBuffer;
function VertexBuffer() {
var _pCtorValue=VertexBuffer.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pDevice = this._pEngine.pDevice;
this._iByteSize = undefined;

}

a.extend(VertexBuffer, a.ResourcePoolItem, a.VBufferBase);
a.defineProperty(VertexBuffer, "size", function() {
return this._iByteSize;

}
);
VertexBuffer.prototype.create = function(iByteSize, iFlags, pData) {
iByteSize = iByteSize || 0;
iFlags = iFlags || 0;
var i;
if (!((this._pBuffer) == null)) {
var err=((((((("Error:: " + "d3d buffer already allocated") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("d3d buffer already allocated");

}


}

;
if (!((this._pBackupCopy) == null)) {
var err=((((((("Error:: " + "backup buffer already allocated") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("backup buffer already allocated");

}


}

;
var eUsage=0;
if (iByteSize < 100)iByteSize = 1000;

this._iByteSize = iByteSize;
this._iTypeFlags = iFlags;
var pRenderer=this._pEngine.shaderManager();
if (!(!((this._iTypeFlags & (1 << 4)) != 0))) {
var err=((((((("Error:: " + "no sftware rendering") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("no sftware rendering");

}


}

;
if (((this._iTypeFlags & (1 << 0)) != 0) && (!((this._iTypeFlags & (1 << 1)) != 0))) {
if (!(this._iTypeFlags & (1 << 4)) != 0) {
var err=((((((("Error:: " + "crazy... more update bun one draw") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("crazy... more update bun one draw");

}


}

;

}

if ((this._iTypeFlags & (1 << 3)) != 0) {
this._iTypeFlags |= 1 << 2;

}
else  {
if ((this._iTypeFlags & (1 << 2)) != 0) {
this._iTypeFlags |= 1 << 3;

}


}

if (pData) {
if (!((pData.byteLength) <= iByteSize)) {
var err=((((((("Error:: " + "Размер переданного массива больше переданного размера буфера") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Размер переданного массива больше переданного размера буфера");

}


}

;

}

if ((this._iTypeFlags & (1 << 3)) != 0) {
this._pBackupCopy = new Uint8Array(this._iByteSize);
if (pData) {
this._pBackupCopy.set(new Uint8Array(pData.buffer), 0);

}


}

if (((this._iTypeFlags & (1 << 0)) != 0) && ((this._iTypeFlags & (1 << 1)) != 0)) {
eUsage = 35048;

}
else if ((!((this._iTypeFlags & (1 << 0)) != 0)) && ((this._iTypeFlags & (1 << 1)) != 0)) {
eUsage = 35044;

}
else  {
eUsage = 35040;

}


this._pBuffer = this._pDevice.createBuffer();
if (!(this._pBuffer)) {
this._pBuffer = null;
if (!0) {
var err=((((((("Error:: " + "Не удалось создать буфер") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Не удалось создать буфер");

}


}

;
this.destroy();
return false;

}

pRenderer.activateVertexBuffer(this);
pRenderer.vertexBufferChanged(this);
this._pDevice.bufferData(34962, this._iByteSize, eUsage);
if (pData) {
this._pDevice.bufferSubData(34962, 0, pData.buffer);

}

this.notifyRestored();
this.notifyLoaded();
return true;

};
VertexBuffer.prototype.destroy = function() {
if (this._pDevice.isBuffer(this._pBuffer)) {
this._pDevice.deleteBuffer(this._pBuffer);

}

this._pBuffer = null;
this._pBackupCopy = null;
this._iByteSize = undefined;
this.freeVertexData();
this._iTypeFlags = undefined;
this._pEngine.shaderManager().releaseRenderResource(this);
this.notifyUnloaded();

};
VertexBuffer.prototype.getData = function(iOffset, iSize) {
if (!this._pBuffer) {
var err=((((((("Error:: " + "Буффер еще не создан") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Буффер еще не создан");

}


}

;
if (!(((this._iTypeFlags & (1 << 3)) != 0) == true)) {
var err=((((((("Error:: " + "Нельзя отдать данные если они не храняться локально") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Нельзя отдать данные если они не храняться локально");

}


}

;
if ((arguments.length) === 0) {
return this._pBackupCopy.buffer;

}

return this._pBackupCopy.buffer.slice(iOffset, iOffset + iSize);

};
VertexBuffer.prototype.setData = function(pData, iOffset, iSize) {
if (!this._pBuffer) {
var err=((((((("Error:: " + "Буффер еще не создан") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Буффер еще не создан");

}


}

;
var pRenderer=this._pEngine.shaderManager();
pRenderer.activateVertexBuffer(this);
if (!((pData.byteLength) <= iSize)) {
var err=((((((("Error:: " + "Размер переданного массива больше переданного размера") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Размер переданного массива больше переданного размера");

}


}

;
if (!((this.size) >= (iOffset + iSize))) {
var err=((((((("Error:: " + "Данные выйдут за предел буфера") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Данные выйдут за предел буфера");

}


}

;
this._pDevice.bufferSubData(34962, iOffset, new Uint8Array(pData.slice(0, iSize)));
if ((this._iTypeFlags & (1 << 3)) != 0) {
this._pBackupCopy.set(new Uint8Array(pData.slice(0, iSize)), iOffset);

}

return true;

};
VertexBuffer.prototype.resize = function(iSize) {
var eUsage;
var pData;
var iMax=0;
var pVertexData;
var pRenderer=this._pEngine.shaderManager();
if (((this._iTypeFlags & (1 << 3)) != 0) != true) {
return false;

}

if (iSize < (this.size)) {
for (var k in this._pVertexDataArray) {
pVertexData = this._pVertexDataArray[k];
if (((pVertexData.getOffset()) + (pVertexData.size)) > iMax) {
iMax = (pVertexData.getOffset()) + (pVertexData.size);

}


}

if (!(iMax <= iSize)) {
var err=((((((("Error:: " + "Уменьшение невозможно. Страая разметка не укладывается в новый размер") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Уменьшение невозможно. Страая разметка не укладывается в новый размер");

}


}

;

}

if (this._pDevice.isBuffer(this._pBuffer)) {
this._pDevice.deleteBuffer(this._pBuffer);

}

if (((this._iTypeFlags & (1 << 0)) != 0) && ((this._iTypeFlags & (1 << 1)) != 0)) {
eUsage = 35048;

}
else if ((!((this._iTypeFlags & (1 << 0)) != 0)) && ((this._iTypeFlags & (1 << 1)) != 0)) {
eUsage = 35044;

}
else  {
eUsage = 35040;

}


this._pBuffer = this._pDevice.createBuffer();
pRenderer.vertexBufferChanged(this);
if (!(this._pBuffer)) {
this._pBuffer = null;
if (!0) {
var err=((((((("Error:: " + "Не удалось создать буфер") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Не удалось создать буфер");

}


}

;
this.destroy();
return false;

}

pRenderer.activateVertexBuffer(this);
this._pDevice.bufferData(34962, iSize, eUsage);
pData = this.getData(0, this._iByteSize);
this._pBackupCopy = new Uint8Array(iSize);
this.setData(pData, 0, this._iByteSize);
this._iByteSize = iSize;
return true;

};
VertexBuffer.prototype.activate = function() {
if (!this.isValid()) {
var err=((((((("Error:: " + "Attempting to activate  an invalid buffer") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Attempting to activate  an invalid buffer");

}


}

;
this._pEngine.shaderManager().activateVertexBuffer(this);

};
VertexBuffer.prototype.bind = function() {
this._pDevice.bindBuffer(34962, this._pBuffer);

};
VertexBuffer.prototype.unbind = function() {
trace("!!!!! VertexBuffer.prototype.unbind #" + (this.resourceHandle()));
this._pDevice.bindBuffer(34962, null);

};
VertexBuffer.prototype.createResource = function() {
this.notifyCreated();
return true;

};
VertexBuffer.prototype.destroyResource = function() {
this.notifyDestroyed();
this.destroy();
return true;

};
VertexBuffer.prototype.restoreResource = function() {
this.notifyRestored();
return true;

};
VertexBuffer.prototype.disableResource = function() {
this.notifyDisabled();
if (((this._iStateFlags & (1 << a.VBufferBase.Volatile)) != 0) && ((this._iTypeFlags & (1 << 3)) != 0)) {
this._pDevice.deleteBuffer(this._pBuffer);
this._pBuffer = null;

}

return true;

};
VertexBuffer.prototype.loadResource = function() {
return false;

};
VertexBuffer.prototype.saveResource = function() {
return false;

};
a.VertexBuffer = VertexBuffer;
function computeBoundingBox(pVertexData, pBoundingBox) {
var fX0=0, fY0=0, fZ0=0, fX1=0, fY1=0, fZ1=0;
var fTemp, pTempData;
var i=0;
var pVertexDeclaration, pVertexElement, pData;
var nStride, nCount;
if ((!pVertexData) || (!pBoundingBox)) {
return false;

}

pVertexDeclaration = pVertexData.getVertexDeclaration();
if (!pVertexDeclaration)return false;

pVertexElement = pVertexDeclaration.element("POSITION", 3);
if (!pVertexDeclaration)return false;

nCount = pVertexData.length;
nStride = pVertexElement.iSize;
pData = pVertexData.getData(pVertexElement.iOffset, pVertexElement.iSize);
if (!pData)return false;

pTempData = new Float32Array(pData, 0, 3);
fX0 = fX1 = pTempData[0];
fY0 = fY1 = pTempData[1];
fZ0 = fZ1 = pTempData[2];
for (i = nStride; i < (nStride * nCount); i += nStride) {
pTempData = new Float32Array(pData, i, 3);
fTemp = pTempData[0];
fX0 = (fX0 > fTemp? fTemp : fX0);
fX1 = (fX1 > fTemp? fX1 : fTemp);
fTemp = pTempData[1];
fY0 = (fY0 > fTemp? fTemp : fY0);
fY1 = (fY1 > fTemp? fY1 : fTemp);
fTemp = pTempData[2];
fZ0 = (fZ0 > fTemp? fTemp : fZ0);
fZ1 = (fZ1 > fTemp? fZ1 : fTemp);

}

pBoundingBox.set(fX0, fX1, fY0, fY1, fZ0, fZ1);
return true;

}

;
a.computeBoundingBox = computeBoundingBox;
function computeDataForCascadeBoundingBox(pBoundingBox, pVertexes, pIndexes, fMinSize) {
var pInd;
var pPoints;
var i, j, k;
pPoints = new Array(8);
for (i = 0; i < 8; i++) {
pPoints[i] = new Array(4);
for (j = 0; j < 4; j++)pPoints[i][j] = Vec3.create(0, 0, 0);


}

Vec3.set([pBoundingBox.fX0, pBoundingBox.fY0, pBoundingBox.fZ0], pPoints[0][0]);
Vec3.set([pBoundingBox.fX0, pBoundingBox.fY1, pBoundingBox.fZ0], pPoints[1][0]);
Vec3.set([pBoundingBox.fX0, pBoundingBox.fY0, pBoundingBox.fZ1], pPoints[2][0]);
Vec3.set([pBoundingBox.fX0, pBoundingBox.fY1, pBoundingBox.fZ1], pPoints[3][0]);
Vec3.set([pBoundingBox.fX1, pBoundingBox.fY0, pBoundingBox.fZ0], pPoints[4][0]);
Vec3.set([pBoundingBox.fX1, pBoundingBox.fY1, pBoundingBox.fZ0], pPoints[5][0]);
Vec3.set([pBoundingBox.fX1, pBoundingBox.fY0, pBoundingBox.fZ1], pPoints[6][0]);
Vec3.set([pBoundingBox.fX1, pBoundingBox.fY1, pBoundingBox.fZ1], pPoints[7][0]);
var fTempFunc=function(pPoints, iPoint, iToPoint1, iToPoint2, iToPoint3) {
for (var i=0; i < 3; i++) {
Vec3.subtract(pPoints[arguments[i + 2]][0], pPoints[iPoint][0], pPoints[iPoint][i + 1]);
if ((Vec3.length(pPoints[iPoint][i + 1])) > fMinSize) {
Vec3.scale(pPoints[iPoint][i + 1], 0.1);

}

Vec3.add(pPoints[iPoint][i + 1], pPoints[iPoint][0]);

}


};
fTempFunc(pPoints, 0, 1, 2, 4);
fTempFunc(pPoints, 1, 0, 3, 5);
fTempFunc(pPoints, 2, 0, 3, 6);
fTempFunc(pPoints, 3, 1, 2, 7);
fTempFunc(pPoints, 4, 0, 5, 6);
fTempFunc(pPoints, 5, 1, 4, 7);
fTempFunc(pPoints, 6, 2, 4, 7);
fTempFunc(pPoints, 7, 3, 5, 6);
for (i = 0; i < 8; i++) {
for (j = 0; j < 4; j++) {
for (k = 0; k < 3; k++) {
pVertexes[((i * 12) + (j * 3)) + k] = pPoints[i][j][k];

}


}


}

pInd = [0, 1, 0, 2, 0, 3, 4, 5, 4, 6, 4, 7, 8, 9, 8, 10, 8, 11, 12, 13, 12, 14, 12, 15, 16, 17, 16, 18, 16, 19, 20, 21, 20, 22, 20, 23, 24, 25, 24, 26, 24, 27, 28, 29, 28, 30, 28, 31];
for (i in pInd) {
pIndexes[i] = pInd[i];

}

return true;

}

a.computeDataForCascadeBoundingBox = computeDataForCascadeBoundingBox;
function computeBoundingSphere(pVertexData, pSphere, eSphereType, pBoundingBox) {
if ((!eSphereType) || (eSphereType == (0))) {
return a.computeBoundingSphereFast(pVertexData, pSphere, pBoundingBox);

}
else  {
return a.computeBoundingSphereMinimal(pVertexData, pSphere);

}


}

a.computeBoundingSphere = computeBoundingSphere;
function computeBoundingSphereFast(pVertexData, pSphere, pBoundingBox) {
var i;
var pVertexDeclaration, pVertexElement;
var nCount, nStride;
var pData, pTempData;
if ((!pSphere) || (!pVertexData)) {
return false;

}

pVertexDeclaration = pVertexData.getVertexDeclaration();
if (!pVertexDeclaration)return false;

pVertexElement = pVertexDeclaration.element("POSITION", 3);
if (!pVertexDeclaration)return false;

nCount = pVertexData.length;
nStride = pVertexElement.iSize;
pData = pVertexData.getData(pVertexElement.iOffset, pVertexElement.iSize);
if (!pData)return false;

if (!pBoundingBox) {
pBoundingBox = new Rect3d();

}

if (pBoundingBox.isClear()) {
if (!(a.computeBoundingBox(pVertexData, pBoundingBox))) {
return false;

}


}

var fCenterX=((pBoundingBox.fX0) + (pBoundingBox.fX1)) / 2;
var fCenterY=((pBoundingBox.fY0) + (pBoundingBox.fY1)) / 2;
var fCenterZ=((pBoundingBox.fZ0) + (pBoundingBox.fZ1)) / 2;
var fRadius=0;
var fDistance=0;
for (i = 0; i < (nStride * nCount); i += nStride) {
pTempData = new Float32Array(pData, i, 3);
fDistance = ((((pTempData[0]) - fCenterX) * ((pTempData[0]) - fCenterX)) + (((pTempData[1]) - fCenterY) * ((pTempData[1]) - fCenterY))) + (((pTempData[2]) - fCenterZ) * ((pTempData[2]) - fCenterZ));
fRadius = (fDistance > fRadius? fDistance : fRadius);

}

pSphere.set(fCenterX, fCenterY, fCenterZ, Math.sqrt(fRadius));
return true;

}

;
a.computeBoundingSphereFast = computeBoundingSphereFast;
function computeBoundingSphereMinimal(pVertexData, pSphere) {
var i=0, j=0, k=0;
var points=[];
var length=0;
var isAdd=false;
var isNew=true;
var fDiametr=0;
var fDistance=0;
var pVertexDeclaration, pVertexElement;
var nCount, nStride;
var pData, pTempData1, pTempData2;
if ((!pSphere) || (!pVertexData)) {
return false;

}

pVertexDeclaration = pVertexData.getVertexDeclaration();
if (!pVertexDeclaration)return false;

pVertexElement = pVertexDeclaration.element("POSITION", 3);
if (!pVertexDeclaration)return false;

nCount = pVertexData.length;
nStride = pVertexElement.iSize;
pData = pVertexData.getData(pVertexElement.iOffset, pVertexElement.iSize);
if (!pData)return false;

for (i = 0; i < (nStride * nCount); i += nStride) {
isNew = true;
isAdd = false;
pTempData1 = new Float32Array(pData, i, 3);
for (k = 0; k < (points.length); k += 3) {
if ((((points[k]) == (pTempData1[0])) && ((points[k + 1]) == (pTempData1[1]))) && ((points[k + 2]) == (pTempData1[2]))) {
isNew = false;
break ;

}


}

if (isNew) {
for (j = i + nStride; j < (nStride * nCount); j += nStride) {
pTempData2 = new Float32Array(pData, j, 3);
fDistance = ((((pTempData1[0]) - (pTempData2[0])) * ((pTempData1[0]) - (pTempData2[0]))) + (((pTempData1[1]) - (pTempData2[1])) * ((pTempData1[1]) - (pTempData2[1])))) + (((pTempData1[2]) - (pTempData2[2])) * ((pTempData1[2]) - (pTempData2[2])));
if (fDistance > fDiametr) {
fDiametr = fDistance;
isAdd = true;
points[0] = pTempData2[0];
points[1] = pTempData2[1];
points[2] = pTempData2[2];
length = 3;

}
else if ((fDistance.toFixed(7)) == (fDiametr.toFixed(7))) {
isAdd = true;
for (k = 0; k < (points.length); k += 3) {
if ((((points[k]) == (pTempData2[0])) && ((points[k + 1]) == (pTempData2[1]))) && ((points[k + 2]) == (pTempData2[2]))) {
isNew = false;
break ;

}


}

if (isNew) {
points[length] = pTempData2[0];
points[length + 1] = pTempData2[1];
points[length + 2] = pTempData2[2];
length += 3;

}


}



}

if (isAdd) {
points[length] = pTempData1[0];
points[length + 1] = pTempData1[1];
points[length + 2] = pTempData1[2];
length += 3;

}


}


}

var fX=0, fY=0, fZ=0;
for (i = 0; i < (points.length); i += 3) {
fX += points[i];
fY += points[i + 1];
fZ += points[i + 2];

}

var x=pSphere.v3fCenter[0] = (fX / (points.length)) * 3;
var y=pSphere.v3fCenter[1] = (fY / (points.length)) * 3;
var z=pSphere.v3fCenter[2] = (fZ / (points.length)) * 3;
pSphere.fRadius = Math.sqrt(((((points[0]) - x) * ((points[0]) - x)) + (((points[1]) - y) * ((points[1]) - y))) + (((points[2]) - z) * ((points[2]) - z)));
return true;

}

;
a.computeBoundingSphereMinimal = computeBoundingSphereMinimal;
function computeGeneralizingSphere(pSphereA, pSphereB, pSphereDest) {
if (!pSphereDest) {
pSphereDest = pSphereA;

}

var fR1=pSphereA.fRadius;
var fR2=pSphereB.fRadius;
var v3fC1=pSphereA.v3fCenter;
var v3fC2=pSphereB.v3fCenter;
var v3fD=new Vec3();
Vec3.subtract(v3fC1, v3fC2, v3fD);
var fD=Vec3.length(v3fD);
if ((fD < fR1) && (fR1 > fR2)) {
pSphereDest.set(pSphereA);
return ;

}

if (fD < fR2) {
pSphereDest.set(pSphereB);
return ;

}

var v3fN=new Vec3();
Vec3.normalize(v3fD, v3fN);
pSphereDest.fRadius = (Vec3.length(Vec3.add(v3fD, Vec3.scale(v3fN, fR1 + fR2)))) / 2;
var v3fTemp=v3fD;
pSphereDest.v3fCenter = Vec3.scale(Vec3.add(Vec3.add(v3fC1, v3fC2, v3fTemp), Vec3.scale(v3fN, (fR1 - fR2) / (fR1 + fR2))), 0.5);

}

a["computeGeneralizingSphere"] = computeGeneralizingSphere;
function computeDataForCascadeBoundingSphere(pBoundingSphere, pVertexes, pIndexes, fMinSize) {
var fTheta, fDelta, fAlpha;
var nCount=10;
var i, j, k, a;
fDelta = (2 * (Math.PI)) / nCount;
for (i = 0; i <= (nCount / 2); i++) {
fTheta = (-(Math.PI)) + (i * fDelta);
for (j = 0; j <= nCount; j++) {
fAlpha = j * fDelta;
pVertexes[(((i * (nCount + 1)) + j) * 3) + 0] = (pBoundingSphere.v3fCenter[0]) + (((pBoundingSphere.fRadius) * (Math.sin(fTheta))) * (Math.cos(fAlpha)));
pVertexes[(((i * (nCount + 1)) + j) * 3) + 1] = (pBoundingSphere.v3fCenter[1]) + (((pBoundingSphere.fRadius) * (Math.sin(fTheta))) * (Math.sin(fAlpha)));
pVertexes[(((i * (nCount + 1)) + j) * 3) + 2] = (pBoundingSphere.v3fCenter[2]) + ((pBoundingSphere.fRadius) * (Math.cos(fTheta)));

}


}

for (i = 0; i < (nCount / 2); i++) {
for (j = 0; j < nCount; j++) {
pIndexes[(((i * nCount) + j) * 12) + 0] = (i * (nCount + 1)) + j;
pIndexes[(((i * nCount) + j) * 12) + 1] = ((i * (nCount + 1)) + j) + 1;
pIndexes[(((i * nCount) + j) * 12) + 2] = (((i * (nCount + 1)) + j) + 2) + nCount;
pIndexes[(((i * nCount) + j) * 12) + 3] = (i * (nCount + 1)) + j;
pIndexes[(((i * nCount) + j) * 12) + 4] = ((i * (nCount + 1)) + j) + 1;
pIndexes[(((i * nCount) + j) * 12) + 5] = (((i * (nCount + 1)) + j) + 2) + nCount;
pIndexes[(((i * nCount) + j) * 12) + 6] = (i * (nCount + 1)) + j;
pIndexes[(((i * nCount) + j) * 12) + 7] = (((i * (nCount + 1)) + j) + 1) + nCount;
pIndexes[(((i * nCount) + j) * 12) + 8] = (((i * (nCount + 1)) + j) + 2) + nCount;
pIndexes[(((i * nCount) + j) * 12) + 9] = (((i * (nCount + 1)) + j) + 1) + nCount;
pIndexes[(((i * nCount) + j) * 12) + 10] = (((i * (nCount + 1)) + j) + 2) + nCount;
pIndexes[(((i * nCount) + j) * 12) + 11] = (i * (nCount + 1)) + j;

}


}

return true;

}

a.computeDataForCascadeBoundingSphere = computeDataForCascadeBoundingSphere;
function IndexData(pIndexBuffer, iOffset, iCount, ePrimitiveType, eElementsType) {
if (!pIndexBuffer) {
var err=((((((("Error:: " + "������ ������ �� ������� ��� �������� IndexData") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("������ ������ �� ������� ��� �������� IndexData");

}


}

;
this._pIndexBuffer = pIndexBuffer;
this._iOffset = iOffset;
this._iCount = iCount;
if (ePrimitiveType != undefined) {
this._ePrimitiveType = ePrimitiveType;

}
else  {
this._ePrimitiveType = 4;

}

if (eElementsType != undefined) {
this._eElementsType = eElementsType;

}
else  {
this._eElementsType = 5123;

}

if (!(((this._eElementsType) == (5121)) || ((this._eElementsType) == (5123)))) {
var err=((((((("Error:: " + "��� �������� �� ���������� ���� ��� ���") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("��� �������� �� ���������� ���� ��� ���");

}


}

;
if (!((this._pIndexBuffer.getSize()) >= ((this.getSize()) + (this.getOffset())))) {
var err=((((((("Error:: " + "IndexData ������� �� ������� IndexBuffer") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("IndexData ������� �� ������� IndexBuffer");

}


}

;

}

IndexData.prototype.destroy = function() {
this._pIndexBuffer = null;
this._iOffset = undefined;
this._iCount = undefined;
this._ePrimitiveType = undefined;
this._eElementsType = undefined;

};
IndexData.prototype.getOffset = function() {
return this._iOffset;

};
IndexData.prototype.getPrimitiveType = function() {
return this._ePrimitiveType;

};
IndexData.prototype.getType = function() {
return this._eElementsType;

};
IndexData.prototype.getCount = function() {
return this._iCount;

};
IndexData.prototype.getIndexSize = function() {
return a.getTypeSize(this.getType());

};
IndexData.prototype.getSize = function() {
return (this.getCount()) * (a.getTypeSize(this.getType()));

};
IndexData.prototype.getData = function(iOffset, iSize) {
if (!((iOffset + iSize) <= (this.getSize()))) {
var err=((((((("Error:: " + "������������� �������� ������� �� ������� IndexData") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("������������� �������� ������� �� ������� IndexData");

}


}

;
return this._pIndexBuffer.getData((this.getOffset()) + iOffset, iSize);

};
IndexData.prototype.setData = function(pData, iOffset, iCount) {
if (!(((iOffset + iCount) * (this.getIndexSize())) <= (this.getSize()))) {
var err=((((((("Error:: " + "�������� ������� �� ������� IndexData") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/IndexData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("�������� ������� �� ������� IndexData");

}


}

;
return this._pIndexBuffer.setData(pData.buffer, (this.getOffset()) + (iOffset * (this.getIndexSize())), iCount * (this.getIndexSize()));

};
IndexData.prototype.activate = function() {
return this._pIndexBuffer.activate();

};
IndexData.prototype.drawElements = function() {
return this._pIndexBuffer.getDevice().drawElements(this.getPrimitiveType(), this.getCount(), this.getType(), this.getOffset());

};
IndexData.prototype.getPrimitiveCount = function() {
switch(arguments.length) {
case 0:
return this.getPrimitiveCount(this.getCount());
break ;

case 1:
var count=(arguments[0]) / 3;
if (((this._ePrimitiveType) == (5)) || ((this._ePrimitiveType) == (6))) {
count = (arguments[0]) - 2;

}

return count;
break ;
}
return undefined;

};
a.IndexData = IndexData;
function VertexElement(nCount, eType, eUsage, iOffset) {
this.nCount = (nCount === undefined? 1 : nCount);
this.eType = eType || (5126);
this.eUsage = eUsage || ("POSITION");
this.eUsage = this.eUsage.toString().toUpperCase();
this.iOffset = iOffset;
this.update();

}

a.defineProperty(VertexElement, "size", function() {
return this.iSize;

}
);
VertexElement.prototype.update = function() {
this.iSize = (this.nCount) * (a.getTypeSize(this.eType));
this.iIndex = 0;
this.eSematics = null;
var pMatches=this.eUsage.match(/^(.*?\w)(\d+)$/i);
if (pMatches) {
this.eSematics = pMatches[1];
this.iIndex = Number(pMatches[2]);

}
else  {
this.eSematics = this.eUsage;

}


};
VertexElement.prototype.clone = function() {
return new a.VertexElement(this.nCount, this.eType, this.eUsage, this.iOffset);

};
VertexElement.prototype.toString = function() {
"use strict";
function _an(s, n, bBackward) {
s = String(s);
bBackward = (bBackward === undefined? false : bBackward);
for (var i=0, t=n - (s.length); i < t; ++i) {
if (bBackward) {
s = " " + s;

}
else  {
s += " ";

}


}

return s;

}

var s=((("[ USAGE: " + (_an(this.eUsage, 12))) + ", OFFSET ") + (_an(this.iOffset, 4))) + " ]";
return s;

};
a["VertexElement"] = VertexElement;
function VertexDeclaration(pArrayElements) {
this.iStride = 0;
if (arguments.length) {
this.append(pArrayElements);

}


}

a.extend(VertexDeclaration, Array);
a.defineProperty(VertexDeclaration, "stride", function() {
return this.iStride;

}
);
VertexDeclaration.prototype.update = function() {
var iStride;
for (var i=0; i < (this.length); ++i) {
if ((this[i].eUsage) === ("\u000D")) {
this.swap(i, i + 1);

}

iStride = (this[i].iSize) + (this[i].iOffset);
if ((this.iStride) < iStride) {
this.iStride = iStride;

}


}

var pLast=this.last;
if (((pLast.eUsage) === ("\u000D")) && ((pLast.iOffset) < (this.iStride))) {
pLast.iOffset = this.iStride;

}

return true;

};
VertexDeclaration.prototype.append = function() {
"use strict";
var pArrayElements;
if (!((arguments[0]) instanceof Array)) {
pArrayElements = arguments;

}
else  {
pArrayElements = arguments[0];

}

var iOffset;
for (var i=0; i < (pArrayElements.length); i++) {
iOffset = pArrayElements[i].iOffset;
if (iOffset === undefined) {
if (i > 0) {
iOffset = (this[i - 1].iOffset) + (this[i - 1].iSize);

}
else  {
iOffset = 0;

}


}

this.push(new VertexElement(pArrayElements[i].nCount, pArrayElements[i].eType, pArrayElements[i].eUsage, iOffset));

}

return this.update();

};
VertexDeclaration.prototype.extend = function(pVertexDecl) {
var pElement;
for (var i=0; i < (this.length); ++i) {
for (var j=0; j < (pVertexDecl.length); ++j) {
if ((pVertexDecl[j].eUsage) == (this[i].eUsage)) {
trace("inconsistent declarations:", this, pVertexDecl);
if (!0) {
var err=((((((("Error:: " + "The attempt to combine the declaration containing the exact same semantics.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The attempt to combine the declaration containing the exact same semantics.");

}


}

;
return false;

}


}


}

for (var i=0; i < (pVertexDecl.length); i++) {
pElement = pVertexDecl[i].clone();
pElement.iOffset += this.iStride;
this.push(pElement);

}

return this.update();

};
VertexDeclaration.prototype.hasSemantics = function(eSemantics) {
return (this.element(eSemantics)) !== null;

};
VertexDeclaration.prototype.element = function(eSemantics, nCount) {
if ((arguments.length) == 1) {
eSemantics = eSemantics.toUpperCase();
for (var i=0; i < (this.length); ++i) {
if ((this[i].eUsage) === eSemantics) {
return this[i];

}


}


}
else if ((arguments.length) == 2) {
eSemantics = eSemantics.toUpperCase();
for (var i=0; i < (this.length); ++i) {
if (((this[i].eUsage) === eSemantics) && ((this[i].nCount) == nCount)) {
return this[i];

}


}


}


return null;

};
VertexDeclaration.prototype.clone = function() {
var pDecl=new a.VertexDeclaration();
for (var i=0; i < (this.length); i++) {
pDecl.push(this[i].clone());

}

pDecl.update();
return pDecl;

};
VertexDeclaration.prototype.toString = function() {
"use strict";
var s="";
s += ("  VERTEX DECLARATION ( " + (this.iStride)) + " b. ) \n";
s += "---------------------------------------\n";
for (var i=0; i < (this.length); ++i) {
s += (this[i].toString()) + "\n";

}

return s;

};
a["VertexDeclaration"] = VertexDeclaration;
function normalizeVertexDecl(pDataDecl) {
if (!(pDataDecl instanceof (a.VertexDeclaration))) {
if (!(pDataDecl instanceof Array)) {
pDataDecl = [pDataDecl];

}

pDataDecl = new a.VertexDeclaration(pDataDecl);

}

return pDataDecl;

}

a["normalizeVertexDecl"] = normalizeVertexDecl;
function VertexData(pVertexBuffer, iOffset, iCount, pVertexDeclaration) {
if (!pVertexBuffer) {
var err=((((((("Error:: " + "Вертекс буффер не передан при создании VertexData") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Вертекс буффер не передан при создании VertexData");

}


}

;
this._pVertexBuffer = pVertexBuffer;
this._iOffset = iOffset;
this._nMemberCount = iCount;
this._pVertexDeclaration = null;
this._iStride = undefined;
this._iID = this._pVertexBuffer.getNextID();
if ((typeof pVertexDeclaration) == "number") {
this._iStride = pVertexDeclaration;

}
else  {
this._iStride = pVertexDeclaration.stride;
this.setVertexDeclaration(pVertexDeclaration);

}

if (!((this._pVertexBuffer.size) >= ((this.size) + (this.getOffset())))) {
var err=((((((("Error:: " + "IndexData выходит за пределы IndexBuffer") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("IndexData выходит за пределы IndexBuffer");

}


}

;

}

VertexData.prototype.toNumber = function() {
return this._iID;

};
a.defineProperty(VertexData, "declaration", function() {
return this._pVertexDeclaration;

}
);
a.defineProperty(VertexData, "buffer", function() {
return this._pVertexBuffer;

}
);
VertexData.prototype.getOffset = function() {
return this._iOffset;

};
VertexData.prototype.getVertexBuffer = function() {
return this._pVertexBuffer;

};
VertexData.prototype.getStartIndex = function() {
var iIndex=(this.getOffset()) / (this.getStride());
if (!((iIndex % 1) == 0)) {
var err=((((((("Error:: " + "Вычислить значенеи индекса указывающего на первый элемен нельзя)") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Вычислить значенеи индекса указывающего на первый элемен нельзя)");

}


}

;
return iIndex;

};
VertexData.prototype.destroy = function() {
this._pVertexDeclaration = null;
this._nMemberCount = undefined;

};
a.defineProperty(VertexData, "size", function() {
return (this.getStride()) * (this.getCount());

}
);
a.defineProperty(VertexData, "length", function() {
return this._nMemberCount;

}
);
a.defineProperty(VertexData, "stride", function() {
return this._iStride;

}
);
a.defineProperty(VertexData, "offset", function() {
return this._iOffset;

}
);
VertexData.prototype.extend = function(pVertexDecl, pData) {
pVertexDecl = a.normalizeVertexDecl(pVertexDecl);
pData = (pData? new Uint8Array(pData.buffer) : new Uint8Array((this.getCount()) * (pVertexDecl.stride)));
if (!((this.length) === ((pData.byteLength) / (pVertexDecl.stride)))) {
var err=((((((("Error:: " + "invalid data size for extending") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid data size for extending");

}


}

;
var nCount=this._nMemberCount;
var nStrideNew=pVertexDecl.stride;
var nStridePrev=this.stride;
var nStrideNext=nStridePrev + nStrideNew;
var nTotalSize=nStrideNext * (this.length);
var pDecl=this.getVertexDeclaration().clone();
var pDataPrev=new Uint8Array(this.getData());
var pDataNext=new Uint8Array(nTotalSize);
for (var i=0, iOffset; i < nCount; ++i) {
iOffset = i * nStrideNext;
pDataNext.set(pDataPrev.subarray(i * nStridePrev, (i + 1) * nStridePrev), iOffset);
pDataNext.set(pData.subarray(i * nStrideNew, (i + 1) * nStrideNew), iOffset + nStridePrev);

}

if (!(pDecl.extend(pVertexDecl))) {
return false;

}

if (!(this.resize(nCount, pDecl))) {
return false;

}

return this.setData(pDataNext, 0, nStrideNext);

};
VertexData.prototype.applyModifier = function(eSemantics, fnModifier) {
"use strict";
var pData=this.getTypedData(eSemantics);
fnModifier(pData);
return this.setData(pData, eSemantics);

};
VertexData.prototype.resize = function(nCount, pVertexDeclaration) {
var iStride=0;
var iOldOffset=this.getOffset();
if ((arguments.length) == 2) {
if ((typeof pVertexDeclaration) == "number") {
iStride = pVertexDeclaration;

}
else  {
iStride = pVertexDeclaration.stride;

}

if ((nCount * iStride) <= (this.size)) {
this._nMemberCount = nCount;
this._iStride = iStride;
this._pVertexDeclaration = null;
if ((typeof pVertexDeclaration) != "number") {
this.setVertexDeclaration(pVertexDeclaration);

}

return true;

}
else  {
var pOldVertexBuffer=this.getVertexBuffer();
this._pVertexBuffer.freeVertexData(this);
if ((pOldVertexBuffer.getEmptyVertexData(nCount, pVertexDeclaration, this)) !== (this)) {
return false;

}

if ((this.getOffset()) != iOldOffset) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexData.js") + "][") + "") + "]") + ((("vertex data moved from " + iOldOffset) + " ---> ") + (this.getOffset())));

}

return true;

}


}
else if ((arguments.length) == 1) {
if (nCount <= (this.length)) {
this._nMemberCount = nCount;
return true;

}
else  {
var pOldVertexBuffer=this.getVertexBuffer();
var pOldVertexDeclaration=this.getVertexDeclaration();
var iOldStride=this.getStride();
this._pVertexBuffer.freeVertexData(this);
if ((pOldVertexBuffer.getEmptyVertexData(nCount, iOldStride, this)) == null) {
return false;

}

this.setVertexDeclaration(pOldVertexDeclaration);
if ((this.getOffset()) != iOldOffset) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexData.js") + "][") + "") + "]") + ((("vertex data moved from " + iOldOffset) + " ---> ") + (this.getOffset())));

}

return true;

}


}


return false;

};
VertexData.prototype.setData = function(pData, iOffset, iSize, nCountStart, nCount) {
switch(arguments.length) {
case 5:
var iStride=this.getStride();
if (iStride != iSize) {
if ((this._pVertexBuffer.isRAMBufferPresent()) && (nCount > 1)) {
var pBackupBuf=new Uint8Array(this._pVertexBuffer.getData());
var pDataU8=new Uint8Array(pData.buffer);
var k;
var iOffsetBuffer=this.getOffset();
for (var i=nCountStart; i < (nCount + nCountStart); i++) {
for (k = 0; k < iSize; k++) {
pBackupBuf[(((iStride * i) + iOffset) + iOffsetBuffer) + k] = pDataU8[(iSize * (i - nCountStart)) + k];

}


}

this._pVertexBuffer.setData(pBackupBuf.buffer, 0, this._pVertexBuffer.size);

}
else  {
for (var i=nCountStart; i < (nCount + nCountStart); i++) {
this._pVertexBuffer.setData(pData.buffer.slice(iSize * (i - nCountStart), (iSize * (i - nCountStart)) + iSize), ((iStride * i) + iOffset) + (this.getOffset()), iSize);

}


}


}
else  {
this._pVertexBuffer.setData(pData.buffer.slice(0, iStride * nCount), iOffset + (this.getOffset()), iStride * nCount);

}

return true;

case 4:
var pDeclaration=this._pVertexDeclaration, pElement=null;
if ((typeof (arguments[1])) == "string") {
pElement = pDeclaration.element(arguments[1]);
if (pElement) {
return this.setData(pData, pElement.iOffset, pElement.iSize, arguments[2], arguments[3]);

}

return false;

}

nCountStart = nCountStart || 0;
if (!nCount) {
nCount = (pData.buffer.byteLength) / iSize;

}

return this.setData(pData, iOffset, iSize, nCountStart, nCount);

case 2:
;

case 3:
var pDeclaration=this._pVertexDeclaration, pElement=null;
if ((typeof (arguments[1])) == "string") {
pElement = pDeclaration.element(arguments[1]);
if (pElement) {
arguments[2] = (arguments[2]) || 0;
if (!(arguments[3])) {
arguments[3] = (pData.buffer.byteLength) / (pElement.iSize);

}

return this.setData(pData, pElement.iOffset, pElement.iSize, arguments[2], arguments[3]);

}

return false;

}
else if ((arguments.length) === 3) {
nCountStart = nCountStart || 0;
if (!nCount) {
nCount = (pData.byteLength) / iSize;

}

return this.setData(pData, iOffset, iSize, nCountStart, nCount);

}


return false;

case 1:
return this.setData(pData, this._pVertexDeclaration[0].eUsage);

default:
return false;
}

};
VertexData.prototype.getTypedData = function(eUsage, iFrom, iCount) {
eUsage = eUsage || (this._pVertexDeclaration[0].eUsage);
var pVertexElement=this._pVertexDeclaration.element(eUsage);
if (pVertexElement) {
return this.getData(eUsage, iFrom, iCount).toTypedArray(pVertexElement.eType);

}

return null;

};
VertexData.prototype.getData = function(iOffset, iSize, iFrom, iCount) {
switch(arguments.length) {
case 4:
;

case 2:
if ((typeof (arguments[0])) === "string") {
return null;

}

iFrom = iFrom || 0;
iCount = iCount || (this._nMemberCount);
iCount = Math.min(iCount, this._nMemberCount);
var iStride=this.getStride();
var pBufferData=new Uint8Array(iSize * (this.getCount()));
for (var i=iFrom; i < iCount; i++) {
pBufferData.set(new Uint8Array(this._pVertexBuffer.getData(((iStride * i) + iOffset) + (this.getOffset()), iSize)), i * iSize);

}

return pBufferData.buffer;

case 3:
;

case 1:
var pDeclaration=this._pVertexDeclaration, pElement=null;
if ((typeof (arguments[0])) == "string") {
pElement = pDeclaration.element(arguments[0]);
if (pElement) {
return this.getData(pElement.iOffset, pElement.iSize, arguments[1], arguments[2]);

}

return null;

}

return null;

case 0:
return this.getData(0, this._pVertexDeclaration.stride);

default:
return null;
}

};
VertexData.prototype.activate = function() {
this._pVertexBuffer.activate();
return true;

};
VertexData.prototype.setVertexDeclaration = function(pVertexDeclaration) {
if (!(!(this._pVertexDeclaration))) {
var err=((((((("Error:: " + "pVertexDeclaration уже выставлен") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("pVertexDeclaration уже выставлен");

}


}

;
var iStride=0;
var nVertexElementCount;
this._pVertexDeclaration = pVertexDeclaration.clone();
iStride = this._pVertexDeclaration.stride;
if (!(iStride < (256))) {
var err=((((((("Error:: " + "stride max is 255 bytes") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("stride max is 255 bytes");

}


}

;
if (!(iStride <= (this.getStride()))) {
var err=((((((("Error:: " + "stride in VertexDeclaration больше чем stride in construtor") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VertexData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("stride in VertexDeclaration больше чем stride in construtor");

}


}

;
return true;

};
VertexData.prototype.getStride = function() {
return this._iStride;

};
VertexData.prototype.getCount = function() {
return this._nMemberCount;

};
VertexData.prototype.getVertexElementCount = function() {
return this._pVertexDeclaration.length;

};
VertexData.prototype.getVertexDeclaration = function() {
return this._pVertexDeclaration;

};
VertexData.prototype.hasSemantics = function(eSemantics) {
if ((this._pVertexDeclaration) != null) {
return this._pVertexDeclaration.hasSemantics(eSemantics);

}

return false;

};
VertexData.prototype.resourceHandle = function() {
return this._pVertexBuffer.resourceHandle();

};
VertexData.prototype.toString = function() {
"use strict";
var s="";
s += ("          VERTEX DATA  #" + (this.toNumber())) + "\n";
s += "---------------+-----------------------\n";
s += ("        BUFFER : " + (this.resourceHandle())) + "\n";
s += ("          SIZE : " + (this.size)) + " b.\n";
s += ("        OFFSET : " + (this.getOffset())) + " b.\n";
s += "---------------+-----------------------\n";
s += (" MEMBERS COUNT : " + (this.getCount())) + " \n";
s += ("        STRIDE : " + (this.getStride())) + " \n";
s += "---------------+-----------------------\n";
s += this.getVertexDeclaration().toString();
return s;

};
a["VertexData"] = VertexData;
function alignBytes(iByteSize, iTypeSize) {
var m=iByteSize % iTypeSize;
return (m? iByteSize + (iTypeSize - (iByteSize % iTypeSize)) : iByteSize);

}

;
function VideoBuffer(pEngine) {
var _pCtorValue=VideoBuffer.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pUpdateEffect = null;
this._pRepackEffect = null;
this._pHeader = null;
this._pSystemVertexDataVB = null;
this._initSystemStorageVB(pEngine);

}

a.extend(VideoBuffer, a.VBufferBase, a.Texture);
a.defineProperty(VideoBuffer, "buffer", function() {
return this._pTexture;

}
);
a.defineProperty(VideoBuffer, "size", function() {
return (((this._iWidth) * (this._iHeight)) * (this._numElementsPerPixel)) * (this.typeSize);

}
);
a.defineProperty(VideoBuffer, "_numElementsPerPixel", function() {
return this.constructor.superclasses["Texture"].__lookupGetter__("numElementsPerPixel").apply(this);

}
);
VideoBuffer.prototype.getMipLevels = undefined;
VideoBuffer.prototype.getPixelRGBA = undefined;
VideoBuffer.prototype.setPixelRGBA = undefined;
VideoBuffer.prototype.generateNormalMap = undefined;
VideoBuffer.prototype.generateNormalizationCubeMap = undefined;
VideoBuffer.prototype.maskWithImage = undefined;
VideoBuffer.prototype.convertToNormalMap = undefined;
VideoBuffer.prototype.getSurfaceLevel = undefined;
VideoBuffer.prototype.uploadCubeFace = undefined;
VideoBuffer.prototype.uploadImage = undefined;
VideoBuffer.prototype.resize = undefined;
VideoBuffer.prototype.extend = undefined;
VideoBuffer.prototype.repack = undefined;
VideoBuffer.prototype.createTexture = undefined;
VideoBuffer.prototype.createCubeTexture = undefined;
VideoBuffer.prototype.convertToNormalMap = undefined;
a.defineProperty(VideoBuffer, "texture", undefined, undefined);
a.defineProperty(VideoBuffer, "height", undefined, undefined);
a.defineProperty(VideoBuffer, "width", undefined, undefined);
a.defineProperty(VideoBuffer, "numElementsPerPixel", undefined, undefined);
a.defineProperty(VideoBuffer, "type", undefined, undefined);
a.defineProperty(VideoBuffer, "format", undefined, undefined);
a.defineProperty(VideoBuffer, "magFilter", undefined, undefined);
a.defineProperty(VideoBuffer, "minFilter", undefined, undefined);
VideoBuffer.prototype._initSystemStorageVB = function(pEngine) {
this._pEngine = pEngine;
var pBuffer, pData, pMethod, pEffect;
if (pEngine._pSystemVertexDataVB) {
this._pSystemVertexDataVB = pEngine._pSystemVertexDataVB;
pMethod = pEngine.pDisplayManager.renderMethodPool().findResource(".update_video_buffer");
this.addRenderMethod(pMethod, ".update_video_buffer");
return true;

}

pBuffer = pEngine.pDisplayManager.vertexBufferPool().createResource(".VERTEXBUFFER");
if (!pBuffer.create(0, 1 << 3)) {
var err=((((((("Error:: " + "Cannot create system vertex buffer") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VideoBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Cannot create system vertex buffer");

}


}

;
pData = pBuffer.getEmptyVertexData(0, [new Object( {nCount: 1, eType: 5126, eUsage: "INDEX", iOffset: undefined}), new Object( {nCount: 1, eType: 5126, eUsage: "SHIFT", iOffset: undefined}), new Object( {nCount: 4, eType: 5126, eUsage: "VALUE", iOffset: undefined})]);
pEngine._pSystemVertexDataVB = this._pSystemVertexDataVB = pData;
pMethod = pEngine.pDisplayManager.renderMethodPool().createResource(".update_video_buffer");
pEffect = pEngine.pDisplayManager.effectPool().createResource(".update_video_buffer");
pEffect.create();
pEffect.use("akra.system.update_video_buffer");
pMethod.effect = pEffect;
this.addRenderMethod(pMethod, ".update_video_buffer");
return true;

};
VideoBuffer.prototype.create = function(iByteSize, iFlags, pData) {
iByteSize = iByteSize || 0;
iFlags = iFlags || 0;
var pSize, pTextureData, pHeader;
if (!((this._pBuffer) == null)) {
var err=((((((("Error:: " + "buffer already allocated") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VideoBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("buffer already allocated");

}


}

;
if (!((this._pBackupCopy) == null)) {
var err=((((((("Error:: " + "backup buffer already allocated") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VideoBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("backup buffer already allocated");

}


}

;
iFlags |= 1 << 5;
iByteSize = Math.max(iByteSize, 4096);
if (!(!((iFlags & (1 << 4)) != 0))) {
var err=((((((("Error:: " + "no sftware rendering") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VideoBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("no sftware rendering");

}


}

;
if ((iFlags & (1 << 3)) != 0) {
iFlags |= 1 << 2;

}

if ((iFlags & (1 << 2)) != 0) {
iFlags |= 1 << 3;

}

if (pData) {
if (!((pData.byteLength) <= iByteSize)) {
var err=((((((("Error:: " + "The size of the array passed more than passed the size of the buffer.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VideoBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The size of the array passed more than passed the size of the buffer.");

}


}

;

}

if ((iFlags & (1 << 3)) != 0) {
this._pBackupCopy = new Uint8Array(iByteSize);
if (pData) {
this._pBackupCopy.set(new Uint8Array(pData.buffer), 0);

}


}

pSize = a.calcPOTtextureSize((alignBytes(iByteSize, this.typeSize)) / (Float32Array.BYTES_PER_ELEMENT), this._numElementsPerPixel);
pTextureData = new Float32Array(pSize[2]);
if (pData) {
new Uint8Array(pTextureData.buffer).set(new Uint8Array(pData.buffer));

}

if (!(this.constructor.superclasses["Texture"].createTexture.call(this, pSize[0], pSize[1], 0, 6408, 5126, pTextureData))) {
if (!0) {
var err=((((((("Error:: " + "Cannot create video buffer.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VideoBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Cannot create video buffer.");

}


}

;
this.destroy();
return false;

}

this.wraps = 33071;
this.wrapt = 33071;
this.minFilter = 9728;
this.magFilter = 9728;
this._pBuffer = this._pTexture;
this._iByteSize = iByteSize;
this._iTypeFlags = iFlags;
this._pHeader = this.allocateData([new Object( {nCount: 2, eType: 5126, eUsage: "TEXTURE_HEADER", iOffset: undefined})], this._header(pSize[0], pSize[1]));
this.notifyLoaded();
this.notifyRestored();
return true;

};
VideoBuffer.prototype.resize = function(iByteSize) {
var pSize, pBackupCopy;
iByteSize = alignBytes(iByteSize, this.typeSize);
pSize = a.calcPOTtextureSize(iByteSize / (Float32Array.BYTES_PER_ELEMENT), this._numElementsPerPixel);
if ((this._iTypeFlags & (1 << 3)) != 0) {
pBackupCopy = new Uint8Array((((pSize[0]) * (pSize[1])) * (this._numElementsPerPixel)) * (this.typeSize));
pBackupCopy.set(this._pBackupCopy);
this._pBackupCopy = pBackupCopy;

}

if (((pSize[0]) <= (this._iWidth)) && ((pSize[1]) <= (this._iHeight))) {
return true;

}

this.constructor.superclasses["Texture"].repack.call(this, pSize[0], pSize[1]);
this._pHeader.setData(this._header());
return true;

};
VideoBuffer.prototype.repack = function(iWidth, iHeight) {

};
VideoBuffer.prototype._header = function(iWidth, iHeight) {
iWidth = iWidth || (this._iWidth);
iHeight = iHeight || (this._iHeight);
var pHeader=new Float32Array(8);
pHeader[0] = iWidth;
pHeader[1] = iHeight;
pHeader[2] = 1 / iWidth;
pHeader[3] = 1 / iHeight;
pHeader[4] = iWidth * iHeight;
pHeader[5] = (pHeader[4]) * (this._numElementsPerPixel);
return pHeader;

};
VideoBuffer.prototype.setData = function(pData, iOffset, iSize, bUpdateRamCopy) {
"use strict";
var iTypeSize=this.typeSize, nElementsPerPix=this.numElementsPerPixel, iFrom, iCount, pBufferData;
var iLeftShift, iRightShift, iBeginPix, iEndPix, nPixels, nElements;
bUpdateRamCopy = (bUpdateRamCopy === undefined? true : bUpdateRamCopy);
iOffset = iOffset || 0;
iSize = iSize || (pData.byteLength);
if ((this.size) < (iOffset + iSize)) {
this.resize(iOffset + iSize);

}

if ((this.isRAMBufferPresent()) && bUpdateRamCopy) {
this._pBackupCopy.set(new Uint8Array(pData.slice(0, iSize)), iOffset);

}

if (!(((iOffset % iTypeSize) === 0) && ((iSize % iTypeSize) === 0))) {
var err=((((((("Error:: " + "Incorrect data size or offset") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VideoBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Incorrect data size or offset");

}


}

;
iFrom = iOffset / iTypeSize;
iCount = iSize / iTypeSize;
iLeftShift = iFrom % nElementsPerPix;
iRightShift = (iFrom + iCount) % nElementsPerPix;
iBeginPix = Math.floor(iFrom / nElementsPerPix);
iEndPix = Math.floor((iFrom + iCount) / nElementsPerPix);
nPixels = (Math.ceil((iFrom + iCount) / nElementsPerPix)) - (Math.floor(iFrom / nElementsPerPix));
nElements = nPixels * nElementsPerPix;
pBufferData = new Float32Array(pData.slice(0, iSize));
if ((iLeftShift === 0) && (iRightShift === 0)) {
var iWidth=this.width;
var iYmin=Math.floor(iBeginPix / iWidth);
var iYmax=Math.ceil(iEndPix / iWidth);
var iXbegin=iBeginPix % iWidth;
var iXend=iEndPix % iWidth;
var iHeight=iYmax - iYmin;
var iBeginElement=0, iEndElement=0;
var pParent=this.constructor.superclasses["Texture"];
var me=this;
iXend = (iXend === 0? iWidth : iXend);
var fnWriteRect=function(iX, iY, iW, iH) {
iBeginElement = iEndElement;
iEndElement = ((iW * iH) * nElementsPerPix) + iEndElement;
pParent.setPixelRGBA.call(me, iX, iY, iW, iH, new Float32Array(pBufferData.subarray(iBeginElement, iEndElement)));

};
if (iHeight === 1) {
fnWriteRect(iXbegin, iYmin, iXend - iXbegin, 1);

}
else  {
fnWriteRect(iXbegin, iYmin, iWidth - iXbegin, 1);
if (iHeight > 2) {
fnWriteRect(0, iYmin + 1, iWidth, iHeight - 2);

}

fnWriteRect(0, iYmax - 1, iXend, 1);

}


}
else if (this.isReadable()) {
var iRealOffset=(iBeginPix * nElementsPerPix) * iTypeSize;
var iRealSize=nElements * iTypeSize;
var iTotalSize=iRealOffset + iRealSize;
return this.setData(this._pBackupCopy.buffer.slice(iRealOffset, iTotalSize), iRealOffset, iRealSize, false);

}
else  {
var pMarkupDataIndex=new Float32Array(nPixels);
var pMarkupDataShift=new Float32Array(nPixels);
var pRealData=new Float32Array(nElements);
pMarkupDataIndex[0] = iBeginPix;
pMarkupDataShift[0] = iLeftShift;
pMarkupDataIndex[nPixels - 1] = (iBeginPix + nPixels) - 1;
pMarkupDataShift[nPixels - 1] = -iRightShift;
for (var i=1; i < (nPixels - 1); ++i) {
pMarkupDataIndex[i] = iBeginPix + i;

}

for (var i=0; i < iCount; i++) {
pRealData[iLeftShift + i] = pBufferData[i];

}

var pDevice=this._pEngine.pDevice;
var pVertexData=this._pSystemVertexDataVB;
pVertexData.resize(nPixels);
pVertexData.setData(pRealData, "VALUE");
pVertexData.setData(pMarkupDataIndex, "INDEX");
pVertexData.setData(pMarkupDataShift, "SHIFT");
this.switchRenderMethod(".update_video_buffer");
var pManager=this._pEngine.shaderManager();
var pSnapshot=this._pActiveSnapshot;
var pEntry=null;
trace("<<<<<<<<<<<<<VIDEO BUFFER SET DATA RENDER>>>>>>>>>>>>>>>>");
pManager.setViewport(0, 0, this._iWidth, this._iHeight);
pManager.activateFrameBuffer();
pManager.applyFrameBufferTexture(this);
this.startRender();
for (var i=0; i < (this.totalPasses()); i++) {
trace("Pass #" + i);
this.activatePass(i);
pSnapshot.applyTextureBySemantic("TEXTURE0", this);
pSnapshot.applyVertexData(pVertexData, 0);
pSnapshot.setParameter("size", [this._iWidth, this._iHeight]);
pEntry = this.renderPass();
this.deactivatePass();

}

this.finishRender();
pManager.deactivateFrameBuffer();
pManager.render(pEntry);
pDevice.flush();
trace("<<<<<<<<<<<<<END VIDEO BUFFER SET DATA RENDER>>>>>>>>>>>>>>>>");

}


;
return true;

};
VideoBuffer.prototype.getData = function(iOffset, iSize) {
if (!this._pBuffer) {
var err=((((((("Error:: " + "Buffer not created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VideoBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Buffer not created.");

}


}

;
if (!(((this._iTypeFlags & (1 << 3)) != 0) == true)) {
var err=((((((("Error:: " + "You can not give data unless they are stored locally.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/buffers/VideoBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("You can not give data unless they are stored locally.");

}


}

;
if ((arguments.length) === 0) {
return this._pBackupCopy.buffer;

}

return this._pBackupCopy.buffer.slice(iOffset, iOffset + iSize);

};
VideoBuffer.prototype.destroy = function() {
this.constructor.superclasses["Texture"].destroyResource.call(this);
this.freeVertexData();
this._pBuffer = null;
this._pBackupCopy = null;
this._pUpdateEffect = null;
this._iByteSize = undefined;
this._iTypeFlags = undefined;

};
VideoBuffer.prototype.destroyResource = function() {
this.destroy();
return true;

};
VideoBuffer.prototype.disableResource = function() {
this.constructor.superclasses["Texture"].disableResource.call(this);
this.notifyDisabled();
return true;

};
VideoBuffer.prototype.restoreResource = function() {
this.constructor.superclasses["Texture"].restoreResource.call(this);
this.notifyRestored();
return true;

};
VideoBuffer.prototype.loadResource = function() {
return false;

};
VideoBuffer.prototype.saveResource = function() {
return false;

};
VideoBuffer.prototype.createResource = function() {
this._pUpdateEffect = this._pEngine.pShaderManager.findEffect("akra:updateTexture");
this._pRepackEffect = this._pEngine.pShaderManager.findEffect("akra:repackTextureWithHeader");
this._eType = 5126;
this.notifyCreated();
this.notifyLoaded();
return true;

};
a.VideoBuffer = VideoBuffer;
function RenderMethod() {
var _pCtorValue=RenderMethod.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pEffect = null;
this._pMaterial = null;

}

a.extend(RenderMethod, a.ResourcePoolItem);
RenderMethod.prototype.isEqual = function(pRenderMethod) {
"use strict";
return ((this._pEffect) && (this._pEffect.isEqual(pRenderMethod._pEffect))) && ((this._pMaterial) && (this._pMaterial.isEqual(pRenderMethod._pMaterial)));

};
a.defineProperty(RenderMethod, "effect", function() {
return this._pEffect;

}
, function(pValue) {
var pEffect=null;
if (this._pEffect) {
this.disconnect(this._pEffect, 1);
if (this._pEffect) {
var safe_release_refcount=this._pEffect.release();
if (safe_release_refcount != 0) {
if (!0) {
var err=((((((("Error:: " + (("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/RenderMethod.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n"));

}


}

;

}

this._pEffect = 0;

}

;

}

if ((typeof pValue) === "string") {
pEffect = this._pEngine.pDisplayManager.effectPool().loadResource(pValue);

}
else if (pValue) {
pEffect = pValue;

}
else  {
pEffect = this._pEngine.pDisplayManager.effectPool().createResource("effect-" + (a.sid()));

}


this._pEffect = pEffect;
this.connect(this._pEffect, 1);
this.connect(this._pEffect, 3);
this.notifyAltered();
pEffect.addRef();

}
);
a.defineProperty(RenderMethod, "material", function() {
return this._pMaterial;

}
, function(pValue) {
var pMaterial=null;
if (this._pMaterial) {
this.disconnect(this._pMaterial, 1);
if (this._pMaterial) {
var safe_release_refcount=this._pMaterial.release();
if (safe_release_refcount != 0) {
if (!0) {
var err=((((((("Error:: " + (("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/RenderMethod.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n"));

}


}

;

}

this._pMaterial = 0;

}

;

}

if ((typeof pValue) === "string") {
pMaterial = this._pEngine.pDisplayManager.surfaceMaterialPool().loadResource(pValue);

}
else if (pValue) {
pMaterial = pValue;

}
else  {
pMaterial = this._pEngine.pDisplayManager.surfaceMaterialPool().createResource("material-" + (a.sid()));

}


this._pMaterial = pMaterial;
this.connect(pMaterial, 1);
pMaterial.addRef();

}
);
RenderMethod.prototype.setEffect = function(pEffect) {
this.effect = pEffect || null;

};
RenderMethod.prototype.setMaterial = function(pMaterial) {
this.material = pMaterial || null;

};
RenderMethod.prototype.createResource = function() {
if (!(!(this.isResourceCreated()))) {
var err=((((((("Error:: " + "The resource has already been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/RenderMethod.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has already been created.");

}


}

;
this.notifyCreated();
return true;

};
RenderMethod.prototype.destroyResource = function() {
if (this._pEffectList) {
var safe_release_refcount=this._pEffectList.release();
if (safe_release_refcount != 0) {
if (!0) {
var err=((((((("Error:: " + (("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/RenderMethod.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n"));

}


}

;

}

this._pEffectList = 0;

}

;
if (this._pMaterialList) {
var safe_release_refcount=this._pMaterialList.release();
if (safe_release_refcount != 0) {
if (!0) {
var err=((((((("Error:: " + (("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/RenderMethod.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n"));

}


}

;

}

this._pMaterialList = 0;

}

;
if (this.isResourceCreated()) {
this.disableResource();
this.notifyUploaded();
this.notifyDestroyed();
return true;

}

return false;

};
RenderMethod.prototype.restoreResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/RenderMethod.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyRestored();
return true;

};
RenderMethod.prototype.disableResource = function() {
if (!this.isResourceCreated()) {
var err=((((((("Error:: " + "The resource has not been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/RenderMethod.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has not been created.");

}


}

;
this.notifyDisabled();
return true;

};
RenderMethod.prototype.loadResource = function(sFileName) {
return false;

};
RenderMethod.prototype.saveResource = function(sFileName) {
return false;

};
a["RenderMethod"] = RenderMethod;
function RenderData(pBuffer) {
;
this._eOptions = 0;
this._pBuffer = pBuffer || null;
this._iId = -1;
this._pIndexBuffer = null;
this._pAttribBuffer = null;
this._pIndexData = null;
this._pAttribData = null;
this._pMap = null;
this._pIndicesArray = [];
this._iIndexSet = 0;
this._iRenderable = 1;

}

a.extend(RenderData, a.ReferenceCounter);
a.defineProperty(RenderData, "buffer", function() {
return this._pBuffer;

}
);
RenderData.prototype.setup = function(pBuffer, iId, ePrimType, eOptions) {
if (((this._pBuffer) === null) && ((arguments.length) < 2)) {
return false;

}

this.renderable(true);
this._eOptions |= eOptions;
this._pBuffer = pBuffer;
this._iId = iId;
this._pMap = new a.BufferMap(pBuffer.getEngine());
this._pMap.primType = (ePrimType === undefined? 4 : ePrimType);
this._pMap._pI2IDataCache =  {};
this._pIndicesArray.push( {pMap: this._pMap, pIndexData: null, pAttribData: null, sName: ".main"});
if (!((this.useSingleIndex()) === false)) {
var err=((((((("Error:: " + "single indexed data not implimented") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("single indexed data not implimented");

}


}

;
return true;

};
RenderData.prototype.renderable = function(bValue) {
(bValue? this._eOptions |= 262144 : this._eOptions &= ~262144);

};
RenderData.prototype.isRenderable = function() {
return ((this._eOptions) & (262144)? true : false);

};
RenderData.prototype._allocateData = function(pDataDecl, pData, eType) {
"use strict";
if (eType === (3)) {
return this.allocateAttribute(pDataDecl, pData);

}

var iFlow;
var pVertexData=this._pBuffer._allocateData(pDataDecl, pData);
var iOffset=pVertexData.getOffset();
iFlow = this._addData(pVertexData, undefined, eType);
if (iFlow < 0) {
trace("invalid data", pDataDecl, pData);
debug_assert("cannot allocate data for submesh");
return -1;

}

return iOffset;

};
RenderData.prototype._addData = function(pVertexData, iFlow, eType) {
"use strict";
if ((((arguments.length) < 3) && (this.useAdvancedIndex())) || ((arguments[2]) === (2))) {
return this._registerData(pVertexData);

}

return (iFlow === undefined? this._pMap.flow(pVertexData) : this._pMap.flow(iFlow, pVertexData));

};
RenderData.prototype._registerData = function(pVertexData) {
"use strict";
var iOffset=pVertexData.getOffset();
var pDataDecl=pVertexData.getVertexDeclaration();
for (var i=0; i < (pDataDecl.length); i++) {
this._pMap._pI2IDataCache[pDataDecl[i].eUsage] = iOffset;

}

;
return 0;

};
RenderData.prototype.allocateData = function(pDataDecl, pData, hasIndex) {
"use strict";
var eType=1;
hasIndex = (hasIndex === undefined? true : hasIndex);
if ((!hasIndex) || (this.useSingleIndex())) {
eType = 3;

}
else if (this.useAdvancedIndex()) {
eType = 2;

}


return this._allocateData(pDataDecl, pData, eType);

};
RenderData.prototype.useAdvancedIndex = function() {
"use strict";
return ((this._eOptions) & (65536)) != 0;

};
RenderData.prototype.useSingleIndex = function() {
"use strict";
return ((this._eOptions) & (131072)) != 0;

};
RenderData.prototype.useMultiIndex = function() {
"use strict";
return ((this._eOptions) & (131072)) == 0;

};
RenderData.prototype.releaseData = function(iDataLocation) {
"use strict";

};
RenderData.prototype.allocateAttribute = function(pAttrDecl, pData) {
"use strict";
var pIndexData=this._pIndexData;
var pAttribData=this._pAttribData;
var pAttribBuffer=this._pAttribBuffer;
var pBuffer=this._pBuffer;
if (!pAttribData) {
if (!pAttribBuffer) {
pAttribBuffer = pBuffer.getEngine().displayManager().vertexBufferPool().createResource("render_data_attrs_" + (a.sid()));
pAttribBuffer.create(0, 1 << 3);
this._pAttribBuffer = pAttribBuffer;

}

this._pAttribData = this._pAttribBuffer.allocateData(pAttrDecl, pData);
this._pIndicesArray[this._iIndexSet].pAttribData = this._pAttribData;
this._pMap.flow(this._pAttribData);
return (this._pAttribData) !== null;

}

if (!(pAttribData.extend(pAttrDecl, pData))) {
trace("invalid data for allocation:", arguments);
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderData.js") + "][") + "") + "]") + "cannot allocate attribute in data subset..");
return false;

}

return true;

};
RenderData.prototype._allocateAdvancedIndex = function(pAttrDecl, pData) {
"use strict";
var pDecl=a.normalizeVertexDecl(pAttrDecl);
var nCount=(pData.byteLength) / (pDecl.iStride);
var iIndLoc=this._allocateData(pAttrDecl, pData, 1);
var pI2IData=new Float32Array(nCount);
var pI2IDecl=[];
for (var i=0; i < (pDecl.length); i++) {
pI2IDecl.push(new Object( {nCount: 1, eType: 5126, eUsage: ("INDEX_" + (pDecl[i].eUsage)), iOffset: 0}));

}

;
for (var i=0; i < (pI2IData.length); i++) {
pI2IData[i] = i;

}

;
if (!(this._allocateIndex(pI2IDecl, pI2IData))) {
this.releaseData(iIndLoc);
pI2IData = null;
pI2IDecl = null;
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderData.js") + "][") + "") + "]") + "cannot allocate index for index in render data subset");
return false;

}

return true;

};
RenderData.prototype._createIndex = function(pAttrDecl, pData) {
"use strict";
if (!(this._pIndexBuffer)) {
if (this.useMultiIndex()) {
this._pIndexBuffer = this._pBuffer.getEngine().displayManager().vertexBufferPool().createResource("subset_" + (a.sid()));
this._pIndexBuffer.create(0, 1 << 3);

}
else  {

}


}

this._pIndexData = this._pIndexBuffer.allocateData(pAttrDecl, pData);
this._pIndexData._iAdditionCache =  {};
this._pIndicesArray[this._iIndexSet].pIndexData = this._pIndexData;
return (this._pIndexData) !== null;

};
RenderData.prototype._allocateIndex = function(pAttrDecl, pData) {
"use strict";
var pIndexData=this._pIndexData;
var pIndexBuffer=this._pIndexBuffer;
var pBuffer=this._pBuffer;
for (var i=0; i < (pAttrDecl.length); i++) {
if ((pAttrDecl[i].eType) !== (5126)) {
return false;

}


}

;
if (!(this._pIndexData)) {
return this._createIndex(pAttrDecl, pData);

}

if (!(this._pIndexData.extend(pAttrDecl, pData))) {
trace("invalid data for allocation:", arguments);
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderData.js") + "][") + "") + "]") + "cannot allocate index in data subset..");
return false;

}

return true;

};
RenderData.prototype.allocateIndex = function(pAttrDecl, pData) {
if (this.useAdvancedIndex()) {
return this._allocateAdvancedIndex(pAttrDecl, pData);

}

return this._allocateIndex(pAttrDecl, pData);

};
RenderData.prototype.addIndexSet = function(usePreviousDataSet, ePrimType, sName) {
"use strict";
usePreviousDataSet = (usePreviousDataSet === undefined? true : usePreviousDataSet);
if (usePreviousDataSet) {
this._pMap = this._pMap.clone(false);
if (!(this._pMap)) {
return -1;

}


}
else  {
this._pMap = new a.BufferMap(this._pBuffer.getEngine());
this._pAttribData = null;

}

this._pMap.primType = (ePrimType === undefined? 4 : ePrimType);
this._pIndexData = null;
this._iIndexSet = this._pIndicesArray.length;
this._pIndicesArray.push( {pMap: this._pMap, pIndexData: this._pIndexData, pAttribData: this._pAttribData, sName: sName});
return this._iIndexSet;

};
RenderData.prototype.getNumIndexSet = function() {
return this._pIndicesArray.length;

};
RenderData.prototype.getIndexSetName = function(iSet) {
iSet = (iSet === undefined? this._iIndexSet : iSet);
return this._pIndicesArray[iSet].sName;

};
RenderData.prototype.selectIndexSet = function(iSet) {
var pIndexSet=this._pIndicesArray[iSet];
if (pIndexSet) {
this._pMap = pIndexSet.pMap;
this._pIndexData = pIndexSet.pIndexData;
this._pAttribData = pIndexSet.pAttribData;
this._iIndexSet = iSet;
return true;

}

return false;

};
RenderData.prototype.getIndexSet = function() {
"use strict";
return this._iIndexSet;

};
RenderData.prototype.setRenderable = function(iIndexSet, bValue) {
"use strict";
iIndexSet = (iIndexSet === undefined? this.getIndexSet() : iIndexSet);
bValue = (bValue === undefined? true : bValue);
(bValue? this._iRenderable |= 1 << iIndexSet : this._iRenderable &= ~(1 << iIndexSet));
return true;

};
RenderData.prototype.isRenderable = function(iIndexSet) {
"use strict";
iIndexSet = (iIndexSet === undefined? this.getIndexSet() : iIndexSet);
return (this._iRenderable & (1 << iIndexSet)) != 0;

};
RenderData.prototype.hasSemantics = function(sSemantics, bSearchComplete) {
"use strict";
return (this.getFlow(sSemantics, bSearchComplete)) !== null;

};
RenderData.prototype.getDataLocation = function(sSemantics) {
"use strict";
var pData=this.getData(sSemantics);
return (pData? pData.getOffset() : -1);

};
RenderData.prototype.getIndices = function() {
"use strict";
return this._pIndexData;

};
RenderData.prototype.getFlow = function() {
"use strict";
if ((typeof (arguments[0])) === "string") {
return this._pMap.getFlow(arguments[0], arguments[1]);

}

for (var i=0, pFlows=this._pMap._pFlows, n=pFlows.length; i < n; ++i) {
var pFlow=pFlows[i];
if ((pFlow.pData) && ((pFlow.pData.getOffset()) === (arguments[0]))) {
return pFlow;

}


}

return null;

};
RenderData.prototype.getData = function() {
"use strict";
var pFlow;
if ((this.useAdvancedIndex()) && ((arguments.length) < 2)) {
if ((typeof (arguments[0])) === "string") {
return this.getData(this._pMap._pI2IDataCache[arguments[0]]);

}

return this._pBuffer.getData(arguments[0]);

}

if ((typeof (arguments[0])) === "string") {
for (var i=0, pFlows=this._pMap._pFlows, n=pFlows.length; i < n; ++i) {
pFlow = pFlows[i];
if (((pFlow.pData) != null) && (pFlow.pData.hasSemantics(arguments[0]))) {
return pFlow.pData;

}


}

return null;

}

pFlow = this.getFlow(arguments[0]);
return (pFlow === null? null : pFlow.pData);

};
RenderData.prototype.getPrimitiveCount = function() {
"use strict";
return this._pMap.primCount;

};
RenderData.prototype.index = function(iData, eSemantics, useSame, iBeginWith) {
"use strict";
iBeginWith = iBeginWith || 0;
useSame = useSame || false;
var iFlow=-1;
var iAddition, iRealAddition, iPrevAddition;
var pFlow;
var pData, pRealData;
var iIndexOffset;
var pIndexData=this._pIndexData;
var sData;
var iStride;
var iTypeSize=4;
if (this.useAdvancedIndex()) {
pRealData = this.getData(iData);
iAddition = pRealData.getOffset();
iStride = pRealData.stride;
pData = this.getData(eSemantics, true);
pData.applyModifier(eSemantics, function(pTypedData) {
for (var i=0; i < (pTypedData.length); i++) {
pTypedData[i] = (((pTypedData[i]) * iStride) + iAddition) / iTypeSize;

}

;

}
);
iData = pData.getOffset();
eSemantics = "INDEX_" + eSemantics;

}
else if ((typeof (arguments[0])) === "string") {
if ((arguments[0]) === "TEXCOORD") {
iData = "TEXCOORD0";

}

iData = this.getDataLocation(iData);
if (!(iData >= 0)) {
var err=((((((("Error:: " + ("cannot find data with semantics: " + (arguments[0]))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderData.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("cannot find data with semantics: " + (arguments[0])));

}


}

;

}


pFlow = this.getFlow(iData);
if (pFlow === null) {
return false;

}

iFlow = pFlow.iFlow;
iIndexOffset = pIndexData._pVertexDeclaration.element(eSemantics).iOffset;
pData = pIndexData.getTypedData(eSemantics);
iAddition = iData;
if (!pData) {
return false;

}

iStride = pFlow.pData.stride;
if ((pIndexData._iAdditionCache[iIndexOffset]) !== iAddition) {
if (!useSame) {
iPrevAddition = (pIndexData._iAdditionCache[iIndexOffset]) || 0;
iRealAddition = iAddition - iPrevAddition;
for (var i=0; i < (pData.length); i++) {
pData[i] = (((pData[i]) * iStride) + iRealAddition) / iTypeSize;

}

;

}
else  {
iRealAddition = iAddition;
for (var i=0; i < (pData.length); i++) {
pData[i] = (iBeginWith + iRealAddition) / iTypeSize;

}

;

}

pIndexData._iAdditionCache[iIndexOffset] = iAddition;
if (!(pIndexData.setData(pData, eSemantics))) {
return false;

}


}

return this._pMap.mapping(iFlow, pIndexData, eSemantics);

};
RenderData.prototype.draw = function() {
"use strict";
var isOK=true;
var bResult;
var i;
for (i = 0; i < (this._pIndicesArray.length); i++) {
if (this.isRenderable(i)) {
this._pBuffer._pEngine.shaderManager().getActiveProgram().applyBufferMap(this._pIndicesArray[i].pMap);
bResult = this._pIndicesArray[i].pMap.draw();
isOK = isOK && bResult;

}


}

return isOK;

};
RenderData.prototype.applyMe = function() {
var pManager=this._pBuffer._pEngine.shaderManager();
if (!pManager) {
return false;

}

return pManager.applyBufferMap(this._pMap);

};
RenderData.prototype.toString = function() {
"use strict";
var s;
s = ("RENDER DATA SUBSET: #" + (this._iId)) + "\n";
s += ("        ATTRIBUTES: " + ((this._pAttribData? "TRUE" : "FALSE"))) + "\n";
s += "----------------------------------------------------------------\n";
s += this._pMap.toString();
return s;

};
a["RenderData"] = RenderData;
function RenderDataBuffer(pEngine) {
var _pCtorValue=RenderDataBuffer.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pDataBuffer = null;
this._pEngine = pEngine;
this._eDataOptions = 0;
this._pSubsetType = null;
this._pDataArray = [];

}

a.extend(RenderDataBuffer, a.ReferenceCounter);
a.defineProperty(RenderDataBuffer, "buffer", function() {
return this._pDataBuffer;

}
);
a.defineProperty(RenderDataBuffer, "dataType", function() {
return this._pSubsetType;

}
, function(pSubsetType) {
if (!((this._pSubsetType) === null)) {
var err=((((((("Error:: " + "subset type already set.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderDataBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("subset type already set.");

}


}

;
this._pSubsetType = pSubsetType;

}
);
RenderDataBuffer.prototype.getEngine = function() {
return this._pEngine;

};
RenderDataBuffer.prototype.getOptions = function() {
return this._eDataOptions;

};
RenderDataBuffer.prototype.getData = function() {
"use strict";
var pData;
if (this._pDataBuffer) {
pData = pData = this._pDataBuffer._pVertexDataArray;
if ((typeof (arguments[0])) === "string") {
for (var i=0; i < (pData.length); i++) {
if (pData[i].hasSemantics(arguments[0])) {
return pData[i];

}


}

;

}
else  {
for (var i=0; i < (pData.length); i++) {
if ((pData[i].getOffset()) === (arguments[0])) {
return pData[i];

}


}

;

}


}

return null;

};
RenderDataBuffer.prototype._allocateData = function(pVertexDecl, pData) {
"use strict";
if (!(this._pDataBuffer)) {
this._createDataBuffer();

}

pVertexDecl = normalizeVertexDecl(pVertexDecl);
var pVertexData;
if ((((arguments.length) < 2) || ((typeof (arguments[1])) === "number")) || (pData === null)) {
pVertexData = this._pDataBuffer.getEmptyVertexData(pData || 1, pVertexDecl);

}
else  {
pVertexData = this._pDataBuffer.allocateData(pVertexDecl, pData);

}

if (!(pVertexData !== null)) {
var err=((((((("Error:: " + ("cannot allocate data:\n" + (pVertexDecl.toString()))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderDataBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("cannot allocate data:\n" + (pVertexDecl.toString())));

}


}

;
return pVertexData;

};
RenderDataBuffer.prototype.allocateData = function(pDataDecl, pData, isCommon) {
isCommon = (isCommon === undefined? true : isCommon);
var pVertexData;
pDataDecl = normalizeVertexDecl(pDataDecl);
for (var i=0; i < (pDataDecl.length); i++) {
if (((this.getData(pDataDecl[i].eUsage)) !== null) && ((pDataDecl[i].nCount) !== 0)) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderDataBuffer.js") + "][") + "") + "]") + (("data buffer already contains data with similar vertex decloration <" + (pDataDecl[i].eUsage)) + ">."));

}


}

;
pVertexData = this._allocateData(pDataDecl, pData);
if (isCommon) {
for (var i=0; i < (this._pDataArray.length); ++i) {
this._pDataArray[i]._addData(pVertexData);

}


}

return pVertexData.getOffset();

};
RenderDataBuffer.prototype.getDataLocation = function(sSemantics) {
"use strict";
if (this._pDataBuffer) {
var pDataList=this._pDataBuffer._pVertexDataArray;
for (var i=0; i < (pDataList.length); i++) {
if (pDataList[i].hasSemantics(sSemantics)) {
return pDataList[i].getOffset();

}


}

;

}

return -1;

};
RenderDataBuffer.prototype._createDataBuffer = function() {
"use strict";
var iVbOption=0;
var iOptions=this._eDataOptions;
if (iOptions & (8)) {
iVbOption |= 1 << 1 << 2;

}

this._pDataBuffer = this._pEngine.pDisplayManager.videoBufferPool().createResource(("render_data_buffer" + "_") + (a.sid()));
this._pDataBuffer.create(0, iVbOption);
this._pDataBuffer.addRef();
return (this._pDataBuffer) !== null;

};
RenderDataBuffer.prototype.getRenderData = function(iSubset) {
"use strict";
return this._pDataArray[iSubset];

};
RenderDataBuffer.prototype.getEmptyRenderData = function(ePrimType, eOptions) {
if (!((this._pSubsetType) !== null)) {
var err=((((((("Error:: " + "subset type not specified.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderDataBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("subset type not specified.");

}


}

;
var iSubsetId=this._pDataArray.length;
var pDataset=new this._pSubsetType(this._pEngine);
eOptions |= this._eDataOptions;
if (!(pDataset.setup(this, iSubsetId, ePrimType, eOptions))) {
if (!0) {
var err=((((((("Error:: " + "cannot setup submesh...") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderDataBuffer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("cannot setup submesh...");

}


}

;

}

this._pDataArray.push(pDataset);
return pDataset;

};
RenderDataBuffer.prototype.draw = function(iSubset) {
"use strict";
if (iSubset !== undefined) {
return this._pDataArray[iSubset].draw();

}

for (var i=0; i < (this._pDataArray.length); i++) {
this._pDataArray[i].draw();

}

;
return true;

};
RenderDataBuffer.prototype.setup = function(eOptions) {
this._eDataOptions = eOptions;
if (!(this._pSubsetType)) {
this._pSubsetType = a.RenderData;

}


};
RenderDataBuffer.prototype.destroy = function() {
"use strict";
 {
if (this._pDataArray) {
for (var _s=0; _s < (this._pDataArray.length); ++_s) {
 {
if (this._pDataArray[_s]) {
if (this._pDataArray[_s].destructor) {
this._pDataArray[_s].destructor();

}

delete this._pDataArray[_s];
this._pDataArray[_s] = null;

}


};

}

delete this._pDataArray;
this._pDataArray = null;

}


};
if (this._pDataBuffer) {
this._pDataBuffer.relese();
this._pDataBuffer.destroy();
this._pDataBuffer = null;

}

this._pEngine = null;
this._eDataOptions = 0;
this._pSubsetType = null;

};
RenderDataBuffer.prototype.destructor = function() {
"use strict";
this.destroy();

};
a["RenderDataBuffer"] = RenderDataBuffer;
function RenderSnapshot() {
this._sName = null;
this._pRenderMethod = null;
this._pShaderManager = null;
this._iCurrentPass = (-1);
this._pPassStates = null;
this._pTextures = null;
this._isUpdated = false;
if (arguments.length) {
this.method = arguments[0];

}

var me=this;
this._fnModificationRoutine = function() {
if (this.isResourceAltered()) {
me._isUpdated = true;

}


};

}

RenderSnapshot.prototype.destructor = function() {
if (this._pRenderMethod) {
this._pRenderMethod.delChangesNotifyRoutine(this._fnModificationRoutine);

}

if (this._pRenderMethod) {
var safe_release_refcount=this._pRenderMethod.release();
if (safe_release_refcount != 0) {
if (!0) {
var err=((((((("Error:: " + (("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/render/RenderSnapshot.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n"));

}


}

;

}

this._pRenderMethod = 0;

}

;
 {
if (this._pPassStates) {
for (var _s=0; _s < (this._pPassStates.length); ++_s) {
 {
if (this._pPassStates[_s]) {
if (this._pPassStates[_s].destructor) {
this._pPassStates[_s].destructor();

}

delete this._pPassStates[_s];
this._pPassStates[_s] = null;

}


};

}

delete this._pPassStates;
this._pPassStates = null;

}


};

};
a.defineProperty(RenderSnapshot, "pass", function() {
return this._iCurrentPass;

}
, function(iPass) {
if (iPass > 0) {
this.activatePass(iPass);

}
else  {
this.deactivatePass();

}


}
);
a.defineProperty(RenderSnapshot, "name", function() {
return this._sName;

}
, function(sName) {
if (sName) {
this._sName = sName;

}


}
);
a.defineProperty(RenderSnapshot, "method", function() {
return this._pRenderMethod;

}
, function(pValue) {
var pMethod=null;
this.destructor();
if ((typeof pValue) === "string") {
pMethod = this._pEngine.pDisplayManager.renderMethodPool().loadResource(pValue);

}
else  {
pMethod = pValue;

}

this._pRenderMethod = pMethod;
this._sName = (this._sName) || (pMethod.findResourceName());
this._pShaderManager = pMethod.getEngine().shaderManager();
this._pRenderMethod.setChangesNotifyRoutine(this._fnModificationRoutine);
this._isUpdated = true;
pMethod.addRef();

}
);
a.defineProperty(RenderSnapshot, "surfaceMaterial", function() {
return this._pRenderMethod._pMaterial;

}
);
RenderSnapshot.prototype._updatePassStates = function() {

};
RenderSnapshot.prototype.setParameter = function(sName, pData, isSemantic) {
if (isSemantic) {
return this.setParameterBySemantic(sName, pData);

}

var sRealName=this._pShaderManager.getUniformRealName(sName);
if (!sRealName) {
return false;

}

var isBaseType=this._pShaderManager.isUniformTypeBase(sRealName);
if (isBaseType) {
return this.setParameterBySemantic(sRealName, pData);

}
else  {
var sParamName;
var bReturn=true;
for (var i in pData) {
sParamName = (sName + ".") + i;
bReturn &= this.setParameter(sParamName, pData[i]);

}

return bReturn;

}


};
RenderSnapshot.prototype.setParameterBySemantic = function(sRealName, pData) {
var isBaseType=this._pShaderManager.isUniformTypeBase(sRealName);
var pPass=this._pPassStates[this._iCurrentPass];
if (isBaseType && ((pPass[sRealName]) !== undefined)) {
pPass[sRealName] = pData;
return true;

}
else if (!isBaseType) {
var sName;
for (var i in pData) {
sName = (sRealName + ".") + i;
this.setParameterBySemantic(sName, pData[i]);

}


}


return false;

};
RenderSnapshot.prototype.setParameterInArray = function(sName, pData, iElement) {
var pPass=this._pPassStates[this._iCurrentPass];
if ((pPass[sName]) !== undefined) {
pPass[sName][iElement] = pData;
return true;

}

return false;

};
RenderSnapshot.prototype.setPassStates = function(pPasses, pTextures) {
this._pPassStates = pPasses;
this._pTextures = pTextures;

};
RenderSnapshot.prototype.activatePass = function(iPass) {
if (this._pShaderManager.activatePass(this, iPass)) {
this._iCurrentPass = iPass;
return true;

}

return false;

};
RenderSnapshot.prototype.deactivatePass = function() {
if (this._pShaderManager.deactivatePass(this)) {
this._iCurrentPass = (-1);
return true;

}

return false;

};
RenderSnapshot.prototype.renderPass = function(iPass) {
iPass = (iPass !== undefined? iPass : this._iCurrentPass);
if (iPass === (-1)) {
return false;

}

return this._pShaderManager.finishPass(iPass);

};
RenderSnapshot.prototype.isUpdated = function(isUpdate) {
if (isUpdate !== undefined) {
this._isUpdated = isUpdate;

}

return this._isUpdated;

};
RenderSnapshot.prototype.begin = function(pRenderObject) {
return this._pShaderManager.push(this, pRenderObject);

};
RenderSnapshot.prototype.end = function() {
return this._pShaderManager.pop(this);

};
RenderSnapshot.prototype.totalPasses = function() {
if ((!(this.method)) || (!(this.method.effect))) {
return 0;

}

return this.method.effect.totalPasses();

};
RenderSnapshot.prototype.prepareForRender = function() {
var pManager=this._pShaderManager;
pManager.prepareForRender();

};
RenderSnapshot.prototype.applySurfaceMaterial = function(pSurfaceMaterial) {
pSurfaceMaterial = pSurfaceMaterial || (this._pRenderMethod._pMaterial);
this._pShaderManager.applySurfaceMaterial(pSurfaceMaterial);

};
RenderSnapshot.prototype.applyCamera = function(pCamera) {
this._pShaderManager.applyCamera(pCamera);

};
RenderSnapshot.prototype.setVideoBuffer = function(sName, pVideoBuffer, isSemantic) {
return this.setParameter(sName, pVideoBuffer, isSemantic);

};
RenderSnapshot.prototype.setVideoBufferBySemantic = function(sRealName, pVideoBuffer) {
return this.setParameterBySemantic(sRealName, pVideoBuffer);

};
RenderSnapshot.prototype.setSamplerStates = function() {
if ((arguments.length) === 4) {
return this.setSamplerStatesBySemantic(arguments[0], arguments[1], arguments[2]);

}

if (((arguments.length) === 3) && ((typeof (arguments[1])) === "object")) {
return this.setSamplerStatesBySemantic(arguments[0], arguments[1]);

}

var sRealName=this._pShaderManager.getUniformRealName(arguments[0]);
if (!sRealName) {
return false;

}

if ((arguments.length) === 3) {
return this.setSamplerStatesBySemantic(sRealName, arguments[1], arguments[2]);

}

return this.setSamplerStatesBySemantic(arguments[0], arguments[1]);

};
RenderSnapshot.prototype.setSamplerStatesBySemantic = function() {
var sRealName=arguments[0];
var pPass=this._pPassStates[this._iCurrentPass];
var pData;
if ((pPass[sRealName]) === undefined) {
return false;

}

if ((arguments.length) === 3) {
if ((pPass[sRealName]) === null) {
pPass[sRealName] =  {};

}

pPass[sRealName][arguments[1]] = arguments[2];

}
else  {
pPass[sRealName] = arguments[1];

}

return true;

};
RenderSnapshot.prototype.applyTexture = function(sName, pTexture, isSemantic) {
if (isSemantic) {
this.applyTextureBySemantic(sName, pTexture);

}

var sRealName=this._pShaderManager.getTextureRealName(sName);
if (!sRealName) {
return false;

}

return this.applyTextureBySemantic(sRealName, pTexture);

};
RenderSnapshot.prototype.applyTextureBySemantic = function(sRealName, pTexture) {
if (!(this._pTextures)) {
return false;

}

var pTextures=this._pTextures[this._iCurrentPass];
if ((pTextures[sRealName]) !== undefined) {
pTextures[sRealName] = pTexture;
return true;

}

return false;

};
RenderSnapshot.prototype.applyBuffer = function(pVertexData) {
this._pShaderManager.applyVertexData(pData);

};
RenderSnapshot.prototype.applyBufferMap = function(pBufferMap) {
this._pShaderManager.applyBufferMap(pBufferMap);

};
RenderSnapshot.prototype.applyRenderData = function(pData) {
this._pShaderManager.applyBufferMap(pData._pMap);

};
RenderSnapshot.prototype.applyVertexData = function(pData, ePrimType) {
this._pShaderManager.applyVertexData(pData, ePrimType);

};
RenderSnapshot.prototype.isMethodLoaded = function() {
return (this._pRenderMethod) && (this._pRenderMethod.isResourceLoaded());

};
RenderSnapshot.prototype.hasRenderMethod = function() {
return (this._pRenderMethod) !== null;

};
RenderSnapshot.prototype.isReady = function() {
return (this._pRenderMethod.isResourceLoaded()) && (!(this._pRenderMethod.isResourceDisabled()));

};
a.RenderSnapshot = RenderSnapshot;
function MeshSubset(pMesh, pRenderData, sName) {
var _pCtorValue=MeshSubset.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pRenderData = null;
this._sName = null;
this._pMesh = null;
this._pSkin = null;
this._pBoundingBox = null;
this._pBoundingSphere = null;
this.setup(pMesh, pRenderData, sName);

}

a.extend(MeshSubset, a.RenderableObject);
a.defineProperty(MeshSubset, "name", function() {
return this._sName;

}
, function(sName) {
this._sName = sName;

}
);
a.defineProperty(MeshSubset, "mesh", function() {
return this._pMesh;

}
);
a.defineProperty(MeshSubset, "data", function() {
return this._pRenderData;

}
);
a.defineProperty(MeshSubset, "skin", function() {
return this._pSkin;

}
);
MeshSubset.prototype.setup = function(pMesh, pRenderData, sName) {
if (!((this._pMesh) === null)) {
var err=((((((("Error:: " + "mesh subset already prepared") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/MeshSubset.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("mesh subset already prepared");

}


}

;
if (!pMesh) {
var err=((((((("Error:: " + "you must specify parent mesh for creation mesh subset") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/MeshSubset.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("you must specify parent mesh for creation mesh subset");

}


}

;
if (!pRenderData) {
var err=((((((("Error:: " + "you must specify render data for creation mesh subset") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/MeshSubset.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("you must specify render data for creation mesh subset");

}


}

;
this._pMesh = pMesh;
this._pRenderData = pRenderData;
this._sName = sName || null;
this.constructor.superclass.setup.call(this, pMesh.getEngine(), sName);

};
MeshSubset.prototype.createBoundingBox = function() {
var pVertexData;
var pNewBoundingBox;
pNewBoundingBox = new a.Rect3d();
pVertexData = this.data.getData("POSITION");
if (!pVertexData)return false;

if ((a.computeBoundingBox(pVertexData, pNewBoundingBox)) == false)return false;

this._pBoundingBox = pNewBoundingBox;
return true;

};
MeshSubset.prototype.deleteBoundingBox = function() {
this._pBoundingBox = null;
return true;

};
MeshSubset.prototype.getBoundingBox = function() {
return this._pBoundingBox;

};
MeshSubset.prototype.showBoundingBox = function() {
var pMaterial;
var iData;
var iCurrentIndexSet;
var pPoints, pIndexes;
if (!(this._pBoundingBox)) {
return false;

}

pPoints = new Array();
pIndexes = new Array();
a.computeDataForCascadeBoundingBox(this._pBoundingBox, pPoints, pIndexes, 10);
iCurrentIndexSet = this.data.getIndexSet();
if (!(this.data.selectIndexSet(".BoundingBox"))) {
this.data.addIndexSet(true, 1, ".BoundingBox");
iData = this.data.allocateData([new Object( {nCount: 3, eType: 5126, eUsage: "POSITION", iOffset: undefined})], new Float32Array(pPoints));
this.data.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX0", iOffset: undefined})], new Float32Array(pIndexes));
this.data.index(iData, "INDEX0");
this.applyFlexMaterial(".MaterialBoundingBox");
pMaterial = this.getFlexMaterial(".MaterialBoundingBox");
pMaterial.emissive = new Float32Array([0, 0, 1, 1]);
pMaterial.diffuse = new Float32Array([0, 0, 1, 1]);

}
else  {
this.data.getData("POSITION").setData(new Float32Array(pPoints), "POSITION");

}

this.data.setRenderable();
this.data.selectIndexSet(iCurrentIndexSet);
return true;

};
MeshSubset.prototype.hideBoundingBox = function() {
var iCurrentIndexSet;
iCurrentIndexSet = this.data.getIndexSet();
if (!(this.data.selectIndexSet(".BoundingBox"))) {
return false;

}
else  {
this.data.setRenderable(this.data.getIndexSet(), false);

}

return this.data.selectIndexSet(iCurrentIndexSet);

};
MeshSubset.prototype.createBoundingSphere = function() {
var pVertexData;
var pNewBoundingSphere;
pNewBoundingSphere = new a.Sphere();
pVertexData = this.data.getData("POSITION");
if (!pVertexData)return false;

if ((a.computeBoundingSphere(pVertexData, pNewBoundingSphere, this._pBoundingBox)) == false)return false;

this._pBoundingSphere = pNewBoundingSphere;
return true;

};
MeshSubset.prototype.deleteBoundingSphere = function() {
this._pBoundingSphere = null;
return true;

};
MeshSubset.prototype.getBoundingSphere = function() {
return this._pBoundingSphere;

};
MeshSubset.prototype.showBoundingSphere = function() {
var pMaterial;
var iData;
var iCurrentIndexSet;
var pPoints, pIndexes;
if (!(this._pBoundingSphere)) {
return false;

}

pPoints = new Array();
pIndexes = new Array();
a.computeDataForCascadeBoundingSphere(this._pBoundingSphere, pPoints, pIndexes);
iCurrentIndexSet = this.data.getIndexSet();
if (!(this.data.selectIndexSet(".BoundingSphere"))) {
this.data.addIndexSet(false, 1, ".BoundingSphere");
iData = this.data.allocateData([new Object( {nCount: 3, eType: 5126, eUsage: "POSITION", iOffset: undefined})], new Float32Array(pPoints));
this.data.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX0", iOffset: undefined})], new Float32Array(pIndexes));
this.data.index(iData, "INDEX0");
this.applyFlexMaterial(".MaterialBoundingSphere");
pMaterial = this.getFlexMaterial(".MaterialBoundingSphere");
pMaterial.emissive = new Float32Array([0, 0, 1, 1]);
pMaterial.diffuse = new Float32Array([0, 0, 1, 1]);

}
else  {
this.data.getData("POSITION").setData(new Float32Array(pPoints), "POSITION");

}

this.data.setRenderable();
this.data.selectIndexSet(iCurrentIndexSet);
return true;

};
MeshSubset.prototype.hideBoundingSphere = function() {
var iCurrentIndexSet;
iCurrentIndexSet = this.data.getIndexSet();
if (!(this.data.selectIndexSet(".BoundingSphere"))) {
return false;

}
else  {
this.data.setRenderable(this.data.getIndexSet(), false);

}

return this.data.selectIndexSet(iCurrentIndexSet);

};
MeshSubset.prototype.computeNormals = function() {

};
MeshSubset.prototype.computeTangents = function() {

};
MeshSubset.prototype.computeBinormals = function() {

};
MeshSubset.prototype.isSkinned = function() {
return (this._pSkin) !== null;

};
MeshSubset.prototype.hasSkin = MeshSubset.prototype.isSkinned;
MeshSubset.prototype.getSkin = function() {
return this._pSkin;

};
MeshSubset.prototype.applyFlexMaterial = function(sMaterial, pMaterialData) {
if (this._pMesh.addFlexMaterial(sMaterial, pMaterialData)) {
return this.setFlexMaterial(sMaterial);

}

return null;

};
MeshSubset.prototype.getFlexMaterial = function(iMaterial) {
"use strict";
return this._pMesh.getFlexMaterial(iMaterial);

};
MeshSubset.prototype.hasFlexMaterial = function() {
"use strict";
return this._pRenderData.hasSemantics("MATERIAL");

};
MeshSubset.prototype.setFlexMaterial = function(iMaterial) {
var pRenderData=this._pRenderData;
var pIndexData=pRenderData.getIndices();
var pMatFlow=pRenderData.getFlow("MATERIAL");
var eSemantics="INDEX10";
var pIndexDecl, pIndexData;
var iMatFlow;
var pMaterial=this._pMesh.getFlexMaterial(iMaterial);
var iMat=pMaterial._pData.getOffset();
if (!pMaterial) {
return false;

}

if (pMatFlow) {
iMatFlow = pMatFlow.iFlow;
eSemantics = pMatFlow.pMapper.eSemantics;
pIndexData = pMatFlow.pMapper.pData;
pRenderData._addData(pMaterial._pData, iMatFlow);
return pRenderData.index(iMat, eSemantics, true);

}

pIndexDecl = new a.VertexDeclaration([new Object( {nCount: 1, eType: 5126, eUsage: eSemantics, iOffset: undefined})]);
pIndexData = new Float32Array(pIndexData.getCount());
iMatFlow = pRenderData._addData(pMaterial._pData);
if (!(iMatFlow >= 0)) {
var err=((((((("Error:: " + "cannot add data flow with material for mesh subsset") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/MeshSubset.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("cannot add data flow with material for mesh subsset");

}


}

;
if (!(pRenderData.allocateIndex(pIndexDecl, pIndexData))) {
trace("cannot allocate index for material!!!");
return false;

}

return pRenderData.index(iMat, eSemantics, true);

};
MeshSubset.prototype.draw = function() {
"use strict";
this._pRenderData.draw();

};
MeshSubset.prototype.show = function() {
this.data.renderable(true);

};
MeshSubset.prototype.hide = function() {
this.datq.renderable(false);

};
MeshSubset.prototype.setSkin = function(pSkin) {
"use strict";
var pPosData;
var pPositionFlow;
var pMetaData;
var pInfMetaData;
var iInfMetaDataLoc;
var iInfMetaDataStride;
pPositionFlow = this.data.getFlow("POSITION");
if (!pPositionFlow) {
var err=((((((("Error:: " + "skin require position with indices in mesh subset") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/MeshSubset.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("skin require position with indices in mesh subset");

}


}

;
pPosData = pPositionFlow.pData;
if (pPosData.hasSemantics("BLENDMETA")) {
if (pSkin.isAffect(pPosData)) {
this._pSkin = pSkin;
return true;

}

if (!0) {
var err=((((((("Error:: " + "mesh subset already has another skin") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/MeshSubset.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("mesh subset already has another skin");

}


}

;
return false;

}

if (!((this.data.buffer) == (pSkin.data))) {
var err=((((((("Error:: " + "can not bind to skin mesh subset that does not belong skin\'s mesh.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/MeshSubset.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("can not bind to skin mesh subset that does not belong skin\'s mesh.");

}


}

;
pSkin.attach(pPosData);
pMetaData = pPosData.getTypedData("BLENDMETA");
if (!pMetaData) {
var err=((((((("Error:: " + "you must specify location for storage blending data") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/MeshSubset.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("you must specify location for storage blending data");

}


}

;
pInfMetaData = pSkin.getInfluenceMetaData();
iInfMetaDataLoc = (pInfMetaData.getOffset()) / (4);
iInfMetaDataStride = (pInfMetaData.stride) / (4);
for (var i=0; i < (pMetaData.length); ++i) {
pMetaData[i] = iInfMetaDataLoc + (i * iInfMetaDataStride);

}

pPosData.setData(pMetaData, "BLENDMETA");
this._pSkin = pSkin;
return true;

};
a["MeshSubset"] = MeshSubset;
function Skin(pRenderDataBuffer) {
if ((arguments[0]) instanceof (a.Mesh)) {
pRenderDataBuffer = arguments[0].data;

}

if (!pRenderDataBuffer) {
var err=((((((("Error:: " + "you must specify mesh for skin") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Skin.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("you must specify mesh for skin");

}


}

;
this._m4fBindMatrix = new Mat4(1);
this._pRenderDataBuffer = pRenderDataBuffer;
this._pSkeleton = null;
this._pBoneTransformMatrixData = null;
this._pBoneTransformMatrices = null;
this._pBoneOffsetMatrixBuffer = null;
this._pNodeNames = null;
this._pBoneOffsetMatrices = null;
this._pAffectingNodes = null;
this._pInfMetaData = null;
this._pInfData = null;
this._pWeightData = null;
this._pTiedData = [];

}

a.defineProperty(Skin, "buffer", function() {
return this._pRenderDataBuffer;

}
);
a.defineProperty(Skin, "data", function() {
return this._pRenderDataBuffer;

}
);
a.defineProperty(Skin, "skeleton", function() {
return this._pSkeleton;

}
);
a.defineProperty(Skin, "totalBones", function() {
return this._pNodeNames.length;

}
);
Skin.prototype.setBindMatrix = function(m4fMatrix) {
"use strict";
this._m4fBindMatrix.set(m4fMatrix);

};
Skin.prototype.getBindMatrix = function() {
"use strict";
return this._m4fBindMatrix;

};
Skin.prototype.hasSkeleton = function() {
return (this._pSkeleton) !== null;

};
Skin.prototype.getSkeleton = function() {
return this._pSkeleton;

};
Skin.prototype.setSkeleton = function(pSkeleton) {
"use strict";
if ((!pSkeleton) || ((pSkeleton.totalBones) < (this.totalBones))) {
return false;

}

for (var i=0, nMatrices=this.totalBones; i < nMatrices; i++) {
this._pAffectingNodes[i] = pSkeleton.findJoint(this._pNodeNames[i]);
if (!this._pAffectingNodes[i]) {
var err=((((((("Error:: " + (("joint<" + (this._pNodeNames[i])) + "> must exists...")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Skin.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("joint<" + (this._pNodeNames[i])) + "> must exists..."));

}


}

;

}

;
this._pSkeleton = pSkeleton;
return true;

};
Skin.prototype.attachToSceneTree = function(pRootNode) {
"use strict";
for (var i=0, nMatrices=this.totalBones; i < nMatrices; i++) {
this._pAffectingNodes[i] = pRootNode.findNode(this._pNodeNames[i]);
if (!this._pAffectingNodes[i]) {
var err=((((((("Error:: " + (("node<" + (this._pNodeNames[i])) + "> must exists...")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Skin.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("node<" + (this._pNodeNames[i])) + "> must exists..."));

}


}

;

}

;
return true;

};
Skin.prototype.bind = function() {
"use strict";
if ((arguments[0]) instanceof (a.Skeleton)) {
return this.setSkeleton(arguments[0]);

}

return this.attachToSceneTree(arguments[0]);

};
Skin.prototype.setBoneNames = function(pNames) {
"use strict";
this._pNodeNames = pNames;
this._pAffectingNodes = new Array(this._pNodeNames.length);
return true;

};
Skin.prototype.setBoneOffsetMatrices = function(pMatrices) {
"use strict";
var pMatrixNames=this._pNodeNames;
if (!((pMatrices && pMatrixNames) && ((pMatrixNames.length) === (pMatrices.length)))) {
var err=((((((("Error:: " + ((("number of matrix names must equal matrices data length:\n" + (pMatrixNames.length)) + " / ") + (pMatrices.length))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Skin.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(((("number of matrix names must equal matrices data length:\n" + (pMatrixNames.length)) + " / ") + (pMatrices.length)));

}


}

;
var nMatrices=pMatrixNames.length;
var pData=this.data;
var pMatrixData=new Float32Array(nMatrices * 16);
this._pBoneOffsetMatrices = pMatrices;
this._pBoneTransformMatrixData = pData._allocateData(new Object( {nCount: 16, eType: 5126, eUsage: "BONE_MATRIX", iOffset: undefined}), pMatrixData);
this._pBoneTransformMatrices = new Array(nMatrices);
for (var i=0; i < nMatrices; i++) {
this._pBoneTransformMatrices[i] = new Mat4(pMatrixData.subarray(i * 16, (i + 1) * 16), true);

}

;
this._pBoneOffsetMatrixBuffer = pMatrixData;

};
Skin.prototype.setWeights = function(pWeights) {
"use strict";
this._pWeightData = this.data._allocateData([new Object( {nCount: 1, eType: 5126, eUsage: "BONE_WEIGHT", iOffset: undefined})], pWeights);
return (this._pWeightData) !== null;

};
Skin.prototype.getWeights = function() {
"use strict";
return this._pWeightData;

};
Skin.prototype.getInfluenceMetaData = function() {
"use strict";
return this._pInfMetaData;

};
Skin.prototype.getInfluences = function(first_argument) {
"use strict";
return this._pInfData;

};
Skin.prototype.setIfluences = function(pInfluencesCount, pInfluences) {
"use strict";
if (!(((this._pInfMetaData) == null) && ((this._pInfData) == null))) {
var err=((((((("Error:: " + "vertex weights already setuped.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Skin.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("vertex weights already setuped.");

}


}

;
if (!this.getWeights()) {
var err=((((((("Error:: " + "you must set weight data before setup influences") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Skin.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("you must set weight data before setup influences");

}


}

;
var pData=this.data;
var pInfluencesMeta=new Float32Array((pInfluencesCount.length) * 2);
var iInfLoc=0;
var iTransformLoc=0;
var iWeightsLoc=0;
pInfluences = new Float32Array(pInfluences);
iTransformLoc = (this._pBoneTransformMatrixData.getOffset()) / (4);
iWeightsLoc = (this._pWeightData.getOffset()) / (4);
for (var i=0, n=pInfluences.length; i < n; i += 2) {
pInfluences[i] = ((pInfluences[i]) * 16) + iTransformLoc;
pInfluences[i + 1] += iWeightsLoc;

}

;
this._pInfData = pData._allocateData([new Object( {nCount: 1, eType: 5126, eUsage: "BONE_INF_DATA", iOffset: undefined}), new Object( {nCount: 1, eType: 5126, eUsage: "BONE_WEIGHT_IND", iOffset: undefined})], pInfluences);
iInfLoc = (this._pInfData.getOffset()) / (4);
for (var i=0, j=0, n=iInfLoc; i < (pInfluencesMeta.length); i += 2) {
var iCount=pInfluencesCount[j++];
pInfluencesMeta[i] = iCount;
pInfluencesMeta[i + 1] = n;
n += 2 * iCount;

}

;
this._pInfMetaData = pData._allocateData([new Object( {nCount: 1, eType: 5126, eUsage: "BONE_INF_COUNT", iOffset: undefined}), new Object( {nCount: 1, eType: 5126, eUsage: "BONE_INF_LOC", iOffset: undefined})], pInfluencesMeta);
return ((this._pInfMetaData) !== null) && ((this._pInfData) !== null);

};
Skin.prototype.setVertexWeights = function(pInfluencesCount, pInfluences, pWeights) {
if (!((arguments.length) > 1)) {
var err=((((((("Error:: " + "you must specify all parameters") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Skin.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("you must specify all parameters");

}


}

;
if (pWeights) {
this.setWeights(pWeights);

}

return this.setIfluences(pInfluencesCount, pInfluences);

};
Skin.prototype.applyBoneMatrices = function(bForce) {
"use strict";
var pData;
var bResult;
var pNode;
var isUpdated=false;
for (var i=0, nMatrices=this.totalBones; i < nMatrices; ++i) {
pNode = this._pAffectingNodes[i];
if ((pNode.isWorldMatrixNew()) || bForce) {
pNode._m4fWorldMatrix.mult(this._pBoneOffsetMatrices[i], this._pBoneTransformMatrices[i]);
isUpdated = true;

}


}

;
if (isUpdated) {
pData = this._pBoneOffsetMatrixBuffer;
return this._pBoneTransformMatrixData.setData(pData, 0, pData.byteLength);

}

return false;

};
Skin.prototype.apply = Skin.prototype.applyBoneMatrices;
Skin.prototype.isReady = function() {
"use strict";
return ((((((this._pInfMetaData) && (this._pInfData)) && (this._pWeightData)) && (this._pBoneOffsetMatrixBuffer)) && (this._pBoneOffsetMatrices)) && (this._pNodeNames)) && (this._m4fBindMatrix);

};
Skin.prototype.getBoneTransforms = function() {
"use strict";
return this._pBoneTransformMatrixData;

};
Skin.prototype.isAffect = function(pData) {
"use strict";
if (pData) {
for (var i=0; i < (this._pTiedData.length); i++) {
if ((this._pTiedData[i]) === pData) {
return true;

}


}

;

}

return false;

};
Skin.prototype.attach = function(pData) {
"use strict";
if (!((pData.stride) === 16)) {
var err=((((((("Error:: " + ("you cannot add skin to mesh with POSITION: {x, y, z}" + "\nyou need POSITION: {x, y, z, w}")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Skin.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(("you cannot add skin to mesh with POSITION: {x, y, z}" + "\nyou need POSITION: {x, y, z, w}"));

}


}

;
pData.getVertexDeclaration().append(new Object( {nCount: 1, eType: 5126, eUsage: "BLENDMETA", iOffset: 12}));
this._pTiedData.push(pData);

};
Skin.debugMeshSubset = function(pSubMesh) {
var pMesh=pSubMesh.mesh;
var pSkin=pSubMesh.skin;
var pMatData=pSkin.getBoneTransforms();
var pPosData=pSubMesh.data.getData("POSITION");
var pEngine=pMesh.getEngine();
pPosData = pPosData.getTypedData("BLENDMETA");
var pVideoBuffer=pSubMesh.mesh.data.buffer;
var iFrom=2618, iTo=2619;
var pWeights=pSkin.getWeights().getTypedData("BONE_WEIGHT");
trace("===== debug vertices from ", iFrom, "to", iTo, " ======");
trace("transformation data location:", (pMatData.getOffset()) / 4);
trace("155 weight: ", pSkin.getWeights().getTypedData("BONE_WEIGHT")[155]);
trace("vertices info ===================>");
for (var i=iFrom; i < iTo; i++) {
trace(pPosData[i], "<< inf meta location");
var pMetaData=new Float32Array(pVideoBuffer.getData(4 * (pPosData[i]), 8));
trace(pMetaData[0], "<< count");
trace(pMetaData[1], "<< inf. location");
for (var j=0; j < (pMetaData[0]); ++j) {
var pInfData=new Float32Array(pVideoBuffer.getData(4 * ((pMetaData[1]) + (2 * j)), 8));
trace(pInfData[0], "<< matrix location");
trace(pInfData[1], "/", (pInfData[1]) - 30432, "<< weight location / index");
var pWeightData=new Float32Array(pVideoBuffer.getData(4 * (pInfData[1]), 4));
trace(pWeightData[0], "<< weight");
var pMatrixData=new Float32Array(pVideoBuffer.getData(4 * (pInfData[0]), 4 * 16));
trace(pMatrixData.toString());

}


}

trace("#############################################");
for (var i=0; i < (pPosData.length); i++) {
var pMetaData=new Float32Array(pVideoBuffer.getData(4 * (pPosData[i]), 8));
for (var j=0; j < (pMetaData[0]); ++j) {
var pInfData=new Float32Array(pVideoBuffer.getData(4 * ((pMetaData[1]) + (2 * j)), 8));
var iWeightsIndex=(pInfData[1]) - 30432;
var fWeightOrigin=pWeights[iWeightsIndex];
var pWeightData=new Float32Array(pVideoBuffer.getData(4 * (pInfData[1]), 4));
var fWeight=pWeightData[0];
if ((Math.abs(fWeight - fWeightOrigin)) > 0.001) {
alert(1);
trace("weight with index", iWeightsIndex, "has wrong weight", fWeightOrigin, "/", fWeightOrigin);

}


}


}

trace("##############################################");

};
a["Skin"] = Skin;
function Skeleton(pEngine, sName) {
;
this._sName = sName || null;
this._pEngine = pEngine;
this._pRootJoints = [];
this._pJointList = null;
this._pNodeList = null;
this._pMeshNode = null;
this._iFlags = false;

}

a.defineProperty(Skeleton, "totalBones", function() {
return Object.keys(this._pJointList).length;

}
);
a.defineProperty(Skeleton, "totalNodes", function() {
return this._pNodeList.length;

}
);
a.defineProperty(Skeleton, "name", function() {
return this._sName;

}
);
a.defineProperty(Skeleton, "root", function() {
return (this._pRootJoints[0]) || null;

}
);
Skeleton.prototype.getEngine = function() {
"use strict";
return this._pEngine;

};
Skeleton.prototype.getRootJoint = function() {
"use strict";
return this.getRootJoints()[0];

};
Skeleton.prototype.getRootJoints = function() {
"use strict";
return this._pRootJoints;

};
Skeleton.prototype.getJointMap = function() {
return this._pJointList;

};
Skeleton.prototype.getNodeList = function() {
"use strict";
return this._pNodeList;

};
Skeleton.prototype.addRootJoint = function(pJoint) {
"use strict";
if (!(pJoint instanceof (a.Joint))) {
var err=((((((("Error:: " + "node must be joint") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Skeleton.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("node must be joint");

}


}

;
var pRootJoints=this._pRootJoints;
for (var i=0; i < (pRootJoints.length); i++) {
if (pJoint.childOf(pRootJoints[i])) {
return false;

}
else if (pRootJoints[i].childOf(pJoint)) {
pRootJoints.splice(i, 1);

}



}

;
this._pRootJoints.push(pJoint);
return this.update();

};
Skeleton.prototype.update = function() {
"use strict";
var pRootJoints=this._pRootJoints;
var pJointList=this._pJointList =  {};
var pNodeList=this._pNodeList = [];
function findNodes(pNode) {
var sJoint;
if (pNode) {
sJoint = pNode.boneName;
if (sJoint) {
if (!(!(pJointList[sJoint]))) {
var err=((((((("Error:: " + (((("joint with name<" + sJoint) + "> already exists in skeleton <") + (this._sName)) + ">")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Skeleton.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((((("joint with name<" + sJoint) + "> already exists in skeleton <") + (this._sName)) + ">"));

}


}

;
pJointList[sJoint] = pNode;

}

pNodeList.push(pNode);
findNodes(pNode.sibling());
findNodes(pNode.child());

}


}

for (var i=0; i < (pRootJoints.length); i++) {
findNodes(pRootJoints[i]);

}

;
return true;

};
Skeleton.prototype.findJoint = function(sName) {
"use strict";
return this._pJointList[sName];

};
Skeleton.prototype.findJointByName = function(sName) {
"use strict";
for (var s in this._pJointList) {
if ((this._pJointList[s].name) === sName) {
return this._pJointList[s];

}


}

return null;

};
Skeleton.prototype.attachMesh = function(pMesh) {
"use strict";
if (!((this.getEngine()) === (pMesh.getEngine()))) {
var err=((((((("Error:: " + "mesh must be from same engine instance") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Skeleton.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("mesh must be from same engine instance");

}


}

;
if ((this._pMeshNode) == null) {
this._pMeshNode = new a.SceneModel(this.getEngine());
this._pMeshNode.create();
this._pMeshNode.setInheritance(2);
this._pMeshNode.attachToParent(this.root);

}

this._pMeshNode.name = (this.name) + "[mesh-container]";
this._pMeshNode.addMesh(pMesh);

};
Skeleton.prototype.detachMesh = function() {
"use strict";

};
a["Skeleton"] = Skeleton;
function Mesh(pEngine, eOptions, sName, pDataBuffer) {
a.ReferenceCounter.call(this);
this._sName = sName || null;
this._pFlexMaterials = null;
this._pBuffer = null;
this._pEngine = pEngine;
this._eOptions = 0;
this._pSkeleton = null;
this._pBoundingBox = null;
this._pBoundingSphere = null;
this.setup(sName, eOptions, pDataBuffer);

}

;
a.extend(Mesh, Array, a.ReferenceCounter);
a.defineProperty(Mesh, "flexMaterials", function() {
return this._pFlexMaterials;

}
);
a.defineProperty(Mesh, "name", function() {
return this._sName;

}
);
a.defineProperty(Mesh, "data", function() {
return this._pBuffer;

}
);
a.defineProperty(Mesh, "buffer", function() {
return this._pBuffer;

}
);
a.defineProperty(Mesh, "skeleton", function() {
return this._pSkeleton;

}
, function(pSkeleton) {
this._pSkeleton = pSkeleton;

}
);
Mesh.prototype.setSkeleton = function(pSkeleton) {
this.skeleton = pSkeleton;

};
Mesh.prototype.getOptions = function() {
"use strict";
return this._eOptions;

};
Mesh.prototype.getEngine = function() {
"use strict";
return this._pEngine;

};
Mesh.prototype.drawSubset = function(iSubset) {
"use strict";
this._pBuffer.draw(iSubset);

};
Mesh.prototype.draw = function() {
"use strict";
for (var i=0; i < (this.length); i++) {
this[i].draw();

}

;

};
Mesh.prototype.isReadyForRender = function() {
"use strict";
for (var i=0; i < (this.length); ++i) {
if (!(this[i].isReadyForRender())) {
return false;

}


}

return true;

};
Mesh.prototype.setup = function(sName, eOptions, pDataBuffer) {
if (!((this._pBuffer) === null)) {
var err=((((((("Error:: " + "mesh already setuped.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Mesh.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("mesh already setuped.");

}


}

;
if (!pDataBuffer) {
this._pBuffer = new a.RenderDataBuffer(this._pEngine);
this._pBuffer.setup(eOptions);

}
else  {
if (!((pDataBuffer.getEngine()) === (this.getEngine()))) {
var err=((((((("Error:: " + "you can not use a buffer with a different context") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Mesh.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("you can not use a buffer with a different context");

}


}

;
this._pBuffer = pDataBuffer;
eOptions |= pDataBuffer.getOptions();

}

this._pBuffer.addRef();
this._eOptions = eOptions || 0;
this._sName = sName || "unknown";
return true;

};
Mesh.prototype.createSubset = function(sName, ePrimType, eOptions) {
var pSubset, pSubMesh;
pSubset = this._pBuffer.getEmptyRenderData(ePrimType, eOptions);
pSubset.addRef();
if (!pSubset) {
return null;

}

pSubMesh = new a.MeshSubset(this, pSubset, sName);
this.push(pSubMesh);
return pSubMesh;

};
Mesh.prototype.replaceFlexMaterials = function(pFlexMaterials) {
"use strict";
this._pFlexMaterials = pFlexMaterials;

};
Mesh.prototype.freeSubset = function(sName) {
if (!0) {
var err=((((((("Error:: " + "Метод freeSubset не реализован") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Mesh.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Метод freeSubset не реализован");

}


}

;
return false;

};
Mesh.prototype.getFlexMaterial = function() {
if (!(this._pFlexMaterials)) {
return null;

}

if ((typeof (arguments[0])) === "number") {
return (this._pFlexMaterials[arguments[0]]) || null;

}
else  {
for (var i=0, pMaterials=this._pFlexMaterials; i < (pMaterials.length); ++i) {
if ((pMaterials[i]._sName) === (arguments[0])) {
return pMaterials[i];

}


}


}

return null;

};
Mesh.prototype.addFlexMaterial = function(sName, pMaterialData) {
"use strict";
var pMaterial;
var pMaterialId;
if (!((arguments.length) < 7)) {
var err=((((((("Error:: " + "only base material supported now...") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/Mesh.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("only base material supported now...");

}


}

;
sName = sName || "unknown";
pMaterial = this.getFlexMaterial(sName);
if (pMaterial) {
if (pMaterialData) {
pMaterial.value = pMaterialData;

}

return true;

}

if (!(this._pFlexMaterials)) {
this._pFlexMaterials = [];

}

pMaterialId = this._pFlexMaterials.length;
pMaterial = new a.MeshMaterial(sName, this._pBuffer._allocateData(a.MeshMaterial.vertexDeclaration(), null));
if (!pMaterialData) {
pMaterialData = new a.Material();
pMaterialData.toDefault();

}

pMaterial.value = pMaterialData;
pMaterial.id = pMaterialId;
this._pFlexMaterials.push(pMaterial);
return true;

};
Mesh.prototype.setFlexMaterial = function(iMaterial) {
"use strict";
var bResult=true;
for (var i=0; i < (this.length); ++i) {
if (!(this[i].setFlexMaterial(iMaterial))) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/model/Mesh.js") + "][") + "") + "]") + (((((("cannot set material<" + iMaterial) + "> for mesh<") + (this.name)) + "> subset<") + (this[i].name)) + ">"));
bResult = false;

}


}

return bResult;

};
Mesh.prototype.destroy = function() {
this._pFlexMaterials = null;
this._pBuffer.destroy(this);

};
Mesh.prototype.destructor = function() {
"use strict";
this.destroy();

};
Mesh.prototype.getSubset = function() {
"use strict";
if ((typeof (arguments[0])) === "number") {
return this[arguments[0]];

}
else  {
for (var i=0; i < (this.length); ++i) {
if ((this[i]._sName) === (arguments[0])) {
return this[i];

}


}


}

return null;

};
Mesh.prototype.setSkin = function(pSkin) {
for (var i=0; i < (this.length); ++i) {
this[i].setSkin(pSkin);

}

;

};
Mesh.prototype.clone = function(eCloneOptions) {
"use strict";
var pClone=null;
var pRenderData;
var pSubMesh;
if (eCloneOptions & (1)) {
pClone = new a.Mesh(this.getEngine(), this.getOptions(), this.name, this.data);
for (var i=0; i < (this.length); ++i) {
pRenderData = this[i].data;
pRenderData.addRef();
pSubMesh = new a.MeshSubset(this, pRenderData, this[i].name);
pClone.push(pSubMesh);

}

pClone.replaceFlexMaterials(this.flexMaterials);

}
else  {

}

if (eCloneOptions & (0)) {
return pClone;

}
else  {

}

return pClone;

};
Mesh.prototype.createAndShowSubBoundingBox = function() {
for (i = 0; i < (this.length); i++) {
pSubMesh = this.getSubset(i);
pSubMesh.createBoundingBox();
pSubMesh.showBoundingBox();

}


};
Mesh.prototype.createAndShowSubBoundingSphere = function() {
for (i = 0; i < (this.length); i++) {
pSubMesh = this.getSubset(i);
pSubMesh.createBoundingSphere();
pSubMesh.showBoundingSphere();

}


};
Mesh.prototype.createBoundingBox = function() {
var pVertexData;
var pSubMesh;
var pNewBoundingBox;
var pTempBoundingBox;
var i;
pNewBoundingBox = new a.Rect3d();
pTempBoundingBox = new a.Rect3d();
pSubMesh = this.getSubset(0);
pVertexData = pSubMesh.data.getData("POSITION");
if (!pVertexData)return false;

if ((a.computeBoundingBox(pVertexData, pNewBoundingBox)) == false)return false;

for (i = 1; i < (this.length); i++) {
pSubMesh = this.getSubset(i);
pVertexData = pSubMesh.data.getData("POSITION");
if (!pVertexData)return false;

if ((a.computeBoundingBox(pVertexData, pTempBoundingBox)) == false)return false;

pNewBoundingBox.fX0 = Math.min(pNewBoundingBox.fX0, pTempBoundingBox.fX0);
pNewBoundingBox.fY0 = Math.min(pNewBoundingBox.fY0, pTempBoundingBox.fY0);
pNewBoundingBox.fZ0 = Math.min(pNewBoundingBox.fZ0, pTempBoundingBox.fZ0);
pNewBoundingBox.fX1 = Math.max(pNewBoundingBox.fX1, pTempBoundingBox.fX1);
pNewBoundingBox.fY1 = Math.max(pNewBoundingBox.fY1, pTempBoundingBox.fY1);
pNewBoundingBox.fZ1 = Math.max(pNewBoundingBox.fZ1, pTempBoundingBox.fZ1);

}

this._pBoundingBox = pNewBoundingBox;
return true;

};
Mesh.prototype.deleteBoundingBox = function() {
this._pBoundingBox = null;
return true;

};
Mesh.prototype.getBoundingBox = function() {
return this._pBoundingBox;

};
Mesh.prototype.showBoundingBox = function() {
var pSubMesh, pMaterial;
var iData;
var pPoints, pIndexes;
if (!(this._pBoundingBox)) {
return false;

}

pPoints = new Array();
pIndexes = new Array();
a.computeDataForCascadeBoundingBox(this._pBoundingBox, pPoints, pIndexes, 400);
pSubMesh = this.getSubset(".BoundingBox");
if (!pSubMesh) {
pSubMesh = this.createSubset(".BoundingBox", 1, 1 << (1));
if (!pSubMesh)return false;

iData = pSubMesh.data.allocateData([new Object( {nCount: 3, eType: 5126, eUsage: "POSITION", iOffset: undefined})], new Float32Array(pPoints));
pSubMesh.data.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX0", iOffset: undefined})], new Float32Array(pIndexes));
pSubMesh.data.index(iData, "INDEX0");
pSubMesh.applyFlexMaterial(".MaterialBoundingBox");
pMaterial = pSubMesh.getFlexMaterial(".MaterialBoundingBox");
pMaterial.emissive = new Float32Array([1, 0, 0, 1]);
pMaterial.diffuse = new Float32Array([1, 0, 0, 1]);
pMaterial.ambient = new Float32Array([1, 0, 0, 1]);
pMaterial.specular = new Float32Array([1, 0, 0, 1]);

}
else  {
pSubMesh.data.getData("POSITION").setData(new Float32Array(pPoints), "POSITION");

}

pSubMesh.data.setRenderable();
return true;

};
Mesh.prototype.hideBoundingBox = function() {
var pSubMesh;
pSubMesh = this.getSubset(".BoundingBox");
if (!pSubMesh) {
return false;

}

return pSubMeshs.data.setRenderable(this.data.getIndexSet(), false);

};
Mesh.prototype.createBoundingSphere = function() {
var pVertexData;
var pSubMesh;
var pNewBoundingSphere, pTempBoundingSphere;
var i;
pNewBoundingSphere = new a.Sphere();
pTempBoundingSphere = new a.Sphere();
pSubMesh = this.getSubset(0);
pVertexData = pSubMesh.data.getData("POSITION");
if (!pVertexData) {
return false;

}

if ((a.computeBoundingSphere(pVertexData, pNewBoundingSphere)) == false) {
return false;

}

for (i = 1; i < (this.length); i++) {
pSubMesh = this.getSubset(i);
pVertexData = pSubMesh.data.getData("POSITION");
if (!pVertexData)return false;

if ((a.computeBoundingSphere(pVertexData, pTempBoundingSphere)) == false)return false;

a.computeGeneralizingSphere(pNewBoundingSphere, pTempBoundingSphere);

}

this._pBoundingSphere = pNewBoundingSphere;
return true;

};
Mesh.prototype.deleteBoundingSphere = function() {
this._pBoundingSphere = null;
return true;

};
Mesh.prototype.getBoundingSphere = function() {
return this._pBoundingSphere;

};
Mesh.prototype.showBoundingSphere = function() {
var pSubMesh, pMaterial;
var iData;
var pPoints, pIndexes;
if (!(this._pBoundingSphere)) {
return false;

}

pPoints = new Array();
pIndexes = new Array();
a.computeDataForCascadeBoundingSphere(this._pBoundingSphere, pPoints, pIndexes);
pSubMesh = this.getSubset(".BoundingSphere");
if (!pSubMesh) {
pSubMesh = this.createSubset(".BoundingSphere", 1, 1 << (1));
if (!pSubMesh)return false;

iData = pSubMesh.data.allocateData([new Object( {nCount: 3, eType: 5126, eUsage: "POSITION", iOffset: undefined})], new Float32Array(pPoints));
pSubMesh.data.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX0", iOffset: undefined})], new Float32Array(pIndexes));
pSubMesh.data.index(iData, "INDEX0");
pSubMesh.applyFlexMaterial(".MaterialBoundingSphere");
pMaterial = pSubMesh.getFlexMaterial(".MaterialBoundingSphere");
pMaterial.emissive = new Float32Array([1, 0, 0, 1]);
pMaterial.diffuse = new Float32Array([1, 0, 0, 1]);
pMaterial.ambient = new Float32Array([1, 0, 0, 1]);
pMaterial.specular = new Float32Array([1, 0, 0, 1]);

}
else  {
pSubMesh.data.getData("POSITION").setData(new Float32Array(pPoints), "POSITION");

}

pSubMesh.data.setRenderable();
return true;

};
Mesh.prototype.hideBoundingSphere = function() {
var pSubMesh;
pSubMesh = this.getSubset(".BoundingSphere");
if (!pSubMesh) {
return false;

}

return pSubMeshs.data.setRenderable(this.data.getIndexSet(), false);

};
a["Mesh"] = Mesh;
function AnimationBase() {
;
this._pTargetMap =  {};
this._pTargetList = [];
this._fDuration = 0;
this._sName = (("animation-" + (a.now())) + "-") + (a.sid());
this._pCallbacks =  {};

}

a["AnimationBase"] = AnimationBase;
a.defineProperty(AnimationBase, "duration", function() {
return this._fDuration;

}
, function(fValue) {
this._fDuration = fValue;

}
);
a.defineProperty(AnimationBase, "name", function() {
return this._sName;

}
, function(sName) {
this._sName = sName;

}
);
AnimationBase.prototype.on = function(eEvent, fnCallback) {
"use strict";
if (!(this._pCallbacks[eEvent])) {
this._pCallbacks[eEvent] = [];

}

this._pCallbacks[eEvent].push(fnCallback);

};
AnimationBase.prototype.fire = function(eEvent, fTime) {
"use strict";
var pCallbacks=this._pCallbacks[eEvent];
if (pCallbacks) {
for (var i=0, n=pCallbacks.length; i < n; i++) {
pCallbacks[i](fTime);

}

;

}


};
AnimationBase.prototype.play = function(fRealTime) {
"use strict";
this.fire("play", fRealTime);

};
AnimationBase.prototype.stop = function(fRealTime) {
"use strict";
this.fire("stop", fRealTime);

};
AnimationBase.prototype.removeEventListener = function(eEvent, fnCallback) {
"use strict";
var pCallbacks=this._pCallbacks[eEvent];
for (var i=0; i < (pCallbacks.length); i++) {
if ((pCallbacks[i]) === fnCallback) {
pCallbacks.splice(i, 1);
return true;

}


}

;
return false;

};
AnimationBase.prototype.bind = function(pTarget) {
if (!0) {
var err=((((((("Error:: " + "method AnimationBase::bind() must be overwritten.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/animation/AnimationBase.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("method AnimationBase::bind() must be overwritten.");

}


}

;

};
AnimationBase.prototype.frame = function(sName, fRealTime) {
"use strict";
return null;

};
AnimationBase.prototype.apply = function(fRealTime) {
"use strict";
var pTargetList=this._pTargetList;
var pTarget;
var pFrame;
var pTransform;
for (var i=0; i < (pTargetList.length); ++i) {
pFrame = this.frame(pTargetList[i].name, fRealTime);
pTarget = pTargetList[i].target;
if ((!pFrame) || (!pTarget)) {
continue ;

}

pTransform = pFrame.toMatrix();
pTarget.accessLocalMatrix().set(pTransform);

}

;
this.fire("enterFrame", fRealTime);

};
AnimationBase.prototype.addTarget = function(sName, pTarget) {
"use strict";
pTarget = pTarget || null;
var pPointer=this._pTargetMap[sName];
if (pPointer) {
pPointer.target = (pTarget || (pPointer.target)) || null;
return pPointer;

}

pPointer =  {target: pTarget, index: this._pTargetList.length, name: sName};
this._pTargetList.push(pPointer);
this._pTargetMap[sName] = pPointer;
return pPointer;

};
AnimationBase.prototype.setTarget = function(sName, pTarget) {
"use strict";
if (!pTarget) {
var err=((((((("Error:: " + (("target with name <" + sName) + "> must have a value")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/animation/AnimationBase.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("target with name <" + sName) + "> must have a value"));

}


}

;
var pPointer=this._pTargetMap[sName];
pPointer.target = pTarget;
return pPointer;

};
AnimationBase.prototype.getTarget = function(sTarget) {
"use strict";
return this._pTargetMap[sTarget];

};
AnimationBase.prototype.targetNames = function() {
var pTargets=this._pTargetList;
var pTargetNames=[];
for (var i=0; i < (pTargets.length); ++i) {
pTargetNames.push(pTargets[i].name);

}

return pTargetNames;

};
AnimationBase.prototype.targetList = function() {
var pTargets=this._pTargetList;
var pTargetList=[];
for (var i=0; i < (pTargets.length); ++i) {
pTargetList.push(pTargets[i].target);

}

return pTargetList;

};
AnimationBase.prototype.jointList = function() {
var pTargets=this._pTargetList;
var pJointList=[];
for (var i=0; i < (pTargets.length); ++i) {
if ((pTargets[i].target) instanceof (a.Joint)) {
pJointList.push(pTargets[i].target);

}


}

return pJointList;

};
AnimationBase.prototype.createAnimationMask = function() {
var pTargets=this.targetNames();
var pMask= {};
for (var i=0; i < (pTargets.length); ++i) {
pMask[pTargets[i]] = 1;

}

return pMask;

};
AnimationBase.prototype.grab = function(pAnimationBase, bRewrite) {
"use strict";
bRewrite = (bRewrite === undefined? true : bRewrite);
var pAdoptTargets=pAnimationBase._pTargetList;
for (var i=0; i < (pAdoptTargets.length); ++i) {
if (!(pAdoptTargets[i].target)) {
continue ;

}

if (bRewrite || (!(this.getTarget(pAdoptTargets[i].name)))) {
this.addTarget(pAdoptTargets[i].name, pAdoptTargets[i].target);

}


}

;

};
function AnimationFrame(fTime, pMatrix, fWeight) {
if ((((this) === window) || (!(this))) || ((this) === (window.AKRA))) {
AnimationFrame._iIndex = ((AnimationFrame._iIndex) === ((AnimationFrame._nStorageSize) - 1)? 0 : AnimationFrame._iIndex);
return AnimationFrame._pStorage[AnimationFrame._iIndex++];

}

;
this.fTime = 0;
this.fWeight = 1;
this.pMatrix = null;
this.qRotation = new Quat4();
this.v3fScale = new Vec3();
this.v3fTranslation = new Vec3();
switch(arguments.length) {
case 0:
this.pMatrix = new Mat4();
return ;

case 3:
this.fWeight = fWeight;

case 2:
this.pMatrix = pMatrix;

case 1:
this.fTime = fTime;
}
this.pMatrix.decompose(this.qRotation, this.v3fScale, this.v3fTranslation);

}

AnimationFrame.prototype.toMatrix = null;
AnimationFrame.prototype.toMatrixFromMatrix = function() {
"use strict";
return this.pMatrix;

};
AnimationFrame.prototype.toMatrixFromTransforms = function() {
"use strict";
return this.qRotation.toMat4(this.pMatrix).setTranslation(this.v3fTranslation).scaleRight(this.v3fScale);

};
AnimationFrame.prototype.reset = function() {
"use strict";
this.fWeight = 0;
this.fTime = 0;
var pData=this.pMatrix.pData;
pData[0] = pData[4] = pData[8] = pData[12] = pData[1] = pData[5] = pData[9] = pData[13] = pData[2] = pData[6] = pData[10] = pData[14] = pData[3] = pData[7] = pData[11] = pData[15] = 0;
pData = this.qRotation.pData;
pData[0] = pData[1] = pData[2] = 0;
pData[3] = 1;
pData = this.v3fTranslation.pData;
pData[0] = pData[1] = pData[2] = 0;
pData = this.v3fScale.pData;
pData[0] = pData[1] = pData[2] = 0;
return this;

};
AnimationFrame.prototype.set = function(pFrame) {
"use strict";
this.pMatrix.set(pFrame.pMatrix);
this.qRotation.set(pFrame.qRotation);
this.v3fScale.set(pFrame.v3fScale);
this.v3fTranslation.set(pFrame.v3fTranslation);
this.fTime = pFrame.fTime;
this.fWeight = pFrame.fWeight;

};
AnimationFrame.prototype.add = null;
AnimationFrame.prototype.addMatrix = function(pFrame) {
"use strict";
var pMatData=pFrame.pMatrix.pData;
var fWeight=pFrame.fWeight;
var pResData=this.pMatrix.pData;
for (var i=0; i < 16; ++i) {
pResData[i] += (pMatData[i]) * fWeight;

}

this.fWeight += fWeight;
return this;

};
AnimationFrame.prototype.addTransforms = function(pFrame, isFirst) {
"use strict";
var pScaleData=pFrame.v3fScale.pData;
var pTranslationData=pFrame.v3fTranslation.pData;
var fWeight=pFrame.fWeight;
var pResScaleData=this.v3fScale.pData;
var pResTranslationData=this.v3fTranslation.pData;
pResScaleData[0] += (pScaleData[0]) * fWeight;
pResScaleData[1] += (pScaleData[1]) * fWeight;
pResScaleData[2] += (pScaleData[2]) * fWeight;
pResTranslationData[0] += (pTranslationData[0]) * fWeight;
pResTranslationData[1] += (pTranslationData[1]) * fWeight;
pResTranslationData[2] += (pTranslationData[2]) * fWeight;
this.fWeight += fWeight;
if (!isFirst) {
this.qRotation.slerp(pFrame.qRotation, fWeight / (this.fWeight));

}
else  {
this.qRotation.set(pFrame.qRotation);

}

return this;

};
AnimationFrame.prototype.mult = function(fScalar) {
"use strict";
this.fWeight *= fScalar;
return this;

};
AnimationFrame.prototype.normilize = null;
AnimationFrame.prototype.normilizeMatrix = function() {
"use strict";
var fScalar=1 / (this.fWeight);
var pData=this.pMatrix.pData;
pData[0] *= fScalar;
pData[4] *= fScalar;
pData[8] *= fScalar;
pData[12] *= fScalar;
pData[1] *= fScalar;
pData[5] *= fScalar;
pData[9] *= fScalar;
pData[13] *= fScalar;
pData[2] *= fScalar;
pData[6] *= fScalar;
pData[10] *= fScalar;
pData[14] *= fScalar;
pData[3] *= fScalar;
pData[7] *= fScalar;
pData[11] *= fScalar;
pData[15] *= fScalar;
return this;

};
AnimationFrame.prototype.normilizeTransforms = function() {
"use strict";
var fScalar=1 / (this.fWeight);
var pScaleData=this.v3fScale.pData;
var pTranslationData=this.v3fTranslation.pData;
pScaleData[0] *= fScalar;
pScaleData[1] *= fScalar;
pScaleData[2] *= fScalar;
pTranslationData[0] *= fScalar;
pTranslationData[1] *= fScalar;
pTranslationData[2] *= fScalar;
return this;

};
AnimationFrame.prototype.interpolate = null;
AnimationFrame.prototype.interpolateMatrix = function(pStartFrame, pEndFrame, fBlend) {
"use strict";
var pResultData=this.pMatrix.pData;
var pStartData=pStartFrame.pMatrix.pData;
var pEndData=pEndFrame.pMatrix.pData;
var fBlendInv=1 - fBlend;
for (var i=0; i < 16; i++) {
pResultData[i] = ((pEndData[i]) * fBlend) + ((pStartData[i]) * fBlendInv);

}

;

};
AnimationFrame.prototype.interpolateTransformations = function(pStartFrame, pEndFrame, fBlend) {
"use strict";
pStartFrame.v3fTranslation.mix(pEndFrame.v3fTranslation, fBlend, this.v3fTranslation);
pStartFrame.v3fScale.mix(pEndFrame.v3fScale, fBlend, this.v3fScale);
pStartFrame.qRotation.slerp(pEndFrame.qRotation, fBlend, this.qRotation);

};
AnimationFrame.prototype.add = AnimationFrame.prototype.addTransforms;
AnimationFrame.prototype.normilize = AnimationFrame.prototype.normilizeTransforms;
AnimationFrame.prototype.interpolate = AnimationFrame.prototype.interpolateTransformations;
AnimationFrame.prototype.toMatrix = AnimationFrame.prototype.toMatrixFromTransforms;
a.allocateStorage(AnimationFrame, (4 * 4096));
a["AnimationFrame"] = AnimationFrame;
function AnimationTrack(sTarget) {
this._sTarget = sTarget || null;
this.pTarget = null;
this._pKeyFrames = [];
this._eInterpolationType = 0;

}

a.defineProperty(AnimationTrack, "targetName", function() {
return this.nodeName;

}
);
a.defineProperty(AnimationTrack, "target", function() {
return this.pTarget;

}
);
a.defineProperty(AnimationTrack, "nodeName", function() {
return this._sTarget;

}
, function(sValue) {
this._sTarget = sValue;

}
);
a.defineProperty(AnimationTrack, "duration", function() {
return this._pKeyFrames.last.fTime;

}
);
AnimationTrack.prototype.keyFrame = function(fTime, pMatrix) {
"use strict";
var pFrame;
var iFrame;
var pKeyFrames=this._pKeyFrames;
var nTotalFrames=pKeyFrames.length;
if ((arguments.length) > 1) {
pFrame = new a.AnimationFrame(fTime, pMatrix);

}
else  {
pFrame = arguments[0];

}

if (nTotalFrames && ((iFrame = this.findKeyFrame(pFrame.fTime)) >= 0)) {
pKeyFrames.splice(iFrame, 0, pFrame);

}
else  {
pKeyFrames.push(pFrame);

}

return true;

};
AnimationTrack.prototype.getKeyFrame = function(iFrame) {
"use strict";
if (!(iFrame < (this._pKeyFrames.length))) {
var err=((((((("Error:: " + "iFrame must be less then number of total jey frames.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/animation/AnimationTrack.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("iFrame must be less then number of total jey frames.");

}


}

;
return this._pKeyFrames[iFrame];

};
AnimationTrack.prototype.findKeyFrame = function(fTime) {
"use strict";
var pKeyFrames=this._pKeyFrames;
var nTotalFrames=pKeyFrames.length;
if ((pKeyFrames[nTotalFrames - 1].fTime) == fTime) {
return nTotalFrames - 1;

}
else  {
for (var i=nTotalFrames - 1; i >= 0; i--) {
if (((pKeyFrames[i].fTime) > fTime) && ((pKeyFrames[i - 1].fTime) <= fTime)) {
return i - 1;

}


}


}

return -1;

};
AnimationTrack.prototype.bind = function() {
"use strict";
var pNode=null, pRootNode;
var pSkeleton;
var sJoint;
switch(arguments.length) {
case 2:
sJoint = arguments[0];
pSkeleton = arguments[1];
this._sTarget = sJoint;
pNode = pSkeleton.findJoint(sJoint);
break ;

default:
if ((arguments[0]) instanceof (a.Skeleton)) {
if ((this._sTarget) == null) {
return false;

}

pSkeleton = arguments[0];
pNode = pSkeleton.findJoint(this._sTarget);

}
else if ((arguments[0]) instanceof (a.Node)) {
pRootNode = arguments[0];
pNode = pRootNode.findNode(this.nodeName);

}


;
}
this.pTarget = pNode;
return (pNode? true : false);

};
AnimationTrack.prototype.frame = function(fTime) {
"use strict";
var iKey1=0, iKey2=0;
var fScalar;
var fTimeDiff;
var pKeys=this._pKeyFrames;
var nKeys=pKeys.length;
var pFrame=a.AnimationFrame();
if (!nKeys) {
var err=((((((("Error:: " + "no frames :(") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/animation/AnimationTrack.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("no frames :(");

}


}

;
if (nKeys === 1) {
pFrame.set(pKeys[0]);

}
else  {
for (var i=0; i < nKeys; i++) {
if (fTime >= (this._pKeyFrames[i].fTime)) {
iKey1 = i;

}


}

iKey2 = (iKey1 >= (nKeys - 1)? iKey1 : iKey1 + 1);
fTimeDiff = (pKeys[iKey2].fTime) - (pKeys[iKey1].fTime);
if (!fTimeDiff)fTimeDiff = 1;

fScalar = (fTime - (pKeys[iKey1].fTime)) / fTimeDiff;
pFrame.interpolate(this._pKeyFrames[iKey1], this._pKeyFrames[iKey2], fScalar);

}

pFrame.fTime = fTime;
pFrame.fWeight = 1;
return pFrame;

};
AnimationTransformation = AnimationTrack;
a["AnimationTrack"] = AnimationTrack;
a["AnimationTransformation"] = AnimationTransformation;
function Animation(sName) {
var _pCtorValue=Animation.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pTracks = [];
if (sName) {
this.name = sName;

}


}

a.extend(Animation, a.AnimationBase);
a.defineProperty(Animation, "totalTracks", function() {
return this._pTracks.length;

}
);
Animation.prototype.push = function(pTrack) {
"use strict";
this._pTracks.push(pTrack);
this._fDuration = Math.max(this._fDuration, pTrack.duration);
this.addTarget(pTrack.targetName);

};
Animation.prototype.bind = function(pTarget) {
"use strict";
var pPointer;
var pTracks=this._pTracks;
for (var i=0; i < (pTracks.length); ++i) {
if (!(pTracks[i].bind(pTarget))) {
trace("cannot bind animation track [", i, "] to joint <", pTracks[i]._sTarget, ">");

}
else  {
pPointer = this.setTarget(pTracks[i].targetName, pTracks[i].target);
pPointer.track = pTracks[i];

}


}

;

};
Animation.prototype.frame = function(sName, fTime) {
"use strict";
var pPointer=this._pTargetMap[sName];
if ((!pPointer) || (!(pPointer.track))) {
return null;

}

return pPointer.track.frame(Math.max(0, Math.min(fTime, this._fDuration)));

};
AnimationBase.prototype.extend = function(pAnimation) {
var pTracks=pAnimation._pTracks;
for (var i=0; i < (pTracks.length); ++i) {
if (!(this.getTarget(pTracks[i].targetName))) {
this.push(pTracks[i]);

}


}


};
a["Animation"] = Animation;
function AnimationContainer(pAnimation) {
var _pCtorValue=AnimationContainer.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._bEnable = true;
this._fStartTime = 0;
this._fSpeed = 1;
this._bLoop = false;
this._pAnimation = null;
this._bReverse = false;
this._fTrueTime = 0;
this._fRealTime = 0;
this._fTime = 0;
this._bPause = false;
this._bLeftInfinity = true;
this._bRightInfinity = true;
this.name = "container-" + (a.sid());
if (pAnimation) {
this.setAnimation(pAnimation);

}


}

a.extend(AnimationContainer, a.AnimationBase);
a.defineProperty(AnimationContainer, "animationName", function() {
return this._pAnimation.name;

}
);
a.defineProperty(AnimationContainer, "speed", function() {
return this._fSpeed;

}
);
AnimationContainer.prototype.getTime = function() {
"use strict";
return this._fTime;

};
AnimationContainer.prototype.play = function(fRealTime) {
"use strict";
this._fRealTime = fRealTime;
this._fTime = 0;
this.fire("play", this._fTime);

};
AnimationContainer.prototype.stop = function() {
"use strict";
this.fire("stop", this._fTime);

};
AnimationContainer.prototype.bind = function(pTarget) {
this._pAnimation.bind(pTarget);
this.grab(this._pAnimation, true);

};
AnimationContainer.prototype.setAnimation = function(pAnimation) {
"use strict";
if (!(!(this._pAnimation))) {
var err=((((((("Error:: " + "anim. already exists") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/animation/AnimationContainer.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("anim. already exists");

}


}

;
this._pAnimation = pAnimation;
this.setSpeed(this.speed);
var me=this;
pAnimation.on("updateDuration", function() {
me.setSpeed(me.speed);

}
);
this.grab(pAnimation);

};
AnimationContainer.prototype.getAnimation = function() {
"use strict";
return this._pAnimation;

};
AnimationContainer.prototype.enable = function() {
"use strict";
this._bEnable = true;

};
AnimationContainer.prototype.disable = function() {
"use strict";
this._bEnable = false;

};
AnimationContainer.prototype.isEnabled = function() {
"use strict";
return this._bEnable;

};
AnimationContainer.prototype.leftInfinity = function(bValue) {
this._bLeftInfinity = bValue;

};
AnimationContainer.prototype.rightInfinity = function(bValue) {
this._bRightInfinity = bValue;

};
AnimationContainer.prototype.setStartTime = function(fRealTime) {
"use strict";
this._fStartTime = fRealTime;

};
AnimationContainer.prototype.getStartTime = function() {
"use strict";
return this._fStartTime;

};
AnimationContainer.prototype.setSpeed = function(fSpeed) {
"use strict";
this._fSpeed = fSpeed;
this._fDuration = (this._pAnimation._fDuration) / fSpeed;
this.fire("updateDuration");

};
AnimationContainer.prototype.getSpeed = function() {
"use strict";
return this._fSpeed;

};
AnimationContainer.prototype.useLoop = function(bValue) {
"use strict";
this._bLoop = bValue;

};
AnimationContainer.prototype.inLoop = function() {
"use strict";
return this._bLoop;

};
AnimationContainer.prototype.reverse = function(bValue) {
this._bReverse = bValue;

};
AnimationContainer.prototype.isReversed = function() {
return this._bReverse;

};
AnimationContainer.prototype.pause = function(bValue) {
"use strict";
this._bPause = bValue;

};
AnimationContainer.prototype.rewind = function(fRealTime) {
"use strict";
this._fTime = fRealTime;

};
AnimationContainer.prototype.isPaused = function() {
"use strict";
return this._bPause;

};
AnimationContainer.prototype.time = function(fRealTime) {
"use strict";
if (this._bPause) {
return ;

}

this._fTime = (this._fTime) + ((fRealTime - (this._fRealTime)) * (this._fSpeed));
this._fRealTime = fRealTime;
var fTime=this._fTime;
if (this._bLoop) {
fTime = fTime - ((Math.floor(fTime / this._pAnimation._fDuration)) * this._pAnimation._fDuration);
if (this._bReverse) {
fTime = (this._pAnimation._fDuration) - fTime;

}


}

this._fTrueTime = fTime;

};
AnimationContainer.prototype.frame = function(sName, fRealTime) {
"use strict";
if (!(this._bEnable)) {
return null;

}

if ((this._fRealTime) !== fRealTime) {
this.time(fRealTime);

}

if ((!(this._bLeftInfinity)) && ((this._fRealTime) < (this._fStartTime))) {
return null;

}

if ((!(this._bRightInfinity)) && ((this._fRealTime) > ((this._fDuration) + (this._fStartTime)))) {
return null;

}

return this._pAnimation.frame(sName, this._fTrueTime);

};
a["AnimationContainer"] = AnimationContainer;
function AnimationController(pEngine, eOptions) {
"use strict";
if (!pEngine) {
var err=((((((("Error:: " + "engine must be.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/animation/AnimationController.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("engine must be.");

}


}

;
this._pEngine = pEngine;
this._pAnimations = [];
this._eOptions = 0;
this._pActiveAnimation = null;
this._fnPlayAnimation = null;
if (eOptions) {
this.setOptions(eOptions);

}


}

a.defineProperty(AnimationController, "totalAnimations", function() {
return this._pAnimations.length;

}
);
a.defineProperty(AnimationController, "active", function() {
return this._pActiveAnimation;

}
);
AnimationController.prototype.on = function(eEvent, fn) {
"use strict";
if (eEvent === "play") {
this._fnPlayAnimation = fn;

}


};
AnimationController.prototype.getEngine = function() {
return this._pEngine;

};
AnimationController.prototype.setOptions = function(eOptions) {

};
AnimationController.prototype.addAnimation = function(pAnimation) {
if (this.findAnimation(pAnimation.name)) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/model/animation/AnimationController.js") + "][") + "") + "]") + (("Animation with name <" + (pAnimation.name)) + "> already exists in this controller"));
return false;

}

this._pAnimations.push(pAnimation);
this._pActiveAnimation = pAnimation;

};
AnimationController.prototype.removeAnimation = function() {
"use strict";
var pAnimation=this.findAnimation(arguments[0]);
var pAnimations=this._pAnimations;
for (var i=0; i < (pAnimations.length); ++i) {
if ((pAnimations[i]) === pAnimation) {
pAnimations.splice(i, 1);
trace("animation controller :: remove animation >> ", pAnimation.name);
return true;

}


}

return false;

};
AnimationController.prototype.findAnimation = function() {
"use strict";
var pAnimations=this._pAnimations;
var iAnimation;
var sAnimation;
if ((typeof (arguments[0])) === "string") {
sAnimation = arguments[0];
for (var i=0; i < (pAnimations.length); ++i) {
if ((pAnimations[i].name) === sAnimation) {
return pAnimations[i];

}


}

return null;

}

if ((typeof (arguments[0])) === "number") {
iAnimation = arguments[0];
return (pAnimations[iAnimation]) || null;

}

return arguments[0];

};
AnimationController.prototype.setAnimation = function(iAnimation, pAnimation) {
"use strict";
if (!(iAnimation < (this._pAnimations.length))) {
var err=((((((("Error:: " + "invalid animation slot") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/animation/AnimationController.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid animation slot");

}


}

;
this._pAnimations[iAnimation] = pAnimation;

};
AnimationController.prototype.bind = function(pTarget) {
"use strict";
var pAnimations=this._pAnimations;
for (var i=0; i < (pAnimations.length); ++i) {
pAnimations[i].bind(pTarget);

}


};
AnimationController.prototype.play = function(pAnimation, fRealTime) {
var pAnimationNext=this.findAnimation(arguments[0]);
var pAnimationPrev=this._pActiveAnimation;
if (pAnimationNext && (pAnimationNext !== pAnimationPrev)) {
if (this._fnPlayAnimation) {
this._fnPlayAnimation(pAnimationNext);

}

if (pAnimationPrev) {
pAnimationPrev.stop(fRealTime);

}

pAnimationNext.play(fRealTime);
this._pActiveAnimation = pAnimationNext;
return true;

}

return false;

};
AnimationController.prototype.update = function(fTime) {
"use strict";
if (this._pActiveAnimation) {
this._pActiveAnimation.apply(fTime);

}


};
a["AnimationController"] = AnimationController;
function AnimationBlend() {
var _pCtorValue=AnimationBlend.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pAnimationList = [];
this.duration = 0;

}

a.extend(AnimationBlend, a.AnimationBase);
a.defineProperty(AnimationBlend, "totalAnimations", function() {
return this._pAnimationList.length;

}
);
AnimationBlend.prototype.play = function(fRealTime) {
"use strict";
var pAnimationList=this._pAnimationList;
var n=pAnimationList.length;
for (var i=0; i < n; ++i) {
pAnimationList[i].realTime = fRealTime;
pAnimationList[i].time = fRealTime * (pAnimationList[i].acceleration);

}

this.fire("play");

};
AnimationBlend.prototype.stop = function() {
"use strict";
this.fire("stop", this._fTime);

};
AnimationBlend.prototype.bind = function(pTarget) {
var pAnimationList=this._pAnimationList;
for (var i=0; i < (pAnimationList.length); ++i) {
var pAnim=pAnimationList[i].animation;
pAnim.bind(pTarget);
this.grab(pAnim, true);

}


};
AnimationBlend.prototype.addAnimation = function(pAnimation, fWeight, pMask) {
"use strict";
if (!pAnimation) {
var err=((((((("Error:: " + "animation must be setted.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/animation/AnimationBlend.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("animation must be setted.");

}


}

;
this._pAnimationList.push(null);
return this.setAnimation((this._pAnimationList.length) - 1, pAnimation, fWeight, pMask);

};
AnimationBlend.prototype.setAnimation = function(iAnimation, pAnimation, fWeight, pMask) {
"use strict";
if (!(iAnimation <= (this._pAnimationList.length))) {
var err=((((((("Error:: " + ((("invalid animation slot: " + iAnimation) + "/") + (this._pAnimationList.length))) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/model/animation/AnimationBlend.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error(((("invalid animation slot: " + iAnimation) + "/") + (this._pAnimationList.length)));

}


}

;
var pPointer=this._pAnimationList[iAnimation];
var me=this;
var pAnimationList=this._pAnimationList;
if (!pAnimation) {
pAnimationList[iAnimation] = null;
return iAnimation;

}

if (!pPointer) {
pPointer =  {animation: pAnimation, weight: (fWeight === undefined? 1 : fWeight), mask: pMask || null, acceleration: 1, time: 0, realTime: 0};
pAnimation.on("updateDuration", function() {
me.updateDuration();

}
);
if (iAnimation == (this._pAnimationList.length)) {
pAnimationList.push(pPointer);

}
else  {
pAnimationList[iAnimation] = pPointer;

}


}

this.grab(pAnimation);
this.updateDuration();
return iAnimation;

};
AnimationBlend.prototype.updateDuration = function() {
"use strict";
var fWeight=0;
var fSumm=0;
var pAnimationList=this._pAnimationList;
var n=pAnimationList.length;
for (var i=0; i < n; ++i) {
if ((pAnimationList[i]) === null) {
continue ;

}

fSumm += (pAnimationList[i].weight) * (pAnimationList[i].animation._fDuration);
fWeight += pAnimationList[i].weight;

}

if (fWeight === 0) {
this._fDuration = 0;

}
else  {
this._fDuration = fSumm / fWeight;
for (var i=0; i < n; ++i) {
if ((pAnimationList[i]) === null) {
continue ;

}

pAnimationList[i].acceleration = (pAnimationList[i].animation._fDuration) / (this._fDuration);

}


}

this.fire("updateDuration");

};
AnimationBlend.prototype.getAnimationIndex = function(sName) {
"use strict";
var pAnimationList=this._pAnimationList;
for (var i=0; i < (pAnimationList.length); i++) {
if ((pAnimationList[i].animation.name) === sName) {
return i;

}


}

;
return -1;

};
AnimationBlend.prototype.getAnimation = function(iAnimation) {
"use strict";
if ((typeof (arguments[0])) === "string") {
iAnimation = this.getAnimationIndex(arguments[0]);

}

return this._pAnimationList[iAnimation].animation;

};
AnimationBlend.prototype.getAnimationWeight = function(iAnimation) {
"use strict";
if ((typeof (arguments[0])) === "string") {
iAnimation = this.getAnimationIndex(arguments[0]);

}

return this._pAnimationList[iAnimation].weight;

};
AnimationBlend.prototype.setWeights = function() {
"use strict";
var fWeight;
var isModified=false;
var pAnimationList=this._pAnimationList;
for (var i=0; i < (arguments.length); ++i) {
fWeight = arguments[i];
if (((fWeight < 0) || (fWeight === null)) || (!(pAnimationList[i]))) {
continue ;

}

if ((pAnimationList[i].weight) !== fWeight) {
pAnimationList[i].weight = fWeight;
isModified = true;

}


}

if (isModified) {
this.updateDuration();

}

return true;

};
AnimationBlend.prototype.setWeightSwitching = function(fWeight, iAnimationFrom, iAnimationTo) {
"use strict";
var pAnimationList=this._pAnimationList;
var isModified=false;
var fWeightInv=1 - fWeight;
if ((!(pAnimationList[iAnimationFrom])) || (!(pAnimationList[iAnimationTo]))) {
return false;

}

if ((pAnimationList[iAnimationFrom].weight) !== fWeightInv) {
pAnimationList[iAnimationFrom].weight = fWeightInv;
isModified = true;

}

if ((pAnimationList[iAnimationTo].weight) !== fWeight) {
pAnimationList[iAnimationTo].weight = fWeight;
isModified = true;

}

if (isModified) {
this.updateDuration();

}

return true;

};
AnimationBlend.prototype.setAnimationWeight = function(iAnimation, fWeight) {
"use strict";
var pAnimationList=this._pAnimationList;
var isModified=false;
if ((arguments.length) === 1) {
fWeight = arguments[0];
for (var i=0; i < (pAnimationList.length); i++) {
pAnimationList[i].weight = fWeight;

}

;
isModified = true;

}
else  {
if ((typeof (arguments[0])) === "string") {
iAnimation = this.getAnimationIndex(arguments[0]);

}

if ((pAnimationList[iAnimation].weight) !== fWeight) {
pAnimationList[iAnimation].weight = fWeight;
isModified = true;

}


}

if (isModified) {
this.updateDuration();

}

return true;

};
AnimationBlend.prototype.setAnimationMask = function(iAnimation, pMask) {
"use strict";
if ((typeof (arguments[0])) === "string") {
iAnimation = this.getAnimationIndex(arguments[0]);

}

this._pAnimationList[iAnimation].mask = pMask;
return true;

};
AnimationBlend.prototype.getAnimationMask = function(iAnimation) {
if ((typeof (arguments[0])) === "string") {
iAnimation = this.getAnimationIndex(arguments[0]);

}

return this._pAnimationList[iAnimation].mask;

};
AnimationBlend.prototype.createAnimationMask = function(iAnimation) {
if ((arguments.length) === 0) {
return a.AnimationBase.prototype.createAnimationMask.call(this);

}

if ((typeof (arguments[0])) === "string") {
iAnimation = this.getAnimationIndex(arguments[0]);

}

var pAnimation=this._pAnimationList[iAnimation].animation;
return pAnimation.createAnimationMask();

};
AnimationBlend.prototype.frame = function(sName, fRealTime) {
"use strict";
var pAnimationList=this._pAnimationList;
var pResultFrame=a.AnimationFrame().reset();
var pFrame;
var pMask;
var pPointer;
var fAcceleration;
var fBoneWeight;
var fWeight;
var iAnim=0;
for (var i=0; i < (pAnimationList.length); i++) {
pPointer = pAnimationList[i];
if (!pPointer) {
continue ;

}

fAcceleration = pPointer.acceleration;
pMask = pPointer.mask;
fBoneWeight = 1;
pPointer.time = (pPointer.time) + ((fRealTime - (pPointer.realTime)) * fAcceleration);
pPointer.realTime = fRealTime;
pFrame = pPointer.animation.frame(sName, pPointer.time);
if (pMask) {
fBoneWeight = (pMask[sName] === undefined? 1 : pMask[sName]);

}

fWeight = fBoneWeight * (pPointer.weight);
if (pFrame && (fWeight > 0)) {
iAnim++;
pResultFrame.add(pFrame.mult(fWeight), iAnim === 1);

}


}

if ((pResultFrame.fWeight) === 0) {
return null;

}

return pResultFrame.normilize();

};
a["AnimationBlend"] = AnimationBlend;
(function(f) {
a.binaryTemplate.set(f);

}
)( {"AnimationFrame":  {members:  {"fTime": "Float", "fWeight": "Float", "pMatrix":  {write: function(pFrame) {
var m4f=pFrame.pMatrix;
if ((((Math.abs((pFrame.v3fScale.x) - 1)) > 0.01) || ((Math.abs((pFrame.v3fScale.y) - 1)) > 0.01)) || ((Math.abs((pFrame.v3fScale.z) - 1)) > 0.01)) {
trace("writing > wrong pFrame detected > ", pFrame);
trace(m4f.toString());

}

this.write(m4f);

}
, read: function(pFrame) {
var m4f=this.read();
m4f.decompose(pFrame.qRotation, pFrame.v3fScale, pFrame.v3fTranslation);
if ((((Math.abs((pFrame.v3fScale.x) - 1)) > 0.01) || ((Math.abs((pFrame.v3fScale.y) - 1)) > 0.01)) || ((Math.abs((pFrame.v3fScale.z) - 1)) > 0.01)) {
trace("loading > wrong pFrame detected > ", pFrame);
trace(m4f.toString());

}

return m4f;

}
}}, ctor: function() {
return new a.AnimationFrame();

}
}, "AnimationTrack":  {members:  {"_sTarget": "String", "_pKeyFrames": "Array"}, ctor: "a.AnimationTrack"}, "AnimationBase":  {members:  {"_pTargetMap": "Object", "_pTargetList": "Array", "_fDuration": "Float", "_sName":  {read: function() {
var str=this.read();
trace("loading animation: ", str);
return str;

}
, write: function(pAnimation) {
trace("writing animation: ", pAnimation.name);
this.write(pAnimation.name);

}
}, "extra": "Object"}, blacklist:  {"Joint": null, "Node": null, "SceneModel": null, "SceneObject": null, "SceneNode": null}}, "Animation":  {members:  {"_pTracks": "Array"}, base: ["AnimationBase"], ctor: "a.Animation"}, "AnimationContainer":  {members:  {"_bEnable": "Boolean", "_fStartTime": "Float", "_fSpeed": "Float", "_bLoop": "Boolean", "_pAnimation":  {read: function(pContainer) {
var pAnimation=this.read();
if (pAnimation) {
pContainer.setAnimation(pAnimation);

}


}
}, "_fDuration": "Float", "_bReverse": "Boolean", "_bPause": "Boolean"}, base: ["AnimationBase"], ctor: "a.AnimationContainer"}, "AnimationBlend":  {members:  {"_pAnimationList":  {read: function(pAnimationBlend) {
var pAnimations=this.read();
for (var i=0; i < (pAnimations.length); ++i) {
trace(pAnimations[i].animation.name, pAnimations[i].weight);
pAnimationBlend.setAnimation(i, pAnimations[i].animation, pAnimations[i].weight, pAnimations[i].mask);

}


}
, write: function(pBlend) {
var pAnimations=pBlend._pAnimationList;
for (var i=0; i < (pAnimations.length); ++i) {
trace("write animation from list: ", pAnimations[i].animation.name, pAnimations[i].weight);

}

this.write(pAnimations);

}
}}, base: ["AnimationBase"], ctor: "a.AnimationBlend", blacklist:  {"Function": null}}, "AnimationSwitch":  {base: ["AnimationBase"], ctor: "a.AnimationSwitch"}, "AnimationController":  {ctor: function() {
return new a.AnimationController(this.options["engine"]);

}
, members:  {"_pAnimations":  {read: function() {
return this.read();

}
, write: "Array"}, "_eOptions": "Int", "_pActiveAnimation": null}}});
function ModelResource(pEngine) {
var _pCtorValue=ModelResource.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pRootNodeList = [];
this._pAnimController = new a.AnimationController(pEngine);
this._pMeshList = [];
this._pSkeletonList = [];
this._nFilesToBeLoaded = 0;
this._pNode = null;

}

a.extend(ModelResource, a.ResourcePoolItem);
a.defineProperty(ModelResource, "totalAnimations", function() {
return this._pAnimController.totalAnimations;

}
);
a.defineProperty(ModelResource, "node", function() {
return this._pNode;

}
);
ModelResource.prototype.createResource = function() {
if (!(!(this.isResourceCreated()))) {
var err=((((((("Error:: " + "The resource has already been created.") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/ModelResource.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("The resource has already been created.");

}


}

;
this.notifyCreated();
this.notifyDisabled();
return true;

};
ModelResource.prototype.destroyResource = function() {
if (this._pFrameRoot) {
this._pFrameRoot = 0;

}

if (this._pAnimController) {
var safe_release_refcount=this._pAnimController.release();
if (safe_release_refcount != 0) {
if (!0) {
var err=((((((("Error:: " + (("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n")) + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/resources/ModelResource.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error((("WARNING: non-zero reference count on release (" + safe_release_refcount) + ")\n"));

}


}

;

}

this._pAnimController = 0;

}

;
return true;

};
ModelResource.prototype.disableResource = function() {
return true;

};
ModelResource.prototype.restoreResource = function() {
return true;

};
ModelResource.prototype.getAnimation = function(iAnim) {
"use strict";
return (this._pAnimList[iAnim]) || null;

};
ModelResource.prototype.setAnimation = function(iAnim, pAnimation) {
"use strict";
this._pAnimController.setAnimation(iAnim, pAnimation);

};
ModelResource.prototype.addAnimation = function(pAnimation) {
"use strict";
this._pAnimController.addAnimation(pAnimation);
this.setAlteredFlag(true);

};
ModelResource.prototype.getAnimationController = function() {
"use strict";
return this._pAnimController;

};
ModelResource.prototype.addMesh = function(pMesh) {
"use strict";
this._pMeshList.push(pMesh);
this.setAlteredFlag(true);

};
ModelResource.prototype.addNode = function(pNode) {
"use strict";
this._pRootNodeList.push(pNode);
this.setAlteredFlag(true);

};
ModelResource.prototype.addSkeleton = function(pSkeleton) {
"use strict";
this._pSkeletonList.push(pSkeleton);
this.setAlteredFlag(true);

};
ModelResource.prototype.addToScene = function() {
"use strict";
var pNodes=this._pRootNodeList;
var pRoot=new a.SceneNode(this._pEngine);
pRoot.create();
pRoot.setInheritance(2);
pRoot.attachToParent(this._pEngine.getRootNode());
for (var i=0; i < (pNodes.length); ++i) {
pNodes[i].attachToParent(pRoot);

}

this._pAnimController.bind(pRoot);
this._pNode = pRoot;

};
ModelResource.prototype.getRootNodes = function() {
"use strict";
return this._pRootNodeList;

};
ModelResource.prototype.loadResource = function(sFilename, pOptions) {
"use strict";
var me=this;
var fnCustomCallback=(pOptions && (pOptions.success)? pOptions.success : null);
var fnCallback=function() {
if (me.isResourceLoaded()) {
me.setAlteredFlag();

}

fnSuccess();
if (fnCustomCallback) {
fnCustomCallback.call(me);

}


};
var fnSuccess=function() {
me._nFilesToBeLoaded--;
if ((me._nFilesToBeLoaded) == 0) {
if (fnCustomCallback == null) {
me.notifyLoaded();

}

me.notifyRestored();

}


};
me._nFilesToBeLoaded++;
me.notifyDisabled();
if ((a.pathinfo(sFilename).ext.toLowerCase()) === "dae") {
pOptions = pOptions || ( {drawJoints: false, wireframe: false});
pOptions.file = sFilename;
pOptions.modelResource = this;
pOptions.success = fnCallback;
a.COLLADA(this._pEngine, pOptions);
return true;

}

if ((a.pathinfo(sFilename).ext.toLowerCase()) === "aac") {
a.fopen(sFilename, "rb").read(function(pData) {
me._pAnimController = a.undump(pData,  {engine: me.getEngine()});
fnCallback();

}
);
return true;

}

fnSuccess();
return false;

};
ModelResource.prototype.loadAnimation = function(sFilename) {
"use strict";
return this.loadResource(sFilename,  {scene: false, animation: true, extractPoses: false, skeletons: this._pSkeletonList, animationWithPose: true});

};
ModelResource.prototype.applyShadow = function() {
var pMeshes=this._pMeshList, pMesh, pSubMesh;
var i, j;
var pEffectPool=this._pEngine.displayManager().effectPool(), pRenderMethodPool=this._pEngine.displayManager().renderMethodPool();
var pEffect;
var pRenderMethod=pRenderMethodPool.findResource(".prepare_shadow_for_mesh");
if (!pRenderMethod) {
pRenderMethod = pRenderMethodPool.createResource(".prepare_shadow_for_mesh");
pEffect = pEffectPool.createResource(".prepare_shadow_for_mesh");
pEffect.create();
pEffect.use("akra.system.prepareShadows");
pRenderMethod.effect = pEffect;

}

if ((!pMeshes) || ((pMeshes.length) === 0)) {
return false;

}

for (i = 0; i < (pMeshes.length); i++) {
pMesh = pMeshes[i];
for (j = 0; j < (pMesh.length); j++) {
pSubMesh = pMesh[j];
pSubMesh.addRenderMethod(pRenderMethod, ".prepare_shadows");
pSubMesh.hasShadow(true);

}


}


};
a["ModelResource"] = ModelResource;
function ParticleManager(pEngine) {
"use strict";
this._pEmitters = [];
this._pEngine = pEngine;
this._pDataFactory = new a.RenderDataBuffer(pEngine);
this._pDataFactory.dataType = a.RenderData;
this._pDataFactory.setup(8);
this._pFramebuffer = null;
this._setup();

}

;
ParticleManager.prototype._setup = function() {
"use strict";
var pDevice=this._pEngine.pDevice;
this._pFramebuffer = pDevice.createFramebuffer();

};
ParticleManager.prototype.registerEmitter = function(pEmitter) {
"use strict";
var pDataSubset=this._pDataFactory.getEmptyRenderData(0, 0);
this._pEmitters.push(pEmitter);
return pDataSubset;

};
a["ParticleManager"] = ParticleManager;
function Emitter(pEngine, eType, nParticles) {
"use strict";
var _pCtorValue=Emitter.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pEngine = pEngine;
this._pDataSubset = pEngine.particleManager().registerEmitter(this);
this._eType = eType;
this._nParticles = nParticles;
this._isActive = false;
this._bParticleDataSetted = false;
this._fTTL = 0;
this._iUpdateMapIndex = this._pDataSubset.getIndexSet();
this._iDrawMapIndex = -1;
this._pParticleData = null;
this._pObjectData = null;
this._pMesh = null;
this._nDrawIndexLength = -1;
this._fnUpdate = null;
this._fnDraw = null;
this._fTime = 0;
this._fDt = 0;
this._nStep = 0;
this._nPreviousTime = 0;
this._nCurrentTime = 0;
this._pPrograms = [];
this._pParticleOffsetsList =  {};
this._pObjectOffsetsList =  {};
this._fTimeAcceleration = 1;
this._setup();

}

a.extend(Emitter, a.SceneObject, a.RenderableObject);
Emitter.prototype.setProgram = function(pProgram) {
"use strict";
this._pPrograms.push(pProgram);

};
Emitter.prototype._setup = function() {
"use strict";
switch(this._eType) {
case 1:
this._nDrawIndexLength = 1 * (this._nParticles);
break ;

case 3:
this._nDrawIndexLength = 3 * (this._nParticles);
break ;

case 4:
this._nDrawIndexLength = 6 * (this._nParticles);
break ;

case 5:
;

case 6:
break ;

default:
console.error("неверный тип частиц");
this._eType = a.EMITTER.POINTLIST;
break ;
}

};
Emitter.prototype.setParticleData = function(pVertexDecl, pData) {
"use strict";
if (this._bParticleDataSetted) {
console.error("нельзя добавлять данные для частиц после добавления данных для объекта");
return ;

}

var pVertexDeclaration=normalizeVertexDecl(pVertexDecl);
if (pVertexDeclaration.hasSemantics("POSITION")) {
if (!0) {
var err=((((((("Error:: " + "семантику POSITION апрещено использовать для данных частиц, используйте PARTICLE_POSITION") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("семантику POSITION апрещено использовать для данных частиц, используйте PARTICLE_POSITION");

}


}

;
return ;

}

pData = new Uint8Array(pData.buffer);
var iStride=pVertexDeclaration.stride;
var nElementsPerPixel=4;
if (!(this._isActive)) {
if (!(((pData.byteLength) % iStride) == 0)) {
var err=((((((("Error:: " + "неверное количество данных") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("неверное количество данных");

}


}

;
if (!((this._nParticles) == ((pData.byteLength) / iStride))) {
var err=((((((("Error:: " + "количество данных не соответствует количеству частиц") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("количество данных не соответствует количеству частиц");

}


}

;
for (var i=0; i < (pVertexDeclaration.length); i++) {
var pVertexElement=pVertexDeclaration[i];
var iSize=pVertexElement.iSize;
var pElementData;
var iOffset=pVertexElement.iOffset;
var pNewVertexDeclaration;
if ((((pVertexElement.eUsage) == "PARTICLE_POSITION") || ((pVertexElement.eUsage) == "PARTICLE_VELOCITY")) || 1) {
if (!((pVertexElement.eType) == (5126))) {
var err=((((((("Error:: " + "позиции и скорости должна быть типа float") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("позиции и скорости должна быть типа float");

}


}

;
if (!((pVertexElement.nCount) <= nElementsPerPixel)) {
var err=((((((("Error:: " + "длина скорости и позиции не должна превышать количества элементов на пиксель в текстуре") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("длина скорости и позиции не должна превышать количества элементов на пиксель в текстуре");

}


}

;
var pElementData;
pElementData = new Uint8Array((4 * (this._nParticles)) * nElementsPerPixel);
for (var j=0; j < (this._nParticles); j++) {
var pSubData=pData.subarray((j * iStride) + iOffset, ((j * iStride) + iOffset) + iSize);
pElementData.set(pSubData, (4 * nElementsPerPixel) * j);

}

if ((pVertexElement.eUsage) == "PARTICLE_POSITION") {
pNewVertexDeclaration = [new Object( {nCount: 4, eType: 5126, eUsage: "PARTICLE_POSITION", iOffset: undefined})];

}
else if ((pVertexElement.eUsage) == "PARTICLE_VELOCITY") {
pNewVertexDeclaration = [new Object( {nCount: 4, eType: 5126, eUsage: "PARTICLE_VELOCITY", iOffset: undefined})];

}
else  {
pNewVertexDeclaration = [new Object( {nCount: 4, eType: 5126, eUsage: pVertexElement.eUsage, iOffset: undefined})];

}



}
else  {
pElementData = new Uint8Array(iSize * (this._nParticles));
for (var j=0; j < (this._nParticles); j++) {
var pSubData=pData.subarray((j * iStride) + iOffset, ((j * iStride) + iOffset) + iSize);
pElementData.set(pSubData, iSize * j);

}


}

if ((this._pParticleData) == null) {
var iDataLocation=this._pDataSubset.allocateData(pNewVertexDeclaration, pElementData);
this._pParticleData = this._pDataSubset.getData(iDataLocation);

}
else  {
this._pParticleData.extend(pNewVertexDeclaration, pElementData);

}

var pDeclaration=this._pParticleData.getVertexDeclaration();
var iOffset=(pDeclaration.element(pVertexElement.eUsage).iOffset) / 4;
var sUniformName=("INDEX_" + (pVertexElement.eUsage)) + "_OFFSET";
this._pParticleOffsetsList[sUniformName] = iOffset;

}


}


};
Emitter.prototype._setObjectData = function(pVertexDecl, pData) {
"use strict";
if (!(this._bParticleDataSetted)) {
if ((this._eType) == (4)) {
this._iDrawMapIndex = this._pDataSubset.addIndexSet(true, 5, "draw");

}
else  {
this._iDrawMapIndex = this._pDataSubset.addIndexSet(true, 4, "draw");

}

this._bParticleDataSetted = true;

}

if ((this._eType) == (5)) {
return this._pDataSubset.allocateData(pVertexDecl, pData);

}
else  {
var pVertexDeclaration=normalizeVertexDecl(pVertexDecl);
pData = new Uint8Array(pData.buffer);
var nElementsPerPixel=4;
var iStride=pVertexDeclaration.iStride;
var pElementData;
var nEndIndex;
if ((this._eType) == (4)) {
pElementData = new Uint8Array(16 * nElementsPerPixel);
nEndIndex = 4;

}
else  {
pElementData = new Uint8Array(12 * nElementsPerPixel);
nEndIndex = 3;

}

for (var i=0; i < (pVertexDeclaration.length); i++) {
var pVertexElement=pVertexDeclaration[i];
var iSize=pVertexElement.iSize;
var iOffset=pVertexElement.iOffset;
var pNewVertexDeclaration;
for (var j=0; j < nEndIndex; j++) {
var pSubData=pData.subarray((j * iStride) + iOffset, ((j * iStride) + iOffset) + iSize);
pElementData.set(pSubData, (4 * nElementsPerPixel) * j);

}

pNewVertexDeclaration = [new Object( {nCount: 4, eType: 5126, eUsage: pVertexElement.eUsage, iOffset: undefined})];

}

if ((this._pObjectData) == null) {
var iDataLocation=this._pDataSubset.allocateData(pNewVertexDeclaration, pElementData);
this._pObjectData = this._pDataSubset.getData(iDataLocation);

}
else  {
this._pObjectData.extend(pNewVertexDeclaration, pElementData);

}

var pDeclaration=this._pObjectData.getVertexDeclaration();
var iOffset=(pDeclaration.element(pVertexElement.eUsage).iOffset) / 4;
var sUniformName=("INDEX_" + (pVertexElement.eUsage)) + "_OFFSET";
this._pObjectOffsetsList[sUniformName] = iOffset;

}


};
Emitter.prototype._setObjectIndex = function(pAttrDecl, pData) {
"use strict";
pData = new Uint8Array(pData.buffer);
var pDataExtended=new Uint8Array((pData.byteLength) * (this._nParticles));
for (var i=0; i < (this._nParticles); i++) {
pDataExtended.set(pData, (pData.byteLength) * i);

}

return this._pDataSubset.allocateIndex(pAttrDecl, pDataExtended);

};
Emitter.prototype._setObjectAttribute = function(pAttrDecl, pData) {
"use strict";
pData = new Uint8Array(pData.buffer);
var pDataExtended=new Uint8Array((pData.byteLength) * (this._nParticles));
for (var i=0; i < (this._nParticles); i++) {
pDataExtended.set(pData, (pData.byteLength) * i);

}

return this._pDataSubset.setIndex.allocateAttribute(pAttrDecl, pDataExtended);

};
Emitter.prototype._objectIndex = function(iData, eSemantic) {
"use strict";
return this._pDataSubset.index(iData, eSemantic);

};
Emitter.prototype.setObjectData = function(pVertexDecl, pData) {
"use strict";
var pVertexDeclaration=normalizeVertexDecl(pVertexDecl);
if ((this._eType) == (5)) {
return this._setObjectData(pVertexDecl, pData);

}
else if ((this._eType) == (4)) {
if (pVertexDeclaration.hasSemantics("POSITION")) {
if (!0) {
var err=((((((("Error:: " + "семантика POSITION запрещена для биллборда") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("семантика POSITION запрещена для биллборда");

}


}

;
return ;

}

var iStride=pVertexDeclaration.iStride;
if (((pData.byteLength) / iStride) != 4) {
if (!0) {
var err=((((((("Error:: " + "неверное количество данных, для биллборда можно выставить данные только для четырех вершин") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("неверное количество данных, для биллборда можно выставить данные только для четырех вершин");

}


}

;
return ;

}

this._setObjectData(pVertexDeclaration, pData);

}
else if ((this._eType) == (3)) {
if (pVertexDeclaration.hasSemantics("POSITION")) {
if (!0) {
var err=((((((("Error:: " + "семантика POSITION запрещена для частиц-треугольников") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("семантика POSITION запрещена для частиц-треугольников");

}


}

;
return ;

}

var iStride=pVertexDeclaration.iStride;
if (((pData.byteLength) / iStride) != 3) {
if (!0) {
var err=((((((("Error:: " + "неверное количество данных, для треугольника можно выставить данные только для трех вершин") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("неверное количество данных, для треугольника можно выставить данные только для трех вершин");

}


}

;
return ;

}

this._setObjectData(pVertexDeclaration, pData);

}
else  {
if (!0) {
var err=((((((("Error:: " + "используемый тип частиц объектом не является") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("используемый тип частиц объектом не является");

}


}

;
return ;

}




};
Emitter.prototype.setObjectIndex = function(pAttrDecl, pData) {
"use strict";
if ((this._eType) == (5)) {
return this._setObjectIndex(pAttrDecl, pData);

}

if (!0) {
var err=((((((("Error:: " + "данную функцию можно использовать только для частиц-объектов") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("данную функцию можно использовать только для частиц-объектов");

}


}

;
return ;

};
Emitter.prototype.setObjectAttribute = function(pAttrDecl, pData) {
"use strict";
if ((this._eType) == (5)) {
return this._setObjectAttribute(pAttrDecl, pData);

}

if (!0) {
var err=((((((("Error:: " + "данную функцию можно использовать только для частиц-объектов") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("данную функцию можно использовать только для частиц-объектов");

}


}

;
return ;

};
Emitter.prototype.objectIndex = function(iData, eSemantic) {
"use strict";
if ((this._eType) == (5)) {
return this._objectIndex(iData, eSemantic);

}

if (!0) {
var err=((((((("Error:: " + "данную функцию можно использовать только для частиц-объектов") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("данную функцию можно использовать только для частиц-объектов");

}


}

;
return ;

};
Emitter.prototype.setLiveTime = function(fTTL) {
"use strict";
this._fTTL = fTTL;

};
Emitter.prototype.setTimeAcceleration = function(fTimeAcceleration) {
"use strict";
this._fTimeAcceleration = fTimeAcceleration;

};
Emitter.prototype.activate = function() {
"use strict";
this._pDataSubset.selectIndexSet(this._iUpdateMapIndex);
if (((this._pDataSubset.hasSemantics("PARTICLE_POSITION", false)) && (this._pDataSubset.hasSemantics("PARTICLE_VELOCITY", false))) && ((this._fTTL) > 0)) {
if (this._generateIndices()) {
this._isActive = true;
this._nPreviousTime = a.now();
return true;

}
else  {
return false;

}


}


};
Emitter.prototype._generateIndices = function() {
"use strict";
var pUpdateIndex=new Float32Array(this._nParticles);
var pDrawIndex;
if (((this._iDrawMapIndex) == (-1)) && ((this._eType) == (5))) {
if (!0) {
var err=((((((("Error:: " + "данные объекта не выставлены") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("данные объекта не выставлены");

}


}

;
return false;

}

for (var i=0; i < (this._nParticles); i++) {
pUpdateIndex[i] = i;

}

var iPos=this._pDataSubset.getDataLocation("PARTICLE_POSITION");
var pDeclaration=this._pParticleData.getVertexDeclaration();
var iStride=pDeclaration.iStride;
this._pDataSubset.selectIndexSet(this._iDrawMapIndex);
if ((this._eType) == (3)) {
this._setObjectData([new Object( {nCount: 3, eType: 5126, eUsage: "POSITION", iOffset: undefined})], new Float32Array([-0.5, (-(Math.sqrt(3))) / 6, 0, 0, (Math.sqrt(3)) / 3, 0, 0.5, (-(Math.sqrt(3))) / 6, 0]));
this._setObjectIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX_POSITION", iOffset: undefined})], new Float32Array([0, 1, 2]));
var iObjectDataPosition=this._pDataSubset.getDataLocation("POSITION");
this._objectIndex(iObjectDataPosition, "INDEX_POSITION");

}
else if ((this._eType) == (4)) {
this._setObjectData([new Object( {nCount: 3, eType: 5126, eUsage: "POSITION", iOffset: undefined})], new Float32Array([-1, -1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0]));
this._setObjectIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX_POSITION", iOffset: undefined})], new Float32Array([0, 0, 1, 2, 3, 3]));
var iObjectDataPosition=this._pDataSubset.getDataLocation("POSITION");
this._objectIndex(iObjectDataPosition, "INDEX_POSITION");

}
else if ((this._eType) == (5)) {
this._nDrawIndexLength = (this._pDataSubset.getPrimitiveCount()) * 3;

}



if (((this._eType) != (6)) && ((this._eType) != (1))) {
pDrawIndex = new Float32Array(this._nDrawIndexLength);
var nParticleDrawLength=(this._nDrawIndexLength) / (this._nParticles);
for (var i=0; i < (this._nParticles); i++) {
for (var j=0; j < nParticleDrawLength; j++) {
pDrawIndex[(i * nParticleDrawLength) + j] = i;

}


}


}

this._pDataSubset.selectIndexSet(this._iUpdateMapIndex);
this._pDataSubset.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX_UPDATE", iOffset: undefined})], pUpdateIndex);
this._pDataSubset.index(iPos, "INDEX_UPDATE");
if (((this._eType) != (6)) && ((this._eType) != (1))) {
this._pDataSubset.selectIndexSet(this._iDrawMapIndex);
if (!(this._pDataSubset.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX_PARTICLE", iOffset: undefined})], pDrawIndex))) {
if (!0) {
var err=((((((("Error:: " + "cannot allocate index: INDEX_PARTICLE") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/particles/ParticleManager.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("cannot allocate index: INDEX_PARTICLE");

}


}

;

}

this._pDataSubset.index(iPos, "INDEX_PARTICLE");

}

return true;

};
a.defineProperty(Emitter, "updateRoutine", function() {
"use strict";
return this._fnUpdate;

}
, function(fnUpdate) {
"use strict";
this._fnUpdate = fnUpdate;

}
);
a.defineProperty(Emitter, "drawRoutine", function() {
"use strict";
return this._fnDraw;

}
, function(fnDraw) {
"use strict";
this._fnDraw = fnDraw;

}
);
Emitter.prototype.update = function() {
"use strict";
this.constructor.superclasses["SceneObject"].update.call(this);
if ((this._isActive) && ((this._fnUpdate) != null)) {
this._update();

}


};
Emitter.prototype._update = function() {
"use strict";
var pDevice=this._pEngine.pDevice;
var pFramebuffer=this._pEngine.particleManager()._pFramebuffer;
pDevice.bindFramebuffer(pDevice.FRAMEBUFFER, pFramebuffer);
var pDataBuffer=this._pEngine.particleManager()._pDataFactory._pDataBuffer;
pDevice.framebufferTexture2D(pDevice.FRAMEBUFFER, pDevice.COLOR_ATTACHMENT0, pDevice.TEXTURE_2D, pDataBuffer._pTexture, 0);
var iHeight=pDataBuffer.height;
var iWidth=pDataBuffer.width;
pDevice.viewport(0, 0, iWidth, iHeight);
this._fTime += this._fDt;
this._nCurrentTime = a.now();
this._fDt = ((this._fTimeAcceleration) * ((this._nCurrentTime) - (this._nPreviousTime))) / 1000;
this._nPreviousTime = this._nCurrentTime;
this._nStep++;
var pUniformList;
this._pDataSubset.selectIndexSet(this._iUpdateMapIndex);
var pProgram=this._pPrograms[0];
pProgram.activate();
pUniformList = pProgram._pUniformList;
for (var sName in this._pParticleOffsetsList) {
var iOffset=this._pParticleOffsetsList[sName];
if ((pUniformList[sName]) != undefined) {
pProgram.applyFloat(sName, iOffset);

}


}

this._fnUpdate(this._fDt, this._fTime, this._nStep, pProgram, "velocity");
this._pDataSubset.draw();
pProgram = this._pPrograms[1];
pProgram.activate();
pUniformList = pProgram._pUniformList;
for (var sName in this._pParticleOffsetsList) {
var iOffset=this._pParticleOffsetsList[sName];
if ((pUniformList[sName]) != undefined) {
pProgram.applyFloat(sName, iOffset);

}


}

this._fnUpdate(this._fDt, this._fTime, this._nStep, pProgram, "position");
this._pDataSubset.draw();
pDevice.flush();
pDevice.bindFramebuffer(pDevice.FRAMEBUFFER, null);

};
Emitter.prototype.render = function() {
"use strict";
if ((this._isActive) && ((this._fnDraw) != null)) {

}


};
Emitter.prototype.renderCallback = function() {
"use strict";
if ((this._eType) == (1)) {
this._pDataSubset.selectIndexSet(this._iUpdateMapIndex);

}
else  {
this._pDataSubset.selectIndexSet(this._iDrawMapIndex);

}

var pProgram=this._pPrograms[(this._pPrograms.length) - 1];
pProgram.activate();
var pUniformList;
pUniformList = pProgram._pUniformList;
if (((this._eType) == (3)) || ((this._eType) == (4))) {
for (var sName in this._pObjectOffsetsList) {
var iOffset=this._pObjectOffsetsList[sName];
if ((pUniformList[sName]) != undefined) {
pProgram.applyFloat(sName, iOffset);

}


}


}

for (var sName in this._pParticleOffsetsList) {
var iOffset=this._pParticleOffsetsList[sName];
if ((pUniformList[sName]) != undefined) {
pProgram.applyFloat(sName, iOffset);

}


}

this._fnDraw(this._fDt, this._fTime, this._nStep, pProgram, "draw");
var pDevice=this._pEngine.pDevice;
pDevice.enable(pDevice.BLEND);
pDevice.disable(pDevice.DEPTH_TEST);
pDevice.blendFunc(pDevice.SRC_ALPHA, pDevice.ONE_MINUS_SRC_ALPHA);
this._pDataSubset.draw();
pDevice.enable(pDevice.DEPTH_TEST);
pDevice.disable(pDevice.BLEND);

};
a["Emitter"] = Emitter;
function SpriteManager(pEngine) {
"use strict";
this._pEngine = pEngine;
this._pSprites = [];
this._pDataFactory = new a.RenderDataBuffer(pEngine);
this._pDataFactory.dataType = a.RenderData;
this._pDataFactory.setup(8);

}

;
SpriteManager.prototype.registerSprite = function(pSprite) {
"use strict";
var pDataSubset=this._pDataFactory.getEmptyRenderData(5, 0);
this._pSprites.push(pSprite);
return pDataSubset;

};
a["SpriteManager"] = SpriteManager;
function Sprite(pEngine) {
"use strict";
var _pCtorValue=Sprite.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._pEngine = pEngine;
this._pRenderData = pEngine.spriteManager().registerSprite(this);
this._bGeometrySetted = false;
this._fnDraw = null;
this._isVisible = true;
this._pProgram = null;

}

a.extend(Sprite, a.SceneObject, a.RenderableObject);
Sprite.prototype._setup = function(pAttrDecl, pData) {
return this._pRenderData.allocateAttribute(pAttrDecl, pData);

};
Sprite.prototype.setGeometry = function(fSizeX, fSizeY) {
"use strict";
if (this._bGeometrySetted) {
if (!0) {
var err=((((((("Error:: " + "геометрия уже установлена") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/sprites/Sprite.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("геометрия уже установлена");

}


}

;
return ;

}
else  {
this._bGeometrySetted = true;

}

var pGeometry=new Float32Array(4 * 3);
for (var i=0; i < 4; i++) {
var signX=((Math.floor(i / 2)) * 2) - 1;
var signY=((i % 2) * 2) - 1;
pGeometry[3 * i] = (signX * fSizeX) / 2;
pGeometry[(3 * i) + 1] = (signY * fSizeY) / 2;
pGeometry[(3 * i) + 2] = 0;

}

return this._setup([new Object( {nCount: 3, eType: 5126, eUsage: "POSITION_OFFSET", iOffset: undefined})], pGeometry);

};
Sprite.prototype.setData = function(pAttrDecl, pData) {
"use strict";
var pAttrDeclaration=normalizeVertexDecl(pAttrDecl);
pData = new Uint8Array(pData.buffer);
var iStride=pAttrDeclaration.iStride;
if (((pData.length) / iStride) != 4) {
if (!0) {
var err=((((((("Error:: " + "неверное количество данных, данные должны быть установлены для каждой вершины спрайта") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/sprites/Sprite.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("неверное количество данных, данные должны быть установлены для каждой вершины спрайта");

}


}

;
return ;

}

if (pAttrDeclaration.hasSemantics("POSITION")) {
if (!0) {
var err=((((((("Error:: " + "семантика POSITION является системной для спрайта и не может использоваться") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/sprites/Sprite.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("семантика POSITION является системной для спрайта и не может использоваться");

}


}

;
return ;

}

return this._setup(pAttrDeclaration, pData);

};
a.defineProperty(Sprite, "drawRoutine", function() {
"use strict";
return this._fnDraw;

}
, function(fnDraw) {
"use strict";
this._fnDraw = fnDraw;

}
);
a.defineProperty(Sprite, "visible", function() {
"use strict";
return this._isVisible;

}
, function(isVisible) {
"use strict";
this._isVisible = isVisible;

}
);
Sprite.prototype.setProgram = function(pProgram) {
"use strict";
this._pProgram = pProgram;

};
Sprite.prototype.render = function() {
"use strict";
if ((this._isVisible) && ((this._fnDraw) != null)) {
this.renderCallback();

}


};
Sprite.prototype.renderCallback = function() {
"use strict";
var pProgram=this._pProgram;
pProgram.activate();
this._fnDraw(pProgram);
this._pRenderData.draw();

};
a["Sprite"] = Sprite;
function Font3D(pEngine, nSize, sFontFamily, isBold, isItalic) {
"use strict";
var _pCtorValue=Font3D.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
nSize = (nSize === undefined? 12 : nSize);
sFontFamily = (sFontFamily === undefined? "times" : sFontFamily);
isBold = (isBold === undefined? false : isBold);
isItalic = (isItalic === undefined? false : isItalic);
this._isBold = isBold;
this._isItalic = isItalic;
this._sBold = null;
this._sItalic = null;
this._isMonospace = true;
this._nFontWidth = -1;
this._pFontMetrics = null;
this._pLetterMap =  {};
this._nLettersX = 0;
this._nLettersY = 0;
this._nTotalFontSize = 0;
this._nFontSize = nSize;
this._sFontSize = (String(nSize)) + "px";
this._sFontFamily = sFontFamily;
if (this._isBold) {
this._sBold = "bold";

}
else  {
this._sBold = "normal";

}

if (this._isItalic) {
this._sItalic = "italic";

}
else  {
this._sItalic = "normal";

}

this._pContext = null;
this._rasterize();

}

;
a.extend(Font3D, a.Texture);
a.defineProperty(Font3D, "letterMap", function() {
"use strict";
return this._pLetterMap;

}
);
a.defineProperty(Font3D, "fontSize", function() {
"use strict";
return this._nFontSize;

}
);
a.defineProperty(Font3D, "totalFontSize", function() {
"use strict";
return this._nTotalFontSize;

}
);
a.defineProperty(Font3D, "fontWidth", function() {
"use strict";
return this._nFontWidth;

}
);
a.defineProperty(Font3D, "isMonospace", function() {
"use strict";
return this._isMonospace;

}
);
a.defineProperty(Font3D, "context", function() {
"use strict";
return this._pContext;

}
);
a.defineProperty(Font3D, "fontMetrics", function() {
"use strict";
return this._pFontMetrics;

}
);
Font3D.prototype._rasterize = function() {
"use strict";
var pLetterMap=this._pLetterMap;
var nLetters=128;
var pTextCanvas=document.createElement("canvas");
var pContext2D=this._pContext = pTextCanvas.getContext("2d");
pContext2D.fillStyle = this._sFontColor;
var sFont="";
sFont += (this._sItalic) + " ";
sFont += (this._sBold) + " ";
sFont += (this._sFontSize) + " ";
sFont += this._sFontFamily;
pContext2D.font = sFont;
var pFontMetrics=this._pFontMetrics = this._getFontMetrics(this._sItalic, this._sBold, this._nFontSize, this._sFontFamily);
this._nTotalFontSize = pFontMetrics.fontMetrics.height;
this._monospaceTest();
var pTextureSizes=this._defineTextureSizes();
if (((pTextureSizes.nTextureWidth) == (-1)) || ((pTextureSizes.nTextureHeight) == (-1))) {
return ;

}

var nTextureWidth=pTextureSizes.nTextureWidth;
var nTextureHeight=pTextureSizes.nTextureHeight;
pTextCanvas.width = nTextureWidth;
pTextCanvas.height = nTextureHeight;
pContext2D.font = sFont;
pContext2D.textBaseline = "top";
pContext2D.textAlignment = "start";
var nVerticalStep=Math.ceilingPowerOfTwo(this._nTotalFontSize);
var nLineNumber=(pTextureSizes.nTextureHeight) / nVerticalStep;
var j=0;
var nStartIndex;
var nCurrentLineWidth;
var relativeWidth;
var relativeHeight=(this._nTotalFontSize) / nTextureHeight;
for (var i=0; i < nLineNumber; i++) {
nCurrentLineWidth = 0;
nStartIndex = j;
var iPositionY=i * nVerticalStep;
for (j = nStartIndex; j < nLetters; j++) {
var sChar=String.fromCharCode(j);
var iPositionX=nCurrentLineWidth;
var iCenterOffsetX=-(pFontMetrics.lettersMetrics[sChar].left);
var nWidth=pFontMetrics.lettersMetrics[sChar].realWidth;
relativeWidth = (nWidth - 1) / nTextureWidth;
nCurrentLineWidth += nWidth;
if (nCurrentLineWidth > nTextureWidth) {
j--;
break ;

}

pContext2D.fillText(sChar, iPositionX + iCenterOffsetX, iPositionY, nWidth);
pLetterMap[sChar] = [iPositionX / nTextureWidth, iPositionY / nTextureHeight, relativeWidth, relativeHeight];

}

if (j == nLetters) {
break ;

}


}

var pImageData=pContext2D.getImageData(0, 0, pTextCanvas.width, pTextCanvas.height);
this.createTexture(nTextureWidth, nTextureHeight, 0, 6408, 5121, new Uint8Array(pImageData.data));
this.applyParameter(10242, 33071);
this.applyParameter(10243, 33071);

};
Font3D.prototype._getFontMetrics = function(sStyle, sWeight, nSize, sFontFamily) {
"use strict";
if ((arguments.length) < 4) {
if (!0) {
var err=((((((("Error:: " + "not enough arguments in function getFontMetrics") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/sprites/Font3D.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("not enough arguments in function getFontMetrics");

}


}

;
return ;

}

var sFont=((((((sStyle + " ") + sWeight) + " ") + nSize) + "px") + " ") + sFontFamily;
var pCanvas=document.createElement("canvas");
pCanvas.width = 2 * nSize;
pCanvas.height = 2 * nSize;
var pContext2D=this._pContext = pCanvas.getContext("2d");
pContext2D.font = sFont;
pContext2D.textBaseline = "top";
pContext2D.textAlign = "start";
var nOffsetX=Math.ceil(nSize / 2);
var nOffsetY=Math.ceil(nSize / 2);
var nLetters=128;
var pLettersMetrics= {};
var nWidth;
var nHeight;
var nMaxLeft, nMaxRight, nMaxTop, nMaxBottom, nMaxTypographicalWidth;
for (var i=0; i < nLetters; i++) {
var sChar=String.fromCharCode(i);
nWidth = pContext2D.measureText(sChar).width;
nHeight = nSize;
nMaxLeft = 0;
nMaxRight = nWidth - 1;
nMaxTop = 0;
nMaxBottom = 0;
nMaxTypographicalWidth = 0;
if (nWidth == 0) {
pLettersMetrics[sChar] =  {"left": 0, "top": 0, "right": 0, "bottom": 0, "height": 0, "realWidth": 0, "typographicalWidth": nWidth};
continue ;

}
else  {
pLettersMetrics[sChar] =  {"left": nMaxLeft, "top": nMaxTop, "right": nMaxRight, "bottom": nMaxBottom, "height": (nMaxBottom - nMaxTop) + 1, "realWidth": (nMaxRight - nMaxLeft) + 1, "typographicalWidth": nWidth};

}

pContext2D.fillText(sChar, nOffsetX, nOffsetY);
var pImageData=pContext2D.getImageData(0, 0, pCanvas.width, pCanvas.height);
for (var iY=0; iY < (pCanvas.height); iY++) {
for (var iX=0; iX < (pCanvas.width); iX++) {
var alpha=pImageData.data[(4 * ((iY * (pCanvas.width)) + iX)) + 3];
if (alpha != 0) {
var iRealX=iX - nOffsetX;
var iRealY=iY - nOffsetY;
if (iRealX < nMaxLeft) {
nMaxLeft = iRealX;

}
else if (iRealX > nMaxRight) {
nMaxRight = iRealX;

}
else if (iRealY > nMaxBottom) {
nMaxBottom = iRealY;

}




}


}


}

pLettersMetrics[sChar].left = nMaxLeft;
pLettersMetrics[sChar].right = nMaxRight;
pLettersMetrics[sChar].top = nMaxTop;
pLettersMetrics[sChar].bottom = nMaxBottom;
pLettersMetrics[sChar].height = (nMaxBottom - nMaxTop) + 1;
pLettersMetrics[sChar].realWidth = (nMaxRight - nMaxLeft) + 1;
pContext2D.clearRect(0, 0, pCanvas.width, pCanvas.height);

}

nMaxRight = 0;
nMaxBottom = 0;
nMaxLeft = 0;
nMaxTop = 0;
nMaxTypographicalWidth = 0;
for (var sChar in pLettersMetrics) {
var pMetrics=pLettersMetrics[sChar];
if ((pMetrics.right) > nMaxRight) {
nMaxRight = pMetrics.right;

}

if ((pMetrics.left) < nMaxLeft) {
nMaxLeft = pMetrics.left;

}

if ((pMetrics.bottom) > nMaxBottom) {
nMaxBottom = pMetrics.bottom;

}

if ((pMetrics.top) < nMaxTop) {
nMaxTop = pMetrics.top;

}

if ((pMetrics.typographicalWidth) > nMaxTypographicalWidth) {
nMaxTypographicalWidth = pMetrics.typographicalWidth;

}


}

var pFontMetrics= {"left": nMaxLeft, "top": nMaxTop, "right": nMaxRight, "bottom": nMaxBottom, "height": (nMaxBottom - nMaxTop) + 1, "realWidth": (nMaxRight - nMaxLeft) + 1, "typographicalWidth": nMaxTypographicalWidth};
return  {"lettersMetrics": pLettersMetrics, "fontMetrics": pFontMetrics};

};
Font3D.prototype._monospaceTest = function() {
"use strict";
var nBaseWidth=this._pFontMetrics.fontMetrics.typographicalWidth;
var pLettersMetrics=this._pFontMetrics.lettersMetrics;
for (var sChar in pLettersMetrics) {
if (((pLettersMetrics[sChar].typographicalWidth) != 0) && ((pLettersMetrics[sChar].typographicalWidth) != nBaseWidth)) {
this._isMonospace = false;

}


}

if (this._isMonospace) {
this._nFontWidth = nBaseWidth;

}


};
Font3D.prototype._defineTextureSizes = function() {
"use strict";
var nMaxTextureSize=a.info.graphics.maxTextureSize(this._pEngine.getDevice());
var nLetters=128;
var nFontTotalWidth=0;
var pLettersMetrics=this._pFontMetrics.lettersMetrics;
for (var sChar in pLettersMetrics) {
nFontTotalWidth += pLettersMetrics[sChar].realWidth;

}

var nTextureWidth=Math.ceilingPowerOfTwo(nFontTotalWidth);
var nTextureHeight=Math.ceilingPowerOfTwo(this._nTotalFontSize);
var nVerticalStep=nTextureHeight;
while (nTextureWidth > nMaxTextureSize) {
nTextureWidth /= 2;
nTextureHeight *= 2;

}
if ((nTextureWidth < 1) || (nTextureHeight > nMaxTextureSize)) {
if (!0) {
var err=((((((("Error:: " + "слишком большой размер шрифта для растеризации") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/sprites/Font3D.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("слишком большой размер шрифта для растеризации");

}


}

;
return  {"nTextureWidth": -1, "nTextureHeight": -1};

}

var nLineNumber=nTextureHeight / nVerticalStep;
var j=0;
var nStartIndex;
var nCurrentLineWidth;
for (var i=0; i < nLineNumber; i++) {
nCurrentLineWidth = 0;
nStartIndex = j;
for (j = nStartIndex; j < nLetters; j++) {
var sChar=String.fromCharCode(i);
nCurrentLineWidth += pLettersMetrics[sChar].realWidth;
if (nCurrentLineWidth > nTextureWidth) {
j--;
break ;

}


}

if (j == nLetters) {
break ;

}


}

if (j < nLetters) {
nTextureHeight *= 2;
if (nTextureHeight > nMaxTextureSize) {
return  {"nTextureWidth": -1, "nTextureHeight": -1};

}


}

return  {"nTextureWidth": nTextureWidth, "nTextureHeight": nTextureHeight};

};
a["Font3D"] = Font3D;
function Text3D(pEngine, pFont) {
"use strict";
var _pCtorValue=Text3D.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
if (!(this.constructor.pTextProg)) {
this.constructor.pTextProg = a.loadProgram(pEngine, "../effects/text3D.glsl");

}

;
if (!(this.constructor.pDrawRoutine)) {
this.constructor.pDrawRoutine = DrawRoutineText3D;

}

;
this._pFont = pFont;
this._v4fBackgroundColor = Vec4.create(0, 0, 0, 0);
this._v4fFontColor = Vec4.create(0, 0, 0, 0);
this._fDistanceMultiplier = 1;
this._nLineQuantity = 0;
this._nLineLength = 0;
this._nPixelLineLingth = 0;
this.setGeometry(2, 2);
this.setProgram(this.constructor.pTextProg);
this.drawRoutine = this.constructor.pDrawRoutine;

}

;
a.extend(Text3D, a.Sprite);
a.defineProperty(Text3D, "backgroundColor", function() {
"use strict";
return this._v4fBackgroundColor;

}
, function(v4fBackgroundColor) {
"use strict";
Vec4.set(v4fBackgroundColor, this._v4fBackgroundColor);

}
);
a.defineProperty(Text3D, "fontColor", function() {
"use strict";
return this._v4fFontColor;

}
, function(v4fFontColor) {
"use strict";
Vec4.set(v4fFontColor, this._v4fFontColor);

}
);
a.defineProperty(Text3D, "fixedSize", function() {
"use strict";
if ((this._fDistanceMultiplier) == 0) {
return true;

}
else  {
return false;

}


}
, function(isFixed) {
"use strict";
if (isFixed) {
this._fDistanceMultiplier = 0;

}
else  {
this._fDistanceMultiplier = 1;

}


}
);
Text3D.prototype.setText = function(sString) {
"use strict";
var pFont=this._pFont;
var pLetterMap=pFont.letterMap;
var pFontMetrics=pFont.fontMetrics;
var pMeasureContext=pFont.context;
var nLineLength=0;
var nMaxLineLength=0;
var nPixelLength=0;
var nMaxPixelLength=0;
var nLineQuantity=1;
var pLinesInfo=[];
for (var i=0; i < (sString.length); i++) {
var sChar=sString[i];
if (sChar == "\n") {
nMaxLineLength = (nLineLength > nMaxLineLength? nLineLength : nMaxLineLength);
nMaxPixelLength = (nPixelLength > nMaxPixelLength? nPixelLength : nMaxPixelLength);
pLinesInfo.push( {"nLetters": nLineLength, "nPixelLength": nPixelLength});
nLineLength = 0;
nPixelLength = 0;
nLineQuantity++;

}
else  {
nLineLength++;
nPixelLength += pFontMetrics.lettersMetrics[sChar].typographicalWidth;

}


}

nMaxLineLength = (nLineLength > nMaxLineLength? nLineLength : nMaxLineLength);
nMaxPixelLength = (nPixelLength > nMaxPixelLength? nPixelLength : nMaxPixelLength);
pLinesInfo.push( {"nLetters": nLineLength, "nPixelLength": nPixelLength});
this._nLineQuantity = nLineQuantity;
this._nLineLength = nMaxLineLength;
this._nPixelLineLingth = nMaxPixelLength;
var fAveragePixelsWidthPerLetter=nMaxPixelLength / nMaxLineLength;
var nTotalRequiredData=(((sString.length) + 1) + (nLineQuantity * nMaxLineLength)) + (((sString.length) - nLineQuantity) + 1);
var pStringData=new Float32Array(4 * nTotalRequiredData);
var nCurrentIndex=0;
var nStringDataOffset=nLineQuantity;
var nLetterInfoOffset=nLineQuantity + (nMaxLineLength * nLineQuantity);
for (var i=0; i < (pLinesInfo.length); i++) {
var pLine=pLinesInfo[i];
var nCurrentPixelLength=0;
pStringData[4 * i] = nStringDataOffset;
pStringData[(4 * i) + 1] = nLetterInfoOffset;
pStringData[(4 * i) + 2] = pLine.nPixelLength;
for (var j=0; j < nMaxLineLength; j++) {
if (j < (pLine.nLetters)) {
var sChar=sString[nCurrentIndex];
var pLetterMetrics=pFontMetrics.lettersMetrics[sChar];
var nTypographicalWidth=pLetterMetrics.typographicalWidth;
var nStartPosition=Math.floor(nCurrentPixelLength / fAveragePixelsWidthPerLetter);
var nEndPosition=Math.floor(((nCurrentPixelLength + nTypographicalWidth) - 1) / fAveragePixelsWidthPerLetter);
var fPixelStartPosition=nCurrentPixelLength % fAveragePixelsWidthPerLetter;
var fPixelEndPosition=((nCurrentPixelLength + nTypographicalWidth) - 1) % fAveragePixelsWidthPerLetter;
var nCurrentPosition=nStartPosition;
var nPositions=(nEndPosition - nStartPosition) + 1;
var nLetterStartPosition=0;
var nLetterEndPosition=0;
var nStartIndex=0;
if (fPixelStartPosition != 0) {
var nCurrentDataPosition=(nLineQuantity + (i * nMaxLineLength)) + nStartPosition;
if ((pStringData[(4 * nCurrentDataPosition) + 1]) != 0) {
nStartIndex = 1;
nLetterStartPosition = fAveragePixelsWidthPerLetter - fPixelStartPosition;

}


}

nLetterEndPosition = ((nLetterStartPosition + fAveragePixelsWidthPerLetter) < nTypographicalWidth? nLetterStartPosition + fAveragePixelsWidthPerLetter : nTypographicalWidth);
for (var k=nStartIndex; k < nPositions; k++) {
var nCurrentDataPosition=((nLineQuantity + (i * nMaxLineLength)) + nStartPosition) + k;
pStringData[4 * nCurrentDataPosition] = j;
pStringData[(4 * nCurrentDataPosition) + 1] = nTypographicalWidth;
pStringData[(4 * nCurrentDataPosition) + 2] = nLetterStartPosition;
pStringData[(4 * nCurrentDataPosition) + 3] = nLetterEndPosition;
nLetterStartPosition += fAveragePixelsWidthPerLetter;
nLetterEndPosition = ((nLetterStartPosition + fAveragePixelsWidthPerLetter) < nTypographicalWidth? nLetterStartPosition + fAveragePixelsWidthPerLetter : nTypographicalWidth);

}

var pLetterMetrics=pFontMetrics.lettersMetrics[sChar];
var pLetterData=pLetterMap[sChar];
nCurrentDataPosition = nLetterInfoOffset + (2 * j);
for (var k=0; k < 4; k++) {
pStringData[(4 * nCurrentDataPosition) + k] = pLetterData[k];

}

nCurrentDataPosition++;
pStringData[4 * nCurrentDataPosition] = pLetterMetrics.typographicalWidth;
pStringData[(4 * nCurrentDataPosition) + 1] = pLetterMetrics.left;
pStringData[(4 * nCurrentDataPosition) + 2] = pLetterMetrics.right;
nCurrentPixelLength += nTypographicalWidth;
nCurrentIndex++;

}
else  {
var nStartPosition=Math.ceil(nCurrentPixelLength / fAveragePixelsWidthPerLetter);
var fPixelStartPosition=nCurrentPixelLength % fAveragePixelsWidthPerLetter;
var nCurrentDataPosition=(nLineQuantity + (i * nMaxLineLength)) + nStartPosition;
pStringData[4 * nCurrentDataPosition] = -1;
nCurrentPixelLength += fAveragePixelsWidthPerLetter;

}


}

nStringDataOffset += nMaxLineLength;
nLetterInfoOffset += (pLine.nLetters) * 2;
nCurrentIndex++;

}

var pIndex=new Float32Array(4);
for (var i=0; i < 4; i++) {
pIndex[i] = i;

}

this._pRenderData.allocateData(new Object( {nCount: 4, eType: 5126, eUsage: "STRING_DATA", iOffset: undefined}), pStringData);
this._pRenderData.allocateIndex(new Object( {nCount: 1, eType: 5126, eUsage: "INDEX1", iOffset: undefined}), pIndex);
this._pRenderData.index(this._pRenderData.getDataLocation("STRING_DATA"), "INDEX1");

};
Text3D.prototype.setDistanceMultiplier = function(fMultiplier) {
"use strict";
if (fMultiplier < 0) {
err("значение множителя не может быть меньше нуля");
return ;

}

this._fDistanceMultiplier = fMultiplier;

};
a["Text3D"] = Text3D;
function DrawRoutineText3D(pProgram) {
"use strict";
var pCamera=this._pEngine.getActiveCamera();
pProgram.applyMatrix4("model_mat", this.worldMatrix());
pProgram.applyMatrix4("proj_mat", pCamera.projectionMatrix());
pProgram.applyMatrix4("view_mat", pCamera.viewMatrix());
pProgram.applyFloat("nLineLength", this._nLineLength);
pProgram.applyFloat("nLineQuantity", this._nLineQuantity);
pProgram.applyFloat("startIndex", (this._pRenderData.getDataLocation("STRING_DATA")) / 4);
pProgram.applyVector2("nPixelsSizes", this._nPixelLineLingth, (this._pFont.fontMetrics.fontMetrics.height) * (this._nLineQuantity));
pProgram.applyVector2("v2fCanvasSizes", this._pEngine.pCanvas.width, this._pEngine.pCanvas.height);
pProgram.applyFloat("nFontSize", this._pFont.totalFontSize);
pProgram.applyFloat("fDistanceMultiplier", this._fDistanceMultiplier);
pProgram.applyVector4("v4fBackgroundColor", this._v4fBackgroundColor);
pProgram.applyVector4("v4fFontColor", this._v4fFontColor);
this._pFont.activate(1);
pProgram.applyInt("textTexture", 1);

}

;
function LightPoint(pEngine, isOmnidirectional, haveShadows, iMaxShadowResolution) {
"use strict";
var _pCtorValue=LightPoint.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this.id = pEngine.lightManager().registerLightPoint(this);
isOmnidirectional = (isOmnidirectional === undefined? true : isOmnidirectional);
haveShadows = (haveShadows === undefined? false : haveShadows);
if (haveShadows) {
iMaxShadowResolution = (iMaxShadowResolution === undefined? 256 : iMaxShadowResolution);

}

this._iMaxShadowResolution = Math.ceilingPowerOfTwo(iMaxShadowResolution);
this._isOmnidirectional = isOmnidirectional;
this._haveShadows = haveShadows;
this._pDepthTexture = null;
var pDepthTextureCube=this._pDepthTextureCube = new Array(6);
for (var i=0; i < 6; i++) {
pDepthTextureCube[i] = null;

}

this._pColorTexture = null;
this._pCamera = null;
var pCameraCube=this._pCameraCube = new Array(6);
for (var i=0; i < 6; i++) {
pCameraCube[i] = null;

}

this._m4fDefaultProj = null;
this._pLightParameters = new LightParameters();
this._isActive = true;
if (haveShadows) {
this._initializeTextures();

}


}

;
a.extend(LightPoint, a.SceneNode);
a.defineProperty(LightPoint, "isOmnidirectional", function() {
return this._isOmnidirectional;

}
);
a.defineProperty(LightPoint, "haveShadows", function() {
return this._haveShadows;

}
);
a.defineProperty(LightPoint, "depthTexture", function() {
return this._pDepthTexture;

}
);
a.defineProperty(LightPoint, "camera", function() {
return this._pCamera;

}
);
a.defineProperty(LightPoint, "depthTextureCube", function() {
return this._pDepthTextureCube;

}
);
a.defineProperty(LightPoint, "cameraCube", function() {
return this._pCameraCube;

}
);
a.defineProperty(LightPoint, "colorTexture", function() {
return this._pColorTexture;

}
);
a.defineProperty(LightPoint, "isActive", function() {
return this._isActive;

}
, function(isActive) {
this._isActive = isActive;

}
);
a.defineProperty(LightPoint, "lightParameters", function() {
return this._pLightParameters;

}
, function(pLightParameters) {
this._pLightParameters = pLightParameters;

}
);
LightPoint.prototype._initializeTextures = function() {
"use strict";
var pEngine=this._pEngine;
var iShadowResolution=this._iMaxShadowResolution;
if (this._isOmnidirectional) {
var pDepthTextureCube=this._pDepthTextureCube;
for (var i=0; i < 6; i++) {
var pDepthTexture=pDepthTextureCube[i] = pEngine.displayManager().texturePool().createResource("depth_texture_" + (a.sid()));
pDepthTexture.createTexture(iShadowResolution, iShadowResolution, 0, 6402, 5125, null);
pDepthTexture.applyParameter(10242, 33071);
pDepthTexture.applyParameter(10243, 33071);
pDepthTexture.applyParameter(10240, 9729);
pDepthTexture.applyParameter(10241, 9729);

}


}
else  {
var pDepthTexture=this._pDepthTexture = pEngine.displayManager().texturePool().createResource("depth_texture_" + (a.sid()));
pDepthTexture.createTexture(iShadowResolution, iShadowResolution, 0, 6402, 5125, null);
pDepthTexture.applyParameter(10242, 33071);
pDepthTexture.applyParameter(10243, 33071);
pDepthTexture.applyParameter(10240, 9729);
pDepthTexture.applyParameter(10241, 9729);

}

this._pColorTexture = pEngine.displayManager().texturePool().createResource();
var pColor=this._pColorTexture;
pColor.createTexture(iShadowResolution, iShadowResolution, 0, 6408, 5121, null);

};
LightPoint.prototype.create = function() {
"use strict";
SceneNode.prototype.create.call(this);
var pEngine=this._pEngine;
if ((this._isOmnidirectional) && (this._haveShadows)) {
var pCameraCube=this._pCameraCube;
for (var i=0; i < 6; i++) {
var pCamera=pCameraCube[i] = new a.Camera(pEngine);
pCamera.create();
pCamera.setInheritance(2);
pCamera.attachToParent(this);
pCamera.setProjParams((Math.PI) / 2, 1, 0.01, 1000);

}

pCameraCube[0].accessLocalMatrix().set([0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 0, 1]);
pCameraCube[1].accessLocalMatrix().set([0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1]);
pCameraCube[2].accessLocalMatrix().set([1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1]);
pCameraCube[3].accessLocalMatrix().set([1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
pCameraCube[4].accessLocalMatrix().set([-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1]);
pCameraCube[5].accessLocalMatrix().set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);

}
else  {
var pCamera=this._pCamera = new a.Camera(pEngine);
pCamera.create();
pCamera.setInheritance(2);
pCamera.attachToParent(this);
pCamera.accessLocalMatrix().set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);

}


};
LightPoint.prototype.calculateShadows = function() {
if (!(this._haveShadows)) {
return true;

}

var pRenderer=this._pEngine.shaderManager();
var pDevice=this._pEngine.pDevice;
if (this._isOmnidirectional) {
var i;
for (i = 0; i < 6; i++) {
pRenderer.activateFrameBuffer();
pRenderer.applyFrameBufferTexture(this._pDepthTextureCube[i], 36096, 3553, 0);
pRenderer.applyFrameBufferTexture(this._pColorTexture, 36064, 3553, 0);
pRenderer.clearScreen((256) | (16384));
this._renderShadowsFromCamera(this._pCameraCube[i]);
pRenderer.deactivateFrameBuffer();

}


}
else  {
pRenderer.activateFrameBuffer();
pRenderer.applyFrameBufferTexture(this._pDepthTexture, 36096, 3553, 0);
pRenderer.applyFrameBufferTexture(this._pColorTexture, 36064, 3553, 0);
pRenderer.clearScreen((256) | (16384));
this._renderShadowsFromCamera(this._pCamera);
pRenderer.deactivateFrameBuffer();

}


};
LightPoint.prototype._renderShadowsFromCamera = function(pCamera) {
var pEngine=this._pEngine;
var pFirstMember=pEngine._pSceneTree.buildSearchResults(pCamera.searchRect(), pCamera.frustum());
var pRenderList=pFirstMember;
var pLastActiveCamera=pEngine.getActiveCamera();
while (pFirstMember) {
pFirstMember.prepareForRender();
pFirstMember = pFirstMember.nextSearchLink();

}
pEngine.setActiveCamera(pCamera);
pFirstMember = pRenderList;
while (pFirstMember) {
pFirstMember.renderShadow();
pFirstMember = pFirstMember.nextSearchLink();

}
pEngine.setActiveCamera(pLastActiveCamera);
return true;

};
a["LightPoint"] = LightPoint;
function LightParameters() {
this.ambient = new Vec4(1, 1, 1, 1);
this.diffuse = new Vec4(1, 1, 1, 1);
this.specular = new Vec4(1, 1, 1, 1);
this.attenuation = new Vec3(0.9, 0, 0);

}

;
function LightManager(pEngine, nMaxDeferredTextureCount) {
"use strict";
nMaxDeferredTextureCount = (nMaxDeferredTextureCount === undefined? 2 : nMaxDeferredTextureCount);
this._pEngine = pEngine;
this._pLightPoints = [];
this._pDepthTexture = null;
this._nMaxDeferredTextureCount = nMaxDeferredTextureCount;
this._pDeferredTextures = new Array(nMaxDeferredTextureCount);
this._iWidth = Math.ceilingPowerOfTwo(pEngine.pCanvas.width);
this._iHeight = Math.ceilingPowerOfTwo(pEngine.pCanvas.height);

}

;
a.defineProperty(LightManager, "depthTexture", function() {
return this._pDepthTexture;

}
);
a.defineProperty(LightManager, "deferredTextures", function() {
return this._pDeferredTextures;

}
);
a.defineProperty(LightManager, "lightPoints", function() {
return this._pLightPoints;

}
);
LightManager.prototype.registerLightPoint = function(pLightPoint) {
"use strict";
var id=this._pLightPoints.length;
this._pLightPoints.push(pLightPoint);
return id;

};
LightManager.prototype._initializeTextures = function() {
"use strict";
var pEngine=this._pEngine;
var pCanvas=pEngine.pCanvas;
var iWidth=this._iWidth;
var iHeight=this._iHeight;
var pDepthTexture=this._pDepthTexture = pEngine.displayManager().texturePool().createResource("depth_texture_" + (a.sid()));
pDepthTexture.createTexture(iWidth, iHeight, 0, 6402, 5125, null);
pDepthTexture.applyParameter(10242, 33071);
pDepthTexture.applyParameter(10243, 33071);
pDepthTexture.applyParameter(10240, 9729);
pDepthTexture.applyParameter(10241, 9729);
var pDeferredTextures=this._pDeferredTextures;
for (var i=0; i < (this._nMaxDeferredTextureCount); i++) {
var pDeferredTexture=pDeferredTextures[i] = pEngine.displayManager().texturePool().createResource("deferred_texture_" + (a.sid()));
pDeferredTexture.createTexture(iWidth, iHeight, 0, 6408, 5126, null);
pDeferredTexture.applyParameter(10242, 33071);
pDeferredTexture.applyParameter(10243, 33071);
pDeferredTexture.applyParameter(10240, 9728);
pDeferredTexture.applyParameter(10241, 9728);

}


};
LightManager.prototype.createDeviceResources = function() {
this._initializeTextures();

};
LightManager.prototype.updateTexture = function() {
"use strict";
var pCanvas=this._pEngine.pCanvas;
var iWidth=Math.ceilingPowerOfTwo(pCanvas.width);
var iHeight=Math.ceilingPowerOfTwo(pCanvas.height);
if ((iWidth != (this._iWidth)) || (iHeight != (this._iHeight))) {
this._iWidth = iWidth;
this._iHeight = iHeight;
var pDepthTexture=this._pDepthTexture;
pDepthTexture.createTexture(iWidth, iHeight, 0, 6402, 5125, null);
pDepthTexture.applyParameter(10242, 33071);
pDepthTexture.applyParameter(10243, 33071);
pDepthTexture.applyParameter(10240, 9729);
pDepthTexture.applyParameter(10241, 9729);
var pDeferredTextures=this._pDeferredTextures;
for (var i=0; i < (this._nMaxDeferredTextureCount); i++) {
var pDeferredTexture=pDeferredTextures[i];
pDeferredTexture.createTexture(iWidth, iHeight, 0, 6408, 5126, null);
pDeferredTexture.applyParameter(10242, 33071);
pDeferredTexture.applyParameter(10243, 33071);
pDeferredTexture.applyParameter(10240, 9728);
pDeferredTexture.applyParameter(10241, 9728);

}


}


};
a["LightManager"] = LightManager;
function SceneModel(pEngine, pMesh) {
var _pCtorValue=SceneModel.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this._iModelFrameIndex = 0;
this._hModelHandle = 0;
this._pMeshes = [];
this._fnRenderCallback = null;
this._isStandAlone = false;
if (pMesh) {
this.addMesh(pMesh);

}


}

a.extend(SceneModel, a.SceneObject);
SceneModel.prototype.create = function() {
SceneObject.prototype.create.call(this);
this._hasShadow = null;

};
SceneModel.prototype.destroy = function() {
this._iModelFrameIndex = 0;
 {
if (this._pMesh) {
if (this._pMesh.destructor) {
this._pMesh.destructor();

}

delete this._pMesh;
this._pMesh = null;

}


};
this.constructor.superclass.destroy.call(this, this);

};
SceneModel.prototype.destructor = function() {
"use strict";
this.destroy();

};
SceneModel.prototype.setRenderCallback = function(fnCallback, isStandAlone) {
this._fnRenderCallback = fnCallback;
this._isStandAlone = (isStandAlone === undefined? false : true);

};
SceneModel.prototype.prepareForRender = function() {

};
SceneModel.prototype.render = function() {
this.constructor.superclass.render.call(this, this);
if (this._fnRenderCallback) {
this._fnRenderCallback.call(this);
if (this._isStandAlone) {
return ;

}


}

trace("<<<<<<<<<<<<<SCENE MODEL RENDER>>>>>>>>>>", this.findMesh());
var pMeshes=this._pMeshes, pRenderer=this._pEngine.shaderManager(), pMesh, pSubMesh;
var i, j, k;
var isSkinning;
if ((!pMeshes) || ((pMeshes.length) === 0)) {
return false;

}

pRenderer.activateSceneObject(this);
pRenderer.setViewport(0, 0, this._pEngine.pCanvas.width, this._pEngine.pCanvas.height);
for (i = 0; i < (pMeshes.length); i++) {
pMesh = pMeshes[i];
if ((!pMesh) || (!(pMesh.isReadyForRender()))) {
return ;

}

for (j = 0; j < (pMesh.length); j++) {
pSubMesh = pMesh[j];
pSubMesh.switchRenderMethod(pSubMesh.name);
pSubMesh.startRender();
isSkinning = this._pEngine.pEngineStates.mesh.isSkinning = pSubMesh.isSkinned();
if (isSkinning) {
pSubMesh.skin.applyBoneMatrices();

}

for (k = 0; k < (pSubMesh.totalPasses()); k++) {
pSubMesh.activatePass(k);
pSubMesh.applySurfaceMaterial();
pSubMesh.applyRenderData(pSubMesh.data);
var pEntry=pSubMesh.renderPass();
trace("SceneModel.prototype.render", this, pEntry.pUniforms, pEntry.pTextures);
pSubMesh.deactivatePass();

}

pSubMesh.finishRender();

}


}

pRenderer.deactivateSceneObject();
trace("<<<<<<<<<<<<<END SCENE MODEL RENDER>>>>>>>>>>");
return true;

};
SceneModel.prototype.renderShadow = function() {
if (!(this.hasShadow())) {
return false;

}

trace("<<<<<<<<<<<<<START SCENE MODEL SHADOW RENDER>>>>>>>>>>");
var pMeshes=this._pMeshes, pRenderer=this._pEngine.shaderManager(), pMesh, pSubMesh;
var i, j, k;
var isSkinning;
if ((!pMeshes) || ((pMeshes.length) === 0)) {
return false;

}

pRenderer.activateSceneObject(this);
pRenderer.setViewport(0, 0, this._pEngine.pCanvas.width, this._pEngine.pCanvas.height);
for (i = 0; i < (pMeshes.length); i++) {
pMesh = pMeshes[i];
if ((!pMesh) || (!(pMesh.isReadyForRender()))) {
return ;

}

for (j = 0; j < (pMesh.length); j++) {
pSubMesh = pMesh[j];
if (!(pSubMesh.hasShadow())) {
continue ;

}

pSubMesh.switchRenderMethod(".prepare_shadows");
pSubMesh.startRender();
isSkinning = this._pEngine.pEngineStates.mesh.isSkinning = pSubMesh.isSkinned();
if (isSkinning) {
pSubMesh.skin.applyBoneMatrices();

}

this._pEngine.pEngineStates.isAdvancedIndex = false;
for (k = 0; k < (pSubMesh.totalPasses()); k++) {
pSubMesh.activatePass(k);
pSubMesh.applyRenderData(pSubMesh.data);
trace("SceneModel.prototype.renderShadow", pSubMesh.renderPass());
pSubMesh.deactivatePass();

}

pSubMesh.finishRender();

}


}

pRenderer.deactivateSceneObject();
trace("<<<<<<<<<<<<<END SCENE MODEL SHADOW RENDER>>>>>>>>>>");
return true;

};
SceneModel.prototype.setShadow = function() {
var pMeshes=this._pMeshes, pMesh;
var i, j;
if ((!pMeshes) || ((pMeshes.length) === 0)) {
return false;

}

for (i = 0; i < (pMeshes.length); i++) {
pMesh = pMeshes[i];
for (j = 0; j < (pMesh.length); j++) {
pMesh[j].hasShadow(true);

}


}

this._hasShadow = true;
return true;

};
SceneModel.prototype.hasShadow = function() {
if ((this._hasShadow) === null) {
var pMeshes=this._pMeshes, pMesh;
var i, j;
if ((!pMeshes) || ((pMeshes.length) === 0)) {
this._hasShadow = false;
return false;

}

for (i = 0; i < (pMeshes.length); i++) {
pMesh = pMeshes[i];
for (j = 0; j < (pMesh.length); j++) {
if (pMesh[j].hasShadow()) {
this._hasShadow = true;
return true;

}


}


}

this._hasShadow = false;
return false;

}
else  {
return this._hasShadow;

}


};
SceneModel.prototype.resetShadow = function() {
this._hasShadow = null;

};
SceneModel.prototype.addMesh = function(pMesh) {
"use strict";
if (!pMesh) {
return false;

}

this._pMeshes.push(pMesh);
return true;

};
SceneModel.prototype.findMesh = function(iMesh) {
"use strict";
iMesh = iMesh || 0;
return (this._pMeshes[iMesh]) || null;

};
SceneModel.prototype.getMeshList = function() {
"use strict";
return this._pMeshes.slice();

};
SceneModel.prototype.toString = function(isRecursive, iDepth) {
"use strict";
isRecursive = isRecursive || false;
if (!isRecursive) {
var sData=(((("<model" + ((this._sName? " " + (this._sName) : ""))) + "(") + (this._pMeshes.length)) + ")") + ">";
if (this._pMeshes.length) {
sData += "( ";
for (var i=0; i < (this._pMeshes.length); i++) {
sData += ((i > 0? "," : "")) + (this._pMeshes[i].name);

}

;
sData += " )";

}

return sData;

}

return SceneObject.prototype.toString.call(this, isRecursive, iDepth);

};
a["SceneModel"] = SceneModel;
function Engine() {
this._isWindowed = true;
this._isActive = false;
this._isDeviceLost = false;
this._isObjectsInited = false;
this._isObjectsRestored = false;
this._isFrameMoving = true;
this._isSingleStep = false;
this.fTime = 0;
this.fElapsedTime = 0;
this.fFPS = 0;
this.fUpdateTimeCount = 0;
this.sWindowTitle = "Akra Engine";
this.sDeviceStats = "";
this.sFrameStats = "";
this.pFont = null;
this._isShowStats = false;
this.pKeymap = null;
this.pCanvas = null;
this.pDevice = null;
this.pResourceManager = null;
this.pDisplayManager = null;
this.pShaderManager = null;
this.pParticleManager = null;
this.pSpriteManager = null;
this.pLightManager = null;
this._pRootNode = null;
this._pDefaultCamera = null;
this._pActiveCamera = null;
this._pSceneTree = null;
this._pWorldExtents = null;
this._isFrameReady = false;
this._iActiveRenderStage = 0;
this._isShowCursorWhenFullscreen = false;
this._isStartFullscreen = false;
this.pause(true);
this.iCreationWidth = 0;
this.iCreationHeight = 0;
this.pEngineStates = null;
this.renderList = null;

}

Engine.prototype.create = function() {
if ((typeof (arguments[0])) === "string") {
this.pCanvas = document.getElementById(arguments[0]);

}
else  {
this.pCanvas = arguments[0];

}

this.pKeymap = new a.Keymap();
this._pRootNode = new a.SceneNode(this);
this._pDefaultCamera = new a.Camera(this);
this._pDefaultCamera.name = ".default-camera";
this._pActiveCamera = this._pDefaultCamera;
this._pSceneTree = new a.OcTree();
this.iCreationWidth = this.pCanvas.width;
this.iCreationHeight = this.pCanvas.height;
this.iCreationHeight = this.pCanvas.height;
this.pDevice = a.createDevice(this.pCanvas);
if (!(this.pDevice)) {
if (!0) {
var err=((((((("Error:: " + "Объект устроства не создан, создание завершилось") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Engine.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Объект устроства не создан, создание завершилось");

}


}

;
a.deleteDevice(this.pDevice);
return false;

}

this.initDefaultStates();
this.pResourceManager = new a.ResourcePoolManager();
this.pDisplayManager = new a.DisplayManager(this);
this.pShaderManager = new a.Renderer(this);
this.pParticleManager = new a.ParticleManager(this);
this.pSpriteManager = new a.SpriteManager(this);
this.pLightManager = new a.LightManager(this);
a.UtilTimer(1);
if (!(this.oneTimeSceneInit())) {
if (!0) {
var err=((((((("Error:: " + "Engine.oneTimeSceneInit") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Engine.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Engine.oneTimeSceneInit");

}


}

;
a.deleteDevice(this.pDevice);
return false;

}

var me=this;
this.pResourceManager.setLoadedAllRoutine(function() {
if (!(me.initialize3DEnvironment())) {
if (!0) {
var err=((((((("Error:: " + "Engine.Initialize3DEnvironment") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Engine.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Engine.Initialize3DEnvironment");

}


}

;
a.deleteDevice(me.pDevice);
return false;

}

me.pause(false);

}
);
return true;

};
Engine.prototype.pause = function(isPause) {
this.pause.iAppPausedCount += (isPause? +1 : -1);
this._isActive = (this.pause.iAppPausedCount? false : true);
if (isPause && (1 == (this.pause.iAppPausedCount))) {
if (this._isFrameMoving) {
a.UtilTimer(2);

}


}

if (0 == (this.pause.iAppPausedCount)) {
if (this._isFrameMoving) {
a.UtilTimer(1);

}


}


};
Engine.prototype.pause.iAppPausedCount = 0;
Engine.prototype.notifyOneTimeSceneInit = function() {
if ((this.pDisplayManager.initialize()) && (this.pShaderManager.initialize())) {
this.pKeymap.setTarget(this.pDisplayManager.getTextLayer(), document);
return true;

}

return false;

};
Engine.prototype.showStats = function(isShow) {
if ((isShow == true) && ((this._isShowStats) == false)) {
this.pFont = new a.Font2D(22, "00FF00", "Arial", true);
this.sFrameStats = this.pDisplayManager.draw2DText(2, 0, this.pFont, "");
this.sDeviceStats = this.pDisplayManager.draw2DText(2, 20, this.pFont, "");
this._isShowStats = true;

}
else if ((isShow == false) && ((this._isShowStats) == true)) {
this.sDeviceStats.clear();
this.sFrameStats.clear();
this.sDeviceStats = null;
this.sFrameStats = null;
this.pFont = null;
this._isShowStats = false;

}



};
Engine.prototype.notifyRestoreDeviceObjects = function() {
this.pDisplayManager.restoreDeviceResources();
this.pShaderManager.restoreDeviceResources();
return true;

};
Engine.prototype.setupWorldOcTree = function(pWorldExtents) {
this._pWorldExtents = pWorldExtents;
this._pSceneTree.create(this._pWorldExtents, 10);

};
Engine.prototype.initDefaultStates = function() {
this.pEngineStates =  {mesh:  {isSkinning: false}, isAdvancedIndex: false};

};
Engine.prototype.notifyDeleteDeviceObjects = function() {
this.pDisplayManager.destroyDeviceResources();
this.pShaderManager.destroyDeviceResources();
this._pDefaultCamera.destroy();
this._pRootNode.destroy();
return true;

};
Engine.prototype.notifyUpdateScene = function() {
this._pRootNode.recursiveUpdate();
this._isFrameReady = true;
return true;

};
Engine.prototype.notifyPreUpdateScene = function() {
"use strict";
this._pRootNode.recursivePreUpdate();

};
Engine.prototype.getRootNode = function() {
return this._pRootNode;

};
Engine.prototype.getSceneTree = function() {
return this._pSceneTree;

};
Engine.prototype.getDefaultCamera = function() {
return this._pDefaultCamera;

};
Engine.prototype.getActiveCamera = function() {
return this._pActiveCamera;

};
Engine.prototype.displayManager = function() {
return this.pDisplayManager;

};
Engine.prototype.particleManager = function() {
return this.pParticleManager;

};
Engine.prototype.spriteManager = function() {
return this.pSpriteManager;

};
Engine.prototype.lightManager = function() {
return this.pLightManager;

};
Engine.prototype.getActiveViewport = function() {
return  {x: 0, y: 0, width: this.pCanvas.width, height: this.pCanvas.height};

};
Engine.prototype.shaderManager = function() {
return this.pShaderManager;

};
Engine.prototype.notifyInitDeviceObjects = function() {
this.pDisplayManager.createDeviceResources();
this.pShaderManager.createDeviceResources();
this.pLightManager.createDeviceResources();
this._pRootNode.create();
this._pDefaultCamera.create();
this._pDefaultCamera.attachToParent(this._pRootNode);
this._pDefaultCamera.setPosition(Vec3(0, 0, 0));
this._pDefaultCamera.setProjParams((Math.PI) / 3, (this.pCanvas.width) / (this.pCanvas.height), 0.1, 3000);
return true;

};
Engine.prototype.renderScene = function() {
var pCamera=this._pActiveCamera;
var pFirstMember=this._pSceneTree.buildSearchResults(pCamera.searchRect(), pCamera.frustum());
var pRenderList=pFirstMember;
this.renderList = pRenderList;
while (pFirstMember) {
pFirstMember.prepareForRender();
pFirstMember = pFirstMember.nextSearchLink();

}
pFirstMember = pRenderList;
while (pFirstMember) {
pFirstMember.render();
pFirstMember = pFirstMember.nextSearchLink();

}
return true;

};
Engine.prototype.renderScene.renderList = null;
Engine.prototype.renderShadows = function() {
var pLightManager=this.pLightManager;
var pLights=pLightManager.lightPoints;
var i;
for (i = 0; i < (pLights.length); i++) {
pLights[i].calculateShadows();

}


};
Engine.prototype.run = function() {
var me=this;
var fnRender=function() {
if (me._isDeviceLost) {
if (!0) {
var err=((((((("Error:: " + "Девайс потерян") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Engine.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Девайс потерян");

}


}

;

}

if (me._isActive) {
if (!(me.render3DEnvironment())) {
if (!0) {
var err=((((((("Error:: " + "a.render3DEnvironmen error") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Engine.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("a.render3DEnvironmen error");

}


}

;

}


}

requestAnimationFrame(fnRender, me.pCanvas);

};
requestAnimationFrame(fnRender, me.pCanvas);
return true;

};
Engine.prototype.setActiveCamera = function(pCamera) {
this._pActiveCamera = pCamera;
if (!(this._pActiveCamera)) {
this._pActiveCamera = this._pDefaultCamera;

}


};
Engine.prototype.confirmDevice = function(pCaps, iBehavior, pDisplay, pBackBuffer) {
if ((a.pSystemInfo.getShaderVersion()) >= 1) {
return true;

}

return false;

};
Engine.prototype.initialize3DEnvironment = function() {
if (!(this.initDeviceObjects())) {
this.deleteDeviceObjects();

}
else  {
this._isDeviceObjectsInited = true;
if (!(this.restoreDeviceObjects())) {
this.invalidateDeviceObjects();

}
else  {
this._isDeviceObjectsRestored = true;
return true;

}


}

this.cleanup3DEnvironment();
return false;

};
Engine.prototype.invalidateDeviceObjects = function() {
this.pDisplayManager.disableDeviceResources();
this.pShaderManager.disableDeviceResources();
return true;

};
Engine.prototype.cleanup3DEnvironment = function() {
if (this.pDevice) {
if (this.pDevice._isDeviceObjectsRestored) {
this.pDevice._isDeviceObjectsRestored = false;
this.pDevice.invalidateDeviceObjects();

}

if (this.pDevice._isDeviceObjectsInited) {
this.pDevice._isDeviceObjectsInited = false;
this.pDevice.deleteDeviceObjects();

}


}


};
Engine.prototype.render3DEnvironment = function() {
if (this._isDeviceLost) {
if (!0) {
var err=((((((("Error:: " + "Девайс потерян") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Engine.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("Девайс потерян");

}


}

;

}

var fAppTime=a.UtilTimer(5);
var fElapsedAppTime=a.UtilTimer(6);
if ((0 == fElapsedAppTime) && (this._isFrameMoving)) {
return true;

}

if ((this._isFrameMoving) || (this._isSingleStep)) {
this.fTime = fAppTime;
this.fElapsedTime = fElapsedAppTime;
if (!(this.frameMove())) {
return false;

}

this._isSingleStep = false;

}

if (!(this.render())) {
return false;

}

if (this._isFrameReady) {
this.notifyPreUpdateScene();

}

if (this._isShowStats) {
this.updateStats();

}

this.pKeymap.mouseSnapshot();
this._isDeviceLost = false;
return true;

};
Engine.prototype.frameMove = function() {
this.fUpdateTimeCount += this.fElapsedTime;
while ((this.fUpdateTimeCount) > (0.0333)) {
if (!(this.updateScene())) {
return false;

}

this.fUpdateTimeCount -= 0.0333;

}
return true;

};
Engine.prototype.render = function() {
if (!(this._isFrameReady)) {
return true;

}

if (this.pDisplayManager.beginRenderSession()) {
trace("==============Rendre Shadow===========");
this.renderShadows();
this.pShaderManager.processRenderQueue();
this.pDevice.flush();
trace("==============Stop Render Shadow===========");
trace("==============Render Scene===========");
this.renderScene();
this.pShaderManager.processRenderQueue();
trace("==============Stop Render Scene===========");
this.pDisplayManager.endRenderSession();

}

return true;

};
Engine.prototype.beginRenderStage = function(iStage) {
if (!(iStage < (a.RenderMethod.max_render_stages))) {
var err=((((((("Error:: " + "invalid render stage") + "\n") + "\tfile: ") + "C:/webservers/home/akra/www/akra-engine-core/src/Engine.js") + "\n") + "\tline: ") + "") + "\n";
if (confirm(err + "Accept to exit, refuse to continue.")) {
throw new Error("invalid render stage");

}


}

;
this._iActiveRenderStage = iStage;
if ((this._iActiveRenderStage) === (a.RenderMethod.bumpMapStage)) {
this.pDevice.colorMask(false, false, false, true);

}
else if ((this._iActiveRenderStage) === (a.RenderMethod.lightingStage)) {
this.pDevice.colorMask(true, true, true, false);

}


this._pActiveCamera.applyRenderStageBias(iStage);

};
Engine.prototype.endRenderStage = function() {
if ((this._iActiveRenderStage) == (a.RenderMethod.bumpMapStage)) {
this.pDevice.colorMask(true, true, true, true);

}

this._iActiveRenderStage = 0;

};
Engine.prototype.updateStats = function() {
var fTime=a.UtilTimer(4);
this.updateStats.iFrames++;
if ((fTime - (this.updateStats.fLastTime)) > 1) {
this.fFPS = (this.updateStats.iFrames) / (fTime - (this.updateStats.fLastTime));
this.updateStats.fLastTime = fTime;
this.updateStats.iFrames = 0;
var sMultiSample="Multisamples " + (a.info.graphics.multisampleType(this.pDevice));
this.sFrameStats.edit(((("" + (this.fFPS.toFixed(1))) + " fps (") + sMultiSample) + ")");

}


};
Engine.prototype.updateStats.fLastTime = 0;
Engine.prototype.updateStats.iFrames = 0;
Engine.prototype.getWorldExtents = function() {
return this._pWorldExtents;

};
Engine.prototype.getDevice = function() {
return this.pDevice;

};
Engine.prototype.getWindowTitle = function() {
return this.sWindowTitle;

};
Engine.prototype.getCurrentRenderStage = function() {
return this._iActiveRenderStage;

};
Engine.prototype.finalCleanup = function() {
this.pDisplayManager.destroy();
this.pShaderManager.destroy();
this._pSceneTree.destroy();
return true;

};
Engine.prototype.bFullscreenLock = false;
Engine.prototype.fullscreen = function() {
"use strict";
if (this.bFullscreenLock) {
return false;

}

try {
var pEngine=this;
var pCanvas=this.pCanvas;
Engine.prototype.bFullscreenLock = true;
((pCanvas.requestFullscreen) || (pCanvas.mozRequestFullScreen)) || (pCanvas.webkitRequestFullscreen)();
pCanvas.onfullscreenchange = pCanvas.onmozfullscreenchange = pCanvas.onwebkitfullscreenchange = function(e) {
var pScreen=a.info.screen;
if (pEngine.inFullscreenMode()) {
pCanvas.width = pScreen.width;
pCanvas.height = pScreen.height;

}
else  {
pCanvas.width = pEngine.iCreationWidth;
pCanvas.height = pEngine.iCreationHeight;

}

var pRoot=pEngine.getRootNode();
pRoot.explore(function() {
if ((this) instanceof (a.Camera)) {
if (!(this.isConstantAspect())) {
this.setProjParams(this.fov(), (pCanvas.width) / (pCanvas.height), this.nearPlane(), this.farPlane());
this.setUpdatedLocalMatrixFlag();

}


}


}
);
Engine.prototype.bFullscreenLock = false;

};

}
catch(e) {
console.warn((((("[WARNING][" + "C:/webservers/home/akra/www/akra-engine-core/src/Engine.js") + "][") + "") + "]") + "Fullscreen API not supported");
trace(e.message);

}

};
Engine.prototype.inFullscreenMode = function() {
"use strict";
return !(!(((document.webkitFullscreenElement) || (document.mozFullScreenElement)) || (document.fullscreenElement)));

};
Engine.prototype.updateCamera = function(fLateralSpeed, fRotationSpeed, pTerrain, fGroundOffset, isForceUpdate) {
var pCamera=this.getActiveCamera();
if (this.pKeymap.isKeyPress(39)) {
pCamera.addRelRotation(0, 0, -fRotationSpeed);

}
else if (this.pKeymap.isKeyPress(37)) {
pCamera.addRelRotation(0, 0, fRotationSpeed);

}


if (this.pKeymap.isKeyPress(38)) {
pCamera.addRelRotation(0, fRotationSpeed, 0);

}
else if (this.pKeymap.isKeyPress(40)) {
pCamera.addRelRotation(0, -fRotationSpeed, 0);

}


var v3fOffset=Vec3(0, 0, 0);
var pOffsetData=v3fOffset.pData;
var isCameraMoved=false;
if (this.pKeymap.isKeyPress(68)) {
pOffsetData[0] = fLateralSpeed;
isCameraMoved = true;

}
else if (this.pKeymap.isKeyPress(65)) {
pOffsetData[0] = -fLateralSpeed;
isCameraMoved = true;

}


if (this.pKeymap.isKeyPress(82)) {
pOffsetData[1] = fLateralSpeed;
isCameraMoved = true;

}
else if (this.pKeymap.isKeyPress(70)) {
pOffsetData[1] = -fLateralSpeed;
isCameraMoved = true;

}


if (this.pKeymap.isKeyPress(87)) {
pOffsetData[2] = -fLateralSpeed;
isCameraMoved = true;

}
else if (this.pKeymap.isKeyPress(83)) {
pOffsetData[2] = fLateralSpeed;
isCameraMoved = true;

}


if (isCameraMoved || isForceUpdate) {
if (pTerrain) {
var v3fCameraWorldPos=Vec3(pCamera.worldPosition());
var fGroundLevel=pTerrain.calcWorldHeight(v3fCameraWorldPos[0], v3fCameraWorldPos[1]);
var fMinCameraZ=fGroundLevel + fGroundOffset;
if (fMinCameraZ > (v3fCameraWorldPos[2])) {
v3fOffset[1] = fMinCameraZ - (v3fCameraWorldPos[2]);

}


}

pCamera.addRelPosition(v3fOffset);

}


};
a.Engine = Engine;
function torus(pEngine, eOptions, sName, rings, sides) {
rings = rings || 50;
sides = sides || 50;
var vertices=[];
var normals=[];
var tex=[];
var ind=[];
var r1=0.3;
var r2=1.5;
var ringDelta=(2 * 3.1415926) / rings;
var sideDelta=(2 * 3.1415926) / sides;
var invRings=1 / rings;
var invSides=1 / sides;
var index=0;
var numVertices=0;
var numFaces=0;
var i, j;
for (i = 0; i <= rings; i++) {
var theta=i * ringDelta;
var cosTheta=Math.cos(theta);
var sinTheta=Math.sin(theta);
for (j = 0; j <= sides; j++) {
var phi=j * sideDelta;
var cosPhi=Math.cos(phi);
var sinPhi=Math.sin(phi);
var dist=r2 + (r1 * cosPhi);
vertices.push(cosTheta * dist);
vertices.push((-sinTheta) * dist);
vertices.push(r1 * sinPhi);
tex.push(j * invSides);
tex.push(i * invRings);
normals.push(cosTheta * cosPhi);
normals.push((-sinTheta) * cosPhi);
normals.push(sinPhi);
numVertices++;

}


}

for (i = 0; i < rings; i++) {
for (j = 0; j < sides; j++) {
ind.push((i * (sides + 1)) + j);
ind.push(((i + 1) * (sides + 1)) + j);
ind.push((((i + 1) * (sides + 1)) + j) + 1);
ind.push((i * (sides + 1)) + j);
ind.push((((i + 1) * (sides + 1)) + j) + 1);
ind.push(((i * (sides + 1)) + j) + 1);
numFaces += 2;

}


}

var pMesh, pSubMesh;
var pMaterial;
var iPos, iNorm;
pMesh = new a.Mesh(pEngine, eOptions || 0, sName || "torus");
pSubMesh = pMesh.createSubset("torus::main");
var vertnorm=[];
for (var i=0; i < (vertices.length); i += 3) {
vertnorm.push(vertices[i], vertices[i + 1], vertices[i + 2]);
vertnorm.push(normals[i], normals[i + 1], normals[i + 2]);

}

iNorm = pSubMesh.data.allocateData([new Object( {nCount: 3, eType: 5126, eUsage: "NORMAL", iOffset: undefined})], new Float32Array(normals));
iPos = pSubMesh.data.allocateData([new Object( {nCount: 3, eType: 5126, eUsage: "POSITION", iOffset: undefined})], new Float32Array(vertices));
pSubMesh.data.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX_POSITION", iOffset: undefined})], new Float32Array(ind));
pSubMesh.data.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX_NORMAL", iOffset: undefined})], new Float32Array(ind));
pSubMesh.data.index(iPos, "INDEX_POSITION");
pSubMesh.data.index(iNorm, "INDEX_NORMAL");
pSubMesh.applyFlexMaterial("blue");
pMaterial = pSubMesh.getFlexMaterial("blue");
pMaterial.diffuse = new Float32Array([0.3, 0.3, 1, 1]);
pMaterial.specular = new Float32Array([1, 1, 1, 1]);
pMaterial.shininess = 30;
return pMesh;

}

function cube(pEngine, eOptions, sName) {
var pMesh, pSubMesh;
var iPos, iNorm;
var pVerticesData=new Float32Array([-0.5, 0.5, 0.5, 0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, -0.5, -0.5, -0.5, 0.5, -0.5, -0.5]);
var pMapData=new Float32Array([0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0]);
var pNormalsData=new Float32Array([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]);
var pVertexIndicesData=new Float32Array([0, 2, 3, 0, 3, 1, 0, 1, 5, 0, 5, 4, 6, 7, 3, 6, 3, 2, 0, 4, 6, 0, 6, 2, 3, 7, 5, 3, 5, 1, 5, 7, 6, 5, 6, 4]);
var pNormalIndicesData=new Float32Array([4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5]);
var pMapIndices=new Float32Array([0, 2, 3, 0, 3, 1, 0, 2, 3, 0, 3, 1, 0, 2, 3, 0, 3, 1, 0, 2, 3, 0, 3, 1, 0, 2, 3, 0, 3, 1, 0, 2, 3, 0, 3, 1]);
var pSerialData=new Float32Array(pNormalIndicesData.length);
for (var i=0; i < (pSerialData.length); i++) {
pSerialData[i] = i % 3;

}

;
var iNorm, iPos, iMap;
pMesh = new a.Mesh(pEngine, eOptions || 0, sName || "cube");
pSubMesh = pMesh.createSubset("cube::main");
iNorm = pSubMesh.data.allocateData([new Object( {nCount: 3, eType: 5126, eUsage: "NORMAL", iOffset: undefined})], pNormalsData);
iPos = pSubMesh.data.allocateData([new Object( {nCount: 3, eType: 5126, eUsage: "POSITION", iOffset: undefined})], pVerticesData);
iMap = pSubMesh.data.allocateData([new Object( {nCount: 3, eType: 5126, eUsage: "TEXCOORD0", iOffset: undefined})], pMapData);
pSubMesh.data.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX0", iOffset: undefined})], pVertexIndicesData);
pSubMesh.data.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX1", iOffset: undefined})], pNormalIndicesData);
pSubMesh.data.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX2", iOffset: undefined})], pMapIndices);
pSubMesh.data.index(iPos, "INDEX0");
pSubMesh.data.index(iNorm, "INDEX1");
pSubMesh.data.index(iMap, "INDEX2");
pSubMesh.applyFlexMaterial("default");
var pMat=pSubMesh.getFlexMaterial("default");
pMat.diffuse = new Float32Array([0.5, 0, 0, 1]);
pMat.ambient = new Float32Array([0.7, 0, 0, 1]);
pMat.specular = new Float32Array([1, 0.7, 0, 1]);
pMat.shininess = 30;
return pMesh;

}

function sceneSurface(pEngine, n) {
n = n || 100;
var nCellW=nCellW || (n + 1);
var nCellH=nCellH || (n + 1);
var nScaleX=nCellW - 1;
var nScaleY=nCellH - 1;
var pMesh, pSubMesh;
var iPos;
var pVerticesData=new Float32Array((nCellW + nCellH) * 6);
var fStepX=1 / (nCellW - 1);
var fStepY=1 / (nCellH - 1);
var n=0;
for (var z=0; z < nCellH; ++z) {
pVerticesData[n] = (-0.5) * nScaleX;
pVerticesData[n + 2] = ((z * fStepY) - 0.5) * nScaleY;
n += 3;
pVerticesData[n] = 0.5 * nScaleX;
pVerticesData[n + 2] = ((z * fStepY) - 0.5) * nScaleY;
n += 3;

}

for (var x=0; x < nCellW; ++x) {
pVerticesData[n] = ((x * fStepX) - 0.5) * nScaleX;
pVerticesData[n + 2] = (-0.5) * nScaleY;
n += 3;
pVerticesData[n] = ((x * fStepX) - 0.5) * nScaleX;
pVerticesData[n + 2] = 0.5 * nScaleY;
n += 3;

}

var pVertexIndicesData=new Float32Array((nCellW + nCellH) * 2);
n = 0;
for (var z=0; z < nCellH; ++z) {
pVertexIndicesData[n++] = z * 2;
pVertexIndicesData[n++] = (z * 2) + 1;

}

;
for (var x=0; x < nCellW; ++x) {
pVertexIndicesData[n++] = (nCellH * 2) + (x * 2);
pVertexIndicesData[n++] = ((nCellH * 2) + (x * 2)) + 1;

}

;
pMesh = new a.Mesh(pEngine, 0, "scene-surface");
pSubMesh = pMesh.createSubset("plane::main", 1);
pSubMesh.data.allocateData([new Object( {nCount: 3, eType: 5126, eUsage: "POSITION", iOffset: undefined})], pVerticesData);
pSubMesh.data.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX_POSITION", iOffset: undefined})], pVertexIndicesData);
pSubMesh.data.index("POSITION", "INDEX_POSITION");
pSubMesh.applyFlexMaterial("default");
return pMesh;

}

function screenSprite(pEngine) {
var pMesh=new a.Mesh(pEngine, 0, "screen-sprite");
var pSubMesh=pMesh.createSubset("screen-sprite :: main", 5);
pSubMesh.data.allocateAttribute([new Object( {nCount: 2, eType: 5126, eUsage: "POSITION", iOffset: undefined})], new Float32Array([-1, -1, -1, 1, 1, -1, 1, 1]));
return pMesh;

}

function plane(pEngine, eOptions, sName, nCellW, nCellH) {
nCellW = nCellW || 25;
nCellH = nCellH || 25;
var pMesh, pSubMesh;
var iPos, iNorm;
var nCells=nCellW * nCellH;
var pVerticesData=new Float32Array(nCells * 3);
var pNormalsData=new Float32Array([0, 0, 1]);
var fStepX=1 / (nCellW - 1);
var fStepY=1 / (nCellH - 1);
var n=0;
for (var z=0; z < nCellH; ++z) {
for (var x=0; x < nCellW; ++x) {
pVerticesData[n] = (x * fStepX) - 0.5;
pVerticesData[n + 2] = (z * fStepY) - 0.5;
n += 3;

}


}

;
var pVertexIndicesData=new Float32Array(nCells * 6);
var pNormalIndicesData=new Float32Array(nCells * 6);
n = 0;
for (var z=0; z < (nCellH - 1); ++z) {
for (var x=0; x < (nCellW - 1); ++x) {
pVertexIndicesData[n] = ((z + 1) * nCellW) + x;
pVertexIndicesData[n + 1] = (((z + 0) * nCellW) + x) + 1;
pVertexIndicesData[n + 2] = ((z + 0) * nCellW) + x;
pVertexIndicesData[n + 3] = pVertexIndicesData[n];
pVertexIndicesData[n + 4] = (pVertexIndicesData[n]) + 1;
pVertexIndicesData[n + 5] = pVertexIndicesData[n + 1];

}

n += 6;

}

;
pMesh = new a.Mesh(pEngine, eOptions || 0, sName || "plane");
pSubMesh = pMesh.createSubset("plane::main", 4);
iNorm = pSubMesh.data.allocateData([new Object( {nCount: 3, eType: 5126, eUsage: "NORMAL", iOffset: undefined})], pNormalsData);
iPos = pSubMesh.data.allocateData([new Object( {nCount: 3, eType: 5126, eUsage: "POSITION", iOffset: undefined})], pVerticesData);
pSubMesh.data.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX_POSITION", iOffset: undefined})], pVertexIndicesData);
pSubMesh.data.allocateIndex([new Object( {nCount: 1, eType: 5126, eUsage: "INDEX_NORMAL", iOffset: undefined})], pNormalIndicesData);
pSubMesh.data.index(iPos, "INDEX_POSITION");
pSubMesh.data.index(iNorm, "INDEX_NORMAL");
pSubMesh.applyFlexMaterial("default");
return pMesh;

}

;
function ShaderDemo() {
var _pCtorValue=ShaderDemo.ctor.apply(this, arguments);
if (_pCtorValue) {
return _pCtorValue;

}

;
this.pPlane = null;
this.pCube = null;
this.pTexture0 = null;
this.pEntry = null;
this.pModel = null;
this.pSprite = null;
this.pLightPoint = null;
if (!(this.constructor.fMoveSpeed)) {
this.constructor.fMoveSpeed = 1;

}

;

}

a.extend(ShaderDemo, a.Engine);
ShaderDemo.prototype.oneTimeSceneInit = function() {
"use strict";
this.notifyOneTimeSceneInit();
this.setupWorldOcTree(new a.Rect3d(-500, 500, -500, 500, 0, 500));
this.showStats(true);
var pManager=this.shaderManager();
var pSystemEffect;
pSystemEffect = pManager.loadEffectFile("http://akra/akra-engine-general/effects/SystemEffects.afx", true);
pManager.loadEffectFile("http://akra/akra-engine-general/effects/Plane.afx", true);
pManager.loadEffectFile("http://akra/akra-engine-general/effects/mesh.afx", true);
pManager.loadEffectFile("http://akra/akra-engine-general/effects/mesh_geometry.afx", true);
pManager.loadEffectFile("http://akra/akra-engine-general/effects/mesh_texture.afx", true);
pManager.loadEffectFile("http://akra/akra-engine-general/effects/samplers_array.afx", true);
pManager.loadEffectFile("http://akra/akra-engine-general/effects/TextureToScreen.afx", true);
pManager.loadEffectFile("http://akra/akra-engine-general/effects/prepare_shadows.afx", true);
this.pTexture0 = this.displayManager().texturePool().loadResource("/akra-engine-general/media/textures/lion.png");
this.pModel = this.displayManager().modelPool().createResource("model");
this.pModel.loadResource("/akra-engine-general/media/models/demo3/mesh_chr/mesh_chr.DAE",  {});
this.pResourceManager.monitorInitResources(function(nLoaded, nTotal, pTarget) {
console.log("loaded:", (nLoaded / nTotal) * 100, "%", pTarget.findResourceName());

}
);
return true;

};
ShaderDemo.prototype.restoreDeviceObjects = function() {
this.notifyRestoreDeviceObjects();
return true;

};
ShaderDemo.prototype.initDeviceObjects = function() {
this.notifyInitDeviceObjects();
trace(this.pModel, "<<@@@@@@@@@@@@@@@@@");
var pManager=this.shaderManager();
var pLightPoint=this.pLightPoint = new a.LightPoint(this, true, true, 2048);
pLightPoint.create();
pLightPoint.attachToParent(this.getRootNode());
var m4fTempView=Mat4.lookAt(Vec3(3, 4, 0), Vec3(0, 1, 0), Vec3(0, 1, 0), Mat4());
pLightPoint.accessLocalMatrix().set(m4fTempView.inverse());
pLightPoint.addRelRotation((Math.PI) / 4, 0, 0);
if (!(pLightPoint.isOmnidirectional)) {
pLightPoint.camera.setProjParams((Math.PI) / 5, 1, 0.01, 1000);

}

var pLightParameters=pLightPoint.lightParameters;
pLightParameters.attenuation.set(0.9, 0, 0);
function addMeshToScene(pEngine, pMesh, pParent) {
var pSceneObject=new a.SceneModel(pEngine, pMesh);
pSceneObject.create();
pSceneObject.attachToParent(pParent || (pEngine.getRootNode()));
return pSceneObject;

}

this.pPlane = addMeshToScene(this, sceneSurface(this));
var pEffectResource=this.pPlane._pMeshes[0][0]._pActiveSnapshot._pRenderMethod._pEffect;
pEffectResource.create();
pEffectResource.use(this.shaderManager().getComponentByName("akra.system.plane"));
this.pCubeMesh = cube(this);
this.appendMesh = function(pMesh, pNode) {
return addMeshToScene(me, pMesh, pNode);

};
this.pModel.addToScene();
this.pModel.applyShadow();
var pCamera=this.getActiveCamera();
pCamera.addRelRotation((-3.14) / 5, 0, 0);
pCamera.addRelPosition(-8, 5, 11);
return true;

};
ShaderDemo.prototype.deleteDeviceObjects = function() {
this.notifyDeleteDeviceObjects();
return true;

};
ShaderDemo.prototype.updateScene = function() {
this.updateCamera(1, 0.1, null, 30, false);
if ((this.pKeymap.isMousePress()) && (this.pKeymap.isMouseMoved())) {
var pCamera=this.getActiveCamera(), fdX=this.pKeymap.mouseShitfX(), fdY=this.pKeymap.mouseShitfY(), pScreen=a.info.screen;
fdX /= (pScreen.width) / 10;
fdY /= (pScreen.height) / 10;
pCamera.addRelRotation(fdX, fdY, 0);

}

return this.notifyUpdateScene();

};
if (!(a.info.support.webgl)) {
alert("Error:: Your browser does not support WebGL.");

}
else  {
var App=new ShaderDemo();
if ((!(App.create("canvas"))) || (!(App.run()))) {
alert("something wrong....");

}


}

;
